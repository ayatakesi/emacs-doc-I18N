# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-09-22 12:26+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: settitle
#: ../../calc.texi:6
#, no-wrap
msgid "GNU Emacs Calc Manual"
msgstr ""

#. type: include
#: ../../calc.texi:7
#, no-wrap
msgid "docstyle.texi"
msgstr ""

#. type: include
#: ../../calc.texi:11
#, no-wrap
msgid "emacsver.texi"
msgstr ""

#. type: iftex
#: ../../calc.texi:30
msgid ""
"@alias infoline=comment @alias expr=math @alias tfn=code @alias mathit=expr "
"@alias summarykey=key"
msgstr ""

#. type: math{#1}
#: ../../calc.texi:32
msgid "@pi{}"
msgstr ""

#. type: math{#1}
#: ../../calc.texi:35
msgid "@pi/\\den\\"
msgstr ""

#. type: ifnottex
#: ../../calc.texi:40
msgid "@alias texline=comment"
msgstr ""

#. type: macro
#: ../../calc.texi:42
msgid "\\stuff\\"
msgstr ""

#. type: ifnottex
#: ../../calc.texi:46
msgid "@alias expr=samp @alias tfn=t @alias mathit=i"
msgstr ""

#. type: macro
#: ../../calc.texi:48
msgid "\\ky\\"
msgstr ""

#. type: macro
#: ../../calc.texi:51
msgid "@expr{pi}"
msgstr ""

#. type: macro
#: ../../calc.texi:54
msgid "@expr{pi/\\den\\}"
msgstr ""

#. type: tex
#: ../../calc.texi:61
#, no-wrap
msgid ""
"% Suggested by Karl Berry <karl@@freefriends.org>\n"
"\\gdef\\!{\\mskip-\\thinmuskip}\n"
msgstr ""

#.  Make Calc fractions come out right in math mode
#. type: iftex
#: ../../calc.texi:67
msgid "@mathcode`@:=`@:"
msgstr ""

#. type: tex
#: ../../calc.texi:69
#, no-wrap
msgid ""
"\\gdef\\coloneq{\\mathrel{\\mathord:\\mathord=}}\n"
"\n"
msgstr ""

#. type: tex
#: ../../calc.texi:74
#, no-wrap
msgid ""
"\\gdef\\beforedisplay{\\vskip-10pt}\n"
"\\gdef\\afterdisplay{\\vskip-5pt}\n"
"\\gdef\\beforedisplayh{\\vskip-25pt}\n"
"\\gdef\\afterdisplayh{\\vskip-10pt}\n"
msgstr ""

#. type: iftex
#: ../../calc.texi:78
msgid ""
"@newdimen@kyvpos @kyvpos=0pt @newdimen@kyhpos @kyhpos=0pt "
"@newcount@calcclubpenalty @calcclubpenalty=1000"
msgstr ""

#. type: ifinfo
#: ../../calc.texi:92
msgid "This file documents Calc, the GNU Emacs calculator."
msgstr ""

#. type: ifnotinfo
#: ../../calc.texi:96
msgid ""
"This file documents Calc, the GNU Emacs calculator, included with GNU Emacs "
"@value{EMACSVER}."
msgstr ""

#. type: copying
#: ../../calc.texi:100
msgid "Copyright @copyright{} 1990--1991, 2001--2021 Free Software Foundation, Inc."
msgstr ""

#. type: quotation
#: ../../calc.texi:109
msgid ""
"Permission is granted to copy, distribute and/or modify this document under "
"the terms of the GNU Free Documentation License, Version 1.3 or any later "
"version published by the Free Software Foundation; with the Invariant "
"Sections being just ``GNU GENERAL PUBLIC LICENSE'', with the Front-Cover "
"Texts being ``A GNU Manual,'' and with the Back-Cover Texts as in (a) "
"below.  A copy of the license is included in the section entitled ``GNU Free "
"Documentation License.''"
msgstr ""

#. type: quotation
#: ../../calc.texi:112
msgid ""
"(a) The FSF's Back-Cover Text is: ``You have the freedom to copy and modify "
"this GNU manual.''"
msgstr ""

#. type: dircategory
#: ../../calc.texi:115
#, no-wrap
msgid "Emacs misc features"
msgstr ""

#. type: menuentry
#: ../../calc.texi:118
msgid "Calc: (calc)"
msgstr ""

#. type: menuentry
#: ../../calc.texi:118
msgid "Advanced desk calculator and mathematical tool."
msgstr ""

#. type: titlefont{#1}
#: ../../calc.texi:122
#, no-wrap
msgid "Calc Manual"
msgstr ""

#. type: center
#: ../../calc.texi:124
#, no-wrap
msgid "GNU Emacs Calc"
msgstr ""

#. type: center
#: ../../calc.texi:127
#, no-wrap
msgid "Dave Gillespie"
msgstr ""

#. type: center
#: ../../calc.texi:128
#, no-wrap
msgid "daveg@@synaptics.com"
msgstr ""

#. type: node
#: ../../calc.texi:144 ../../calc.texi:205 ../../calc.texi:208 ../../calc.texi:1244 ../../calc.texi:1273 ../../calc.texi:1276 ../../calc.texi:9570 ../../calc.texi:10493 ../../calc.texi:11717 ../../calc.texi:12079 ../../calc.texi:16127 ../../calc.texi:18245 ../../calc.texi:19459 ../../calc.texi:21507 ../../calc.texi:27747 ../../calc.texi:28522 ../../calc.texi:29111 ../../calc.texi:29814 ../../calc.texi:30156 ../../calc.texi:30553 ../../calc.texi:31441 ../../calc.texi:35322 ../../calc.texi:35326 ../../calc.texi:35330 ../../calc.texi:35724 ../../calc.texi:35749 ../../calc.texi:37020 ../../calc.texi:37025 ../../calc.texi:37035 ../../calc.texi:37048 ../../calc.texi:37053 ../../calc.texi:37065
#, no-wrap
msgid "Top"
msgstr ""

#. type: node
#: ../../calc.texi:144 ../../calc.texi:168 ../../calc.texi:205 ../../calc.texi:208 ../../calc.texi:210 ../../calc.texi:225 ../../calc.texi:286 ../../calc.texi:363 ../../calc.texi:404 ../../calc.texi:573 ../../calc.texi:1141 ../../calc.texi:1244 ../../calc.texi:1276
#, no-wrap
msgid "Getting Started"
msgstr ""

#. type: node
#: ../../calc.texi:144
#, no-wrap
msgid "(dir)"
msgstr ""

#. type: top
#: ../../calc.texi:145
#, no-wrap
msgid "The GNU Emacs Calculator"
msgstr ""

#. type: ifnottex
#: ../../calc.texi:150
msgid ""
"@dfn{Calc} is an advanced desk calculator and mathematical tool written by "
"Dave Gillespie that runs as part of the GNU Emacs environment."
msgstr ""

#. type: ifnottex
#: ../../calc.texi:156
msgid ""
"This manual, also written (mostly) by Dave Gillespie, is divided into three "
"major parts: ``Getting Started,'' the ``Calc Tutorial,'' and the ``Calc "
"Reference.'' The Tutorial introduces all the major aspects of Calculator use "
"in an easy, hands-on way.  The remainder of the manual is a complete "
"reference to the features of the Calculator."
msgstr ""

#. type: ifinfo
#: ../../calc.texi:162
msgid ""
"For help in the Emacs Info system (which you are using to read this file), "
"type @kbd{?}.  (You can also type @kbd{h} to run through a longer Info "
"tutorial.)"
msgstr ""

#. type: menuentry
#: ../../calc.texi:168
msgid "General description and overview."
msgstr ""

#. type: ifinfo
#: ../../calc.texi:170
msgid "* Interactive Tutorial::"
msgstr ""

#. type: node
#: ../../calc.texi:172 ../../calc.texi:208 ../../calc.texi:1244 ../../calc.texi:1245 ../../calc.texi:1271 ../../calc.texi:1273 ../../calc.texi:1276 ../../calc.texi:1278 ../../calc.texi:1332 ../../calc.texi:2658 ../../calc.texi:3044 ../../calc.texi:4217 ../../calc.texi:4741 ../../calc.texi:5690 ../../calc.texi:6349 ../../calc.texi:9570
#, no-wrap
msgid "Tutorial"
msgstr ""

#. type: menuentry
#: ../../calc.texi:172
msgid "A step-by-step introduction for beginners."
msgstr ""

#. type: node
#: ../../calc.texi:188 ../../calc.texi:1273 ../../calc.texi:1276 ../../calc.texi:9570 ../../calc.texi:9571 ../../calc.texi:9595 ../../calc.texi:9764 ../../calc.texi:9909 ../../calc.texi:9961 ../../calc.texi:9998 ../../calc.texi:10116 ../../calc.texi:10185 ../../calc.texi:10233 ../../calc.texi:10291 ../../calc.texi:10322 ../../calc.texi:10349 ../../calc.texi:10493
#, no-wrap
msgid "Introduction"
msgstr ""

#. type: menuentry
#: ../../calc.texi:188
msgid "Introduction to the Calc reference manual."
msgstr ""

#. type: node
#: ../../calc.texi:188 ../../calc.texi:9570 ../../calc.texi:10493 ../../calc.texi:10494 ../../calc.texi:10528 ../../calc.texi:10554 ../../calc.texi:10575 ../../calc.texi:10649 ../../calc.texi:10687 ../../calc.texi:10774 ../../calc.texi:10816 ../../calc.texi:10893 ../../calc.texi:10955 ../../calc.texi:11111 ../../calc.texi:11195 ../../calc.texi:11310 ../../calc.texi:11425 ../../calc.texi:11488 ../../calc.texi:11559 ../../calc.texi:11717
#, no-wrap
msgid "Data Types"
msgstr ""

#. type: menuentry
#: ../../calc.texi:188
msgid "Types of objects manipulated by Calc."
msgstr ""

#. type: node
#: ../../calc.texi:188 ../../calc.texi:10493 ../../calc.texi:11717 ../../calc.texi:11732 ../../calc.texi:11861 ../../calc.texi:11915 ../../calc.texi:12036 ../../calc.texi:12079
#, no-wrap
msgid "Stack and Trail"
msgstr ""

#. type: menuentry
#: ../../calc.texi:188
msgid "Manipulating the stack and trail buffers."
msgstr ""

#. type: node
#: ../../calc.texi:188 ../../calc.texi:11717 ../../calc.texi:12079 ../../calc.texi:12080 ../../calc.texi:12100 ../../calc.texi:12182 ../../calc.texi:12239 ../../calc.texi:12282 ../../calc.texi:12572 ../../calc.texi:12653 ../../calc.texi:13062 ../../calc.texi:13927 ../../calc.texi:15806 ../../calc.texi:15908 ../../calc.texi:16127
#, no-wrap
msgid "Mode Settings"
msgstr ""

#. type: menuentry
#: ../../calc.texi:188
msgid "Adjusting display format and other modes."
msgstr ""

#. type: node
#: ../../calc.texi:188 ../../calc.texi:12079 ../../calc.texi:16127 ../../calc.texi:16157 ../../calc.texi:16514 ../../calc.texi:16637 ../../calc.texi:16705 ../../calc.texi:16868 ../../calc.texi:17513 ../../calc.texi:18064 ../../calc.texi:18245
#, no-wrap
msgid "Arithmetic"
msgstr ""

#. type: menuentry
#: ../../calc.texi:188
msgid "Basic arithmetic functions."
msgstr ""

#. type: node
#: ../../calc.texi:188 ../../calc.texi:16127 ../../calc.texi:18245 ../../calc.texi:18246 ../../calc.texi:18312 ../../calc.texi:18406 ../../calc.texi:18583 ../../calc.texi:18720 ../../calc.texi:18864 ../../calc.texi:19092 ../../calc.texi:19308 ../../calc.texi:19459
#, no-wrap
msgid "Scientific Functions"
msgstr ""

#. type: menuentry
#: ../../calc.texi:188
msgid "Transcendentals and other scientific functions."
msgstr ""

#. type: node
#: ../../calc.texi:188 ../../calc.texi:18245 ../../calc.texi:19459 ../../calc.texi:19487 ../../calc.texi:19707 ../../calc.texi:19875 ../../calc.texi:19981 ../../calc.texi:20213 ../../calc.texi:20335 ../../calc.texi:20525 ../../calc.texi:20884 ../../calc.texi:21360 ../../calc.texi:21507
#, no-wrap
msgid "Matrix Functions"
msgstr ""

#. type: menuentry
#: ../../calc.texi:188
msgid "Operations on vectors and matrices."
msgstr ""

#. type: node
#: ../../calc.texi:188 ../../calc.texi:19459 ../../calc.texi:21507 ../../calc.texi:21508 ../../calc.texi:21547 ../../calc.texi:22260 ../../calc.texi:22424 ../../calc.texi:23214 ../../calc.texi:23438 ../../calc.texi:23786 ../../calc.texi:24155 ../../calc.texi:24348 ../../calc.texi:25449 ../../calc.texi:25610 ../../calc.texi:25988 ../../calc.texi:27747
#, no-wrap
msgid "Algebra"
msgstr ""

#. type: menuentry
#: ../../calc.texi:188
msgid "Manipulating expressions algebraically."
msgstr ""

#. type: node
#: ../../calc.texi:188 ../../calc.texi:21507 ../../calc.texi:27747 ../../calc.texi:27766 ../../calc.texi:27971 ../../calc.texi:28028 ../../calc.texi:28131 ../../calc.texi:28140 ../../calc.texi:28215 ../../calc.texi:28454 ../../calc.texi:28522
#, no-wrap
msgid "Units"
msgstr ""

#. type: menuentry
#: ../../calc.texi:188
msgid "Operations on numbers with units."
msgstr ""

#. type: node
#: ../../calc.texi:188 ../../calc.texi:27747 ../../calc.texi:28522 ../../calc.texi:28539 ../../calc.texi:28767 ../../calc.texi:28790 ../../calc.texi:28947 ../../calc.texi:28985 ../../calc.texi:29111
#, no-wrap
msgid "Store and Recall"
msgstr ""

#. type: menuentry
#: ../../calc.texi:188
msgid "Storing and recalling variables."
msgstr ""

#. type: node
#: ../../calc.texi:188 ../../calc.texi:28522 ../../calc.texi:29111 ../../calc.texi:29112 ../../calc.texi:29142 ../../calc.texi:29228 ../../calc.texi:29296 ../../calc.texi:29455 ../../calc.texi:29621 ../../calc.texi:29814
#, no-wrap
msgid "Graphics"
msgstr ""

#. type: menuentry
#: ../../calc.texi:188
msgid "Commands for making graphs of data."
msgstr ""

#. type: node
#: ../../calc.texi:188 ../../calc.texi:29111 ../../calc.texi:29814 ../../calc.texi:29834 ../../calc.texi:29878 ../../calc.texi:29910 ../../calc.texi:29944 ../../calc.texi:29956 ../../calc.texi:30073 ../../calc.texi:30127 ../../calc.texi:30156
#, no-wrap
msgid "Kill and Yank"
msgstr ""

#. type: menuentry
#: ../../calc.texi:188
msgid "Moving data into and out of Calc."
msgstr ""

#. type: node
#: ../../calc.texi:188 ../../calc.texi:29814 ../../calc.texi:30156 ../../calc.texi:30157 ../../calc.texi:30208 ../../calc.texi:30339 ../../calc.texi:30382 ../../calc.texi:30415 ../../calc.texi:30497 ../../calc.texi:30553
#, no-wrap
msgid "Keypad Mode"
msgstr ""

#. type: menuentry
#: ../../calc.texi:188
msgid "Operating Calc from a keypad."
msgstr ""

#. type: node
#: ../../calc.texi:188 ../../calc.texi:30156 ../../calc.texi:30553 ../../calc.texi:30554 ../../calc.texi:30570 ../../calc.texi:30734 ../../calc.texi:30918 ../../calc.texi:31144 ../../calc.texi:31289 ../../calc.texi:31441
#, no-wrap
msgid "Embedded Mode"
msgstr ""

#. type: menuentry
#: ../../calc.texi:188
msgid "Working with formulas embedded in a file."
msgstr ""

#. type: node
#: ../../calc.texi:188 ../../calc.texi:30553 ../../calc.texi:31441 ../../calc.texi:31442 ../../calc.texi:31492 ../../calc.texi:31567 ../../calc.texi:31934 ../../calc.texi:31967 ../../calc.texi:32079 ../../calc.texi:35322
#, no-wrap
msgid "Programming"
msgstr ""

#. type: menuentry
#: ../../calc.texi:188
msgid "Calc as a programmable calculator."
msgstr ""

#. type: node
#: ../../calc.texi:193 ../../calc.texi:31441 ../../calc.texi:35322 ../../calc.texi:35326
#, no-wrap
msgid "Copying"
msgstr ""

#. type: menuentry
#: ../../calc.texi:193
msgid "How you can copy and share Calc."
msgstr ""

#. type: node
#: ../../calc.texi:193 ../../calc.texi:35322 ../../calc.texi:35326 ../../calc.texi:35327 ../../calc.texi:35330
#, no-wrap
msgid "GNU Free Documentation License"
msgstr ""

#. type: menuentry
#: ../../calc.texi:193
msgid "The license for this documentation."
msgstr ""

#. type: node
#: ../../calc.texi:193 ../../calc.texi:35326 ../../calc.texi:35330 ../../calc.texi:35331 ../../calc.texi:35724
#, no-wrap
msgid "Customizing Calc"
msgstr ""

#. type: menuentry
#: ../../calc.texi:193
msgid "Customizing Calc."
msgstr ""

#. type: node
#: ../../calc.texi:193 ../../calc.texi:35330 ../../calc.texi:35724 ../../calc.texi:35725 ../../calc.texi:35749
#, no-wrap
msgid "Reporting Bugs"
msgstr ""

#. type: menuentry
#: ../../calc.texi:193
msgid "How to report bugs and make suggestions."
msgstr ""

#. type: node
#: ../../calc.texi:195 ../../calc.texi:35724 ../../calc.texi:35749 ../../calc.texi:37020
#, no-wrap
msgid "Summary"
msgstr ""

#. type: menuentry
#: ../../calc.texi:195
msgid "Summary of Calc commands and functions."
msgstr ""

#. type: node
#: ../../calc.texi:202 ../../calc.texi:35749 ../../calc.texi:37020 ../../calc.texi:37025
#, no-wrap
msgid "Key Index"
msgstr ""

#. type: menuentry
#: ../../calc.texi:202
msgid "The standard Calc key sequences."
msgstr ""

#. type: node
#: ../../calc.texi:202 ../../calc.texi:37020 ../../calc.texi:37025 ../../calc.texi:37035
#, no-wrap
msgid "Command Index"
msgstr ""

#. type: menuentry
#: ../../calc.texi:202
msgid "The interactive Calc commands."
msgstr ""

#. type: node
#: ../../calc.texi:202 ../../calc.texi:37025 ../../calc.texi:37035 ../../calc.texi:37048
#, no-wrap
msgid "Function Index"
msgstr ""

#. type: menuentry
#: ../../calc.texi:202
msgid "Functions (in algebraic formulas)."
msgstr ""

#. type: node
#: ../../calc.texi:202 ../../calc.texi:37035 ../../calc.texi:37048 ../../calc.texi:37049 ../../calc.texi:37053
#, no-wrap
msgid "Concept Index"
msgstr ""

#. type: menuentry
#: ../../calc.texi:202
msgid "General concepts."
msgstr ""

#. type: node
#: ../../calc.texi:202 ../../calc.texi:37048 ../../calc.texi:37053 ../../calc.texi:37065
#, no-wrap
msgid "Variable Index"
msgstr ""

#. type: menuentry
#: ../../calc.texi:202
msgid "Variables used by Calc (both user and internal)."
msgstr ""

#. type: node
#: ../../calc.texi:202 ../../calc.texi:37053 ../../calc.texi:37065
#, no-wrap
msgid "Lisp Function Index"
msgstr ""

#. type: menuentry
#: ../../calc.texi:202
msgid "Internal Lisp math functions."
msgstr ""

#. type: node
#: ../../calc.texi:205 ../../calc.texi:1244 ../../calc.texi:1273
#, no-wrap
msgid "Interactive Tutorial"
msgstr ""

#. type: Plain text
#: ../../calc.texi:215
msgid ""
"This chapter provides a general overview of Calc, the GNU Emacs Calculator: "
"What it is, how to start it and how to exit from it, and what are the "
"various ways that it can be used."
msgstr ""

#. type: menuentry
#: ../../calc.texi:223
msgid "What is Calc::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:223
msgid "About This Manual::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:223
msgid "Notations Used in This Manual::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:223
msgid "Demonstration of Calc::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:223
msgid "Using Calc::"
msgstr ""

#. type: section
#: ../../calc.texi:223 ../../calc.texi:573 ../../calc.texi:1141 ../../calc.texi:1142
#, no-wrap
msgid "History and Acknowledgments"
msgstr ""

#. type: node
#: ../../calc.texi:225 ../../calc.texi:286
#, no-wrap
msgid "What is Calc"
msgstr ""

#. type: node
#: ../../calc.texi:225 ../../calc.texi:286 ../../calc.texi:287 ../../calc.texi:363
#, no-wrap
msgid "About This Manual"
msgstr ""

#. type: section
#: ../../calc.texi:226
#, no-wrap
msgid "What is Calc?"
msgstr ""

#. type: Plain text
#: ../../calc.texi:232
msgid ""
"@dfn{Calc} is an advanced calculator and mathematical tool that runs as part "
"of the GNU Emacs environment.  Very roughly based on the HP-28/48 series of "
"calculators, its many features include:"
msgstr ""

#. type: itemize
#: ../../calc.texi:236
msgid "Choice of algebraic or RPN (stack-based) entry of calculations."
msgstr ""

#. type: itemize
#: ../../calc.texi:239
msgid "Arbitrary precision integers and floating-point numbers."
msgstr ""

#. type: itemize
#: ../../calc.texi:245
msgid ""
"Arithmetic on rational numbers, complex numbers (rectangular and polar), "
"error forms with standard deviations, open and closed intervals, vectors and "
"matrices, dates and times, infinities, sets, quantities with units, and "
"algebraic formulas."
msgstr ""

#. type: itemize
#: ../../calc.texi:248
msgid "Mathematical operations such as logarithms and trigonometric functions."
msgstr ""

#. type: itemize
#: ../../calc.texi:251
msgid "Programmer's features (bitwise operations, non-decimal numbers)."
msgstr ""

#. type: itemize
#: ../../calc.texi:254
msgid "Financial functions such as future value and internal rate of return."
msgstr ""

#. type: itemize
#: ../../calc.texi:258
msgid ""
"Number theoretical features such as prime factorization and arithmetic "
"modulo @var{m} for any @var{m}."
msgstr ""

#. type: itemize
#: ../../calc.texi:261
msgid "Algebraic manipulation features, including symbolic calculus."
msgstr ""

#. type: itemize
#: ../../calc.texi:264
msgid "Moving data to and from regular editing buffers."
msgstr ""

#. type: itemize
#: ../../calc.texi:268
msgid ""
"Embedded mode for manipulating Calc formulas and data directly inside any "
"editing buffer."
msgstr ""

#. type: itemize
#: ../../calc.texi:271
msgid "Graphics using GNUPLOT, a versatile (and free) plotting program."
msgstr ""

#. type: itemize
#: ../../calc.texi:275
msgid ""
"Easy programming using keyboard macros, algebraic formulas, algebraic "
"rewrite rules, or extended Emacs Lisp."
msgstr ""

#. type: Plain text
#: ../../calc.texi:285
msgid ""
"Calc tries to include a little something for everyone; as a result it is "
"large and might be intimidating to the first-time user.  If you plan to use "
"Calc only as a traditional desk calculator, all you really need to read is "
"the ``Getting Started'' chapter of this manual and possibly the first few "
"sections of the tutorial.  As you become more comfortable with the program "
"you can learn its additional features.  Calc does not have the scope and "
"depth of a fully-functional symbolic math package, but Calc has the "
"advantages of convenience, portability, and freedom."
msgstr ""

#. type: node
#: ../../calc.texi:286 ../../calc.texi:363 ../../calc.texi:364 ../../calc.texi:404
#, no-wrap
msgid "Notations Used in This Manual"
msgstr ""

#. type: Plain text
#: ../../calc.texi:296
msgid ""
"This document serves as a complete description of the GNU Emacs Calculator.  "
"It works both as an introduction for novices and as a reference for "
"experienced users.  While it helps to have some experience with GNU Emacs in "
"order to get the most out of Calc, this manual ought to be readable even if "
"you don't know or use Emacs regularly."
msgstr ""

#. type: Plain text
#: ../../calc.texi:304
msgid ""
"This manual is divided into three major parts: the ``Getting Started'' "
"chapter you are reading now, the Calc tutorial, and the Calc reference "
"manual."
msgstr ""

#. type: Plain text
#: ../../calc.texi:310
msgid ""
"If you are in a hurry to use Calc, there is a brief ``demonstration'' below "
"which illustrates the major features of Calc in just a couple of pages.  If "
"you don't have time to go through the full tutorial, this will show you "
"everything you need to know to begin.  @xref{Demonstration of Calc}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:318
msgid ""
"The tutorial chapter walks you through the various parts of Calc with lots "
"of hands-on examples and explanations.  If you are new to Calc and you have "
"some time, try going through at least the beginning of the tutorial.  The "
"tutorial includes about 70 exercises with answers.  These exercises give you "
"some guided practice with Calc, as well as pointing out some interesting and "
"unusual ways to use its features."
msgstr ""

#. type: Plain text
#: ../../calc.texi:324
msgid ""
"The reference section discusses Calc in complete depth.  You can read the "
"reference from start to finish if you want to learn every aspect of Calc.  "
"Or, you can look in the table of contents or the Concept Index to find the "
"parts of the manual that discuss the things you need to know."
msgstr ""

#. type: Plain text
#: ../../calc.texi:333
msgid ""
"Every Calc keyboard command is listed in the Calc Summary, and also in the "
"Key Index.  Algebraic functions, @kbd{M-x} commands, and variables also have "
"their own indices."
msgstr ""

#. type: Plain text
#: ../../calc.texi:344
msgid ""
"You can access this manual on-line at any time within Calc by pressing the "
"@kbd{h i} key sequence.  Outside of the Calc window, you can press @kbd{C-x "
"* i} to read the manual on-line.  From within Calc the command @kbd{h t} "
"will jump directly to the Tutorial; from outside of Calc the command "
"@kbd{C-x * t} will jump to the Tutorial and start Calc if necessary.  "
"Pressing @kbd{h s} or @kbd{C-x * s} will take you directly to the Calc "
"Summary.  Within Calc, you can also go to the part of the manual describing "
"any Calc key, function, or variable using @w{@kbd{h k}}, @kbd{h f}, or "
"@kbd{h v}, respectively.  @xref{Help Commands}."
msgstr ""

#. type: ifnottex
#: ../../calc.texi:359
msgid ""
"The Calc manual can be printed, but because the manual is so large, you "
"should only make a printed copy if you really need it.  To print the manual, "
"you will need the @TeX{} typesetting program (this is a free program by "
"Donald Knuth at Stanford University) as well as the @file{texindex} program "
"and @file{texinfo.tex} file, both of which can be obtained from the FSF as "
"part of the @code{texinfo} package.  To print the Calc manual in one huge "
"tome, you will need the Emacs source, which contains the source code to this "
"manual, @file{calc.texi}.  Change to the @file{doc/misc} subdirectory of the "
"Emacs source distribution, which contains source code for this manual, and "
"type @kbd{make calc.pdf}. (Don't worry if you get some ``overfull box'' "
"warnings while @TeX{} runs.)  The result will be this entire manual as a pdf "
"file."
msgstr ""

#. type: node
#: ../../calc.texi:363 ../../calc.texi:404 ../../calc.texi:408 ../../calc.texi:573
#, no-wrap
msgid "Demonstration of Calc"
msgstr ""

#. type: Plain text
#: ../../calc.texi:369
msgid ""
"This section describes the various notations that are used throughout the "
"Calc manual."
msgstr ""

#. type: Plain text
#: ../../calc.texi:379
msgid ""
"In keystroke sequences, uppercase letters mean you must hold down the shift "
"key while typing the letter.  Keys pressed with Control held down are shown "
"as @kbd{C-x}.  Keys pressed with Meta held down are shown as @kbd{M-x}.  "
"Other notations are @key{RET} for the Return key, @key{SPC} for the space "
"bar, @key{TAB} for the Tab key, @key{DEL} for the Delete key, and @key{LFD} "
"for the Line-Feed key.  The @key{DEL} key is called Backspace on some "
"keyboards, it is whatever key you would use to correct a simple typing error "
"when regularly using Emacs."
msgstr ""

#. type: Plain text
#: ../../calc.texi:385
msgid ""
"(If you don't have the @key{LFD} or @key{TAB} keys on your keyboard, the "
"@kbd{C-j} and @kbd{C-i} keys are equivalent to them, respectively.  If you "
"don't have a Meta key, look for Alt or Extend Char.  You can also press "
"@key{ESC} or @kbd{C-[} first to get the same effect, so that @kbd{M-x}, "
"@kbd{@key{ESC} x}, and @kbd{C-[ x} are all equivalent.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:389
msgid ""
"Sometimes the @key{RET} key is not shown when it is ``obvious'' that you "
"must press @key{RET} to proceed.  For example, the @key{RET} is usually "
"omitted in key sequences like @kbd{M-x calc-keypad @key{RET}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:394
msgid ""
"Commands are generally shown like this: @kbd{p} (@code{calc-precision})  or "
"@kbd{C-x * k} (@code{calc-keypad}).  This means that the command is normally "
"used by pressing the @kbd{p} key or @kbd{C-x * k} key sequence, but it also "
"has the full-name equivalent shown, e.g., @kbd{M-x calc-precision}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:400
msgid ""
"Commands that correspond to functions in algebraic notation are written: "
"@kbd{C} (@code{calc-cos}) [@code{cos}].  This means the @kbd{C} key is "
"equivalent to @kbd{M-x calc-cos}, and that the corresponding function in an "
"algebraic-style formula would be @samp{cos(@var{x})}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:403
msgid ""
"A few commands don't have key equivalents: @code{calc-sincos} "
"[@code{sincos}]."
msgstr ""

#. type: node
#: ../../calc.texi:404 ../../calc.texi:573 ../../calc.texi:574 ../../calc.texi:591 ../../calc.texi:622 ../../calc.texi:716 ../../calc.texi:739 ../../calc.texi:817 ../../calc.texi:844 ../../calc.texi:975 ../../calc.texi:1141
#, no-wrap
msgid "Using Calc"
msgstr ""

#. type: section
#: ../../calc.texi:405
#, no-wrap
msgid "A Demonstration of Calc"
msgstr ""

#. type: Plain text
#: ../../calc.texi:413
msgid ""
"This section will show some typical small problems being solved with Calc.  "
"The focus is more on demonstration than explanation, but everything you see "
"here will be covered more thoroughly in the Tutorial."
msgstr ""

#. type: Plain text
#: ../../calc.texi:418
msgid ""
"To begin, start Emacs if necessary (usually the command @code{emacs} does "
"this), and type @kbd{C-x * c} to start the Calculator.  (You can also use "
"@kbd{M-x calc} if this doesn't work.  @xref{Starting Calc}, for various ways "
"of starting the Calculator.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:423
msgid ""
"Be sure to type all the sample input exactly, especially noting the "
"difference between lower-case and upper-case letters.  Remember, @key{RET}, "
"@key{TAB}, @key{DEL}, and @key{SPC} are the Return, Tab, Delete, and Space "
"keys."
msgstr ""

#. type: Plain text
#: ../../calc.texi:426
msgid ""
"@strong{RPN calculation.} In RPN, you type the input number(s) first, then "
"the command to operate on the numbers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:431
msgid ""
"Type @kbd{2 @key{RET} 3 + Q} to compute @texline @math{\\sqrt{2+3} = "
"2.2360679775}.  @infoline the square root of 2+3, which is 2.2360679775."
msgstr ""

#. type: Plain text
#: ../../calc.texi:436
msgid ""
"Type @kbd{P 2 ^} to compute @texline @math{\\pi^2 = 9.86960440109}.  "
"@infoline the value of @cpi{} squared, 9.86960440109."
msgstr ""

#. type: Plain text
#: ../../calc.texi:439
msgid "Type @key{TAB} to exchange the order of these two results."
msgstr ""

#. type: Plain text
#: ../../calc.texi:443
msgid ""
"Type @kbd{- I H S} to subtract these results and compute the Inverse "
"Hyperbolic sine of the difference, 2.72996136574."
msgstr ""

#. type: Plain text
#: ../../calc.texi:446
msgid "Type @key{DEL} to erase this result."
msgstr ""

#. type: Plain text
#: ../../calc.texi:450
msgid ""
"@strong{Algebraic calculation.} You can also enter calculations using "
"conventional ``algebraic'' notation.  To enter an algebraic formula, use the "
"apostrophe key."
msgstr ""

#. type: Plain text
#: ../../calc.texi:455
msgid ""
"Type @kbd{' sqrt(2+3) @key{RET}} to compute @texline @math{\\sqrt{2+3}}.  "
"@infoline the square root of 2+3."
msgstr ""

#. type: Plain text
#: ../../calc.texi:461
msgid ""
"Type @kbd{' pi^2 @key{RET}} to enter @texline @math{\\pi^2}.  @infoline "
"@cpi{} squared.  To evaluate this symbolic formula as a number, type "
"@kbd{=}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:465
msgid ""
"Type @kbd{' arcsinh($ - $$) @key{RET}} to subtract the second-most-recent "
"result from the most-recent and compute the Inverse Hyperbolic sine."
msgstr ""

#. type: Plain text
#: ../../calc.texi:469
msgid ""
"@strong{Keypad mode.} If you are using the X window system, press "
"@w{@kbd{C-x * k}} to get Keypad mode.  (If you don't use X, skip to the next "
"section.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:473
msgid ""
"Click on the @key{2}, @key{ENTER}, @key{3}, @key{+}, and @key{SQRT} "
"``buttons'' using your left mouse button."
msgstr ""

#. type: Plain text
#: ../../calc.texi:476
msgid "Click on @key{PI}, @key{2}, and @tfn{y^x}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:479
msgid "Click on @key{INV}, then @key{ENTER} to swap the two results."
msgstr ""

#. type: Plain text
#: ../../calc.texi:482
msgid "Click on @key{-}, @key{INV}, @key{HYP}, and @key{SIN}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:486
msgid ""
"Click on @key{<-} to erase the result, then click @key{OFF} to turn the "
"Keypad Calculator off."
msgstr ""

#. type: Plain text
#: ../../calc.texi:494
msgid ""
"@strong{Grabbing data.} Type @kbd{C-x * x} if necessary to exit Calc.  Now "
"select the following numbers as an Emacs region: ``Mark'' the front of the "
"list by typing @kbd{C-@key{SPC}} or @kbd{C-@@} there, then move to the other "
"end of the list.  (Either get this list from the on-line copy of this "
"manual, accessed by @w{@kbd{C-x * i}}, or just type these numbers into a "
"scratch file.)  Now type @kbd{C-x * g} to ``grab'' these numbers into Calc."
msgstr ""

#. type: group
#: ../../calc.texi:500
#, no-wrap
msgid ""
"1.23  1.97\n"
"1.6   2\n"
"1.19  1.08\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:506
msgid ""
"The result @samp{[1.23, 1.97, 1.6, 2, 1.19, 1.08]} is a Calc ``vector.'' "
"Type @w{@kbd{V R +}} to compute the sum of these numbers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:510
msgid ""
"Type @kbd{U} to Undo this command, then type @kbd{V R *} to compute the "
"product of the numbers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:515
msgid ""
"You can also grab data as a rectangular matrix.  Place the cursor on the "
"upper-leftmost @samp{1} and set the mark, then move to just after the "
"lower-right @samp{8} and press @kbd{C-x * r}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:527
msgid ""
"Type @kbd{v t} to transpose this @texline @math{3\\times2} @infoline 3x2 "
"matrix into a @texline @math{2\\times3} @infoline 2x3 matrix.  Type "
"@w{@kbd{v u}} to unpack the rows into two separate vectors.  Now type "
"@w{@kbd{V R + @key{TAB} V R +}} to compute the sums of the two original "
"columns. (There is also a special grab-and-sum-columns command, @kbd{C-x * "
":}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:531
msgid ""
"@strong{Units conversion.} Units are entered algebraically.  Type @w{@kbd{' "
"43 mi/hr @key{RET}}} to enter the quantity 43 miles-per-hour.  Type "
"@w{@kbd{u c km/hr @key{RET}}}.  Type @w{@kbd{u c m/s @key{RET}}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:536
msgid ""
"@strong{Date arithmetic.} Type @kbd{t N} to get the current date and time.  "
"Type @kbd{90 +} to find the date 90 days from now.  Type @kbd{' <25 dec 87> "
"@key{RET}} to enter a date, then @kbd{- 7 /} to see how many weeks have "
"passed since then."
msgstr ""

#. type: Plain text
#: ../../calc.texi:543
msgid ""
"@strong{Algebra.} Algebraic entries can also include formulas or equations "
"involving variables.  Type @kbd{@w{' [x + y} = a, x y = 1] @key{RET}} to "
"enter a pair of equations involving three variables.  (Note the leading "
"apostrophe in this example; also, note that the space in @samp{x y} is "
"required.)  Type @w{@kbd{a S x,y @key{RET}}} to solve these equations for "
"the variables @expr{x} and @expr{y}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:550
msgid ""
"Type @kbd{d B} to view the solutions in more readable notation.  Type "
"@w{@kbd{d C}} to view them in C language notation, @kbd{d T} to view them in "
"the notation for the @TeX{} typesetting system, and @kbd{d L} to view them "
"in the notation for the @LaTeX{} typesetting system.  Type @kbd{d N} to "
"return to normal notation."
msgstr ""

#. type: Plain text
#: ../../calc.texi:554
msgid ""
"Type @kbd{7.5}, then @kbd{s l a @key{RET}} to let @expr{a = 7.5} in these "
"formulas.  (That's the letter @kbd{l}, not the numeral @kbd{1}.)"
msgstr ""

#. type: ifnotinfo
#: ../../calc.texi:561
msgid ""
"@strong{Help functions.} You can read about any command in the on-line "
"manual.  Type @kbd{C-x * c} to return to Calc after each of these commands: "
"@kbd{h k t N} to read about the @kbd{t N} command, @kbd{h f sqrt @key{RET}} "
"to read about the @code{sqrt} function, and @kbd{h s} to read the Calc "
"summary."
msgstr ""

#. type: ifinfo
#: ../../calc.texi:568
msgid ""
"@strong{Help functions.} You can read about any command in the on-line "
"manual.  Remember to type the letter @kbd{l}, then @kbd{C-x * c}, to return "
"here after each of these commands: @w{@kbd{h k t N}} to read about the "
"@w{@kbd{t N}} command, @kbd{h f sqrt @key{RET}} to read about the "
"@code{sqrt} function, and @kbd{h s} to read the Calc summary."
msgstr ""

#. type: Plain text
#: ../../calc.texi:572
msgid ""
"Press @key{DEL} repeatedly to remove any leftover results from the stack.  "
"To exit from Calc, press @kbd{q} or @kbd{C-x * c} again."
msgstr ""

#. type: Plain text
#: ../../calc.texi:580
msgid ""
"Calc has several user interfaces that are specialized for different kinds of "
"tasks.  As well as Calc's standard interface, there are Quick mode, Keypad "
"mode, and Embedded mode."
msgstr ""

#. type: menuentry
#: ../../calc.texi:589
msgid "Starting Calc::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:589
msgid "The Standard Interface::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:589
msgid "Quick Mode Overview::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:589
msgid "Keypad Mode Overview::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:589
msgid "Standalone Operation::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:589
msgid "Embedded Mode Overview::"
msgstr ""

#. type: node
#: ../../calc.texi:589 ../../calc.texi:844 ../../calc.texi:975
#, no-wrap
msgid "Other C-x * Commands"
msgstr ""

#. type: node
#: ../../calc.texi:591 ../../calc.texi:592 ../../calc.texi:622
#, no-wrap
msgid "Starting Calc"
msgstr ""

#. type: node
#: ../../calc.texi:591 ../../calc.texi:622 ../../calc.texi:716
#, no-wrap
msgid "The Standard Interface"
msgstr ""

#. type: Plain text
#: ../../calc.texi:598
msgid ""
"On most systems, you can type @kbd{C-x *} to start the Calculator.  The key "
"sequence @kbd{C-x *} is bound to the command @code{calc-dispatch}, which can "
"be rebound if convenient (@pxref{Customizing Calc})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:603
msgid ""
"When you press @kbd{C-x *}, Emacs waits for you to press a second key to "
"complete the command.  In this case, you will follow @kbd{C-x *} with a "
"letter (upper- or lower-case, it doesn't matter for @kbd{C-x *}) that says "
"which Calc interface you want to use."
msgstr ""

#. type: Plain text
#: ../../calc.texi:608
msgid ""
"To get Calc's standard interface, type @kbd{C-x * c}.  To get Keypad mode, "
"type @kbd{C-x * k}.  Type @kbd{C-x * ?} to get a brief list of the available "
"options, and type a second @kbd{?} to get a complete list."
msgstr ""

#. type: Plain text
#: ../../calc.texi:612
msgid ""
"To ease typing, @kbd{C-x * *} also works to start Calc.  It starts the same "
"interface (either @kbd{C-x * c} or @w{@kbd{C-x * k}}) that you last used, "
"selecting the @kbd{C-x * c} interface by default."
msgstr ""

#. type: Plain text
#: ../../calc.texi:618
msgid ""
"If @kbd{C-x *} doesn't work for you, you can always type explicit commands "
"like @kbd{M-x calc} (for the standard user interface) or @w{@kbd{M-x "
"calc-keypad}} (for Keypad mode).  First type @kbd{M-x} (that's Meta with the "
"letter @kbd{x}), then, at the prompt, type the full command (like "
"@kbd{calc-keypad}) and press Return."
msgstr ""

#. type: Plain text
#: ../../calc.texi:621
msgid ""
"The same commands (like @kbd{C-x * c} or @kbd{C-x * *}) that start the "
"Calculator also turn it off if it is already on."
msgstr ""

#. type: node
#: ../../calc.texi:622 ../../calc.texi:716 ../../calc.texi:739
#, no-wrap
msgid "Quick Mode Overview"
msgstr ""

#. type: subsection
#: ../../calc.texi:623
#, no-wrap
msgid "The Standard Calc Interface"
msgstr ""

#. type: cindex
#: ../../calc.texi:626
#, no-wrap
msgid "Standard user interface"
msgstr ""

#. type: Plain text
#: ../../calc.texi:631
msgid ""
"Calc's standard interface acts like a traditional RPN calculator, operated "
"by the normal Emacs keyboard.  When you type @kbd{C-x * c} to start the "
"Calculator, the Emacs screen splits into two windows with the file you were "
"editing on top and Calc on the bottom."
msgstr ""

#. type: group
#: ../../calc.texi:646
#, no-wrap
msgid ""
"...\n"
"--**-Emacs: myfile             (Fundamental)----All----------------------\n"
"--- Emacs Calculator Mode ---                   |Emacs Calculator Trail\n"
"2:  17.3                                        |    17.3\n"
"1:  -5                                          |    3\n"
"    .                                           |    2\n"
"                                                |    4\n"
"                                                |  * 8\n"
"                                                |  ->-5\n"
"                                                |\n"
"--%*-Calc: 12 Deg       (Calculator)----All----- --%*- *Calc Trail*\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:658
msgid ""
"In this figure, the mode-line for @file{myfile} has moved up and the "
"``Calculator'' window has appeared below it.  As you can see, Calc actually "
"makes two windows side-by-side.  The lefthand one is called the @dfn{stack "
"window} and the righthand one is called the @dfn{trail window.} The stack "
"holds the numbers involved in the calculation you are currently performing.  "
"The trail holds a complete record of all calculations you have done.  In a "
"desk calculator with a printer, the trail corresponds to the paper tape that "
"records what you do."
msgstr ""

#. type: Plain text
#: ../../calc.texi:664
msgid ""
"In this case, the trail shows that four numbers (17.3, 3, 2, and 4)  were "
"first entered into the Calculator, then the 2 and 4 were multiplied to get "
"8, then the 3 and 8 were subtracted to get @mathit{-5}.  (The @samp{>} "
"symbol shows that this was the most recent calculation.)  The net result is "
"the two numbers 17.3 and @mathit{-5} sitting on the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:668
msgid ""
"Most Calculator commands deal explicitly with the stack only, but there is a "
"set of commands that allow you to search back through the trail and retrieve "
"any previous result."
msgstr ""

#. type: Plain text
#: ../../calc.texi:676
msgid ""
"Calc commands use the digits, letters, and punctuation keys.  Shifted (i.e., "
"upper-case) letters are different from lowercase letters.  Some letters are "
"@dfn{prefix} keys that begin two-letter commands.  For example, @kbd{e} "
"means ``enter exponent'' and shifted @kbd{E} means @expr{e^x}.  With the "
"@kbd{d} (``display modes'') prefix the letter ``e'' takes on very different "
"meanings: @kbd{d e} means ``engineering notation'' and @kbd{d E} means "
"``@dfn{eqn} language mode.''"
msgstr ""

#. type: Plain text
#: ../../calc.texi:683
msgid ""
"There is nothing stopping you from switching out of the Calc window and back "
"into your editing window, say by using the Emacs @w{@kbd{C-x o}} "
"(@code{other-window}) command.  When the cursor is inside a regular window, "
"Emacs acts just like normal.  When the cursor is in the Calc stack or trail "
"windows, keys are interpreted as Calc commands."
msgstr ""

#. type: Plain text
#: ../../calc.texi:689
msgid ""
"When you quit by pressing @kbd{C-x * c} a second time, the Calculator "
"windows go away but the actual Stack and Trail are not gone, just hidden.  "
"When you press @kbd{C-x * c} once again you will get the same stack and "
"trail contents you had when you last used the Calculator."
msgstr ""

#. type: Plain text
#: ../../calc.texi:697
msgid ""
"The Calculator does not remember its state between Emacs sessions.  Thus if "
"you quit Emacs and start it again, @kbd{C-x * c} will give you a fresh stack "
"and trail.  There is a command (@kbd{m m}) that lets you save your favorite "
"mode settings between sessions, though.  One of the things it saves is which "
"user interface (standard or Keypad) you last used; otherwise, a freshly "
"started Emacs will always treat @kbd{C-x * *} the same as @kbd{C-x * c}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:699
msgid "The @kbd{q} key is another equivalent way to turn the Calculator off."
msgstr ""

#. type: Plain text
#: ../../calc.texi:707
msgid ""
"If you type @kbd{C-x * b} first and then @kbd{C-x * c}, you get a "
"full-screen version of Calc (@code{full-calc}) in which the stack and trail "
"windows are still side-by-side but are now as tall as the whole Emacs "
"screen.  When you press @kbd{q} or @kbd{C-x * c} again to quit, the file you "
"were editing before reappears.  The @kbd{C-x * b} key switches back and "
"forth between ``big'' full-screen mode and the normal partial-screen mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:715
msgid ""
"Finally, @kbd{C-x * o} (@code{calc-other-window}) is like @kbd{C-x * c} "
"except that the Calc window is not selected.  The buffer you were editing "
"before remains selected instead.  If you are in a Calc window, then @kbd{C-x "
"* o} will switch you out of it, being careful not to switch you to the Calc "
"Trail window.  So @kbd{C-x * o} is a handy way to switch out of Calc "
"momentarily to edit your file; you can then type @kbd{C-x * c} to switch "
"back into Calc when you are done."
msgstr ""

#. type: node
#: ../../calc.texi:716 ../../calc.texi:739 ../../calc.texi:817
#, no-wrap
msgid "Keypad Mode Overview"
msgstr ""

#. type: subsection
#: ../../calc.texi:717
#, no-wrap
msgid "Quick Mode (Overview)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:723
msgid ""
"@dfn{Quick mode} is a quick way to use Calc when you don't need the full "
"complexity of the stack and trail.  To use it, type @kbd{C-x * q} "
"(@code{quick-calc}) in any regular editing buffer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:732
msgid ""
"Quick mode is very simple: It prompts you to type any formula in standard "
"algebraic notation (like @samp{4 - 2/3}) and then displays the result at the "
"bottom of the Emacs screen (@mathit{3.33333333333} in this case).  You are "
"then back in the same editing buffer you were in before, ready to continue "
"editing or to type @kbd{C-x * q} again to do another quick calculation.  The "
"result of the calculation will also be in the Emacs ``kill ring'' so that a "
"@kbd{C-y} command at this point will yank the result into your editing "
"buffer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:735
msgid ""
"Calc mode settings affect Quick mode, too, though you will have to go into "
"regular Calc (with @kbd{C-x * c}) to change the mode settings."
msgstr ""

#. type: Plain text
#: ../../calc.texi:738
msgid "@xref{Quick Calculator}, for further information."
msgstr ""

#. type: node
#: ../../calc.texi:739 ../../calc.texi:817 ../../calc.texi:818 ../../calc.texi:821 ../../calc.texi:844
#, no-wrap
msgid "Standalone Operation"
msgstr ""

#. type: subsection
#: ../../calc.texi:740
#, no-wrap
msgid "Keypad Mode (Overview)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:747
msgid ""
"@dfn{Keypad mode} is a mouse-based interface to the Calculator.  It is "
"designed for use with terminals that support a mouse.  If you don't have a "
"mouse, you will have to operate Keypad mode with your arrow keys (which is "
"probably more trouble than it's worth)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:752
msgid ""
"Type @kbd{C-x * k} to turn Keypad mode on or off.  Once again you get two "
"new windows, this time on the righthand side of the screen instead of at the "
"bottom.  The upper window is the familiar Calc Stack; the lower window is a "
"picture of a typical calculator keypad."
msgstr ""

#. type: tex
#: ../../calc.texi:758
#, no-wrap
msgid ""
"\\dimen0=\\pagetotal%\n"
"\\advance \\dimen0 by 24\\baselineskip%\n"
"\\ifdim \\dimen0>\\pagegoal \\vfill\\eject \\fi%\n"
"\\medskip\n"
msgstr ""

#. type: group
#: ../../calc.texi:783
#, no-wrap
msgid ""
"|--- Emacs Calculator Mode ---\n"
"|2:  17.3\n"
"|1:  -5\n"
"|    .\n"
"|--%*-Calc: 12 Deg       (Calcul\n"
"|----+----+--Calc---+----+----1\n"
"|FLR |CEIL|RND |TRNC|CLN2|FLT |\n"
"|----+----+----+----+----+----|\n"
"| LN |EXP |    |ABS |IDIV|MOD |\n"
"|----+----+----+----+----+----|\n"
"|SIN |COS |TAN |SQRT|y^x |1/x |\n"
"|----+----+----+----+----+----|\n"
"|  ENTER  |+/- |EEX |UNDO| <- |\n"
"|-----+---+-+--+--+-+---++----|\n"
"| INV |  7  |  8  |  9  |  /  |\n"
"|-----+-----+-----+-----+-----|\n"
"| HYP |  4  |  5  |  6  |  *  |\n"
"|-----+-----+-----+-----+-----|\n"
"|EXEC |  1  |  2  |  3  |  -  |\n"
"|-----+-----+-----+-----+-----|\n"
"| OFF |  0  |  .  | PI  |  +  |\n"
"|-----+-----+-----+-----+-----+\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:792
msgid ""
"Keypad mode is much easier for beginners to learn, because there is no need "
"to memorize lots of obscure key sequences.  But not all commands in regular "
"Calc are available on the Keypad.  You can always switch the cursor into the "
"Calc stack window to use standard Calc commands if you need.  Serious Calc "
"users, though, often find they prefer the standard interface over Keypad "
"mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:798
msgid ""
"To operate the Calculator, just click on the ``buttons'' of the keypad using "
"your left mouse button.  To enter the two numbers shown here you would click "
"@w{@kbd{1 7 .@: 3 ENTER 5 +/- ENTER}}; to add them together you would then "
"click @kbd{+} (to get 12.3 on the stack)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:803
msgid ""
"If you click the right mouse button, the top three rows of the keypad change "
"to show other sets of commands, such as advanced math functions, vector "
"operations, and operations on binary numbers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:809
msgid ""
"Because Keypad mode doesn't use the regular keyboard, Calc leaves the cursor "
"in your original editing buffer.  You can type in this buffer in the usual "
"way while also clicking on the Calculator keypad.  One advantage of Keypad "
"mode is that you don't need an explicit command to switch between editing "
"and calculating."
msgstr ""

#. type: Plain text
#: ../../calc.texi:813
msgid ""
"If you press @kbd{C-x * b} first, you get a full-screen Keypad mode "
"(@code{full-calc-keypad}) with three windows: The keypad in the lower left, "
"the stack in the lower right, and the trail on top."
msgstr ""

#. type: Plain text
#: ../../calc.texi:816
msgid "@xref{Keypad Mode}, for further information."
msgstr ""

#. type: node
#: ../../calc.texi:817 ../../calc.texi:844 ../../calc.texi:975
#, no-wrap
msgid "Embedded Mode Overview"
msgstr ""

#. type: Plain text
#: ../../calc.texi:825
msgid ""
"If you are not in Emacs at the moment but you wish to use Calc, you must "
"start Emacs first.  If all you want is to run Calc, you can give the "
"commands:"
msgstr ""

#. type: example
#: ../../calc.texi:828
#, no-wrap
msgid "emacs -f full-calc\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:832
msgid "or"
msgstr ""

#. type: example
#: ../../calc.texi:835
#, no-wrap
msgid "emacs -f full-calc-keypad\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:843
msgid ""
"which run a full-screen Calculator (as if by @kbd{C-x * b C-x * c}) or a "
"full-screen X-based Calculator (as if by @kbd{C-x * b C-x * k}).  In "
"standalone operation, quitting the Calculator (by pressing @kbd{q} or "
"clicking on the keypad @key{EXIT} button) quits Emacs itself."
msgstr ""

#. type: subsection
#: ../../calc.texi:845
#, no-wrap
msgid "Embedded Mode (Overview)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:851
msgid ""
"@dfn{Embedded mode} is a way to use Calc directly from inside an editing "
"buffer.  Suppose you have a formula written as part of a document like this:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:855 ../../calc.texi:872 ../../calc.texi:896 ../../calc.texi:914 ../../calc.texi:30822 ../../calc.texi:30850 ../../calc.texi:30860
#, no-wrap
msgid ""
"The derivative of\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:857 ../../calc.texi:874 ../../calc.texi:898 ../../calc.texi:916
#, no-wrap
msgid ""
"                                   ln(ln(x))\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:859
#, no-wrap
msgid "is\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:868
msgid ""
"and you wish to have Calc compute and format the derivative for you and "
"store this derivative in the buffer automatically.  To do this with Embedded "
"mode, first copy the formula down to where you want the result to be, "
"leaving a blank line before and after the formula:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:876 ../../calc.texi:900 ../../calc.texi:30826
#, no-wrap
msgid ""
"is\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:878
#, no-wrap
msgid "                                   ln(ln(x))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:892
msgid ""
"Now, move the cursor onto this new formula and press @kbd{C-x * e}.  Calc "
"will read the formula (using the surrounding blank lines to tell how much "
"text to read), then push this formula (invisibly) onto the Calc stack.  The "
"cursor will stay on the formula in the editing buffer, but the line with the "
"formula will now appear as it would on the Calc stack (in this case, it will "
"be left-aligned) and the buffer's mode line will change to look like the "
"Calc mode line (with mode indicators like @samp{12 Deg} and so on).  Even "
"though you are still in your editing buffer, the keyboard now acts like the "
"Calc keyboard, and any new result you get is copied from the stack back into "
"the buffer.  To take the derivative, you would type @kbd{a d x @key{RET}}."
msgstr ""

#. type: group
#: ../../calc.texi:902
#, no-wrap
msgid "1 / x ln(x)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:907
msgid ""
"(Note that by default, Calc gives division lower precedence than "
"multiplication, so that @samp{1 / x ln(x)} is equivalent to @samp{1 / (x "
"ln(x))}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:910
msgid ""
"To make this look nicer, you might want to press @kbd{d =} to center the "
"formula, and even @kbd{d B} to use Big display mode."
msgstr ""

#. type: group
#: ../../calc.texi:920
#, no-wrap
msgid ""
"is\n"
"% [calc-mode: justify: center]\n"
"% [calc-mode: language: big]\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:924
#, no-wrap
msgid ""
"                                       1\n"
"                                    -------\n"
"                                    x ln(x)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:933
msgid ""
"Calc has added annotations to the file to help it remember the modes that "
"were used for this formula.  They are formatted like comments in the @TeX{} "
"typesetting language, just in case you are using @TeX{} or @LaTeX{}. (In "
"this example @TeX{} is not being used, so you might want to move these "
"comments up to the top of the file or otherwise put them out of the way.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:936
msgid ""
"As an extra flourish, we can add an equation number using a righthand label: "
"Type @kbd{d @} (1) @key{RET}}."
msgstr ""

#. type: group
#: ../../calc.texi:942
#, no-wrap
msgid ""
"% [calc-mode: justify: center]\n"
"% [calc-mode: language: big]\n"
"% [calc-mode: right-label: \" (1)\"]\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:946
#, no-wrap
msgid ""
"                                       1\n"
"                                    -------                      (1)\n"
"                                    ln(x) x\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:951
msgid ""
"To leave Embedded mode, type @kbd{C-x * e} again.  The mode line and "
"keyboard will revert to the way they were before."
msgstr ""

#. type: Plain text
#: ../../calc.texi:958
msgid ""
"The related command @kbd{C-x * w} operates on a single word, which generally "
"means a single number, inside text.  It searches for an expression which "
"``looks'' like a number containing the point.  Here's an example of its use "
"(before you try this, remove the Calc annotations or use a new buffer so "
"that the extra settings in the annotations don't take effect):"
msgstr ""

#. type: smallexample
#: ../../calc.texi:961
#, no-wrap
msgid "A slope of one-third corresponds to an angle of 1 degrees.\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:967
msgid ""
"Place the cursor on the @samp{1}, then type @kbd{C-x * w} to enable Embedded "
"mode on that number.  Now type @kbd{3 /} (to get one-third), and @kbd{I T} "
"(the Inverse Tangent converts a slope into an angle), then @w{@kbd{C-x * w}} "
"again to exit Embedded mode."
msgstr ""

#. type: smallexample
#: ../../calc.texi:970
#, no-wrap
msgid "A slope of one-third corresponds to an angle of 18.4349488229 degrees.\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:974
msgid "@xref{Embedded Mode}, for full details."
msgstr ""

#. type: subsection
#: ../../calc.texi:976
#, no-wrap
msgid "Other @kbd{C-x *} Commands"
msgstr ""

#. type: Plain text
#: ../../calc.texi:984
msgid ""
"Two more Calc-related commands are @kbd{C-x * g} and @kbd{C-x * r}, which "
"``grab'' data from a selected region of a buffer into the Calculator.  The "
"region is defined in the usual Emacs way, by a ``mark'' placed at one end of "
"the region, and the Emacs cursor or ``point'' placed at the other."
msgstr ""

#. type: Plain text
#: ../../calc.texi:992
msgid ""
"The @kbd{C-x * g} command reads the region in the usual left-to-right, "
"top-to-bottom order.  The result is packaged into a Calc vector of numbers "
"and placed on the stack.  Calc (in its standard user interface) is then "
"started.  Type @kbd{v u} if you want to unpack this vector into separate "
"numbers on the stack.  Also, @kbd{C-u C-x * g} interprets the region as a "
"single number or formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:996
msgid ""
"The @kbd{C-x * r} command reads a rectangle, with the point and mark "
"defining opposite corners of the rectangle.  The result is a matrix of "
"numbers on the Calculator stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1005
msgid ""
"Complementary to these is @kbd{C-x * y}, which ``yanks'' the value at the "
"top of the Calc stack back into an editing buffer.  If you type @w{@kbd{C-x "
"* y}} while in such a buffer, the value is yanked at the current position.  "
"If you type @kbd{C-x * y} while in the Calc buffer, Calc makes an educated "
"guess as to which editing buffer you want to use.  The Calc window does not "
"have to be visible in order to use this command, as long as there is "
"something on the Calc stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1009
msgid ""
"Here, for reference, is the complete list of @kbd{C-x *} commands.  The "
"shift, control, and meta keys are ignored for the keystroke following "
"@kbd{C-x *}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1012
msgid "Commands for turning Calc on and off:"
msgstr ""

#. type: kindex
#: ../../calc.texi:1014 ../../calc.texi:16238
#, no-wrap
msgid "*"
msgstr ""

#. type: table
#: ../../calc.texi:1016
msgid "Turn Calc on or off, employing the same user interface as last time."
msgstr ""

#. type: item
#: ../../calc.texi:1017
#, no-wrap
msgid "=, +, -, /, \\, &, #"
msgstr ""

#. type: table
#: ../../calc.texi:1019
msgid "Alternatives for @kbd{*}."
msgstr ""

#. type: kindex
#: ../../calc.texi:1020 ../../calc.texi:16017 ../../calc.texi:18460
#, no-wrap
msgid "C"
msgstr ""

#. type: table
#: ../../calc.texi:1024
msgid ""
"Turn Calc on or off using its standard bottom-of-the-screen interface.  If "
"Calc is already turned on but the cursor is not in the Calc window, move the "
"cursor into the window."
msgstr ""

#. type: kindex
#: ../../calc.texi:1025 ../../calc.texi:12265
#, no-wrap
msgid "O"
msgstr ""

#. type: table
#: ../../calc.texi:1029
msgid ""
"Same as @kbd{C}, but don't select the new Calc window.  If Calc is already "
"turned on and the cursor is in the Calc window, move it out of that window."
msgstr ""

#. type: kindex
#: ../../calc.texi:1030 ../../calc.texi:18361
#, no-wrap
msgid "B"
msgstr ""

#. type: table
#: ../../calc.texi:1032
msgid "Control whether @kbd{C-x * c} and @kbd{C-x * k} use the full screen."
msgstr ""

#. type: kindex
#: ../../calc.texi:1033 ../../calc.texi:16415
#, no-wrap
msgid "Q"
msgstr ""

#. type: table
#: ../../calc.texi:1035
msgid "Use Quick mode for a single short calculation."
msgstr ""

#. type: kindex
#: ../../calc.texi:1036 ../../calc.texi:12040
#, no-wrap
msgid "K"
msgstr ""

#. type: table
#: ../../calc.texi:1038
msgid "Turn Calc Keypad mode on or off."
msgstr ""

#. type: item
#: ../../calc.texi:1039 ../../calc.texi:18328 ../../calc.texi:24833
#, no-wrap
msgid "E"
msgstr ""

#. type: table
#: ../../calc.texi:1041
msgid "Turn Calc Embedded mode on or off at the current formula."
msgstr ""

#. type: kindex
#: ../../calc.texi:1042 ../../calc.texi:13659 ../../calc.texi:16641
#, no-wrap
msgid "J"
msgstr ""

#. type: table
#: ../../calc.texi:1044
msgid "Turn Calc Embedded mode on or off, select the interesting part."
msgstr ""

#. type: item
#: ../../calc.texi:1045 ../../calc.texi:13591
#, no-wrap
msgid "W"
msgstr ""

#. type: table
#: ../../calc.texi:1047
msgid "Turn Calc Embedded mode on or off at the current word (number)."
msgstr ""

#. type: item
#: ../../calc.texi:1048
#, no-wrap
msgid "Z"
msgstr ""

#. type: table
#: ../../calc.texi:1050
msgid "Turn Calc on in a user-defined way, as defined by a @kbd{Z I} command."
msgstr ""

#. type: kindex
#: ../../calc.texi:1051 ../../calc.texi:13665 ../../calc.texi:24837 ../../calc.texi:31571
#, no-wrap
msgid "X"
msgstr ""

#. type: table
#: ../../calc.texi:1054
msgid ""
"Quit Calc; turn off standard, Keypad, or Embedded mode if on.  (This is like "
"@kbd{q} or @key{OFF} inside of Calc.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1061
msgid "Commands for moving data into and out of the Calculator:"
msgstr ""

#. type: kindex
#: ../../calc.texi:1063 ../../calc.texi:16650
#, no-wrap
msgid "G"
msgstr ""

#. type: table
#: ../../calc.texi:1065
msgid "Grab the region into the Calculator as a vector."
msgstr ""

#. type: kindex
#: ../../calc.texi:1066 ../../calc.texi:16553
#, no-wrap
msgid "R"
msgstr ""

#. type: table
#: ../../calc.texi:1068
msgid "Grab the rectangular region into the Calculator as a matrix."
msgstr ""

#. type: kindex
#: ../../calc.texi:1069 ../../calc.texi:16361
#, no-wrap
msgid ":"
msgstr ""

#. type: table
#: ../../calc.texi:1071
msgid "Grab the rectangular region and compute the sums of its columns."
msgstr ""

#. type: kindex
#: ../../calc.texi:1072 ../../calc.texi:9978
#, no-wrap
msgid "_"
msgstr ""

#. type: table
#: ../../calc.texi:1074
msgid "Grab the rectangular region and compute the sums of its rows."
msgstr ""

#. type: kindex
#: ../../calc.texi:1075 ../../calc.texi:13531 ../../calc.texi:32435
#, no-wrap
msgid "Y"
msgstr ""

#. type: table
#: ../../calc.texi:1077
msgid "Yank a value from the Calculator into the current editing buffer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1084
msgid "Commands for use with Embedded mode:"
msgstr ""

#. type: kindex
#: ../../calc.texi:1086 ../../calc.texi:16379
#, no-wrap
msgid "A"
msgstr ""

#. type: table
#: ../../calc.texi:1090
msgid ""
"``Activate'' the current buffer.  Locate all formulas that contain @samp{:=} "
"or @samp{=>} symbols and record their locations so that they can be updated "
"automatically as variables are changed."
msgstr ""

#. type: item
#: ../../calc.texi:1091 ../../calc.texi:10261 ../../calc.texi:13585
#, no-wrap
msgid "D"
msgstr ""

#. type: table
#: ../../calc.texi:1094
msgid "Duplicate the current formula immediately below and select the duplicate."
msgstr ""

#. type: kindex
#: ../../calc.texi:1095 ../../calc.texi:16528
#, no-wrap
msgid "F"
msgstr ""

#. type: table
#: ../../calc.texi:1097
msgid "Insert a new formula at the current point."
msgstr ""

#. type: item
#: ../../calc.texi:1098 ../../calc.texi:12435 ../../calc.texi:13655
#, no-wrap
msgid "N"
msgstr ""

#. type: table
#: ../../calc.texi:1100
msgid "Move the cursor to the next active formula in the buffer."
msgstr ""

#. type: kindex
#: ../../calc.texi:1101 ../../calc.texi:13629 ../../calc.texi:18254
#, no-wrap
msgid "P"
msgstr ""

#. type: table
#: ../../calc.texi:1103
msgid "Move the cursor to the previous active formula in the buffer."
msgstr ""

#. type: item
#: ../../calc.texi:1104 ../../calc.texi:10237 ../../calc.texi:13663
#, no-wrap
msgid "U"
msgstr ""

#. type: table
#: ../../calc.texi:1106
msgid "Update (i.e., as if by the @kbd{=} key) the formula at the current point."
msgstr ""

#. type: kindex
#: ../../calc.texi:1107 ../../calc.texi:11865
#, no-wrap
msgid "`"
msgstr ""

#. type: table
#: ../../calc.texi:1109
msgid "Edit (as if by @code{calc-edit}) the formula at the current point."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1116
msgid "Miscellaneous commands:"
msgstr ""

#. type: kindex
#: ../../calc.texi:1118 ../../calc.texi:12243
#, no-wrap
msgid "I"
msgstr ""

#. type: table
#: ../../calc.texi:1121
msgid ""
"Run the Emacs Info system to read the Calc manual.  (This is the same as "
"@kbd{h i} inside of Calc.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:1122 ../../calc.texi:13613 ../../calc.texi:18493
#, no-wrap
msgid "T"
msgstr ""

#. type: table
#: ../../calc.texi:1124
msgid "Run the Emacs Info system to read the Calc Tutorial."
msgstr ""

#. type: kindex
#: ../../calc.texi:1125 ../../calc.texi:18410
#, no-wrap
msgid "S"
msgstr ""

#. type: table
#: ../../calc.texi:1127
msgid "Run the Emacs Info system to read the Calc Summary."
msgstr ""

#. type: item
#: ../../calc.texi:1128 ../../calc.texi:18316 ../../calc.texi:24841
#, no-wrap
msgid "L"
msgstr ""

#. type: table
#: ../../calc.texi:1131
msgid ""
"Load Calc entirely into memory.  (Normally the various parts are loaded only "
"as they are needed.)"
msgstr ""

#. type: item
#: ../../calc.texi:1132 ../../calc.texi:10387 ../../calc.texi:13569
#, no-wrap
msgid "M"
msgstr ""

#. type: table
#: ../../calc.texi:1135
msgid ""
"Read a region of written keystroke names (like @kbd{C-n a b c @key{RET}})  "
"and record them as the current keyboard macro."
msgstr ""

#. type: item
#: ../../calc.texi:1136 ../../calc.texi:13774
#, no-wrap
msgid "0"
msgstr ""

#. type: table
#: ../../calc.texi:1139
msgid ""
"(This is the ``zero'' digit key.)  Reset the Calculator to its initial "
"state: Empty stack, and initial mode settings."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1156
msgid ""
"Calc was originally started as a two-week project to occupy a lull in the "
"author's schedule.  Basically, a friend asked if I remembered the value of "
"@texline @math{2^{32}}.  @infoline @expr{2^32}.  I didn't offhand, but I "
"said, ``that's easy, just call up an @code{xcalc}.'' @code{Xcalc} duly "
"reported that the answer to our question was @samp{4.294967e+09}---with no "
"way to see the full ten digits even though we knew they were there in the "
"program's memory! I was so annoyed, I vowed to write a calculator of my own, "
"once and for all."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1161
msgid ""
"I chose Emacs Lisp, a) because I had always been curious about it and b) "
"because, being only a text editor extension language after all, Emacs Lisp "
"would surely reach its limits long before the project got too far out of "
"hand."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1165
msgid ""
"To make a long story short, Emacs Lisp turned out to be a distressingly "
"solid implementation of Lisp, and the humble task of calculating turned out "
"to be more open-ended than one might have expected."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1178
msgid ""
"Emacs Lisp didn't have built-in floating point math (now it does), so this "
"had to be simulated in software.  In fact, Emacs integers would only "
"comfortably fit six decimal digits or so (at the time)---not enough for a "
"decent calculator.  So I had to write my own high-precision integer code as "
"well, and once I had this I figured that arbitrary-size integers were just "
"as easy as large integers.  Arbitrary floating-point precision was the "
"logical next step.  Also, since the large integer arithmetic was there "
"anyway it seemed only fair to give the user direct access to it, which in "
"turn made it practical to support fractions as well as floats. All these "
"features inspired me to look around for other data types that might be worth "
"having."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1188
msgid ""
"Around this time, my friend Rick Koshi showed me his nifty new HP-28 "
"calculator.  It allowed the user to manipulate formulas as well as numerical "
"quantities, and it could also operate on matrices.  I decided that these "
"would be good for Calc to have, too.  And once things had gone this far, I "
"figured I might as well take a look at serious algebra systems for further "
"ideas.  Since these systems did far more than I could ever hope to "
"implement, I decided to focus on rewrite rules and other programming "
"features so that users could implement what they needed for themselves."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1192
msgid ""
"Rick complained that matrices were hard to read, so I put in code to format "
"them in a 2D style.  Once these routines were in place, Big mode was "
"obligatory.  Gee, what other language modes would be useful?"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1196
msgid ""
"Scott Hemphill and Allen Knutson, two friends with a strong mathematical "
"bent, contributed ideas and algorithms for a number of Calc features "
"including modulo forms, primality testing, and float-to-fraction conversion."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1203
msgid ""
"Units were added at the eager insistence of Mass Sivilotti.  Later, Ulrich "
"Mueller at CERN and Przemek Klosowski at NIST provided invaluable expert "
"assistance with the units table.  As far as I can remember, the idea of "
"using algebraic formulas and variables to represent units dates back to an "
"ancient article in Byte magazine about muMath, an early algebra system for "
"microcomputers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1219
msgid ""
"Many people have contributed to Calc by reporting bugs and suggesting "
"features, large and small.  A few deserve special mention: Tim Peters, who "
"helped develop the ideas that led to the selection commands, rewrite rules, "
"and many other algebra features; François Pinard, who contributed an early "
"prototype of the Calc Summary appendix as well as providing valuable "
"suggestions in many other areas of Calc; Carl Witty, whose eagle eyes "
"discovered many typographical and factual errors in the Calc manual; Tim "
"Kay, who drove the development of Embedded mode; Ove Ewerlid, who made many "
"suggestions relating to the algebra commands and contributed some code for "
"polynomial operations; Randal Schwartz, who suggested the @code{calc-eval} "
"function; Juha Sarlin, who first worked out how to split Calc into "
"quickly-loading parts; Bob Weiner, who helped immensely with the Lucid Emacs "
"port; and Robert J. Chassell, who suggested the Calc Tutorial and exercises "
"as well as many other things."
msgstr ""

#. type: cindex
#: ../../calc.texi:1220
#, no-wrap
msgid "Bibliography"
msgstr ""

#. type: cindex
#: ../../calc.texi:1221
#, no-wrap
msgid "Knuth, Art of Computer Programming"
msgstr ""

#. type: cindex
#: ../../calc.texi:1222
#, no-wrap
msgid "Numerical Recipes"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1235
msgid ""
"Among the books used in the development of Calc were Knuth's @emph{Art of "
"Computer Programming} (especially volume II, @emph{Seminumerical "
"Algorithms}); @emph{Numerical Recipes} by Press, Flannery, Teukolsky, and "
"Vetterling; Bevington's @emph{Data Reduction and Error Analysis for the "
"Physical Sciences}; @emph{Concrete Mathematics} by Graham, Knuth, and "
"Patashnik; Steele's @emph{Common Lisp, the Language}; the @emph{CRC Standard "
"Math Tables} (William H. Beyer, ed.); and Abramowitz and Stegun's venerable "
"@emph{Handbook of Mathematical Functions}.  Also, of course, Calc could not "
"have been written without the excellent @emph{GNU Emacs Lisp Reference "
"Manual}, by Bil Lewis and Dan LaLiberte."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1239
msgid ""
"Final thanks go to Richard Stallman, without whose fine implementations of "
"the Emacs editor, language, and environment, Calc would have been finished "
"in two weeks."
msgstr ""

#. type: ifinfo
#: ../../calc.texi:1249
msgid "Some brief instructions on using the Emacs Info system for this tutorial:"
msgstr ""

#. type: ifinfo
#: ../../calc.texi:1253
msgid ""
"Press the space bar and Delete keys to go forward and backward in a section "
"by screenfuls (or use the regular Emacs scrolling commands for this)."
msgstr ""

#. type: ifinfo
#: ../../calc.texi:1258
msgid ""
"Press @kbd{n} or @kbd{p} to go to the Next or Previous section.  If the "
"section has a @dfn{menu}, press a digit key like @kbd{1} or @kbd{2} to go to "
"a sub-section from the menu.  Press @kbd{u} to go back up from a sub-section "
"to the menu it is part of."
msgstr ""

#. type: ifinfo
#: ../../calc.texi:1264
msgid ""
"Exercises in the tutorial all have cross-references to the appropriate page "
"of the ``answers'' section.  Press @kbd{f}, then the exercise number, to see "
"the answer to an exercise.  After you have followed a cross-reference, you "
"can press the letter @kbd{l} to return to where you were before."
msgstr ""

#. type: ifinfo
#: ../../calc.texi:1266
msgid "You can press @kbd{?} at any time for a brief summary of Info commands."
msgstr ""

#. type: ifinfo
#: ../../calc.texi:1268
msgid "Press the number @kbd{1} now to enter the first section of the Tutorial."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1289
msgid ""
"This chapter explains how to use Calc and its many features, in a "
"step-by-step, tutorial way.  You are encouraged to run Calc and work along "
"with the examples as you read (@pxref{Starting Calc}).  If you are already "
"familiar with advanced calculators, you may wish to skip on to the rest of "
"this manual."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1295
msgid ""
"This tutorial describes the standard user interface of Calc only.  The Quick "
"mode and Keypad mode interfaces are fairly self-explanatory.  @xref{Embedded "
"Mode}, for a description of the Embedded mode interface."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1304
msgid ""
"The easiest way to read this tutorial on-line is to have two windows on your "
"Emacs screen, one with Calc and one with the Info system.  Press @kbd{C-x * "
"t} to set this up; the on-line tutorial will be opened in the current window "
"and Calc will be started in another window.  From the Info window, the "
"command @kbd{C-x * c} can be used to switch to the Calc window and @kbd{C-x "
"* o} can be used to switch back to the Info window.  (If you have a printed "
"copy of the manual you can use that instead; in that case you only need to "
"press @kbd{C-x * c} to start Calc.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1309
msgid ""
"This tutorial is designed to be done in sequence.  But the rest of this "
"manual does not assume you have gone through the tutorial.  The tutorial "
"does not cover everything in the Calculator, but it touches on most general "
"areas."
msgstr ""

#. type: ifnottex
#: ../../calc.texi:1314
msgid ""
"You may wish to print out a copy of the Calc Summary and keep notes on it as "
"you learn Calc.  @xref{About This Manual}, to see how to make a printed "
"summary.  @xref{Summary}."
msgstr ""

#. type: iftex
#: ../../calc.texi:1319
msgid ""
"The Calc Summary at the end of the reference manual includes some blank "
"space for your own use.  You may wish to keep notes there as you learn Calc."
msgstr ""

#. type: menuentry
#: ../../calc.texi:1328
msgid "Basic Tutorial::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:1328
msgid "Arithmetic Tutorial::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:1328
msgid "Vector/Matrix Tutorial::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:1328
msgid "Types Tutorial::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:1328
msgid "Algebra Tutorial::"
msgstr ""

#. type: node
#: ../../calc.texi:1328 ../../calc.texi:4741 ../../calc.texi:5690 ../../calc.texi:5691 ../../calc.texi:6349
#, no-wrap
msgid "Programming Tutorial"
msgstr ""

#. type: node
#: ../../calc.texi:1330 ../../calc.texi:5690 ../../calc.texi:6349 ../../calc.texi:6350 ../../calc.texi:6436 ../../calc.texi:6446 ../../calc.texi:6503 ../../calc.texi:6534 ../../calc.texi:6572 ../../calc.texi:6585 ../../calc.texi:6594 ../../calc.texi:6611 ../../calc.texi:6671 ../../calc.texi:6691 ../../calc.texi:6733 ../../calc.texi:6754 ../../calc.texi:6774 ../../calc.texi:6786 ../../calc.texi:6806 ../../calc.texi:6815 ../../calc.texi:6822 ../../calc.texi:6868 ../../calc.texi:6986 ../../calc.texi:7018 ../../calc.texi:7101 ../../calc.texi:7145 ../../calc.texi:7185 ../../calc.texi:7224 ../../calc.texi:7231 ../../calc.texi:7304 ../../calc.texi:7393 ../../calc.texi:7515 ../../calc.texi:7546 ../../calc.texi:7613 ../../calc.texi:7724 ../../calc.texi:7864 ../../calc.texi:7929 ../../calc.texi:7973 ../../calc.texi:8009 ../../calc.texi:8031 ../../calc.texi:8060 ../../calc.texi:8112 ../../calc.texi:8158 ../../calc.texi:8203 ../../calc.texi:8235 ../../calc.texi:8259 ../../calc.texi:8307 ../../calc.texi:8355 ../../calc.texi:8385 ../../calc.texi:8391 ../../calc.texi:8425 ../../calc.texi:8459 ../../calc.texi:8471 ../../calc.texi:8514 ../../calc.texi:8577 ../../calc.texi:8647 ../../calc.texi:8699 ../../calc.texi:8735 ../../calc.texi:8757 ../../calc.texi:8830 ../../calc.texi:8854 ../../calc.texi:8929 ../../calc.texi:8942 ../../calc.texi:8959 ../../calc.texi:8995 ../../calc.texi:9001 ../../calc.texi:9017 ../../calc.texi:9046 ../../calc.texi:9087 ../../calc.texi:9203 ../../calc.texi:9326 ../../calc.texi:9424 ../../calc.texi:9529
#, no-wrap
msgid "Answers to Exercises"
msgstr ""

#. type: node
#: ../../calc.texi:1332 ../../calc.texi:1333 ../../calc.texi:1347 ../../calc.texi:1741 ../../calc.texi:2041 ../../calc.texi:2178 ../../calc.texi:2658
#, no-wrap
msgid "Basic Tutorial"
msgstr ""

#. type: node
#: ../../calc.texi:1332 ../../calc.texi:2658 ../../calc.texi:2659 ../../calc.texi:3044
#, no-wrap
msgid "Arithmetic Tutorial"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1339
msgid ""
"In this section, we learn how RPN and algebraic-style calculations work, how "
"to undo and redo an operation done by mistake, and how to control various "
"modes of the Calculator."
msgstr ""

#. type: node
#: ../../calc.texi:1345 ../../calc.texi:1347 ../../calc.texi:1741
#, no-wrap
msgid "RPN Tutorial"
msgstr ""

#. type: menuentry
#: ../../calc.texi:1345
msgid "Basic operations with the stack."
msgstr ""

#. type: node
#: ../../calc.texi:1345 ../../calc.texi:1347 ../../calc.texi:1741 ../../calc.texi:2041
#, no-wrap
msgid "Algebraic Tutorial"
msgstr ""

#. type: menuentry
#: ../../calc.texi:1345
msgid "Algebraic entry; variables."
msgstr ""

#. type: node
#: ../../calc.texi:1345 ../../calc.texi:1741 ../../calc.texi:2041 ../../calc.texi:2178
#, no-wrap
msgid "Undo Tutorial"
msgstr ""

#. type: menuentry
#: ../../calc.texi:1345
msgid "If you make a mistake: Undo and the trail."
msgstr ""

#. type: node
#: ../../calc.texi:1345 ../../calc.texi:2041 ../../calc.texi:2178
#, no-wrap
msgid "Modes Tutorial"
msgstr ""

#. type: menuentry
#: ../../calc.texi:1345
msgid "Common mode-setting commands."
msgstr ""

#. type: subsection
#: ../../calc.texi:1348
#, no-wrap
msgid "RPN Calculations and the Stack"
msgstr ""

#. type: cindex
#: ../../calc.texi:1350
#, no-wrap
msgid "RPN notation"
msgstr ""

#. type: ifnottex
#: ../../calc.texi:1357
msgid ""
"Calc normally uses RPN notation.  You may be familiar with the RPN system "
"from Hewlett-Packard calculators, FORTH, or PostScript.  (Reverse Polish "
"Notation, RPN, is named after the Polish mathematician Jan Lukasiewicz.)"
msgstr ""

#. type: tex
#: ../../calc.texi:1363
#, no-wrap
msgid ""
"Calc normally uses RPN notation.  You may be familiar with the RPN\n"
"system from Hewlett-Packard calculators, FORTH, or PostScript.\n"
"(Reverse Polish Notation, RPN, is named after the Polish mathematician\n"
"Jan \\L ukasiewicz.)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1369
msgid ""
"The central component of an RPN calculator is the @dfn{stack}.  A calculator "
"stack is like a stack of dishes.  New dishes (numbers) are added at the top "
"of the stack, and numbers are normally only removed from the top of the "
"stack."
msgstr ""

#. type: cindex
#: ../../calc.texi:1370
#, no-wrap
msgid "Operators"
msgstr ""

#. type: cindex
#: ../../calc.texi:1371
#, no-wrap
msgid "Operands"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1378
msgid ""
"In an operation like @expr{2+3}, the 2 and 3 are called the @dfn{operands} "
"and the @expr{+} is the @dfn{operator}.  In an RPN calculator you always "
"enter the operands first, then the operator.  Each time you type a number, "
"Calc adds or @dfn{pushes} it onto the top of the Stack.  When you press an "
"operator key like @kbd{+}, Calc @dfn{pops} the appropriate number of "
"operands from the stack and pushes back the result."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1388
msgid ""
"Thus we could add the numbers 2 and 3 in an RPN calculator by typing: @kbd{2 "
"@key{RET} 3 @key{RET} +}.  (The @key{RET} key, Return, corresponds to the "
"@key{ENTER} key on traditional RPN calculators.)  Try this now if you wish; "
"type @kbd{C-x * c} to switch into the Calc window (you can type @kbd{C-x * "
"c} again or @kbd{C-x * o} to switch back to the Tutorial window).  The first "
"four keystrokes ``push'' the numbers 2 and 3 onto the stack.  The @kbd{+} "
"key ``pops'' the top two numbers from the stack, adds them, and pushes the "
"result (5) back onto the stack.  Here's how the stack will look at various "
"points throughout the calculation:"
msgstr ""

#. type: group
#: ../../calc.texi:1394
#, no-wrap
msgid ""
"    .          1:  2          2:  2          1:  5              .\n"
"                   .          1:  3              .\n"
"                                  .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1396
#, no-wrap
msgid ""
"  C-x * c          2 @key{RET}          3 @key{RET}            +             "
"@key{DEL}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1403
msgid ""
"The @samp{.} symbol is a marker that represents the top of the stack.  Note "
"that the ``top'' of the stack is really shown at the bottom of the Stack "
"window.  This may seem backwards, but it turns out to be less distracting in "
"regular use."
msgstr ""

#. type: cindex
#: ../../calc.texi:1404
#, no-wrap
msgid "Stack levels"
msgstr ""

#. type: cindex
#: ../../calc.texi:1405
#, no-wrap
msgid "Levels of stack"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1413
msgid ""
"The numbers @samp{1:} and @samp{2:} on the left are @dfn{stack level "
"numbers}.  Old RPN calculators always had four stack levels called @expr{x}, "
"@expr{y}, @expr{z}, and @expr{t}.  Calc's stack can grow as large as you "
"like, so it uses numbers instead of letters.  Some stack-manipulation "
"commands accept a numeric argument that says which stack level to work on.  "
"Normal commands like @kbd{+} always work on the top few levels of the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1424
msgid ""
"The Stack buffer is just an Emacs buffer, and you can move around in it "
"using the regular Emacs motion commands.  But no matter where the cursor is, "
"even if you have scrolled the @samp{.} marker out of view, most Calc "
"commands always move the cursor back down to level 1 before doing anything.  "
"It is possible to move the @samp{.} marker upwards through the stack, "
"temporarily ``hiding'' some numbers from commands like @kbd{+}.  This is "
"called @dfn{stack truncation} and we will not cover it in this tutorial; "
"@pxref{Truncating the Stack}, if you are interested."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1430
msgid ""
"You don't really need the second @key{RET} in @kbd{2 @key{RET} 3 @key{RET} "
"+}.  That's because if you type any operator name or other non-numeric key "
"when you are entering a number, the Calculator automatically enters that "
"number and then does the requested command.  Thus @kbd{2 @key{RET} 3 +} will "
"work just as well."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1433
msgid ""
"Examples in this tutorial will often omit @key{RET} even when the stack "
"displays shown would only happen if you did press @key{RET}:"
msgstr ""

#. type: group
#: ../../calc.texi:1439
#, no-wrap
msgid ""
"1:  2          2:  2          1:  5\n"
"    .          1:  3              .\n"
"                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1441
#, no-wrap
msgid "  2 @key{RET}            3              +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1448
msgid ""
"Here, after pressing @kbd{3} the stack would really show @samp{1: 2} with "
"@samp{Calc:@: 3} in the minibuffer.  In these situations, you can press the "
"optional @key{RET} to see the stack as the figure shows."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1456
msgid ""
"(@bullet{}) @strong{Exercise 1.} (This tutorial will include exercises at "
"various points.  Try them if you wish.  Answers to all the exercises are "
"located at the end of the Tutorial chapter.  Each exercise will include a "
"cross-reference to its particular answer.  If you are reading with the Emacs "
"Info system, press @kbd{f} and the exercise number to go to the answer, then "
"the letter @kbd{l} to return to where you were.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1462
msgid ""
"Here's the first exercise: What will the keystrokes @kbd{1 @key{RET} 2 "
"@key{RET} 3 @key{RET} 4 + * -} compute? (@samp{*} is the symbol for "
"multiplication.)  Figure it out by hand, then try it with Calc to see if "
"you're right.  @xref{RPN Answer 1, 1}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1467
msgid ""
"(@bullet{}) @strong{Exercise 2.} Compute @texline @math{(2\\times4) + "
"(7\\times9.5) + {5\\over4}} @infoline @expr{2*4 + 7*9.5 + 5/4} using the "
"stack.  @xref{RPN Answer 2, 2}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1477
msgid ""
"The @key{DEL} key is called Backspace on some keyboards.  It is whatever key "
"you would use to correct a simple typing error when regularly using Emacs.  "
"The @key{DEL} key pops and throws away the top value on the stack.  (You can "
"still get that value back from the Trail if you should need it later on.)  "
"There are many places in this tutorial where we assume you have used "
"@key{DEL} to erase the results of the previous example at the beginning of a "
"new example.  In the few places where it is really important to use "
"@key{DEL} to clear away old results, the text will remind you to do so."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1481
msgid ""
"(It won't hurt to let things accumulate on the stack, except that whenever "
"you give a display-mode-changing command Calc will have to spend a long time "
"reformatting such a large stack.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1487
msgid ""
"Since the @kbd{-} key is also an operator (it subtracts the top two stack "
"elements), how does one enter a negative number? Calc uses the @kbd{_} "
"(underscore) key to act like the minus sign in a number.  So, typing @kbd{-5 "
"@key{RET}} won't work because the @kbd{-} key will try to do a subtraction, "
"but @kbd{_5 @key{RET}} works just fine."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1491
msgid ""
"You can also press @kbd{n}, which means ``change sign.'' It changes the "
"number at the top of the stack (or the number being entered)  from positive "
"to negative or vice-versa: @kbd{5 n @key{RET}}."
msgstr ""

#. type: cindex
#: ../../calc.texi:1492
#, no-wrap
msgid "Duplicating a stack entry"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1495
msgid ""
"If you press @key{RET} when you're not entering a number, the effect is to "
"duplicate the top number on the stack.  Consider this calculation:"
msgstr ""

#. type: group
#: ../../calc.texi:1501
#, no-wrap
msgid ""
"1:  3          2:  3          1:  9          2:  9          1:  81\n"
"    .          1:  3              .          1:  9              .\n"
"                   .                             .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1503
#, no-wrap
msgid ""
"  3 @key{RET}           @key{RET}             *             @key{RET}             "
"*\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1509
msgid ""
"(Of course, an easier way to do this would be @kbd{3 @key{RET} 4 ^}, to "
"raise 3 to the fourth power.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1513
msgid ""
"The space-bar key (denoted @key{SPC} here) performs the same function as "
"@key{RET}; you could replace all three occurrences of @key{RET} in the above "
"example with @key{SPC} and the effect would be the same."
msgstr ""

#. type: cindex
#: ../../calc.texi:1514
#, no-wrap
msgid "Exchanging stack entries"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1519
msgid ""
"Another stack manipulation key is @key{TAB}.  This exchanges the top two "
"stack entries.  Suppose you have computed @kbd{2 @key{RET} 3 +} to get 5, "
"and then you realize what you really wanted to compute was @expr{20 / "
"(2+3)}."
msgstr ""

#. type: group
#: ../../calc.texi:1525
#, no-wrap
msgid ""
"1:  5          2:  5          2:  20         1:  4\n"
"    .          1:  20         1:  5              .\n"
"                   .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1527
#, no-wrap
msgid " 2 @key{RET} 3 +         20            @key{TAB}             /\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1532
msgid "Planning ahead, the calculation would have gone like this:"
msgstr ""

#. type: group
#: ../../calc.texi:1539
#, no-wrap
msgid ""
"1:  20         2:  20         3:  20         2:  20         1:  4\n"
"    .          1:  2          2:  2          1:  5              .\n"
"                   .          1:  3              .\n"
"                                  .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1541
#, no-wrap
msgid ""
"  20 @key{RET}         2 @key{RET}            3              +              "
"/\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1547
msgid ""
"A related stack command is @kbd{M-@key{TAB}} (hold @key{META} and type "
"@key{TAB}).  It rotates the top three elements of the stack upward, bringing "
"the object in level 3 to the top."
msgstr ""

#. type: group
#: ../../calc.texi:1554
#, no-wrap
msgid ""
"1:  10         2:  10         3:  10         3:  20         3:  30\n"
"    .          1:  20         2:  20         2:  30         2:  10\n"
"                   .          1:  30         1:  10         1:  20\n"
"                                  .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1556
#, no-wrap
msgid ""
"  10 @key{RET}         20 @key{RET}         30 @key{RET}         M-@key{TAB}          "
"M-@key{TAB}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1563
msgid ""
"(@bullet{}) @strong{Exercise 3.} Suppose the numbers 10, 20, and 30 are on "
"the stack.  Figure out how to add one to the number in level 2 without "
"affecting the rest of the stack.  Also figure out how to add one to the "
"number in level 3.  @xref{RPN Answer 3, 3}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1568
msgid ""
"Operations like @kbd{+}, @kbd{-}, @kbd{*}, @kbd{/}, and @kbd{^} pop two "
"arguments from the stack and push a result.  Operations like @kbd{n} and "
"@kbd{Q} (square root) pop a single number and push the result.  You can "
"think of them as simply operating on the top element of the stack."
msgstr ""

#. type: group
#: ../../calc.texi:1574
#, no-wrap
msgid ""
"1:  3          1:  9          2:  9          1:  25         1:  5\n"
"    .              .          1:  16             .              .\n"
"                                  .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1576
#, no-wrap
msgid ""
"  3 @key{RET}          @key{RET} *        4 @key{RET} @key{RET} *        +              "
"Q\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1582
msgid ""
"(Note that capital @kbd{Q} means to hold down the Shift key while typing "
"@kbd{q}.  Remember, plain unshifted @kbd{q} is the Quit command.)"
msgstr ""

#. type: cindex
#: ../../calc.texi:1583
#, no-wrap
msgid "Pythagorean Theorem"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1588
msgid ""
"Here we've used the Pythagorean Theorem to determine the hypotenuse of a "
"right triangle.  Calc actually has a built-in command for that called @kbd{f "
"h}, but let's suppose we can't remember the necessary keystrokes.  We can "
"still enter it by its full name using @kbd{M-x} notation:"
msgstr ""

#. type: group
#: ../../calc.texi:1594 ../../calc.texi:1609
#, no-wrap
msgid ""
"1:  3          2:  3          1:  5\n"
"    .          1:  4              .\n"
"                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1596
#, no-wrap
msgid "  3 @key{RET}          4 @key{RET}      M-x calc-hypot\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1603
msgid ""
"All Calculator commands begin with the word @samp{calc-}.  Since it gets "
"tiring to type this, Calc provides an @kbd{x} key which is just like the "
"regular Emacs @kbd{M-x} key except that it types the @samp{calc-} prefix for "
"you:"
msgstr ""

#. type: group
#: ../../calc.texi:1611
#, no-wrap
msgid "  3 @key{RET}          4 @key{RET}         x hypot\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1615
msgid "What happens if you take the square root of a negative number?"
msgstr ""

#. type: group
#: ../../calc.texi:1620
#, no-wrap
msgid ""
"1:  4          1:  -4         1:  (0, 2)\n"
"    .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1622
#, no-wrap
msgid "  4 @key{RET}            n              Q\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1630
msgid ""
"The notation @expr{(a, b)} represents a complex number.  Complex numbers are "
"more traditionally written @expr{a + b i}; Calc can display in this format, "
"too, but for now we'll stick to the @expr{(a, b)} notation."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1636
msgid ""
"If you don't know how complex numbers work, you can safely ignore this "
"feature.  Complex numbers only arise from operations that would be errors in "
"a calculator that didn't have complex numbers.  (For example, taking the "
"square root or logarithm of a negative number produces a complex result.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1639
msgid ""
"Complex numbers are entered in the notation shown.  The @kbd{(} and @kbd{,} "
"and @kbd{)} keys manipulate ``incomplete complex numbers.''"
msgstr ""

#. type: group
#: ../../calc.texi:1645
#, no-wrap
msgid ""
"1:  ( ...      2:  ( ...      1:  (2, ...    1:  (2, ...    1:  (2, 3)\n"
"    .          1:  2              .              3              .\n"
"                   .                             .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1647
#, no-wrap
msgid "    (              2              ,              3              )\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1652
msgid ""
"You can perform calculations while entering parts of incomplete objects.  "
"However, an incomplete object cannot actually participate in a calculation:"
msgstr ""

#. type: group
#: ../../calc.texi:1661
#, no-wrap
msgid ""
"1:  ( ...      2:  ( ...      3:  ( ...      1:  ( ...      1:  ( ...\n"
"    .          1:  2          2:  2              5              5\n"
"                   .          1:  3              .              .\n"
"                                  .\n"
"                                                             (error)\n"
"    (             2 @key{RET}           3              +              +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1667
msgid ""
"Adding 5 to an incomplete object makes no sense, so the last command "
"produces an error message and leaves the stack the same."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1670
msgid ""
"Incomplete objects can't participate in arithmetic, but they can be moved "
"around by the regular stack commands."
msgstr ""

#. type: group
#: ../../calc.texi:1677
#, no-wrap
msgid ""
"2:  2          3:  2          3:  3          1:  ( ...      1:  (2, 3)\n"
"1:  3          2:  3          2:  ( ...          2              .\n"
"    .          1:  ( ...      1:  2              3\n"
"                   .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1679
#, no-wrap
msgid ""
"2 @key{RET} 3 @key{RET}        (            M-@key{TAB}          M-@key{TAB}            "
")\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1687
msgid ""
"Note that the @kbd{,} (comma) key did not have to be used here.  When you "
"press @kbd{)} all the stack entries between the incomplete entry and the top "
"are collected, so there's never really a reason to use the comma.  It's up "
"to you."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1693
msgid ""
"(@bullet{}) @strong{Exercise 4.} To enter the complex number @expr{(2, 3)}, "
"your friend Joe typed @kbd{( 2 , @key{SPC} 3 )}.  What happened? (Joe "
"thought of a clever way to correct his mistake in only two keystrokes, but "
"it didn't quite work.  Try it to find out why.)  @xref{RPN Answer 4, "
"4}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1697
msgid ""
"Vectors are entered the same way as complex numbers, but with square "
"brackets in place of parentheses.  We'll meet vectors again later in the "
"tutorial."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1705
msgid ""
"Any Emacs command can be given a @dfn{numeric prefix argument} by typing a "
"series of @key{META}-digits beforehand.  If @key{META} is awkward for you, "
"you can instead type @kbd{C-u} followed by the necessary digits.  Numeric "
"prefix arguments can be negative, as in @kbd{M-- M-3 M-5} or @w{@kbd{C-u - 3 "
"5}}.  Calc commands use numeric prefix arguments in a variety of ways.  For "
"example, a numeric prefix on the @kbd{+} operator adds any number of stack "
"entries at once:"
msgstr ""

#. type: group
#: ../../calc.texi:1712
#, no-wrap
msgid ""
"1:  10         2:  10         3:  10         3:  10         1:  60\n"
"    .          1:  20         2:  20         2:  20             .\n"
"                   .          1:  30         1:  30\n"
"                                  .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1714
#, no-wrap
msgid ""
"  10 @key{RET}         20 @key{RET}         30 @key{RET}         C-u 3            "
"+\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1722
msgid ""
"For stack manipulation commands like @key{RET}, a positive numeric prefix "
"argument operates on the top @var{n} stack entries at once.  A negative "
"argument operates on the entry in level @var{n} only.  An argument of zero "
"operates on the entire stack.  In this example, we copy the second-to-top "
"element of the stack:"
msgstr ""

#. type: group
#: ../../calc.texi:1730
#, no-wrap
msgid ""
"1:  10         2:  10         3:  10         3:  10         4:  10\n"
"    .          1:  20         2:  20         2:  20         3:  20\n"
"                   .          1:  30         1:  30         2:  30\n"
"                                  .              .          1:  20\n"
"                                                                .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1732
#, no-wrap
msgid ""
"  10 @key{RET}         20 @key{RET}         30 @key{RET}         C-u -2          "
"@key{RET}\n"
msgstr ""

#. type: cindex
#: ../../calc.texi:1735
#, no-wrap
msgid "Clearing the stack"
msgstr ""

#. type: cindex
#: ../../calc.texi:1736
#, no-wrap
msgid "Emptying the stack"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1740
msgid ""
"Another common idiom is @kbd{M-0 @key{DEL}}, which clears the stack.  (The "
"@kbd{M-0} numeric prefix tells @key{DEL} to operate on the entire stack.)"
msgstr ""

#. type: subsection
#: ../../calc.texi:1742
#, no-wrap
msgid "Algebraic-Style Calculations"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1749
msgid ""
"If you are not used to RPN notation, you may prefer to operate the "
"Calculator in Algebraic mode, which is closer to the way non-RPN calculators "
"work.  In Algebraic mode, you enter formulas in traditional @expr{2+3} "
"notation."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1753
msgid ""
"@strong{Notice:} Calc gives @samp{/} lower precedence than @samp{*}, so that "
"@samp{a/b*c} is interpreted as @samp{a/(b*c)}; this is not standard across "
"all computer languages.  See below for details."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1761
msgid ""
"You don't really need any special ``mode'' to enter algebraic formulas.  You "
"can enter a formula at any time by pressing the apostrophe (@kbd{'})  key.  "
"Answer the prompt with the desired formula, then press @key{RET}.  The "
"formula is evaluated and the result is pushed onto the RPN stack.  If you "
"don't want to think in RPN at all, you can enter your whole computation as a "
"formula, read the result from the stack, then press @key{DEL} to delete it "
"from the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1764
msgid ""
"Try pressing the apostrophe key, then @kbd{2+3+4}, then @key{RET}.  The "
"result should be the number 9."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1770
msgid ""
"Algebraic formulas use the operators @samp{+}, @samp{-}, @samp{*}, @samp{/}, "
"and @samp{^}.  You can use parentheses to make the order of evaluation "
"clear.  In the absence of parentheses, @samp{^} is evaluated first, then "
"@samp{*}, then @samp{/}, then finally @samp{+} and @samp{-}.  For example, "
"the expression"
msgstr ""

#. type: example
#: ../../calc.texi:1773
#, no-wrap
msgid "2 + 3*4*5 / 6*7^8 - 9\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1777
msgid "is equivalent to"
msgstr ""

#. type: example
#: ../../calc.texi:1780
#, no-wrap
msgid "2 + ((3*4*5) / (6*(7^8))) - 9\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1784
msgid "or, in large mathematical notation,"
msgstr ""

#. type: group
#: ../../calc.texi:1792
#, no-wrap
msgid ""
"    3 * 4 * 5\n"
"2 + --------- - 9\n"
"          8\n"
"     6 * 7\n"
msgstr ""

#. type: tex
#: ../../calc.texi:1799
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ 2 + { 3 \\times 4 \\times 5 \\over 6 \\times 7^8 } - 9 $$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1803
msgid "The result of this expression will be the number @mathit{-6.99999826533}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1808
msgid ""
"Calc's order of evaluation is the same as for most computer languages, "
"except that @samp{*} binds more strongly than @samp{/}, as the above example "
"shows.  As in normal mathematical notation, the @samp{*} symbol can often be "
"omitted: @samp{2 a} is the same as @samp{2*a}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1813
msgid ""
"Operators at the same level are evaluated from left to right, except that "
"@samp{^} is evaluated from right to left.  Thus, @samp{2-3-4} is equivalent "
"to @samp{(2-3)-4} or @mathit{-5}, whereas @samp{2^3^4} is equivalent to "
"@samp{2^(3^4)} (a very large integer; try it!)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1819
msgid ""
"If you tire of typing the apostrophe all the time, there is Algebraic mode, "
"where Calc automatically senses when you are about to type an algebraic "
"expression.  To enter this mode, press the two letters @w{@kbd{m a}}.  (An "
"@samp{Alg} indicator should appear in the Calc window's mode line.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1821
msgid "Press @kbd{m a}, then @kbd{2+3+4} with no apostrophe, then @key{RET}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1826
msgid ""
"In Algebraic mode, when you press any key that would normally begin entering "
"a number (such as a digit, a decimal point, or the @kbd{_} key), or if you "
"press @kbd{(} or @kbd{[}, Calc automatically begins an algebraic entry."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1832
msgid ""
"Functions which do not have operator symbols like @samp{+} and @samp{*} must "
"be entered in formulas using function-call notation.  For example, the "
"function name corresponding to the square-root key @kbd{Q} is @code{sqrt}.  "
"To compute a square root in a formula, you would use the notation "
"@samp{sqrt(@var{x})}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1835
msgid ""
"Press the apostrophe, then type @kbd{sqrt(5*2) - 3}.  The result should be "
"@expr{0.16227766017}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1841
msgid ""
"Note that if the formula begins with a function name, you need to use the "
"apostrophe even if you are in Algebraic mode.  If you type @kbd{arcsin} out "
"of the blue, the @kbd{a r} will be taken as an Algebraic Rewrite command, "
"and the @kbd{csin} will be taken as the name of the rewrite rule to use!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1845
msgid ""
"Some people prefer to enter complex numbers and vectors in algebraic form "
"because they find RPN entry with incomplete objects to be too distracting, "
"even though they otherwise use Calc as an RPN calculator."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1847
msgid "Still in Algebraic mode, type:"
msgstr ""

#. type: group
#: ../../calc.texi:1853
#, no-wrap
msgid ""
"1:  (2, 3)     2:  (2, 3)     1:  (8, -1)    2:  (8, -1)    1:  (9, -1)\n"
"    .          1:  (1, -2)        .          1:  1              .\n"
"                   .                             .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1855
#, no-wrap
msgid ""
" (2,3) @key{RET}      (1,-2) @key{RET}        *              1 @key{RET}          "
"+\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1861
msgid ""
"Algebraic mode allows us to enter complex numbers without pressing an "
"apostrophe first, but it also means we need to press @key{RET} after every "
"entry, even for a simple number like @expr{1}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1869
msgid ""
"(You can type @kbd{C-u m a} to enable a special Incomplete Algebraic mode in "
"which the @kbd{(} and @kbd{[} keys use algebraic entry even though regular "
"numeric keys still use RPN numeric entry.  There is also Total Algebraic "
"mode, started by typing @kbd{m t}, in which all normal keys begin algebraic "
"entry.  You must then use the @key{META} key to type Calc commands: @kbd{M-m "
"t} to get back out of Total Algebraic mode, @kbd{M-q} to quit, etc.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1871
msgid "If you're still in Algebraic mode, press @kbd{m a} again to turn it off."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1885
msgid ""
"Actual non-RPN calculators use a mixture of algebraic and RPN styles.  In "
"general, operators of two numbers (like @kbd{+} and @kbd{*})  use algebraic "
"form, but operators of one number (like @kbd{n} and @kbd{Q})  use RPN form.  "
"Also, a non-RPN calculator allows you to see the intermediate results of a "
"calculation as you go along.  You can accomplish this in Calc by performing "
"your calculation as a series of algebraic entries, using the @kbd{$} sign to "
"tie them together.  In an algebraic formula, @kbd{$} represents the number "
"on the top of the stack.  Here, we perform the calculation @texline "
"@math{\\sqrt{2\\times4+1}}, @infoline @expr{sqrt(2*4+1)}, which on a "
"traditional calculator would be done by pressing @kbd{2 * 4 + 1 =} and then "
"the square-root key."
msgstr ""

#. type: group
#: ../../calc.texi:1890
#, no-wrap
msgid ""
"1:  8          1:  9          1:  3\n"
"    .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1892
#, no-wrap
msgid "  ' 2*4 @key{RET}        $+1 @key{RET}        Q\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1898
msgid ""
"Notice that we didn't need to press an apostrophe for the @kbd{$+1}, because "
"the dollar sign always begins an algebraic entry."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1903
msgid ""
"(@bullet{}) @strong{Exercise 1.} How could you get the same effect as "
"pressing @kbd{Q} but using an algebraic entry instead? How about if the "
"@kbd{Q} key on your keyboard were broken? @xref{Algebraic Answer 1, "
"1}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1906
msgid ""
"The notations @kbd{$$}, @kbd{$$$}, and so on stand for higher stack "
"entries.  For example, @kbd{' $$+$ @key{RET}} is just like typing @kbd{+}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1914
msgid ""
"Algebraic formulas can include @dfn{variables}.  To store in a variable, "
"press @kbd{s s}, then type the variable name, then press @key{RET}.  (There "
"are actually two flavors of store command: @kbd{s s} stores a number in a "
"variable but also leaves the number on the stack, while @w{@kbd{s t}} "
"removes a number from the stack and stores it in the variable.)  A variable "
"name should consist of one or more letters or digits, beginning with a "
"letter."
msgstr ""

#. type: group
#: ../../calc.texi:1919
#, no-wrap
msgid ""
"1:  17             .          1:  a + a^2    1:  306\n"
"    .                             .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1921
#, no-wrap
msgid "    17          s t a @key{RET}      ' a+a^2 @key{RET}       =\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1927
msgid ""
"The @kbd{=} key @dfn{evaluates} a formula by replacing all its variables by "
"the values that were stored in them."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1931
msgid ""
"For RPN calculations, you can recall a variable's value on the stack either "
"by entering its name as a formula and pressing @kbd{=}, or by using the "
"@kbd{s r} command."
msgstr ""

#. type: group
#: ../../calc.texi:1938
#, no-wrap
msgid ""
"1:  17         2:  17         3:  17         2:  17         1:  306\n"
"    .          1:  17         2:  17         1:  289            .\n"
"                   .          1:  2              .\n"
"                                  .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1940
#, no-wrap
msgid ""
"  s r a @key{RET}     ' a @key{RET} =         2              ^              "
"+\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1949
msgid ""
"If you press a single digit for a variable name (as in @kbd{s t 3}, you get "
"one of ten @dfn{quick variables} @code{q0} through @code{q9}.  They are "
"``quick'' simply because you don't have to type the letter @code{q} or the "
"@key{RET} after their names.  In fact, you can type simply @kbd{s 3} as a "
"shorthand for @kbd{s s 3}, and likewise for @kbd{t 3} and @w{@kbd{r 3}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1952
msgid ""
"Any variables in an algebraic formula for which you have not stored values "
"are left alone, even when you evaluate the formula."
msgstr ""

#. type: group
#: ../../calc.texi:1957
#, no-wrap
msgid ""
"1:  2 a + 2 b     1:  2 b + 34\n"
"    .                 .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1959
#, no-wrap
msgid " ' 2a+2b @key{RET}          =\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1964
msgid ""
"Calls to function names which are undefined in Calc are also left alone, as "
"are calls for which the value is undefined."
msgstr ""

#. type: group
#: ../../calc.texi:1969
#, no-wrap
msgid ""
"1:  log10(0) + log10(x) + log10(5, 6) + foo(3) + 2\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:1971
#, no-wrap
msgid " ' log10(100) + log10(0) + log10(x) + log10(5,6) + foo(3) @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1989
msgid ""
"In this example, the first call to @code{log10} works, but the other calls "
"are not evaluated.  In the second call, the logarithm is undefined for that "
"value of the argument; in the third, the argument is symbolic, and in the "
"fourth, there are too many arguments.  In the fifth case, there is no "
"function called @code{foo}.  You will see a ``Wrong number of arguments'' "
"message referring to @samp{log10(5,6)}.  Press the @kbd{w} (``why'') key to "
"see any other messages that may have arisen from the last calculation.  In "
"this case you will get ``logarithm of zero,'' then ``number expected: "
"@code{x}''.  Calc automatically displays the first message only if the "
"message is sufficiently important; for example, Calc considers ``wrong "
"number of arguments'' and ``logarithm of zero'' to be important enough to "
"report automatically, while a message like ``number expected: @code{x}'' "
"will only show up if you explicitly press the @kbd{w} key."
msgstr ""

#. type: Plain text
#: ../../calc.texi:1995
msgid ""
"(@bullet{}) @strong{Exercise 2.} Joe entered the formula @samp{2 x y}, "
"stored 5 in @code{x}, pressed @kbd{=}, and got the expected result, @samp{10 "
"y}.  He then tried the same for the formula @samp{2 x (1+y)}, expecting "
"@samp{10 (1+y)}, but it didn't work.  Why not? @xref{Algebraic Answer 2, "
"2}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:1999
msgid ""
"(@bullet{}) @strong{Exercise 3.} What result would you expect @kbd{1 "
"@key{RET} 0 /} to give? What if you then type @kbd{0 *}? @xref{Algebraic "
"Answer 3, 3}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2008
msgid ""
"One interesting way to work with variables is to use the @dfn{evaluates-to} "
"(@samp{=>}) operator.  It works like this: Enter a formula algebraically in "
"the usual way, but follow the formula with an @samp{=>} symbol.  (There is "
"also an @kbd{s =} command which builds an @samp{=>} formula using the "
"stack.)  On the stack, you will see two copies of the formula with an "
"@samp{=>} between them.  The lefthand formula is exactly like you typed it; "
"the righthand formula has been evaluated as if by typing @kbd{=}."
msgstr ""

#. type: group
#: ../../calc.texi:2014
#, no-wrap
msgid ""
"2:  2 + 3 => 5                     2:  2 + 3 => 5\n"
"1:  2 a + 2 b => 34 + 2 b          1:  2 a + 2 b => 20 + 2 b\n"
"    .                                  .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2016
#, no-wrap
msgid "' 2+3 => @key{RET}  ' 2a+2b @key{RET} s =          10 s t a @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2025
msgid ""
"Notice that the instant we stored a new value in @code{a}, all @samp{=>} "
"operators already on the stack that referred to @expr{a} were updated to use "
"the new value.  With @samp{=>}, you can push a set of formulas on the stack, "
"then change the variables experimentally to see the effects on the formulas' "
"values."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2027
msgid "You can also ``unstore'' a variable when you are through with it:"
msgstr ""

#. type: group
#: ../../calc.texi:2033
#, no-wrap
msgid ""
"2:  2 + 3 => 5\n"
"1:  2 a + 2 b => 2 a + 2 b\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2035
#, no-wrap
msgid "    s u a @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2040
msgid ""
"We will encounter formulas involving variables and functions again when we "
"discuss the algebra and calculus features of the Calculator."
msgstr ""

#. type: subsection
#: ../../calc.texi:2042
#, no-wrap
msgid "Undo and Redo"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2049
msgid ""
"If you make a mistake, you can usually correct it by pressing shift-@kbd{U}, "
"the ``undo'' command.  First, clear the stack (@kbd{M-0 @key{DEL}}) and exit "
"and restart Calc (@kbd{C-x * * C-x * *}) to make sure things start off with "
"a clean slate.  Now:"
msgstr ""

#. type: group
#: ../../calc.texi:2055
#, no-wrap
msgid ""
"1:  2          2:  2          1:  8          2:  2          1:  6\n"
"    .          1:  3              .          1:  3              .\n"
"                   .                             .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2057
#, no-wrap
msgid "   2 @key{RET}           3              ^              U              *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2063
msgid ""
"You can undo any number of times.  Calc keeps a complete record of all you "
"have done since you last opened the Calc window.  After the above example, "
"you could type:"
msgstr ""

#. type: group
#: ../../calc.texi:2071
#, no-wrap
msgid ""
"1:  6          2:  2          1:  2              .              .\n"
"    .          1:  3              .\n"
"                   .\n"
"                                                             (error)\n"
"                   U              U              U              U\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2076
msgid ""
"You can also type @kbd{D} to ``redo'' a command that you have undone "
"mistakenly."
msgstr ""

#. type: group
#: ../../calc.texi:2084
#, no-wrap
msgid ""
"    .          1:  2          2:  2          1:  6          1:  6\n"
"                   .          1:  3              .              .\n"
"                                  .\n"
"                                                             (error)\n"
"                   D              D              D              D\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2090
msgid ""
"It was not possible to redo past the @expr{6}, since that was placed there "
"by something other than an undo command."
msgstr ""

#. type: cindex
#: ../../calc.texi:2091
#, no-wrap
msgid "Time travel"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2098
msgid ""
"You can think of undo and redo as a sort of ``time machine.'' Press @kbd{U} "
"to go backward in time, @kbd{D} to go forward.  If you go backward and do "
"something (like @kbd{*}) then, as any science fiction reader knows, you have "
"changed your future and you cannot go forward again.  Thus, the inability to "
"redo past the @expr{6} even though there was an earlier undo command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2103
msgid ""
"You can always recall an earlier result using the Trail.  We've ignored the "
"trail so far, but it has been faithfully recording everything we did since "
"we loaded the Calculator.  If the Trail is not displayed, press @kbd{t d} "
"now to turn it on."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2112
msgid ""
"Let's try grabbing an earlier result.  The @expr{8} we computed was undone "
"by a @kbd{U} command, and was lost even to Redo when we pressed @kbd{*}, but "
"it's still there in the trail.  There should be a little @samp{>} arrow (the "
"@dfn{trail pointer}) resting on the last trail entry.  If there isn't, press "
"@kbd{t ]} to reset the trail pointer.  Now, press @w{@kbd{t p}} to move the "
"arrow onto the line containing @expr{8}, and press @w{@kbd{t y}} to ``yank'' "
"that number back onto the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2115
msgid ""
"If you press @kbd{t ]} again, you will see that even our Yank command went "
"into the trail."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2124
msgid ""
"Let's go further back in time.  Earlier in the tutorial we computed a huge "
"integer using the formula @samp{2^3^4}.  We don't remember what it was, but "
"the first digits were ``241''.  Press @kbd{t r} (which stands for "
"trail-search-reverse), then type @kbd{241}.  The trail cursor will jump back "
"to the next previous occurrence of the string ``241'' in the trail.  This is "
"just a regular Emacs incremental search; you can now press @kbd{C-s} or "
"@kbd{C-r} to continue the search forwards or backwards as you like."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2130
msgid ""
"To finish the search, press @key{RET}.  This halts the incremental search "
"and leaves the trail pointer at the thing we found.  Now we can type @kbd{t "
"y} to yank that number onto the stack.  If we hadn't remembered the ``241'', "
"we could simply have searched for @kbd{2^3^4}, then pressed @kbd{@key{RET} t "
"n} to halt and then move to the next item."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2142
msgid ""
"You may have noticed that all the trail-related commands begin with the "
"letter @kbd{t}.  (The store-and-recall commands, on the other hand, all "
"began with @kbd{s}.)  Calc has so many commands that there aren't enough "
"keys for all of them, so various commands are grouped into two-letter "
"sequences where the first letter is called the @dfn{prefix} key.  If you "
"type a prefix key by accident, you can press @kbd{C-g} to cancel it.  (In "
"fact, you can press @kbd{C-g} to cancel almost anything in Emacs.)  To get "
"help on a prefix key, press that key followed by @kbd{?}.  Some prefixes "
"have several lines of help, so you need to press @kbd{?} repeatedly to see "
"them all.  You can also type @kbd{h h} to see all the help at once."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2144
msgid "Try pressing @kbd{t ?} now.  You will see a line of the form,"
msgstr ""

#. type: smallexample
#: ../../calc.texi:2147
#, no-wrap
msgid "trail/time: Display; Fwd, Back; Next, Prev, Here, [, ]; Yank:  [MORE]  t-\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2157
msgid ""
"The word ``trail'' indicates that the @kbd{t} prefix key contains "
"trail-related commands.  Each entry on the line shows one command, with a "
"single capital letter showing which letter you press to get that command.  "
"We have used @kbd{t n}, @kbd{t p}, @kbd{t ]}, and @kbd{t y} so far.  The "
"@samp{[MORE]} means you can press @kbd{?} again to see more @kbd{t}-prefix "
"commands.  Notice that the commands are roughly divided (by semicolons) into "
"related groups."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2163
msgid ""
"When you are in the help display for a prefix key, the prefix is still "
"active.  If you press another key, like @kbd{y} for example, it will be "
"interpreted as a @kbd{t y} command.  If all you wanted was to look at the "
"help messages, press @kbd{C-g} afterwards to cancel the prefix."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2168
msgid ""
"One more way to correct an error is by editing the stack entries.  The "
"actual Stack buffer is marked read-only and must not be edited directly, but "
"you can press @kbd{`} (grave accent)  to edit a stack entry."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2177
msgid ""
"Try entering @samp{3.141439} now.  If this is supposed to represent @cpi{}, "
"it's got several errors.  Press @kbd{`} to edit this number.  Now use the "
"normal Emacs cursor motion and editing keys to change the second 4 to a 5, "
"and to transpose the 3 and the 9.  When you press @key{RET}, the number on "
"the stack will be replaced by your new number.  This works for formulas, "
"vectors, and all other types of values you can put on the stack.  The "
"@kbd{`} key also works during entry of a number or algebraic formula."
msgstr ""

#. type: subsection
#: ../../calc.texi:2179
#, no-wrap
msgid "Mode-Setting Commands"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2186
msgid ""
"Calc has many types of @dfn{modes} that affect the way it interprets your "
"commands or the way it displays data.  We have already seen one mode, namely "
"Algebraic mode.  There are many others, too; we'll try some of the most "
"common ones here."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2189
msgid ""
"Perhaps the most fundamental mode in Calc is the current @dfn{precision}.  "
"Notice the @samp{12} on the Calc window's mode line:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:2192
#, no-wrap
msgid "--%*-Calc: 12 Deg       (Calculator)----All------\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2201
msgid ""
"Most of the symbols there are Emacs things you don't need to worry about, "
"but the @samp{12} and the @samp{Deg} are mode indicators.  The @samp{12} "
"means that calculations should always be carried to 12 significant figures.  "
"That is why, when we type @kbd{1 @key{RET} 7 /}, we get "
"@expr{0.142857142857} with exactly 12 digits, not counting leading and "
"trailing zeros."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2205
msgid ""
"You can set the precision to anything you like by pressing @kbd{p}, then "
"entering a suitable number.  Try pressing @kbd{p 30 @key{RET}}, then doing "
"@kbd{1 @key{RET} 7 /} again:"
msgstr ""

#. type: group
#: ../../calc.texi:2211
#, no-wrap
msgid ""
"1:  0.142857142857\n"
"2:  0.142857142857142857142857142857\n"
"    .\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2218
msgid ""
"Although the precision can be set arbitrarily high, Calc always has to have "
"@emph{some} value for the current precision.  After all, the true value "
"@expr{1/7} is an infinitely repeating decimal; Calc has to stop somewhere."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2221
msgid ""
"Of course, calculations are slower the more digits you request.  Press "
"@w{@kbd{p 12}} now to set the precision back down to the default."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2229
msgid ""
"Calculations always use the current precision.  For example, even though we "
"have a 30-digit value for @expr{1/7} on the stack, if we use it in a "
"calculation in 12-digit mode it will be rounded down to 12 digits before it "
"is used.  Try it; press @key{RET} to duplicate the number, then @w{@kbd{1 "
"+}}.  Notice that the @key{RET} key didn't round the number, because it "
"doesn't do any calculation.  But the instant we pressed @kbd{+}, the number "
"was rounded down."
msgstr ""

#. type: group
#: ../../calc.texi:2236
#, no-wrap
msgid ""
"1:  0.142857142857\n"
"2:  0.142857142857142857142857142857\n"
"3:  1.14285714286\n"
"    .\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2242
msgid ""
"In fact, since we added a digit on the left, we had to lose one digit on the "
"right from even the 12-digit value of @expr{1/7}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2254
msgid ""
"How did we get more than 12 digits when we computed @samp{2^3^4}? The answer "
"is that Calc makes a distinction between @dfn{integers} and "
"@dfn{floating-point} numbers, or @dfn{floats}.  An integer is a number that "
"does not contain a decimal point.  There is no such thing as an ``infinitely "
"repeating fraction integer,'' so Calc doesn't have to limit itself.  If you "
"asked for @samp{2^10000} (don't try this!), you would have to wait a long "
"time but you would eventually get an exact answer.  If you ask for "
"@samp{2.^10000}, you will quickly get an answer which is correct only to 12 "
"places.  The decimal point tells Calc that it should use floating-point "
"arithmetic to get the answer, not exact integer arithmetic."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2258
msgid ""
"You can use the @kbd{F} (@code{calc-floor}) command to convert a "
"floating-point value to an integer, and @kbd{c f} (@code{calc-float})  to "
"convert an integer to floating-point form."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2260
msgid "Let's try entering that last calculation:"
msgstr ""

#. type: group
#: ../../calc.texi:2266
#, no-wrap
msgid ""
"1:  2.         2:  2.         1:  1.99506311689e3010\n"
"    .          1:  10000          .\n"
"                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2268
#, no-wrap
msgid "  2.0 @key{RET}          10000 @key{RET}      ^\n"
msgstr ""

#. type: cindex
#: ../../calc.texi:2272
#, no-wrap
msgid "Scientific notation, entry of"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2277
msgid ""
"Notice the letter @samp{e} in there.  It represents ``times ten to the power "
"of,'' and is used by Calc automatically whenever writing the number out "
"fully would introduce more extra zeros than you probably want to see.  You "
"can enter numbers in this notation, too."
msgstr ""

#. type: group
#: ../../calc.texi:2283
#, no-wrap
msgid ""
"1:  2.         2:  2.         1:  1.99506311678e3010\n"
"    .          1:  10000.         .\n"
"                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2285
#, no-wrap
msgid "  2.0 @key{RET}          1e4 @key{RET}        ^\n"
msgstr ""

#. type: cindex
#: ../../calc.texi:2288
#, no-wrap
msgid "Round-off errors"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2300
msgid ""
"Hey, the answer is different! Look closely at the middle columns of the two "
"examples.  In the first, the stack contained the exact integer @expr{10000}, "
"but in the second it contained a floating-point value with a decimal point.  "
"When you raise a number to an integer power, Calc uses repeated squaring and "
"multiplication to get the answer.  When you use a floating-point power, Calc "
"uses logarithms and exponentials.  As you can see, a slight error crept in "
"during one of these methods.  Which one should we trust? Let's raise the "
"precision a bit and find out:"
msgstr ""

#. type: group
#: ../../calc.texi:2306
#, no-wrap
msgid ""
"    .          1:  2.         2:  2.         1:  1.995063116880828e3010\n"
"                   .          1:  10000.         .\n"
"                                  .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2308
#, no-wrap
msgid ""
" p 16 @key{RET}        2. @key{RET}           1e4            ^    p 12 "
"@key{RET}\n"
msgstr ""

#. type: cindex
#: ../../calc.texi:2312 ../../calc.texi:2320
#, no-wrap
msgid "Guard digits"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2319
msgid ""
"Presumably, it doesn't matter whether we do this higher-precision "
"calculation using an integer or floating-point power, since we have added "
"enough ``guard digits'' to trust the first 12 digits no matter what.  And "
"the verdict is@dots{} Integer powers were more accurate; in fact, the result "
"was only off by one unit in the last place."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2328
msgid ""
"Calc does many of its internal calculations to a slightly higher precision, "
"but it doesn't always bump the precision up enough.  In each case, Calc "
"added about two digits of precision during its calculation and then rounded "
"back down to 12 digits afterward.  In one case, it was enough; in the other, "
"it wasn't.  If you really need @var{x} digits of precision, it never hurts "
"to do the calculation with a few extra guard digits."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2340
msgid ""
"What if we want guard digits but don't want to look at them? We can set the "
"@dfn{float format}.  Calc supports four major formats for floating-point "
"numbers, called @dfn{normal}, @dfn{fixed-point}, @dfn{scientific notation}, "
"and @dfn{engineering notation}.  You get them by pressing @w{@kbd{d n}}, "
"@kbd{d f}, @kbd{d s}, and @kbd{d e}, respectively.  In each case, you can "
"supply a numeric prefix argument which says how many digits should be "
"displayed.  As an example, let's put a few numbers onto the stack and try "
"some different display modes.  First, use @kbd{M-0 @key{DEL}} to clear the "
"stack, then enter the four numbers shown here:"
msgstr ""

#. type: group
#: ../../calc.texi:2348
#, no-wrap
msgid ""
"4:  12345      4:  12345      4:  12345      4:  12345      4:  12345\n"
"3:  12345.     3:  12300.     3:  1.2345e4   3:  1.23e4     3:  12345.000\n"
"2:  123.45     2:  123.       2:  1.2345e2   2:  1.23e2     2:  123.450\n"
"1:  12.345     1:  12.3       1:  1.2345e1   1:  1.23e1     1:  12.345\n"
"    .              .              .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2350
#, no-wrap
msgid "   d n          M-3 d n          d s          M-3 d s        M-3 d f\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2360
msgid ""
"Notice that when we typed @kbd{M-3 d n}, the numbers were rounded down to "
"three significant digits, but then when we typed @kbd{d s} all five "
"significant figures reappeared.  The float format does not affect how "
"numbers are stored, it only affects how they are displayed.  Only the "
"current precision governs the actual rounding of numbers in the Calculator's "
"memory."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2365
msgid ""
"Engineering notation, not shown here, is like scientific notation except the "
"exponent (the power-of-ten part) is always adjusted to be a multiple of "
"three (as in ``kilo,'' ``micro,'' etc.).  As a result there will be one, "
"two, or three digits before the decimal point."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2371
msgid ""
"Whenever you change a display-related mode, Calc redraws everything in the "
"stack.  This may be slow if there are many things on the stack, so Calc "
"allows you to type shift-@kbd{H} before any mode command to prevent it from "
"updating the stack.  Anything Calc displays after the mode-changing command "
"will appear in the new format."
msgstr ""

#. type: group
#: ../../calc.texi:2379
#, no-wrap
msgid ""
"4:  12345      4:  12345      4:  12345      4:  12345      4:  12345\n"
"3:  12345.000  3:  12345.000  3:  12345.000  3:  1.2345e4   3:  12345.\n"
"2:  123.450    2:  123.450    2:  1.2345e1   2:  1.2345e1   2:  123.45\n"
"1:  12.345     1:  1.2345e1   1:  1.2345e2   1:  1.2345e2   1:  12.345\n"
"    .              .              .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2381
#, no-wrap
msgid ""
"    H d s          @key{DEL} U          @key{TAB}            d @key{SPC}          "
"d n\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2392
msgid ""
"Here the @kbd{H d s} command changes to scientific notation but without "
"updating the screen.  Deleting the top stack entry and undoing it back "
"causes it to show up in the new format; swapping the top two stack entries "
"reformats both entries.  The @kbd{d @key{SPC}} command refreshes the whole "
"stack.  The @kbd{d n} command changes back to the normal float format; since "
"it doesn't have an @kbd{H} prefix, it also updates all the stack entries to "
"be in @kbd{d n} format."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2396
msgid ""
"Notice that the integer @expr{12345} was not affected by any of the float "
"formats.  Integers are integers, and are always displayed exactly."
msgstr ""

#. type: cindex
#: ../../calc.texi:2397
#, no-wrap
msgid "Large numbers, readability"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2400
msgid ""
"Large integers have their own problems.  Let's look back at the result of "
"@kbd{2^3^4}."
msgstr ""

#. type: example
#: ../../calc.texi:2403
#, no-wrap
msgid "2417851639229258349412352\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2407
msgid "Quick---how many digits does this have? Try typing @kbd{d g}:"
msgstr ""

#. type: example
#: ../../calc.texi:2410
#, no-wrap
msgid "2,417,851,639,229,258,349,412,352\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2416
msgid ""
"Now how many digits does this have? It's much easier to tell! We can "
"actually group digits into clumps of any size.  Some people prefer @kbd{M-5 "
"d g}:"
msgstr ""

#. type: example
#: ../../calc.texi:2419
#, no-wrap
msgid "24178,51639,22925,83494,12352\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2424
msgid ""
"Let's see what happens to floating-point numbers when they are grouped.  "
"First, type @kbd{p 25 @key{RET}} to make sure we have enough precision to "
"get ourselves into trouble.  Now, type @kbd{1e13 /}:"
msgstr ""

#. type: example
#: ../../calc.texi:2427
#, no-wrap
msgid "24,17851,63922.9258349412352\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2432
msgid ""
"The integer part is grouped but the fractional part isn't.  Now try @kbd{M-- "
"M-5 d g} (that's meta-minus-sign, meta-five):"
msgstr ""

#. type: example
#: ../../calc.texi:2435
#, no-wrap
msgid "24,17851,63922.92583,49412,352\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2439
msgid ""
"If you find it hard to tell the decimal point from the commas, try changing "
"the grouping character to a space with @kbd{d , @key{SPC}}:"
msgstr ""

#. type: example
#: ../../calc.texi:2442
#, no-wrap
msgid "24 17851 63922.92583 49412 352\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2447
msgid ""
"Type @kbd{d , ,} to restore the normal grouping character, then @kbd{d g} "
"again to turn grouping off.  Also, press @kbd{p 12} to restore the default "
"precision."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2452
msgid ""
"Press @kbd{U} enough times to get the original big integer back.  (Notice "
"that @kbd{U} does not undo each mode-setting command; if you want to undo a "
"mode-setting command, you have to do it yourself.)  Now, type @kbd{d r 16 "
"@key{RET}}:"
msgstr ""

#. type: example
#: ../../calc.texi:2455
#, no-wrap
msgid "16#200000000000000000000\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2463
msgid ""
"The number is now displayed in @dfn{hexadecimal}, or ``base-16'' form.  "
"Suddenly it looks pretty simple; this should be no surprise, since we got "
"this number by computing a power of two, and 16 is a power of 2.  In fact, "
"we can use @w{@kbd{d r 2 @key{RET}}} to see it in actual binary form:"
msgstr ""

#. type: example
#: ../../calc.texi:2466
#, no-wrap
msgid "2#1000000000000000000000000000000000000000000000000000000 @dots{}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2475
msgid ""
"We don't have enough space here to show all the zeros! They won't fit on a "
"typical screen, either, so you will have to use horizontal scrolling to see "
"them all.  Press @kbd{<} and @kbd{>} to scroll the stack window left and "
"right by half its width.  Another way to view something large is to press "
"@kbd{`} (grave accent) to edit the top of stack in a separate window.  "
"(Press @kbd{C-c C-c} when you are done.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2481
msgid ""
"You can enter non-decimal numbers using the @kbd{#} symbol, too.  Let's see "
"what the hexadecimal number @samp{5FE} looks like in binary.  Type "
"@kbd{16#5FE} (the letters can be typed in upper or lower case; they will "
"always appear in upper case).  It will also help to turn grouping on with "
"@kbd{d g}:"
msgstr ""

#. type: example
#: ../../calc.texi:2484
#, no-wrap
msgid "2#101,1111,1110\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2489
msgid ""
"Notice that @kbd{d g} groups by fours by default if the display radix is "
"binary or hexadecimal, but by threes if it is decimal, octal, or any other "
"radix."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2491
msgid "Now let's see that number in decimal; type @kbd{d r 10}:"
msgstr ""

#. type: example
#: ../../calc.texi:2494
#, no-wrap
msgid "1,534\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2500
msgid ""
"Numbers are not @emph{stored} with any particular radix attached.  They're "
"just numbers; they can be entered in any radix, and are always displayed in "
"whatever radix you've chosen with @kbd{d r}.  The current radix applies to "
"integers, fractions, and floats."
msgstr ""

#. type: cindex
#: ../../calc.texi:2501
#, no-wrap
msgid "Roundoff errors, in non-decimal numbers"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2510
msgid ""
"(@bullet{}) @strong{Exercise 1.} Your friend Joe tried to enter one-third as "
"@samp{3#0.1} in @kbd{d r 3} mode with a precision of 12.  He got "
"@samp{3#0.0222222...} (with 25 2's) in the display.  When he multiplied that "
"by three, he got @samp{3#0.222222...} instead of the expected @samp{3#1}.  "
"Next, Joe entered @samp{3#0.2} and, to his great relief, saw @samp{3#0.2} on "
"the screen.  But when he typed @kbd{2 /}, he got @samp{3#0.10000001} (some "
"zeros omitted).  What's going on here? @xref{Modes Answer 1, 1}. (@bullet{})"
msgstr ""

#. type: cindex
#: ../../calc.texi:2511
#, no-wrap
msgid "Scientific notation, in non-decimal numbers"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2519
msgid ""
"(@bullet{}) @strong{Exercise 2.} Scientific notation works in non-decimal "
"modes in the natural way (the exponent is a power of the radix instead of a "
"power of ten, although the exponent itself is always written in decimal).  "
"Thus @samp{8#1.23e3 = 8#1230.0}.  Suppose we have the hexadecimal number "
"@samp{f.e8f} times 16 to the 15th power: We write @samp{16#f.e8fe15}.  What "
"is wrong with this picture? What could we write instead that would work "
"better? @xref{Modes Answer 2, 2}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2524
msgid ""
"The @kbd{m} prefix key has another set of modes, relating to the way Calc "
"interprets your inputs and does computations.  Whereas @kbd{d}-prefix modes "
"generally affect the way things look, @kbd{m}-prefix modes affect the way "
"they are actually computed."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2529
msgid ""
"The most popular @kbd{m}-prefix mode is the @dfn{angular mode}.  Notice the "
"@samp{Deg} indicator in the mode line.  This means that if you use a command "
"that interprets a number as an angle, it will assume the angle is measured "
"in degrees.  For example,"
msgstr ""

#. type: group
#: ../../calc.texi:2534
#, no-wrap
msgid ""
"1:  45         1:  0.707106781187   1:  0.500000000001    1:  0.5\n"
"    .              .                    .                     .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2536
#, no-wrap
msgid "    45             S                    2 ^                   c 1\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2551
msgid ""
"The shift-@kbd{S} command computes the sine of an angle.  The sine of 45 "
"degrees is @texline @math{\\sqrt{2}/2}; @infoline @expr{sqrt(2)/2}; squaring "
"this yields @expr{2/4 = 0.5}.  However, there has been a slight roundoff "
"error because the representation of @texline @math{\\sqrt{2}/2} @infoline "
"@expr{sqrt(2)/2} wasn't exact.  The @kbd{c 1} command is a handy way to "
"clean up numbers in this case; it temporarily reduces the precision by one "
"digit while it re-rounds the number on the top of the stack."
msgstr ""

#. type: cindex
#: ../../calc.texi:2552 ../../calc.texi:2876
#, no-wrap
msgid "Roundoff errors, examples"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2557
msgid ""
"(@bullet{}) @strong{Exercise 3.} Your friend Joe computed the sine of 45 "
"degrees as shown above, then, hoping to avoid an inexact result, he "
"increased the precision to 16 digits before squaring.  What happened? "
"@xref{Modes Answer 3, 3}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2563
msgid ""
"To do this calculation in radians, we would type @kbd{m r} first.  (The "
"indicator changes to @samp{Rad}.)  45 degrees corresponds to @cpiover{4} "
"radians.  To get @cpi{}, press the @kbd{P} key.  (Once again, this is a "
"shifted capital @kbd{P}.  Remember, unshifted @kbd{p} sets the precision.)"
msgstr ""

#. type: group
#: ../../calc.texi:2568
#, no-wrap
msgid ""
"1:  3.14159265359   1:  0.785398163398   1:  0.707106781187\n"
"    .                   .                .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2570
#, no-wrap
msgid "    P                   4 /       m r    S\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2575
msgid ""
"Likewise, inverse trigonometric functions generate results in either radians "
"or degrees, depending on the current angular mode."
msgstr ""

#. type: group
#: ../../calc.texi:2580
#, no-wrap
msgid ""
"1:  0.707106781187   1:  0.785398163398   1:  45.\n"
"    .                    .                    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2582
#, no-wrap
msgid "    .5 Q        m r      I S        m d       U I S\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2590
msgid ""
"Here we compute the Inverse Sine of @texline @math{\\sqrt{0.5}}, @infoline "
"@expr{sqrt(0.5)}, first in radians, then in degrees."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2593
msgid ""
"Use @kbd{c d} and @kbd{c r} to convert a number from radians to degrees and "
"vice-versa."
msgstr ""

#. type: group
#: ../../calc.texi:2598
#, no-wrap
msgid ""
"1:  45         1:  0.785398163397     1:  45.\n"
"    .              .                      .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2600
#, no-wrap
msgid "    45             c r                    c d\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2608
msgid ""
"Another interesting mode is @dfn{Fraction mode}.  Normally, dividing two "
"integers produces a floating-point result if the quotient can't be expressed "
"as an exact integer.  Fraction mode causes integer division to produce a "
"fraction, i.e., a rational number, instead."
msgstr ""

#. type: group
#: ../../calc.texi:2614
#, no-wrap
msgid ""
"2:  12         1:  1.33333333333    1:  4:3\n"
"1:  9              .                    .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2616
#, no-wrap
msgid " 12 @key{RET} 9          /          m f       U /      m f\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2622
msgid ""
"In the first case, we get an approximate floating-point result.  In the "
"second case, we get an exact fractional result (four-thirds)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2629
msgid ""
"You can enter a fraction at any time using @kbd{:} notation.  (Calc uses "
"@kbd{:} instead of @kbd{/} as the fraction separator because @kbd{/} is "
"already used to divide the top two stack elements.)  Calculations involving "
"fractions will always produce exact fractional results; Fraction mode only "
"says what to do when dividing two integers."
msgstr ""

#. type: cindex
#: ../../calc.texi:2630
#, no-wrap
msgid "Fractions vs. floats"
msgstr ""

#. type: cindex
#: ../../calc.texi:2631
#, no-wrap
msgid "Floats vs. fractions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2635
msgid ""
"(@bullet{}) @strong{Exercise 4.} If fractional arithmetic is exact, why "
"would you ever use floating-point numbers instead? @xref{Modes Answer 4, "
"4}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2641
msgid ""
"Typing @kbd{m f} doesn't change any existing values in the stack.  In the "
"above example, we had to Undo the division and do it over again when we "
"changed to Fraction mode.  But if you use the evaluates-to operator you can "
"get commands like @kbd{m f} to recompute for you."
msgstr ""

#. type: group
#: ../../calc.texi:2646
#, no-wrap
msgid ""
"1:  12 / 9 => 1.33333333333    1:  12 / 9 => 1.333    1:  12 / 9 => 4:3\n"
"    .                              .                      .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2648
#, no-wrap
msgid "   ' 12/9 => @key{RET}                   p 4 @key{RET}                m f\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2657
msgid ""
"In this example, the righthand side of the @samp{=>} operator on the stack "
"is recomputed when we change the precision, then again when we change to "
"Fraction mode.  All @samp{=>} expressions on the stack are recomputed every "
"time you change any mode that might affect their values."
msgstr ""

#. type: node
#: ../../calc.texi:2658 ../../calc.texi:3044 ../../calc.texi:3045 ../../calc.texi:3059 ../../calc.texi:3184 ../../calc.texi:3510 ../../calc.texi:4217
#, no-wrap
msgid "Vector/Matrix Tutorial"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2664
msgid ""
"In this section, we explore the arithmetic and scientific functions "
"available in the Calculator."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2669
msgid ""
"The standard arithmetic commands are @kbd{+}, @kbd{-}, @kbd{*}, @kbd{/}, and "
"@kbd{^}.  Each normally takes two numbers from the top of the stack and "
"pushes back a result.  The @kbd{n} and @kbd{&} keys perform change-sign and "
"reciprocal operations, respectively."
msgstr ""

#. type: group
#: ../../calc.texi:2674
#, no-wrap
msgid ""
"1:  5          1:  0.2        1:  5.         1:  -5.        1:  5.\n"
"    .              .              .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2676
#, no-wrap
msgid "    5              &              &              n              n\n"
msgstr ""

#. type: cindex
#: ../../calc.texi:2679
#, no-wrap
msgid "Binary operators"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2684
msgid ""
"You can apply a ``binary operator'' like @kbd{+} across any number of stack "
"entries by giving it a numeric prefix.  You can also apply it pairwise to "
"several stack elements along with the top one if you use a negative prefix."
msgstr ""

#. type: group
#: ../../calc.texi:2692
#, no-wrap
msgid ""
"3:  2          1:  9          3:  2          4:  2          3:  12\n"
"2:  3              .          2:  3          3:  3          2:  13\n"
"1:  4                         1:  4          2:  4          1:  14\n"
"    .                             .          1:  10             .\n"
"                                                 .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2694
#, no-wrap
msgid ""
"2 @key{RET} 3 @key{RET} 4     M-3 +           U              10          M-- "
"M-3 +\n"
msgstr ""

#. type: cindex
#: ../../calc.texi:2697
#, no-wrap
msgid "Unary operators"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2700
msgid ""
"You can apply a ``unary operator'' like @kbd{&} to the top @var{n} stack "
"entries with a numeric prefix, too."
msgstr ""

#. type: group
#: ../../calc.texi:2707
#, no-wrap
msgid ""
"3:  2          3:  0.5                3:  0.5\n"
"2:  3          2:  0.333333333333     2:  3.\n"
"1:  4          1:  0.25               1:  4.\n"
"    .              .                      .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2709
#, no-wrap
msgid "2 @key{RET} 3 @key{RET} 4      M-3 &                  M-2 &\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2717
msgid ""
"Notice that the results here are left in floating-point form.  We can "
"convert them back to integers by pressing @kbd{F}, the ``floor'' function.  "
"This function rounds down to the next lower integer.  There is also @kbd{R}, "
"which rounds to the nearest integer."
msgstr ""

#. type: group
#: ../../calc.texi:2728
#, no-wrap
msgid ""
"7:  2.         7:  2          7:  2\n"
"6:  2.4        6:  2          6:  2\n"
"5:  2.5        5:  2          5:  3\n"
"4:  2.6        4:  2          4:  3\n"
"3:  -2.        3:  -2         3:  -2\n"
"2:  -2.4       2:  -3         2:  -2\n"
"1:  -2.6       1:  -3         1:  -3\n"
"    .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2730
#, no-wrap
msgid "                  M-7 F        U M-7 R\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2738
msgid ""
"Since dividing-and-flooring (i.e., ``integer quotient'') is such a common "
"operation, Calc provides a special command for that purpose, the backslash "
"@kbd{\\}.  Another common arithmetic operator is @kbd{%}, which computes the "
"remainder that would arise from a @kbd{\\} operation, i.e., the ``modulo'' "
"of two numbers.  For example,"
msgstr ""

#. type: group
#: ../../calc.texi:2744
#, no-wrap
msgid ""
"2:  1234       1:  12         2:  1234       1:  34\n"
"1:  100            .          1:  100            .\n"
"    .                             .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2746
#, no-wrap
msgid "1234 @key{RET} 100       \\              U              %\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2750
msgid "These commands actually work for any real numbers, not just integers."
msgstr ""

#. type: group
#: ../../calc.texi:2756
#, no-wrap
msgid ""
"2:  3.1415     1:  3          2:  3.1415     1:  0.1415\n"
"1:  1              .          1:  1              .\n"
"    .                             .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2758
#, no-wrap
msgid "3.1415 @key{RET} 1       \\              U              %\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2766
msgid ""
"(@bullet{}) @strong{Exercise 1.} The @kbd{\\} command would appear to be a "
"frill, since you could always do the same thing with @kbd{/ F}.  Think of a "
"situation where this is not true---@kbd{/ F} would be inadequate.  Now think "
"of a way you could get around the problem if Calc didn't provide a @kbd{\\} "
"command.  @xref{Arithmetic Answer 1, 1}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2772
msgid ""
"We've already seen the @kbd{Q} (square root) and @kbd{S} (sine)  commands.  "
"Other commands along those lines are @kbd{C} (cosine), @kbd{T} (tangent), "
"@kbd{E} (@expr{e^x}) and @kbd{L} (natural logarithm).  These can be modified "
"by the @kbd{I} (inverse) and @kbd{H} (hyperbolic) prefix keys."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2779
msgid ""
"Let's compute the sine and cosine of an angle, and verify the identity "
"@texline @math{\\sin^2x + \\cos^2x = 1}.  @infoline @expr{sin(x)^2 + "
"cos(x)^2 = 1}.  We'll arbitrarily pick @mathit{-64} degrees as a good value "
"for @expr{x}.  With the angular mode set to degrees (type @w{@kbd{m d}}), "
"do:"
msgstr ""

#. type: group
#: ../../calc.texi:2785
#, no-wrap
msgid ""
"2:  -64        2:  -64        2:  -0.89879   2:  -0.89879   1:  1.\n"
"1:  -64        1:  -0.89879   1:  -64        1:  0.43837        .\n"
"    .              .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2787
#, no-wrap
msgid ""
" 64 n @key{RET} @key{RET}      S              @key{TAB}            C              "
"f h\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2793
msgid ""
"(For brevity, we're showing only five digits of the results here.  You can "
"of course do these calculations to any precision you like.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2796
msgid ""
"Remember, @kbd{f h} is the @code{calc-hypot}, or square-root of sum of "
"squares, command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2800
msgid ""
"Another identity is @texline @math{\\displaystyle\\tan x = {\\sin x \\over "
"\\cos x}}.  @infoline @expr{tan(x) = sin(x) / cos(x)}."
msgstr ""

#. type: group
#: ../../calc.texi:2806
#, no-wrap
msgid ""
"2:  -0.89879   1:  -2.0503    1:  -64.\n"
"1:  0.43837        .              .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2808
#, no-wrap
msgid "    U              /              I T\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2815
msgid ""
"A physical interpretation of this calculation is that if you move "
"@expr{0.89879} units downward and @expr{0.43837} units to the right, your "
"direction of motion is @mathit{-64} degrees from horizontal.  Suppose we "
"move in the opposite direction, up and to the left:"
msgstr ""

#. type: group
#: ../../calc.texi:2821
#, no-wrap
msgid ""
"2:  -0.89879   2:  0.89879    1:  -2.0503    1:  -64.\n"
"1:  0.43837    1:  -0.43837       .              .\n"
"    .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2823
#, no-wrap
msgid "    U U            M-2 n          /              I T\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2834
msgid ""
"How can the angle be the same? The answer is that the @kbd{/} operation "
"loses information about the signs of its inputs.  Because the quotient is "
"negative, we know exactly one of the inputs was negative, but we can't tell "
"which one.  There is an @kbd{f T} [@code{arctan2}] function which computes "
"the inverse tangent of the quotient of a pair of numbers.  Since you feed it "
"the two original numbers, it has enough information to give you a full "
"360-degree answer."
msgstr ""

#. type: group
#: ../../calc.texi:2841
#, no-wrap
msgid ""
"2:  0.89879    1:  116.       3:  116.       2:  116.       1:  180.\n"
"1:  -0.43837       .          2:  -0.89879   1:  -64.           .\n"
"    .                         1:  0.43837        .\n"
"                                  .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2843
#, no-wrap
msgid "    U U            f T         M-@key{RET} M-2 n       f T            -\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2849
msgid ""
"The resulting angles differ by 180 degrees; in other words, they point in "
"opposite directions, just as we would expect."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2858
msgid ""
"The @key{META}-@key{RET} we used in the third step is the ``last-arguments'' "
"command.  It is sort of like Undo, except that it restores the arguments of "
"the last command to the stack without removing the command's result.  It is "
"useful in situations like this one, where we need to do several operations "
"on the same inputs.  We could have accomplished the same thing by using "
"@kbd{M-2 @key{RET}} to duplicate the top two stack elements right after the "
"@kbd{U U}, then a pair of @kbd{M-@key{TAB}} commands to cycle the 116 up "
"around the duplicates."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2864
msgid ""
"A similar identity is supposed to hold for hyperbolic sines and cosines, "
"except that it is the @emph{difference} @texline @math{\\cosh^2x - "
"\\sinh^2x} @infoline @expr{cosh(x)^2 - sinh(x)^2} that always equals one.  "
"Let's try to verify this identity."
msgstr ""

#. type: group
#: ../../calc.texi:2870
#, no-wrap
msgid ""
"2:  -64        2:  -64        2:  -64        2:  9.7192e54  2:  9.7192e54\n"
"1:  -64        1:  -3.1175e27 1:  9.7192e54  1:  -64        1:  9.7192e54\n"
"    .              .              .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2872
#, no-wrap
msgid ""
" 64 n @key{RET} @key{RET}      H C            2 ^            @key{TAB}            "
"H S 2 ^\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2882
msgid ""
"Something's obviously wrong, because when we subtract these numbers the "
"answer will clearly be zero! But if you think about it, if these numbers "
"@emph{did} differ by one, it would be in the 55th decimal place.  The "
"difference we seek has been lost entirely to roundoff error."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2887
msgid ""
"We could verify this hypothesis by doing the actual calculation with, say, "
"60 decimal places of precision.  This will be slow, but not enormously so.  "
"Try it if you wish; sure enough, the answer is 0.99999, reasonably close to "
"1."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2890
msgid ""
"Of course, a more reasonable way to verify the identity is to use a more "
"reasonable value for @expr{x}!"
msgstr ""

#. type: cindex
#: ../../calc.texi:2891
#, no-wrap
msgid "Common logarithm"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2896
msgid ""
"Some Calculator commands use the Hyperbolic prefix for other purposes.  The "
"logarithm and exponential functions, for example, work to the base @expr{e} "
"normally but use base-10 instead if you use the Hyperbolic prefix."
msgstr ""

#. type: group
#: ../../calc.texi:2901
#, no-wrap
msgid ""
"1:  1000       1:  6.9077     1:  1000       1:  3\n"
"    .              .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2903
#, no-wrap
msgid "    1000           L              U              H L\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2909
msgid ""
"First, we mistakenly compute a natural logarithm.  Then we undo and compute "
"a common logarithm instead."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2912
msgid ""
"The @kbd{B} key computes a general base-@var{b} logarithm for any value of "
"@var{b}."
msgstr ""

#. type: group
#: ../../calc.texi:2918
#, no-wrap
msgid ""
"2:  1000       1:  3          1:  1000.      2:  1000.      1:  6.9077\n"
"1:  10             .              .          1:  2.71828        .\n"
"    .                                            .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2920
#, no-wrap
msgid " 1000 @key{RET} 10       B              H E            H P            B\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2929
msgid ""
"Here we first use @kbd{B} to compute the base-10 logarithm, then use the "
"``hyperbolic'' exponential as a cheap hack to recover the number 1000, then "
"use @kbd{B} again to compute the natural logarithm.  Note that @kbd{P} with "
"the hyperbolic prefix pushes the constant @expr{e} onto the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2940
msgid ""
"You may have noticed that both times we took the base-10 logarithm of 1000, "
"we got an exact integer result.  Calc always tries to give an exact rational "
"result for calculations involving rational numbers where possible.  But when "
"we used @kbd{H E}, the result was a floating-point number for no apparent "
"reason.  In fact, if we had computed @kbd{10 @key{RET} 3 ^} we @emph{would} "
"have gotten an exact integer 1000.  But the @kbd{H E} command is rigged to "
"generate a floating-point result all of the time so that @kbd{1000 H E} will "
"not waste time computing a thousand-digit integer when all you probably "
"wanted was @samp{1e1000}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2944
msgid ""
"(@bullet{}) @strong{Exercise 2.} Find a pair of integer inputs to the "
"@kbd{B} command for which Calc could find an exact rational result but "
"doesn't.  @xref{Arithmetic Answer 2, 2}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2948
msgid ""
"The Calculator also has a set of functions relating to combinatorics and "
"statistics.  You may be familiar with the @dfn{factorial} function, which "
"computes the product of all the integers up to a given number."
msgstr ""

#. type: group
#: ../../calc.texi:2953
#, no-wrap
msgid ""
"1:  100        1:  93326215443...    1:  100.       1:  9.3326e157\n"
"    .              .                     .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2955
#, no-wrap
msgid "    100            !                     U c f          !\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2965
msgid ""
"Recall, the @kbd{c f} command converts the integer or fraction at the top of "
"the stack to floating-point format.  If you take the factorial of a "
"floating-point number, you get a floating-point result accurate to the "
"current precision.  But if you give @kbd{!} an exact integer, you get an "
"exact integer result (158 digits long in this case)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2971
msgid ""
"If you take the factorial of a non-integer, Calc uses a generalized "
"factorial function defined in terms of Euler's Gamma function @texline "
"@math{\\Gamma(n)} @infoline @expr{gamma(n)} (which is itself available as "
"the @kbd{f g} command)."
msgstr ""

#. type: group
#: ../../calc.texi:2978
#, no-wrap
msgid ""
"3:  4.         3:  24.               1:  5.5        1:  52.342777847\n"
"2:  4.5        2:  52.3427777847         .              .\n"
"1:  5.         1:  120.\n"
"    .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:2980
#, no-wrap
msgid "                   M-3 !              M-0 @key{DEL} 5.5       f g\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:2987
msgid ""
"Here we verify the identity @texline @math{n! = \\Gamma(n+1)}.  @infoline "
"@expr{@var{n}!@: = gamma(@var{n}+1)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:2997
msgid ""
"The binomial coefficient @var{n}-choose-@var{m} @texline or "
"@math{\\displaystyle {n \\choose m}} is defined by @texline "
"@math{\\displaystyle {n! \\over m! \\, (n-m)!}} @infoline @expr{n!@: / m!@: "
"(n-m)!} for all reals @expr{n} and @expr{m}.  The intermediate results in "
"this formula can become quite large even if the final result is small; the "
"@kbd{k c} command computes a binomial coefficient in a way that avoids large "
"intermediate values."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3001
msgid ""
"The @kbd{k} prefix key defines several common functions out of combinatorics "
"and number theory.  Here we compute the binomial coefficient 30-choose-20, "
"then determine its prime factorization."
msgstr ""

#. type: group
#: ../../calc.texi:3007
#, no-wrap
msgid ""
"2:  30         1:  30045015   1:  [3, 3, 5, 7, 11, 13, 23, 29]\n"
"1:  20             .              .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3009
#, no-wrap
msgid " 30 @key{RET} 20         k c            k f\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3016
msgid ""
"You can verify these prime factors by using @kbd{V R *} to multiply together "
"the elements of this vector.  The result is the original number, 30045015."
msgstr ""

#. type: cindex
#: ../../calc.texi:3017
#, no-wrap
msgid "Hash tables"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3021
msgid ""
"Suppose a program you are writing needs a hash table with at least 10000 "
"entries.  It's best to use a prime number as the actual size of a hash "
"table.  Calc can compute the next prime number after 10000:"
msgstr ""

#. type: group
#: ../../calc.texi:3026
#, no-wrap
msgid ""
"1:  10000      1:  10007      1:  9973\n"
"    .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3028
#, no-wrap
msgid "    10000          k n            I k n\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3034
msgid "Just for kicks we've also computed the next prime @emph{less} than 10000."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3039
msgid ""
"@xref{Financial Functions}, for a description of the Calculator commands "
"that deal with business and financial calculations (functions like "
"@code{pv}, @code{rate}, and @code{sln})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3043
msgid ""
"@xref{Binary Functions}, to read about the commands for operating on binary "
"numbers (like @code{and}, @code{xor}, and @code{lsh})."
msgstr ""

#. type: node
#: ../../calc.texi:3044 ../../calc.texi:4217 ../../calc.texi:4218 ../../calc.texi:4741
#, no-wrap
msgid "Types Tutorial"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3052
msgid ""
"A @dfn{vector} is a list of numbers or other Calc data objects.  Calc "
"provides a large set of commands that operate on vectors.  Some are familiar "
"operations from vector analysis.  Others simply treat a vector as a list of "
"objects."
msgstr ""

#. type: menuentry
#: ../../calc.texi:3057
msgid "Vector Analysis Tutorial::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:3057
msgid "Matrix Tutorial::"
msgstr ""

#. type: node
#: ../../calc.texi:3057 ../../calc.texi:3184 ../../calc.texi:3510
#, no-wrap
msgid "List Tutorial"
msgstr ""

#. type: node
#: ../../calc.texi:3059 ../../calc.texi:3184
#, no-wrap
msgid "Vector Analysis Tutorial"
msgstr ""

#. type: node
#: ../../calc.texi:3059 ../../calc.texi:3184 ../../calc.texi:3510
#, no-wrap
msgid "Matrix Tutorial"
msgstr ""

#. type: subsection
#: ../../calc.texi:3060
#, no-wrap
msgid "Vector Analysis"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3065
msgid ""
"If you add two vectors, the result is a vector of the sums of the elements, "
"taken pairwise."
msgstr ""

#. type: group
#: ../../calc.texi:3071
#, no-wrap
msgid ""
"1:  [1, 2, 3]     2:  [1, 2, 3]     1:  [8, 8, 3]\n"
"    .             1:  [7, 6, 0]         .\n"
"                      .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3073
#, no-wrap
msgid "    [1,2,3]  s 1      [7 6 0]  s 2      +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3081
msgid ""
"Note that we can separate the vector elements with either commas or spaces.  "
"This is true whether we are using incomplete vectors or algebraic entry.  "
"The @kbd{s 1} and @kbd{s 2} commands save these vectors so we can easily "
"reuse them later."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3085
msgid ""
"If you multiply two vectors, the result is the sum of the products of the "
"elements taken pairwise.  This is called the @dfn{dot product} of the "
"vectors."
msgstr ""

#. type: group
#: ../../calc.texi:3091
#, no-wrap
msgid ""
"2:  [1, 2, 3]     1:  19\n"
"1:  [7, 6, 0]         .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3093
#, no-wrap
msgid "    r 1 r 2           *\n"
msgstr ""

#. type: cindex
#: ../../calc.texi:3096
#, no-wrap
msgid "Dot product"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3103
msgid ""
"The dot product of two vectors is equal to the product of their lengths "
"times the cosine of the angle between them.  (Here the vector is interpreted "
"as a line from the origin @expr{(0,0,0)} to the specified point in "
"three-dimensional space.)  The @kbd{A} (absolute value) command can be used "
"to compute the length of a vector."
msgstr ""

#. type: group
#: ../../calc.texi:3110
#, no-wrap
msgid ""
"3:  19            3:  19          1:  0.550782    1:  56.579\n"
"2:  [1, 2, 3]     2:  3.741657        .               .\n"
"1:  [7, 6, 0]     1:  9.219544\n"
"    .                 .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3112
#, no-wrap
msgid "    M-@key{RET}             M-2 A          * /             I C\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3122
msgid ""
"First we recall the arguments to the dot product command, then we compute "
"the absolute values of the top two stack entries to obtain the lengths of "
"the vectors, then we divide the dot product by the product of the lengths to "
"get the cosine of the angle.  The inverse cosine finds that the angle "
"between the vectors is about 56 degrees."
msgstr ""

#. type: cindex
#: ../../calc.texi:3123
#, no-wrap
msgid "Cross product"
msgstr ""

#. type: cindex
#: ../../calc.texi:3124
#, no-wrap
msgid "Perpendicular vectors"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3131
msgid ""
"The @dfn{cross product} of two vectors is a vector whose length is the "
"product of the lengths of the inputs times the sine of the angle between "
"them, and whose direction is perpendicular to both input vectors.  Unlike "
"the dot product, the cross product is defined only for three-dimensional "
"vectors.  Let's double-check our computation of the angle using the cross "
"product."
msgstr ""

#. type: group
#: ../../calc.texi:3138
#, no-wrap
msgid ""
"2:  [1, 2, 3]  3:  [-18, 21, -8]  1:  [-0.52, 0.61, -0.23]  1:  56.579\n"
"1:  [7, 6, 0]  2:  [1, 2, 3]          .                         .\n"
"    .          1:  [7, 6, 0]\n"
"                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3140
#, no-wrap
msgid ""
"    r 1 r 2        V C  s 3  M-@key{RET}    M-2 A * /                 A I "
"S\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3148
msgid ""
"First we recall the original vectors and compute their cross product, which "
"we also store for later reference.  Now we divide the vector by the product "
"of the lengths of the original vectors.  The length of this vector should be "
"the sine of the angle; sure enough, it is!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3155
msgid ""
"Vector-related commands generally begin with the @kbd{v} prefix key.  Some "
"are uppercase letters and some are lowercase.  To make it easier to type "
"these commands, the shift-@kbd{V} prefix key acts the same as the @kbd{v} "
"key.  (@xref{General Mode Commands}, for a way to make all prefix keys have "
"this property.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3159
msgid ""
"If we take the dot product of two perpendicular vectors we expect to get "
"zero, since the cosine of 90 degrees is zero.  Let's check that the cross "
"product is indeed perpendicular to both inputs:"
msgstr ""

#. type: group
#: ../../calc.texi:3165
#, no-wrap
msgid ""
"2:  [1, 2, 3]      1:  0          2:  [7, 6, 0]      1:  0\n"
"1:  [-18, 21, -8]      .          1:  [-18, 21, -8]      .\n"
"    .                                 .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3167
#, no-wrap
msgid "    r 1 r 3            *          @key{DEL} r 2 r 3            *\n"
msgstr ""

#. type: menuentry
#: ../../calc.texi:3170 ../../calc.texi:6425
#, no-wrap
msgid "Normalizing a vector"
msgstr ""

#. type: cindex
#: ../../calc.texi:3171
#, no-wrap
msgid "Unit vectors"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3176
msgid ""
"(@bullet{}) @strong{Exercise 1.} Given a vector on the top of the stack, "
"what keystrokes would you use to @dfn{normalize} the vector, i.e., to reduce "
"its length to one without changing its direction? @xref{Vector Answer 1, "
"1}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3183
msgid ""
"(@bullet{}) @strong{Exercise 2.} Suppose a certain particle can be at any of "
"several positions along a ruler.  You have a list of those positions in the "
"form of a vector, and another list of the probabilities for the particle to "
"be at the corresponding positions.  Find the average position of the "
"particle.  @xref{Vector Answer 2, 2}. (@bullet{})"
msgstr ""

#. type: cindex
#: ../../calc.texi:3185 ../../calc.texi:10780
#, no-wrap
msgid "Matrices"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3192
msgid ""
"A @dfn{matrix} is just a vector of vectors, all the same length.  This means "
"you can enter a matrix using nested brackets.  You can also use the "
"semicolon character to enter a matrix.  We'll show both methods here:"
msgstr ""

#. type: group
#: ../../calc.texi:3198
#, no-wrap
msgid ""
"1:  [ [ 1, 2, 3 ]             1:  [ [ 1, 2, 3 ]\n"
"      [ 4, 5, 6 ] ]                 [ 4, 5, 6 ] ]\n"
"    .                             .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3200
#, no-wrap
msgid "  [[1 2 3] [4 5 6]]             ' [1 2 3; 4 5 6] @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3205
msgid "We'll be using this matrix again, so type @kbd{s 4} to save it now."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3209
msgid ""
"Note that semicolons work with incomplete vectors, but they work better in "
"algebraic entry.  That's why we use the apostrophe in the second example."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3215
msgid ""
"When two matrices are multiplied, the lefthand matrix must have the same "
"number of columns as the righthand matrix has rows.  Row @expr{i}, column "
"@expr{j} of the result is effectively the dot product of row @expr{i} of the "
"left matrix by column @expr{j} of the right matrix."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3218
msgid ""
"If we try to duplicate this matrix and multiply it by itself, the dimensions "
"are wrong and the multiplication cannot take place:"
msgstr ""

#. type: group
#: ../../calc.texi:3224
#, no-wrap
msgid ""
"1:  [ [ 1, 2, 3 ]   * [ [ 1, 2, 3 ]\n"
"      [ 4, 5, 6 ] ]     [ 4, 5, 6 ] ]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3226
#, no-wrap
msgid "    @key{RET} *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3233
msgid ""
"Though rather hard to read, this is a formula which shows the product of two "
"matrices.  The @samp{*} function, having invalid arguments, has been left in "
"symbolic form."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3235
msgid "We can multiply the matrices if we @dfn{transpose} one of them first."
msgstr ""

#. type: group
#: ../../calc.texi:3244
#, no-wrap
msgid ""
"2:  [ [ 1, 2, 3 ]       1:  [ [ 14, 32 ]      1:  [ [ 17, 22, 27 ]\n"
"      [ 4, 5, 6 ] ]           [ 32, 77 ] ]          [ 22, 29, 36 ]\n"
"1:  [ [ 1, 4 ]              .                       [ 27, 36, 45 ] ]\n"
"      [ 2, 5 ]                                    .\n"
"      [ 3, 6 ] ]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3246
#, no-wrap
msgid "    U v t                   *                     U @key{TAB} *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3252
msgid ""
"Matrix multiplication is not commutative; indeed, switching the order of the "
"operands can even change the dimensions of the result matrix, as happened "
"here!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3257
msgid ""
"If you multiply a plain vector by a matrix, it is treated as a single row or "
"column depending on which side of the matrix it is on.  The result is a "
"plain vector which should also be interpreted as a row or column as "
"appropriate."
msgstr ""

#. type: group
#: ../../calc.texi:3264
#, no-wrap
msgid ""
"2:  [ [ 1, 2, 3 ]      1:  [14, 32]\n"
"      [ 4, 5, 6 ] ]        .\n"
"1:  [1, 2, 3]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3266
#, no-wrap
msgid "    r 4 r 1                *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3272
msgid ""
"Multiplying in the other order wouldn't work because the number of rows in "
"the matrix is different from the number of elements in the vector."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3280
msgid ""
"(@bullet{}) @strong{Exercise 1.} Use @samp{*} to sum along the rows of the "
"above @texline @math{2\\times3} @infoline 2x3 matrix to get @expr{[6, 15]}.  "
"Now use @samp{*} to sum along the columns to get @expr{[5, 7, 9]}.  "
"@xref{Matrix Answer 1, 1}. (@bullet{})"
msgstr ""

#. type: cindex
#: ../../calc.texi:3281
#, no-wrap
msgid "Identity matrix"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3286
msgid ""
"An @dfn{identity matrix} is a square matrix with ones along the diagonal and "
"zeros elsewhere.  It has the property that multiplication by an identity "
"matrix, on the left or on the right, always produces the original matrix."
msgstr ""

#. type: group
#: ../../calc.texi:3295
#, no-wrap
msgid ""
"1:  [ [ 1, 2, 3 ]      2:  [ [ 1, 2, 3 ]      1:  [ [ 1, 2, 3 ]\n"
"      [ 4, 5, 6 ] ]          [ 4, 5, 6 ] ]          [ 4, 5, 6 ] ]\n"
"    .                  1:  [ [ 1, 0, 0 ]          .\n"
"                             [ 0, 1, 0 ]\n"
"                             [ 0, 0, 1 ] ]\n"
"                           .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3297
#, no-wrap
msgid "    r 4                    v i 3 @key{RET}              *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3304
msgid ""
"If a matrix is square, it is often possible to find its @dfn{inverse}, that "
"is, a matrix which, when multiplied by the original matrix, yields an "
"identity matrix.  The @kbd{&} (reciprocal) key also computes the inverse of "
"a matrix."
msgstr ""

#. type: group
#: ../../calc.texi:3311
#, no-wrap
msgid ""
"1:  [ [ 1, 2, 3 ]      1:  [ [   -2.4,     1.2,   -0.2 ]\n"
"      [ 4, 5, 6 ]            [    2.8,    -1.4,    0.4 ]\n"
"      [ 7, 6, 0 ] ]          [ -0.73333, 0.53333, -0.2 ] ]\n"
"    .                      .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3313
#, no-wrap
msgid "    r 4 r 2 |  s 5         &\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3320
msgid ""
"The vertical bar @kbd{|} @dfn{concatenates} numbers, vectors, and matrices "
"together.  Here we have used it to add a new row onto our matrix to make it "
"square."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3322
msgid "We can multiply these two matrices in either order to get an identity."
msgstr ""

#. type: group
#: ../../calc.texi:3329
#, no-wrap
msgid ""
"1:  [ [ 1., 0., 0. ]      1:  [ [ 1., 0., 0. ]\n"
"      [ 0., 1., 0. ]            [ 0., 1., 0. ]\n"
"      [ 0., 0., 1. ] ]          [ 0., 0., 1. ] ]\n"
"    .                         .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3331
#, no-wrap
msgid "    M-@key{RET}  *                  U @key{TAB} *\n"
msgstr ""

#. type: cindex
#: ../../calc.texi:3334
#, no-wrap
msgid "Systems of linear equations"
msgstr ""

#. type: cindex
#: ../../calc.texi:3335
#, no-wrap
msgid "Linear equations, systems of"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3338
msgid ""
"Matrix inverses are related to systems of linear equations in algebra.  "
"Suppose we had the following set of equations:"
msgstr ""

#. type: example
#: ../../calc.texi:3345
#, no-wrap
msgid ""
"    a + 2b + 3c = 6\n"
"   4a + 5b + 6c = 2\n"
"   7a + 6b      = 3\n"
msgstr ""

#. type: tex
#: ../../calc.texi:3360
#, no-wrap
msgid ""
"\\beforedisplayh\n"
"$$ \\openup1\\jot \\tabskip=0pt plus1fil\n"
"\\halign to\\displaywidth{\\tabskip=0pt\n"
"   $\\hfil#$&$\\hfil{}#{}$&\n"
"   $\\hfil#$&$\\hfil{}#{}$&\n"
"   $\\hfil#$&${}#\\hfil$\\tabskip=0pt plus1fil\\cr\n"
"  a&+&2b&+&3c&=6 \\cr\n"
" 4a&+&5b&+&6c&=2 \\cr\n"
" 7a&+&6b& &  &=3 \\cr}\n"
"$$\n"
"\\afterdisplayh\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3364
msgid "This can be cast into the matrix equation,"
msgstr ""

#. type: example
#: ../../calc.texi:3371
#, no-wrap
msgid ""
"   [ [ 1, 2, 3 ]     [ [ a ]     [ [ 6 ]\n"
"     [ 4, 5, 6 ]   *   [ b ]   =   [ 2 ]\n"
"     [ 7, 6, 0 ] ]     [ c ] ]     [ 3 ] ]\n"
msgstr ""

#. type: tex
#: ../../calc.texi:3381
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ \\pmatrix{ 1 & 2 & 3 \\cr 4 & 5 & 6 \\cr 7 & 6 & 0 }\n"
"   \\times\n"
"   \\pmatrix{ a \\cr b \\cr c } = \\pmatrix{ 6 \\cr 2 \\cr 3 }\n"
"$$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3385
msgid ""
"We can solve this system of equations by multiplying both sides by the "
"inverse of the matrix.  Calc can do this all in one step:"
msgstr ""

#. type: group
#: ../../calc.texi:3393
#, no-wrap
msgid ""
"2:  [6, 2, 3]          1:  [-12.6, 15.2, -3.93333]\n"
"1:  [ [ 1, 2, 3 ]          .\n"
"      [ 4, 5, 6 ]\n"
"      [ 7, 6, 0 ] ]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3395
#, no-wrap
msgid "    [6,2,3] r 5            /\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3402
msgid ""
"The result is the @expr{[a, b, c]} vector that solves the equations.  "
"(Dividing by a square matrix is equivalent to multiplying by its inverse.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3404
msgid "Let's verify this solution:"
msgstr ""

#. type: group
#: ../../calc.texi:3412
#, no-wrap
msgid ""
"2:  [ [ 1, 2, 3 ]                1:  [6., 2., 3.]\n"
"      [ 4, 5, 6 ]                    .\n"
"      [ 7, 6, 0 ] ]\n"
"1:  [-12.6, 15.2, -3.93333]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3414
#, no-wrap
msgid "    r 5  @key{TAB}                         *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3431
msgid ""
"Note that we had to be careful about the order in which we multiplied the "
"matrix and vector.  If we multiplied in the other order, Calc would assume "
"the vector was a row vector in order to make the dimensions come out right, "
"and the answer would be incorrect.  If you don't feel safe letting Calc take "
"either interpretation of your vectors, use explicit @texline "
"@math{N\\times1} @infoline Nx1 or @texline @math{1\\times N} @infoline 1xN "
"matrices instead.  In this case, you would enter the original column vector "
"as @samp{[[6], [2], [3]]} or @samp{[6; 2; 3]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3436
msgid ""
"(@bullet{}) @strong{Exercise 2.} Algebraic entry allows you to make vectors "
"and matrices that include variables.  Solve the following system of "
"equations to get expressions for @expr{x} and @expr{y} in terms of @expr{a} "
"and @expr{b}."
msgstr ""

#. type: group
#: ../../calc.texi:3442 ../../calc.texi:6830
#, no-wrap
msgid ""
"   x + a y = 6\n"
"   x + b y = 10\n"
msgstr ""

#. type: tex
#: ../../calc.texi:3451 ../../calc.texi:6839
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ \\eqalign{ x &+ a y = 6 \\cr\n"
"             x &+ b y = 10}\n"
"$$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3455
msgid "@xref{Matrix Answer 2, 2}. (@bullet{})"
msgstr ""

#. type: cindex
#: ../../calc.texi:3456
#, no-wrap
msgid "Least-squares for over-determined systems"
msgstr ""

#. type: cindex
#: ../../calc.texi:3457
#, no-wrap
msgid "Over-determined systems of equations"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3467
msgid ""
"(@bullet{}) @strong{Exercise 3.} A system of equations is "
"``over-determined'' if it has more equations than variables.  It is often "
"the case that there are no values for the variables that will satisfy all "
"the equations at once, but it is still useful to find a set of values which "
"``nearly'' satisfy all the equations.  In terms of matrix equations, you "
"can't solve @expr{A X = B} directly because the matrix @expr{A} is not "
"square for an over-determined system.  Matrix inversion works only for "
"square matrices.  One common trick is to multiply both sides on the left by "
"the transpose of @expr{A}:"
msgstr ""

#. type: ifnottex
#: ../../calc.texi:3469
msgid "@samp{trn(A)*A*X = trn(A)*B}."
msgstr ""

#. type: tex
#: ../../calc.texi:3472
#, no-wrap
msgid "$A^T A \\, X = A^T B$, where $A^T$ is the transpose \\samp{trn(A)}.\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3481
msgid ""
"Now @texline @math{A^T A} @infoline @expr{trn(A)*A} is a square matrix so a "
"solution is possible.  It turns out that the @expr{X} vector you compute in "
"this way will be a ``least-squares'' solution, which can be regarded as the "
"``closest'' solution to the set of equations.  Use Calc to solve the "
"following over-determined system:"
msgstr ""

#. type: group
#: ../../calc.texi:3489 ../../calc.texi:6893
#, no-wrap
msgid ""
"    a + 2b + 3c = 6\n"
"   4a + 5b + 6c = 2\n"
"   7a + 6b      = 3\n"
"   2a + 4b + 6c = 11\n"
msgstr ""

#. type: tex
#: ../../calc.texi:3505 ../../calc.texi:6909
#, no-wrap
msgid ""
"\\beforedisplayh\n"
"$$ \\openup1\\jot \\tabskip=0pt plus1fil\n"
"\\halign to\\displaywidth{\\tabskip=0pt\n"
"   $\\hfil#$&$\\hfil{}#{}$&\n"
"   $\\hfil#$&$\\hfil{}#{}$&\n"
"   $\\hfil#$&${}#\\hfil$\\tabskip=0pt plus1fil\\cr\n"
"  a&+&2b&+&3c&=6 \\cr\n"
" 4a&+&5b&+&6c&=2 \\cr\n"
" 7a&+&6b& &  &=3 \\cr\n"
" 2a&+&4b&+&6c&=11 \\cr}\n"
"$$\n"
"\\afterdisplayh\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3509
msgid "@xref{Matrix Answer 3, 3}. (@bullet{})"
msgstr ""

#. type: subsection
#: ../../calc.texi:3511
#, no-wrap
msgid "Vectors as Lists"
msgstr ""

#. type: cindex
#: ../../calc.texi:3514
#, no-wrap
msgid "Lists"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3520
msgid ""
"Although Calc has a number of features for manipulating vectors and matrices "
"as mathematical objects, you can also treat vectors as simple lists of "
"values.  For example, we saw that the @kbd{k f} command returns a vector "
"which is a list of the prime factors of a number."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3522
msgid "You can pack and unpack stack entries into vectors:"
msgstr ""

#. type: group
#: ../../calc.texi:3529
#, no-wrap
msgid ""
"3:  10         1:  [10, 20, 30]     3:  10\n"
"2:  20             .                2:  20\n"
"1:  30                              1:  30\n"
"    .                                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3531
#, no-wrap
msgid "                   M-3 v p              v u\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3536
msgid ""
"You can also build vectors out of consecutive integers, or out of many "
"copies of a given value:"
msgstr ""

#. type: group
#: ../../calc.texi:3542
#, no-wrap
msgid ""
"1:  [1, 2, 3, 4]    2:  [1, 2, 3, 4]    2:  [1, 2, 3, 4]\n"
"    .               1:  17              1:  [17, 17, 17, 17]\n"
"                        .                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3544
#, no-wrap
msgid "    v x 4 @key{RET}           17                  v b 4 @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3549
msgid ""
"You can apply an operator to every element of a vector using the @dfn{map} "
"command."
msgstr ""

#. type: group
#: ../../calc.texi:3554
#, no-wrap
msgid ""
"1:  [17, 34, 51, 68]   1:  [289, 1156, 2601, 4624]  1:  [17, 34, 51, 68]\n"
"    .                      .                            .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3556
#, no-wrap
msgid "    V M *                  2 V M ^                      V M Q\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3566
msgid ""
"In the first step, we multiply the vector of integers by the vector of 17's "
"elementwise.  In the second step, we raise each element to the power two.  "
"(The general rule is that both operands must be vectors of the same length, "
"or else one must be a vector and the other a plain number.)  In the final "
"step, we take the square root of each element."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3572
msgid ""
"(@bullet{}) @strong{Exercise 1.} Compute a vector of powers of two from "
"@texline @math{2^{-4}} @infoline @expr{2^-4} to @expr{2^4}.  @xref{List "
"Answer 1, 1}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3576
msgid ""
"You can also @dfn{reduce} a binary operator across a vector.  For example, "
"reducing @samp{*} computes the product of all the elements in the vector:"
msgstr ""

#. type: group
#: ../../calc.texi:3581
#, no-wrap
msgid ""
"1:  123123     1:  [3, 7, 11, 13, 41]      1:  123123\n"
"    .              .                           .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3583
#, no-wrap
msgid "    123123         k f                         V R *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3589
msgid ""
"In this example, we decompose 123123 into its prime factors, then multiply "
"those factors together again to yield the original number."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3592
msgid "We could compute a dot product ``by hand'' using mapping and reduction:"
msgstr ""

#. type: group
#: ../../calc.texi:3598
#, no-wrap
msgid ""
"2:  [1, 2, 3]     1:  [7, 12, 0]     1:  19\n"
"1:  [7, 6, 0]         .                  .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3600
#, no-wrap
msgid "    r 1 r 2           V M *              V R +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3607
msgid ""
"Recalling two vectors from the previous section, we compute the sum of "
"pairwise products of the elements to get the same answer for the dot product "
"as before."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3611
msgid ""
"A slight variant of vector reduction is the @dfn{accumulate} operation, "
"@kbd{V U}.  This produces a vector of the intermediate results from a "
"corresponding reduction.  Here we compute a table of factorials:"
msgstr ""

#. type: group
#: ../../calc.texi:3616
#, no-wrap
msgid ""
"1:  [1, 2, 3, 4, 5, 6]    1:  [1, 2, 6, 24, 120, 720]\n"
"    .                         .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3618
#, no-wrap
msgid "    v x 6 @key{RET}                 V U *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3627
msgid ""
"Calc allows vectors to grow as large as you like, although it gets rather "
"slow if vectors have more than about a hundred elements.  Actually, most of "
"the time is spent formatting these large vectors for display, not "
"calculating on them.  Try the following experiment (if your computer is very "
"fast you may need to substitute a larger vector size)."
msgstr ""

#. type: group
#: ../../calc.texi:3632
#, no-wrap
msgid ""
"1:  [1, 2, 3, 4, ...      1:  [2, 3, 4, 5, ...\n"
"    .                         .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3634 ../../calc.texi:3647
#, no-wrap
msgid "    v x 500 @key{RET}               1 V M +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3640
msgid ""
"Now press @kbd{v .} (the letter @kbd{v}, then a period) and try the "
"experiment again.  In @kbd{v .} mode, long vectors are displayed "
"``abbreviated'' like this:"
msgstr ""

#. type: group
#: ../../calc.texi:3645
#, no-wrap
msgid ""
"1:  [1, 2, 3, ..., 500]   1:  [2, 3, 4, ..., 501]\n"
"    .                         .\n"
"\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3658
msgid ""
"(where now the @samp{...} is actually part of the Calc display).  You will "
"find both operations are now much faster.  But notice that even in @w{@kbd{v "
".}} mode, the full vectors are still shown in the Trail.  Type @w{@kbd{t .}} "
"to cause the trail to abbreviate as well, and try the experiment one more "
"time.  Operations on long vectors are now quite fast! (But of course if you "
"use @kbd{t .} you will lose the ability to get old vectors back using the "
"@kbd{t y} command.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3662
msgid ""
"An easy way to view a full vector when @kbd{v .} mode is active is to press "
"@kbd{`} (grave accent) to edit the vector; editing always works with the "
"full, unabbreviated value."
msgstr ""

#. type: cindex
#: ../../calc.texi:3663
#, no-wrap
msgid "Least-squares for fitting a straight line"
msgstr ""

#. type: cindex
#: ../../calc.texi:3664
#, no-wrap
msgid "Fitting data to a line"
msgstr ""

#. type: cindex
#: ../../calc.texi:3665
#, no-wrap
msgid "Line, fitting data to"
msgstr ""

#. type: cindex
#: ../../calc.texi:3666
#, no-wrap
msgid "Data, extracting from buffers"
msgstr ""

#. type: cindex
#: ../../calc.texi:3667
#, no-wrap
msgid "Columns of data, extracting"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3673
msgid ""
"As a larger example, let's try to fit a straight line to some data, using "
"the method of least squares.  (Calc has a built-in command for least-squares "
"curve fitting, but we'll do it by hand here just to practice working with "
"vectors.)  Suppose we have the following list of values in a file we have "
"loaded into Emacs:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:3696
#, no-wrap
msgid ""
"  x        y\n"
" ---      ---\n"
" 1.34    0.234\n"
" 1.41    0.298\n"
" 1.49    0.402\n"
" 1.56    0.412\n"
" 1.64    0.466\n"
" 1.73    0.473\n"
" 1.82    0.601\n"
" 1.91    0.519\n"
" 2.01    0.603\n"
" 2.11    0.637\n"
" 2.22    0.645\n"
" 2.33    0.705\n"
" 2.45    0.917\n"
" 2.58    1.009\n"
" 2.71    0.971\n"
" 2.85    1.062\n"
" 3.00    1.148\n"
" 3.15    1.157\n"
" 3.32    1.354\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3703
msgid ""
"If you are reading this tutorial in printed form, you will find it easiest "
"to press @kbd{C-x * i} to enter the on-line Info version of the manual and "
"find this table there.  (Press @kbd{g}, then type @kbd{List Tutorial}, to "
"jump straight to this section.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3712
msgid ""
"Position the cursor at the upper-left corner of this table, just to the left "
"of the @expr{1.34}.  Press @kbd{C-@@} to set the mark.  (On your system this "
"may be @kbd{C-2}, @kbd{C-@key{SPC}}, or @kbd{NUL}.)  Now position the cursor "
"to the lower-right, just after the @expr{1.354}.  You have now defined this "
"region as an Emacs ``rectangle.'' Still in the Info buffer, type @kbd{C-x * "
"r}.  This command (@code{calc-grab-rectangle}) will pop you back into the "
"Calculator, with the contents of the rectangle you specified in the form of "
"a matrix."
msgstr ""

#. type: group
#: ../../calc.texi:3718
#, no-wrap
msgid ""
"1:  [ [ 1.34, 0.234 ]\n"
"      [ 1.41, 0.298 ]\n"
"      @dots{}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3724
msgid ""
"(You may wish to use @kbd{v .} mode to abbreviate the display of this large "
"matrix.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3729
msgid ""
"We want to treat this as a pair of lists.  The first step is to transpose "
"this matrix into a pair of rows.  Remember, a matrix is just a vector of "
"vectors.  So we can unpack the matrix into a pair of row vectors on the "
"stack."
msgstr ""

#. type: group
#: ../../calc.texi:3735
#, no-wrap
msgid ""
"1:  [ [ 1.34,  1.41,  1.49,  ... ]     2:  [1.34, 1.41, 1.49, ... ]\n"
"      [ 0.234, 0.298, 0.402, ... ] ]   1:  [0.234, 0.298, 0.402, ... ]\n"
"    .                                      .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3737
#, no-wrap
msgid "    v t                                    v u\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3742
msgid "Let's store these in quick variables 1 and 2, respectively."
msgstr ""

#. type: group
#: ../../calc.texi:3747
#, no-wrap
msgid ""
"1:  [1.34, 1.41, 1.49, ... ]        .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3749
#, no-wrap
msgid "    t 2                             t 1\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3755
msgid ""
"(Recall that @kbd{t 2} is a variant of @kbd{s 2} that removes the stored "
"value from the stack.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3757
msgid "In a least squares fit, the slope @expr{m} is given by the formula"
msgstr ""

#. type: example
#: ../../calc.texi:3761
#, no-wrap
msgid "m = (N sum(x y) - sum(x) sum(y)) / (N sum(x^2) - sum(x)^2)\n"
msgstr ""

#. type: tex
#: ../../calc.texi:3768
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ m = {N \\sum x y - \\sum x \\sum y  \\over\n"
"        N \\sum x^2 - \\left( \\sum x \\right)^2} $$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3778
msgid ""
"where @texline @math{\\sum x} @infoline @expr{sum(x)} represents the sum of "
"all the values of @expr{x}.  While there is an actual @code{sum} function in "
"Calc, it's easier to sum a vector using a simple reduction.  First, let's "
"compute the four different sums that this formula uses."
msgstr ""

#. type: group
#: ../../calc.texi:3783
#, no-wrap
msgid ""
"1:  41.63                 1:  98.0003\n"
"    .                         .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3785
#, no-wrap
msgid ""
" r 1 V R +   t 3           r 1 2 V M ^ V R +   t 4\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3793
#, no-wrap
msgid ""
"1:  13.613                1:  33.36554\n"
"    .                         .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3795
#, no-wrap
msgid " r 2 V R +   t 5           r 1 r 2 V M * V R +   t 6\n"
msgstr ""

#. type: ifnottex
#: ../../calc.texi:3803
msgid ""
"These are @samp{sum(x)}, @samp{sum(x^2)}, @samp{sum(y)}, and @samp{sum(x "
"y)}, respectively.  (We could have used @kbd{*} to compute @samp{sum(x^2)} "
"and @samp{sum(x y)}.)"
msgstr ""

#. type: tex
#: ../../calc.texi:3808
#, no-wrap
msgid ""
"These are $\\sum x$, $\\sum x^2$, $\\sum y$, and $\\sum x y$,\n"
"respectively.  (We could have used \\kbd{*} to compute $\\sum x^2$ and\n"
"$\\sum x y$.)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3812
msgid ""
"Finally, we also need @expr{N}, the number of data points.  This is just the "
"length of either of our lists."
msgstr ""

#. type: group
#: ../../calc.texi:3817
#, no-wrap
msgid ""
"1:  19\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3819
#, no-wrap
msgid " r 1 v l   t 7\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3824
msgid "(That's @kbd{v} followed by a lower-case @kbd{l}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3826
msgid "Now we grind through the formula:"
msgstr ""

#. type: group
#: ../../calc.texi:3832
#, no-wrap
msgid ""
"1:  633.94526  2:  633.94526  1:  67.23607\n"
"    .          1:  566.70919      .\n"
"                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3834
#, no-wrap
msgid ""
" r 7 r 6 *      r 3 r 5 *         -\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3844
#, no-wrap
msgid ""
"2:  67.23607   3:  67.23607   2:  67.23607   1:  0.52141679\n"
"1:  1862.0057  2:  1862.0057  1:  128.9488       .\n"
"    .          1:  1733.0569      .\n"
"                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3846
#, no-wrap
msgid " r 7 r 4 *      r 3 2 ^           -              /   t 8\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3851
msgid ""
"That gives us the slope @expr{m}.  The y-intercept @expr{b} can now be found "
"with the simple formula,"
msgstr ""

#. type: example
#: ../../calc.texi:3855
#, no-wrap
msgid "b = (sum(y) - m sum(x)) / N\n"
msgstr ""

#. type: tex
#: ../../calc.texi:3862
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ b = {\\sum y - m \\sum x \\over N} $$\n"
"\\afterdisplay\n"
"\\vskip10pt\n"
msgstr ""

#. type: group
#: ../../calc.texi:3869
#, no-wrap
msgid ""
"1:  13.613     2:  13.613     1:  -8.09358   1:  -0.425978\n"
"    .          1:  21.70658       .              .\n"
"                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3871
#, no-wrap
msgid "   r 5            r 8 r 3 *       -              r 7 /   t 9\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3878
msgid ""
"Let's ``plot'' this straight line approximation, @texline @math{y \\approx m "
"x + b}, @infoline @expr{m x + b}, and compare it with the original data."
msgstr ""

#. type: group
#: ../../calc.texi:3883
#, no-wrap
msgid ""
"1:  [0.699, 0.735, ... ]    1:  [0.273, 0.309, ... ]\n"
"    .                           .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3885
#, no-wrap
msgid "    r 1 r 8 *                   r 9 +    s 0\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3893
msgid ""
"Notice that multiplying a vector by a constant, and adding a constant to a "
"vector, can be done without mapping commands since these are common "
"operations from vector algebra.  As far as Calc is concerned, we've just "
"been doing geometry in 19-dimensional space!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3896
msgid ""
"We can subtract this vector from our original @expr{y} vector to get a feel "
"for the error of our fit.  Let's find the maximum error:"
msgstr ""

#. type: group
#: ../../calc.texi:3901
#, no-wrap
msgid ""
"1:  [0.0387, 0.0112, ... ]   1:  [0.0387, 0.0112, ... ]   1:  0.0897\n"
"    .                            .                            .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3903
#, no-wrap
msgid "    r 2 -                        V M A                        V R X\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3916
msgid ""
"First we compute a vector of differences, then we take the absolute values "
"of these differences, then we reduce the @code{max} function across the "
"vector.  (The @code{max} function is on the two-key sequence @kbd{f x}; "
"because it is so common to use @code{max} in a vector operation, the letters "
"@kbd{X} and @kbd{N} are also accepted for @code{max} and @code{min} in this "
"context.  In general, you answer the @kbd{V M} or @kbd{V R} prompt with the "
"actual key sequence that invokes the function you want.  You could have "
"typed @kbd{V R f x} or even @kbd{V R x max @key{RET}} if you had preferred.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3922
msgid ""
"If your system has the GNUPLOT program, you can see graphs of your data and "
"your straight line to see how well they match.  (If you have GNUPLOT 3.0 or "
"higher, the following instructions will work regardless of the kind of "
"display you have.  Some GNUPLOT 2.0, non-X-windows systems may require "
"additional steps to view the graphs.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3927
msgid ""
"Let's start by plotting the original data.  Recall the ``@var{x}'' and "
"``@var{y}'' vectors onto the stack and press @kbd{g f}.  This ``fast'' "
"graphing command does everything you need to do for simple, straightforward "
"plotting of data."
msgstr ""

#. type: group
#: ../../calc.texi:3933
#, no-wrap
msgid ""
"2:  [1.34, 1.41, 1.49, ... ]\n"
"1:  [0.234, 0.298, 0.402, ... ]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3935
#, no-wrap
msgid "    r 1 r 2    g f\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3944
msgid ""
"If all goes well, you will shortly get a new window containing a graph of "
"the data.  (If not, contact your GNUPLOT or Calc installer to find out what "
"went wrong.)  In the X window system, this will be a separate graphics "
"window.  For other kinds of displays, the default is to display the graph in "
"Emacs itself using rough character graphics.  Press @kbd{q} when you are "
"done viewing the character graphics."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3946
msgid "Next, let's add the line we got from our least-squares fit."
msgstr ""

#. type: ifinfo
#: ../../calc.texi:3951
msgid ""
"(If you are reading this tutorial on-line while running Calc, typing @kbd{g "
"a} may cause the tutorial to disappear from its window and be replaced by a "
"buffer named @file{*Gnuplot Commands*}.  The tutorial will reappear when you "
"terminate GNUPLOT by typing @kbd{g q}.)"
msgstr ""

#. type: group
#: ../../calc.texi:3958
#, no-wrap
msgid ""
"2:  [1.34, 1.41, 1.49, ... ]\n"
"1:  [0.273, 0.309, 0.351, ... ]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:3960
#, no-wrap
msgid "    @key{DEL} r 0    g a  g p\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3966
msgid ""
"It's not very useful to get symbols to mark the data points on this second "
"curve; you can type @kbd{g S g p} to remove them.  Type @kbd{g q} when you "
"are done to remove the X graphics window and terminate GNUPLOT."
msgstr ""

#. type: Plain text
#: ../../calc.texi:3973
msgid ""
"(@bullet{}) @strong{Exercise 2.} An earlier exercise showed how to do least "
"squares fitting to a general system of equations.  Our 19 data points are "
"really 19 equations of the form @expr{y_i = m x_i + b} for different pairs "
"of @expr{(x_i,y_i)}.  Use the matrix-transpose method to solve for @expr{m} "
"and @expr{b}, duplicating the above result.  @xref{List Answer 2, "
"2}. (@bullet{})"
msgstr ""

#. type: cindex
#: ../../calc.texi:3974 ../../calc.texi:6425 ../../calc.texi:20720
#, no-wrap
msgid "Geometric mean"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3981
msgid ""
"(@bullet{}) @strong{Exercise 3.} If the input data do not form a rectangle, "
"you can use @w{@kbd{C-x * g}} (@code{calc-grab-region})  to grab the data "
"the way Emacs normally works with regions---it reads left-to-right, "
"top-to-bottom, treating line breaks the same as spaces.  Use this command to "
"find the geometric mean of the following numbers.  (The geometric mean is "
"the @var{n}th root of the product of @var{n} numbers.)"
msgstr ""

#. type: example
#: ../../calc.texi:3986
#, no-wrap
msgid ""
"2.3  6  22  15.1  7\n"
"  15  14  7.5\n"
"  2.5\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:3992
msgid ""
"The @kbd{C-x * g} command accepts numbers separated by spaces or commas, "
"with or without surrounding vector brackets.  @xref{List Answer 3, "
"3}. (@bullet{})"
msgstr ""

#. type: ifnottex
#: ../../calc.texi:4000
msgid ""
"As another example, a theorem about binomial coefficients tells us that the "
"alternating sum of binomial coefficients @var{n}-choose-0 minus "
"@var{n}-choose-1 plus @var{n}-choose-2, and so on up to "
"@var{n}-choose-@var{n}, always comes out to zero.  Let's verify this for "
"@expr{n=6}."
msgstr ""

#. type: tex
#: ../../calc.texi:4007
#, no-wrap
msgid ""
"As another example, a theorem about binomial coefficients tells\n"
"us that the alternating sum of binomial coefficients\n"
"${n \\choose 0} - {n \\choose 1} + {n \\choose 2} - \\cdots \\pm {n \\choose "
"n}$\n"
"always comes out to zero.  Let's verify this\n"
"for \\cite{n=6}.\n"
msgstr ""

#. type: group
#: ../../calc.texi:4013
#, no-wrap
msgid ""
"1:  [1, 2, 3, 4, 5, 6, 7]     1:  [0, 1, 2, 3, 4, 5, 6]\n"
"    .                             .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4015
#, no-wrap
msgid ""
"    v x 7 @key{RET}                     1 -\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4023
#, no-wrap
msgid ""
"1:  [1, -6, 15, -20, 15, -6, 1]          1:  0\n"
"    .                                        .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4025
#, no-wrap
msgid "    V M ' (-1)^$ choose(6,$) @key{RET}             V R +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4033
msgid ""
"The @kbd{V M '} command prompts you to enter any algebraic expression to "
"define the function to map over the vector.  The symbol @samp{$} inside this "
"expression represents the argument to the function.  The Calculator applies "
"this formula to each element of the vector, substituting each element's "
"value for the @samp{$} sign(s) in turn."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4040
msgid ""
"To define a two-argument function, use @samp{$$} for the first argument and "
"@samp{$} for the second: @kbd{V M ' $$-$ @key{RET}} is equivalent to @kbd{V "
"M -}.  This is analogous to regular algebraic entry, where @samp{$$} would "
"refer to the next-to-top stack entry and @samp{$} would refer to the top "
"stack entry, and @kbd{' $$-$ @key{RET}} would act exactly like @kbd{-}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4056
msgid ""
"Notice that the @kbd{V M '} command has recorded two things in the trail: "
"The result, as usual, and also a funny-looking thing marked @samp{oper} that "
"represents the operator function you typed in.  The function is enclosed in "
"@samp{< >} brackets, and the argument is denoted by a @samp{#} sign.  If "
"there were several arguments, they would be shown as @samp{#1}, @samp{#2}, "
"and so on.  (For example, @kbd{V M ' $$-$} will put the function @samp{<#1 - "
"#2>} on the trail.)  This object is a ``nameless function''; you can use "
"nameless @w{@samp{< >}} notation to answer the @kbd{V M '} prompt if you "
"like.  Nameless function notation has the interesting, occasionally useful "
"property that a nameless function is not actually evaluated until it is "
"used.  For example, @kbd{V M ' $+random(2.0)} evaluates @samp{random(2.0)} "
"once and adds that random number to all elements of the vector, but @kbd{V M "
"' <#+random(2.0)>} evaluates the @samp{random(2.0)} separately for each "
"vector element."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4061
msgid ""
"Another group of operators that are often useful with @kbd{V M} are the "
"relational operators: @kbd{a =}, for example, compares two numbers and gives "
"the result 1 if they are equal, or 0 if not.  Similarly, @w{@kbd{a <}} "
"checks for one number being less than another."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4068
msgid ""
"Other useful vector operations include @kbd{v v}, to reverse a vector "
"end-for-end; @kbd{V S}, to sort the elements of a vector into increasing "
"order; and @kbd{v r} and @w{@kbd{v c}}, to extract one row or column of a "
"matrix, or (in both cases) to extract one element of a plain vector.  With a "
"negative argument, @kbd{v r} and @kbd{v c} instead delete one row, column, "
"or vector element."
msgstr ""

#. type: cindex
#: ../../calc.texi:4069
#, no-wrap
msgid "Divisor functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4071
msgid "(@bullet{}) @strong{Exercise 4.} The @expr{k}th @dfn{divisor function}"
msgstr ""

#. type: tex
#: ../../calc.texi:4073
#, no-wrap
msgid "$\\sigma_k(n)$\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4079
msgid ""
"is the sum of the @expr{k}th powers of all the divisors of an integer "
"@expr{n}.  Figure out a method for computing the divisor function for "
"reasonably small values of @expr{n}.  As a test, the 0th and 1st divisor "
"functions of 30 are 8 and 72, respectively.  @xref{List Answer 4, "
"4}. (@bullet{})"
msgstr ""

#. type: cindex
#: ../../calc.texi:4080
#, no-wrap
msgid "Square-free numbers"
msgstr ""

#. type: cindex
#: ../../calc.texi:4081
#, no-wrap
msgid "Duplicate values in a list"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4089
msgid ""
"(@bullet{}) @strong{Exercise 5.} The @kbd{k f} command produces a list of "
"prime factors for a number.  Sometimes it is important to know that a number "
"is @dfn{square-free}, i.e., that no prime occurs more than once in its list "
"of prime factors.  Find a sequence of keystrokes to tell if a number is "
"square-free; your method should leave 1 on the stack if it is, or 0 if it "
"isn't.  @xref{List Answer 5, 5}. (@bullet{})"
msgstr ""

#. type: cindex
#: ../../calc.texi:4090
#, no-wrap
msgid "Triangular lists"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4094
msgid ""
"(@bullet{}) @strong{Exercise 6.} Build a list of lists that looks like the "
"following diagram.  (You may wish to use the @kbd{v /} command to enable "
"multi-line display of vectors.)"
msgstr ""

#. type: group
#: ../../calc.texi:4103
#, no-wrap
msgid ""
"1:  [ [1],\n"
"      [1, 2],\n"
"      [1, 2, 3],\n"
"      [1, 2, 3, 4],\n"
"      [1, 2, 3, 4, 5],\n"
"      [1, 2, 3, 4, 5, 6] ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4108
msgid "@xref{List Answer 6, 6}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4110
msgid "(@bullet{}) @strong{Exercise 7.} Build the following list of lists."
msgstr ""

#. type: group
#: ../../calc.texi:4119
#, no-wrap
msgid ""
"1:  [ [0],\n"
"      [1, 2],\n"
"      [3, 4, 5],\n"
"      [6, 7, 8, 9],\n"
"      [10, 11, 12, 13, 14],\n"
"      [15, 16, 17, 18, 19, 20] ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4124
msgid "@xref{List Answer 7, 7}. (@bullet{})"
msgstr ""

#. type: cindex
#: ../../calc.texi:4125
#, no-wrap
msgid "Maximizing a function over a list of values"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4137
msgid ""
"(@bullet{}) @strong{Exercise 8.} Compute a list of values of Bessel's "
"@texline @math{J_1(x)} @infoline @expr{J1} function @samp{besJ(1,x)} for "
"@expr{x} from 0 to 5 in steps of 0.25.  Find the value of @expr{x} (from "
"among the above set of values) for which @samp{besJ(1,x)} is a maximum.  Use "
"an ``automatic'' method, i.e., just reading along the list by hand to find "
"the largest value is not allowed! (There is an @kbd{a X} command which does "
"this kind of thing automatically; @pxref{Numerical Solutions}.)  @xref{List "
"Answer 8, 8}. (@bullet{})"
msgstr ""

#. type: cindex
#: ../../calc.texi:4138
#, no-wrap
msgid "Digits, vectors of"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4149
msgid ""
"(@bullet{}) @strong{Exercise 9.} You are given an integer in the range "
"@texline @math{0 \\le N < 10^m} @infoline @expr{0 <= N < 10^m} for "
"@expr{m=12} (i.e., an integer of less than twelve digits).  Convert this "
"integer into a vector of @expr{m} digits, each in the range from 0 to 9.  In "
"vector-of-digits notation, add one to this integer to produce a vector of "
"@expr{m+1} digits (since there could be a carry out of the most significant "
"digit).  Convert this vector back into a regular integer.  A good integer to "
"try is 25129925999.  @xref{List Answer 9, 9}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4153
msgid ""
"(@bullet{}) @strong{Exercise 10.} Your friend Joe tried to use @kbd{V R a =} "
"to test if all numbers in a list were equal.  What happened? How would you "
"do this test? @xref{List Answer 10, 10}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4168
msgid ""
"(@bullet{}) @strong{Exercise 11.} The area of a circle of radius one is "
"@cpi{}.  The area of the @texline @math{2\\times2} @infoline 2x2 square that "
"encloses that circle is 4.  So if we throw @var{n} darts at random points in "
"the square, about @cpiover{4} of them will land inside the circle.  This "
"gives us an entertaining way to estimate the value of @cpi{}.  The @w{@kbd{k "
"r}} command picks a random number between zero and the value on the stack.  "
"We could get a random floating-point number between @mathit{-1} and 1 by "
"typing @w{@kbd{2.0 k r 1 -}}.  Build a vector of 100 random @expr{(x,y)} "
"points in this square, then use vector mapping and reduction to count how "
"many points lie inside the unit circle.  Hint: Use the @kbd{v b} command.  "
"@xref{List Answer 11, 11}. (@bullet{})"
msgstr ""

#. type: cindex
#: ../../calc.texi:4169
#, no-wrap
msgid "Matchstick problem"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4184
msgid ""
"(@bullet{}) @strong{Exercise 12.} The @dfn{matchstick problem} provides "
"another way to calculate @cpi{}.  Say you have an infinite field of vertical "
"lines with a spacing of one inch.  Toss a one-inch matchstick onto the "
"field.  The probability that the matchstick will land crossing a line turns "
"out to be @texline @math{2/\\pi}.  @infoline @expr{2/pi}.  Toss 100 "
"matchsticks to estimate @cpi{}.  (If you want still more fun, the "
"probability that the GCD (@w{@kbd{k g}}) of two large integers is one turns "
"out to be @texline @math{6/\\pi^2}.  @infoline @expr{6/pi^2}.  That provides "
"yet another way to estimate @cpi{}.)  @xref{List Answer 12, 12}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4203
msgid ""
"(@bullet{}) @strong{Exercise 13.} An algebraic entry of a string in "
"double-quote marks, @samp{\"hello\"}, creates a vector of the numerical "
"(ASCII) codes of the characters (here, @expr{[104, 101, 108, 108, 111]}).  "
"Sometimes it is convenient to compute a @dfn{hash code} of a string, which "
"is just an integer that represents the value of that string.  Two equal "
"strings have the same hash code; two different strings @dfn{probably} have "
"different hash codes.  (For example, Calc has over 400 function names, but "
"Emacs can quickly find the definition for any given name because it has "
"sorted the functions into ``buckets'' by their hash codes.  Sometimes a few "
"names will hash into the same bucket, but it is easier to search among a few "
"names than among all the names.)  One popular hash function is computed as "
"follows: First set @expr{h = 0}.  Then, for each character from the string "
"in turn, set @expr{h = 3h + c_i} where @expr{c_i} is the character's ASCII "
"code.  If we have 511 buckets, we then take the hash code modulo 511 to get "
"the bucket number.  Develop a simple command or commands for converting "
"string vectors into hash codes.  The hash code for @samp{\"Testing, 1, 2, "
"3\"} is 1960915098, which modulo 511 is 121.  @xref{List Answer 13, "
"13}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4216
msgid ""
"(@bullet{}) @strong{Exercise 14.} The @kbd{H V R} and @kbd{H V U} commands "
"do nested function evaluations.  @kbd{H V U} takes a starting value and a "
"number of steps @var{n} from the stack; it then applies the function you "
"give to the starting value 0, 1, 2, up to @var{n} times and returns a vector "
"of the results.  Use this command to create a ``random walk'' of 50 steps.  "
"Start with the two-dimensional point @expr{(0,0)}; then take one step a "
"random distance between @mathit{-1} and 1 in both @expr{x} and @expr{y}; "
"then take another step, and so on.  Use the @kbd{g f} command to display "
"this random walk.  Now modify your random walk to walk a unit distance, but "
"in a random direction, at each step.  (Hint: The @code{sincos} function "
"returns a vector of the cosine and sine of an angle.)  @xref{List Answer 14, "
"14}. (@bullet{})"
msgstr ""

#. type: node
#: ../../calc.texi:4217 ../../calc.texi:4741 ../../calc.texi:4754 ../../calc.texi:5249 ../../calc.texi:5690
#, no-wrap
msgid "Algebra Tutorial"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4223
msgid ""
"Calc understands a variety of data types as well as simple numbers.  In this "
"section, we'll experiment with each of these types in turn."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4229
msgid ""
"The numbers we've been using so far have mainly been either @dfn{integers} "
"or @dfn{floats}.  We saw that floats are usually a good approximation to the "
"mathematical concept of real numbers, but they are only approximations and "
"are susceptible to roundoff error.  Calc also supports @dfn{fractions}, "
"which can exactly represent any rational number."
msgstr ""

#. type: group
#: ../../calc.texi:4235
#, no-wrap
msgid ""
"1:  3628800    2:  3628800    1:  518400:7   1:  518414:7   1:  7:518414\n"
"    .          1:  49             .              .              .\n"
"                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4237
#, no-wrap
msgid "    10 !           49 @key{RET}         :              2 +            &\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4246
msgid ""
"The @kbd{:} command divides two integers to get a fraction; @kbd{/} would "
"normally divide integers to get a floating-point result.  Notice we had to "
"type @key{RET} between the @kbd{49} and the @kbd{:} since the @kbd{:} would "
"otherwise be interpreted as part of a fraction beginning with 49."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4249
msgid ""
"You can convert between floating-point and fractional format using @kbd{c f} "
"and @kbd{c F}:"
msgstr ""

#. type: group
#: ../../calc.texi:4254
#, no-wrap
msgid ""
"1:  1.35027217629e-5    1:  7:518414\n"
"    .                       .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4256
#, no-wrap
msgid "    c f                     c F\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4262
msgid ""
"The @kbd{c F} command replaces a floating-point number with the ``simplest'' "
"fraction whose floating-point representation is the same, to within the "
"current precision."
msgstr ""

#. type: group
#: ../../calc.texi:4267
#, no-wrap
msgid ""
"1:  3.14159265359   1:  1146408:364913   1:  3.1416   1:  355:113\n"
"    .                   .                    .            .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4269
#, no-wrap
msgid "    P                   c F      @key{DEL}       p 5 @key{RET} P      c F\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4276
msgid ""
"(@bullet{}) @strong{Exercise 1.} A calculation has produced the result "
"1.26508260337.  You suspect it is the square root of the product of @cpi{} "
"and some rational number.  Is it? (Be sure to allow for roundoff error!)  "
"@xref{Types Answer 1, 1}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4278
msgid "@dfn{Complex numbers} can be stored in both rectangular and polar form."
msgstr ""

#. type: group
#: ../../calc.texi:4283
#, no-wrap
msgid ""
"1:  -9     1:  (0, 3)    1:  (3; 90.)   1:  (6; 90.)   1:  (2.4495; 45.)\n"
"    .          .             .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4285
#, no-wrap
msgid "    9 n        Q             c p            2 *            Q\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4293
msgid ""
"The square root of @mathit{-9} is by default rendered in rectangular form "
"(@w{@expr{0 + 3i}}), but we can convert it to polar form (3 with a phase "
"angle of 90 degrees).  All the usual arithmetic and scientific operations "
"are defined on both types of complex numbers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4301
msgid ""
"Another generalized kind of number is @dfn{infinity}.  Infinity isn't really "
"a number, but it can sometimes be treated like one.  Calc uses the symbol "
"@code{inf} to represent positive infinity, i.e., a value greater than any "
"real number.  Naturally, you can also write @samp{-inf} for minus infinity, "
"a value less than any real number.  The word @code{inf} can only be input "
"using algebraic entry."
msgstr ""

#. type: group
#: ../../calc.texi:4307
#, no-wrap
msgid ""
"2:  inf        2:  -inf       2:  -inf       2:  -inf       1:  nan\n"
"1:  -17        1:  -inf       1:  -inf       1:  inf            .\n"
"    .              .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4309
#, no-wrap
msgid ""
"' inf @key{RET} 17 n     *  @key{RET}         72 +           A              "
"+\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4326
msgid ""
"Since infinity is infinitely large, multiplying it by any finite number "
"(like @mathit{-17}) has no effect, except that since @mathit{-17} is "
"negative, it changes a plus infinity to a minus infinity.  (``A huge "
"positive number, multiplied by @mathit{-17}, yields a huge negative "
"number.'')  Adding any finite number to infinity also leaves it unchanged.  "
"Taking an absolute value gives us plus infinity again.  Finally, we add this "
"plus infinity to the minus infinity we had earlier.  If you work it out, you "
"might expect the answer to be @mathit{-72} for this.  But the 72 has been "
"completely lost next to the infinities; by the time we compute @w{@samp{inf "
"- inf}} the finite difference between them, if any, is undetectable.  So we "
"say the result is @dfn{indeterminate}, which Calc writes with the symbol "
"@code{nan} (for Not A Number)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4330
msgid ""
"Dividing by zero is normally treated as an error, but you can get Calc to "
"write an answer in terms of infinity by pressing @kbd{m i} to turn on "
"Infinite mode."
msgstr ""

#. type: group
#: ../../calc.texi:4337
#, no-wrap
msgid ""
"3:  nan        2:  nan        2:  nan        2:  nan        1:  nan\n"
"2:  1          1:  1 / 0      1:  uinf       1:  uinf           .\n"
"1:  0              .              .              .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4339
#, no-wrap
msgid "  1 @key{RET} 0          /       m i    U /            17 n *         +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4359
msgid ""
"Dividing by zero normally is left unevaluated, but after @kbd{m i} it "
"instead gives an infinite result.  The answer is actually @code{uinf}, "
"``undirected infinity.'' If you look at a graph of @expr{1 / x} around "
"@w{@expr{x = 0}}, you'll see that it goes toward plus infinity as you "
"approach zero from above, but toward minus infinity as you approach from "
"below.  Since we said only @expr{1 / 0}, Calc knows that the answer is "
"infinite but not in which direction.  That's what @code{uinf} means.  Notice "
"that multiplying @code{uinf} by a negative number still leaves plain "
"@code{uinf}; there's no point in saying @samp{-uinf} because the sign of "
"@code{uinf} is unknown anyway.  Finally, we add @code{uinf} to our "
"@code{nan}, yielding @code{nan} again.  It's easy to see that, because "
"@code{nan} means ``totally unknown'' while @code{uinf} means ``unknown sign "
"but known to be infinite,'' the more mysterious @code{nan} wins out when it "
"is combined with @code{uinf}, or, for that matter, with anything else."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4365
msgid ""
"(@bullet{}) @strong{Exercise 2.} Predict what Calc will answer for each of "
"these formulas: @samp{inf / inf}, @samp{exp(inf)}, @samp{exp(-inf)}, "
"@samp{sqrt(-inf)}, @samp{sqrt(uinf)}, @samp{abs(uinf)}, @samp{ln(0)}.  "
"@xref{Types Answer 2, 2}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4370
msgid ""
"(@bullet{}) @strong{Exercise 3.} We saw that @samp{inf - inf = nan}, which "
"stands for an unknown value.  Can @code{nan} stand for a complex number? Can "
"it stand for infinity? @xref{Types Answer 3, 3}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4373
msgid "@dfn{HMS forms} represent a value in terms of hours, minutes, and seconds."
msgstr ""

#. type: group
#: ../../calc.texi:4379
#, no-wrap
msgid ""
"1:  2@@ 30' 0\"     1:  3@@ 30' 0\"     2:  3@@ 30' 0\"     1:  2.\n"
"    .                 .             1:  1@@ 45' 0.\"        .\n"
"                                        .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4381
#, no-wrap
msgid "  2@@ 30' @key{RET}          1 +               @key{RET} 2 /           /\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4386
msgid "HMS forms can also be used to hold angles in degrees, minutes, and seconds."
msgstr ""

#. type: group
#: ../../calc.texi:4391
#, no-wrap
msgid ""
"1:  0.5        1:  26.56505   1:  26@@ 33' 54.18\"    1:  0.44721\n"
"    .              .              .                     .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4393
#, no-wrap
msgid "    0.5            I T            c h                   S\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4400
msgid ""
"First we convert the inverse tangent of 0.5 to degrees-minutes-seconds form, "
"then we take the sine of that angle.  Note that the trigonometric functions "
"will accept HMS forms directly as input."
msgstr ""

#. type: cindex
#: ../../calc.texi:4401
#, no-wrap
msgid "Beatles"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4407
msgid ""
"(@bullet{}) @strong{Exercise 4.} The Beatles' @emph{Abbey Road} is 47 "
"minutes and 26 seconds long, and contains 17 songs.  What is the average "
"length of a song on @emph{Abbey Road}? If the Extended Disco Version of "
"@emph{Abbey Road} added 20 seconds to the length of each song, how long "
"would the album be? @xref{Types Answer 4, 4}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4411
msgid ""
"A @dfn{date form} represents a date, or a date and time.  Dates must be "
"entered using algebraic entry.  Date forms are surrounded by @samp{< >} "
"symbols; most standard formats for dates are recognized."
msgstr ""

#. type: group
#: ../../calc.texi:4417
#, no-wrap
msgid ""
"2:  <Sun Jan 13, 1991>                    1:  2.25\n"
"1:  <6:00pm Thu Jan 10, 1991>                 .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4419
#, no-wrap
msgid "' <13 Jan 1991>, <1/10/91, 6pm> @key{RET}           -\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4427
msgid ""
"In this example, we enter two dates, then subtract to find the number of "
"days between them.  It is also possible to add an HMS form or a number (of "
"days) to a date form to get another date form."
msgstr ""

#. type: group
#: ../../calc.texi:4432
#, no-wrap
msgid ""
"1:  <4:45:59pm Mon Jan 14, 1991>     1:  <2:50:59am Thu Jan 17, 1991>\n"
"    .                                    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4434
#, no-wrap
msgid "    t N                                  2 + 10@@ 5' +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4445
msgid ""
"The @kbd{t N} (``now'') command pushes the current date and time on the "
"stack; then we add two days, ten hours and five minutes to the date and "
"time.  Other date-and-time related commands include @kbd{t J}, which does "
"Julian day conversions, @kbd{t W}, which finds the beginning of the week in "
"which a date form lies, and @kbd{t I}, which increments a date by one or "
"several months.  @xref{Date Arithmetic}, for more."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4448
msgid ""
"(@bullet{}) @strong{Exercise 5.} How many days until the next Friday the "
"13th? @xref{Types Answer 5, 5}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4451
msgid ""
"(@bullet{}) @strong{Exercise 6.} How many leap years will there be between "
"now and the year 10001 AD@? @xref{Types Answer 6, 6}. (@bullet{})"
msgstr ""

#. type: cindex
#: ../../calc.texi:4452
#, no-wrap
msgid "Slope and angle of a line"
msgstr ""

#. type: cindex
#: ../../calc.texi:4453
#, no-wrap
msgid "Angle and slope of a line"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4460
msgid ""
"An @dfn{error form} represents a mean value with an attached standard "
"deviation, or error estimate.  Suppose our measurements indicate that a "
"certain telephone pole is about 30 meters away, with an estimated error of 1 "
"meter, and 8 meters tall, with an estimated error of 0.2 meters.  What is "
"the slope of a line from here to the top of the pole, and what is the "
"equivalent angle in degrees?"
msgstr ""

#. type: group
#: ../../calc.texi:4466
#, no-wrap
msgid ""
"1:  8 +/- 0.2    2:  8 +/- 0.2   1:  0.266 +/- 0.011   1:  14.93 +/- 0.594\n"
"    .            1:  30 +/- 1        .                     .\n"
"                     .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4468
#, no-wrap
msgid "    8 p .2 @key{RET}       30 p 1          /                     I T\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4475
msgid ""
"This means that the angle is about 15 degrees, and, assuming our original "
"error estimates were valid standard deviations, there is about a 60% chance "
"that the result is correct within 0.59 degrees."
msgstr ""

#. type: cindex
#: ../../calc.texi:4476
#, no-wrap
msgid "Torus, volume of"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4485
msgid ""
"(@bullet{}) @strong{Exercise 7.} The volume of a torus (a donut shape) is "
"@texline @math{2 \\pi^2 R r^2} @infoline @w{@expr{2 pi^2 R r^2}} where "
"@expr{R} is the radius of the circle that defines the center of the tube and "
"@expr{r} is the radius of the tube itself.  Suppose @expr{R} is 20 cm and "
"@expr{r} is 4 cm, each known to within 5 percent.  What is the volume and "
"the relative uncertainty of the volume? @xref{Types Answer 7, "
"7}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4491
msgid ""
"An @dfn{interval form} represents a range of values.  While an error form is "
"best for making statistical estimates, intervals give you exact bounds on an "
"answer.  Suppose we additionally know that our telephone pole is definitely "
"between 28 and 31 meters away, and that it is between 7.7 and 8.1 meters "
"tall."
msgstr ""

#. type: group
#: ../../calc.texi:4497
#, no-wrap
msgid ""
"1:  [7.7 .. 8.1]  2:  [7.7 .. 8.1]  1:  [0.24 .. 0.28]  1:  [13.9 .. 16.1]\n"
"    .             1:  [28 .. 31]        .                   .\n"
"                      .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4499
#, no-wrap
msgid "  [ 7.7 .. 8.1 ]    [ 28 .. 31 ]        /                   I T\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4505
msgid ""
"If our bounds were correct, then the angle to the top of the pole is sure to "
"lie in the range shown."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4513
msgid ""
"The square brackets around these intervals indicate that the endpoints "
"themselves are allowable values.  In other words, the distance to the "
"telephone pole is between 28 and 31, @emph{inclusive}.  You can also make an "
"interval that is exclusive of its endpoints by writing parentheses instead "
"of square brackets.  You can even make an interval which is inclusive "
"(``closed'') on one end and exclusive (``open'') on the other."
msgstr ""

#. type: group
#: ../../calc.texi:4519
#, no-wrap
msgid ""
"1:  [1 .. 10)    1:  (0.1 .. 1]   2:  (0.1 .. 1]   1:  (0.2 .. 3)\n"
"    .                .            1:  [2 .. 3)         .\n"
"                                      .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4521
#, no-wrap
msgid "  [ 1 .. 10 )        &              [ 2 .. 3 )         *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4529
msgid ""
"The Calculator automatically keeps track of which end values should be open "
"and which should be closed.  You can also make infinite or semi-infinite "
"intervals by using @samp{-inf} or @samp{inf} for one or both endpoints."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4535
msgid ""
"(@bullet{}) @strong{Exercise 8.} What answer would you expect from "
"@samp{@w{1 /} @w{(0 .. 10)}}? What about @samp{@w{1 /} @w{(-10 .. 0)}}? What "
"about @samp{@w{1 /} @w{[0 .. 10]}} (where the interval actually includes "
"zero)? What about @samp{@w{1 /} @w{(-10 .. 10)}}? @xref{Types Answer 8, "
"8}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4541
msgid ""
"(@bullet{}) @strong{Exercise 9.} Two easy ways of squaring a number are "
"@kbd{@key{RET} *} and @w{@kbd{2 ^}}.  Normally these produce the same "
"answer.  Would you expect this still to hold true for interval forms? If "
"not, which of these will result in a larger interval? @xref{Types Answer 9, "
"9}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4545
msgid ""
"A @dfn{modulo form} is used for performing arithmetic modulo @var{m}.  For "
"example, arithmetic involving time is generally done modulo 12 or 24 hours."
msgstr ""

#. type: group
#: ../../calc.texi:4550
#, no-wrap
msgid ""
"1:  17 mod 24    1:  3 mod 24     1:  21 mod 24    1:  9 mod 24\n"
"    .                .                .                .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4552
#, no-wrap
msgid "    17 M 24 @key{RET}      10 +             n                5 /\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4561
msgid ""
"In this last step, Calc has divided by 5 modulo 24; i.e., it has found a new "
"number which, when multiplied by 5 modulo 24, produces the original number, "
"21.  If @var{m} is prime and the divisor is not a multiple of @var{m}, it is "
"always possible to find such a number.  For non-prime @var{m} like 24, it is "
"only sometimes possible."
msgstr ""

#. type: group
#: ../../calc.texi:4566
#, no-wrap
msgid ""
"1:  10 mod 24    1:  16 mod 24    1:  1000000...   1:  16\n"
"    .                .                .                .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4568
#, no-wrap
msgid "    10 M 24 @key{RET}      100 ^            10 @key{RET} 100 ^     24 %\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4575
msgid ""
"These two calculations get the same answer, but the first one is much more "
"efficient because it avoids the huge intermediate value that arises in the "
"second one."
msgstr ""

#. type: cindex
#: ../../calc.texi:4576
#, no-wrap
msgid "Fermat, primality test of"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4587
msgid ""
"(@bullet{}) @strong{Exercise 10.} A theorem of Pierre de Fermat says that "
"@texline @math{x^{n-1} \\bmod n = 1} @infoline @expr{x^(n-1) mod n = 1} if "
"@expr{n} is a prime number and @expr{x} is an integer less than @expr{n}.  "
"If @expr{n} is @emph{not} a prime number, this will @emph{not} be true for "
"most values of @expr{x}.  Thus we can test informally if a number is prime "
"by trying this formula for several values of @expr{x}.  Use this test to "
"tell whether the following numbers are prime: 811749613, 15485863.  "
"@xref{Types Answer 10, 10}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4592
msgid ""
"It is possible to use HMS forms as parts of error forms, intervals, modulo "
"forms, or as the phase part of a polar complex number.  For example, the "
"@code{calc-time} command pushes the current time of day on the stack as an "
"HMS/modulo form."
msgstr ""

#. type: group
#: ../../calc.texi:4597
#, no-wrap
msgid ""
"1:  17@@ 34' 45\" mod 24@@ 0' 0\"     1:  6@@ 22' 15\" mod 24@@ 0' 0\"\n"
"    .                                 .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4599
#, no-wrap
msgid "    x time @key{RET}                        n\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4604
msgid "This calculation tells me it is six hours and 22 minutes until midnight."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4611
msgid ""
"(@bullet{}) @strong{Exercise 11.} A rule of thumb is that one year is about "
"@texline @math{\\pi \\times 10^7} @infoline @w{@expr{pi * 10^7}} seconds.  "
"What time will it be that many seconds from right now? @xref{Types Answer "
"11, 11}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4618
msgid ""
"(@bullet{}) @strong{Exercise 12.} You are preparing to order packaging for "
"the CD release of the Extended Disco Version of @emph{Abbey Road}.  You are "
"told that the songs will actually be anywhere from 20 to 60 seconds longer "
"than the originals.  One CD can hold about 75 minutes of music.  Should you "
"order single or double packages? @xref{Types Answer 12, 12}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4624
msgid ""
"Another kind of data the Calculator can manipulate is numbers with "
"@dfn{units}.  This isn't strictly a new data type; it's simply an "
"application of algebraic expressions, where we use variables with suggestive "
"names like @samp{cm} and @samp{in} to represent units like centimeters and "
"inches."
msgstr ""

#. type: group
#: ../../calc.texi:4629
#, no-wrap
msgid ""
"1:  2 in        1:  5.08 cm      1:  0.027778 fath   1:  0.0508 m\n"
"    .               .                .                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4631
#, no-wrap
msgid ""
"    ' 2in @key{RET}       u c cm @key{RET}       u c fath @key{RET}        u "
"b\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4639
msgid ""
"We enter the quantity ``2 inches'' (actually an algebraic expression which "
"means two times the variable @samp{in}), then we convert it first to "
"centimeters, then to fathoms, then finally to ``base'' units, which in this "
"case means meters."
msgstr ""

#. type: group
#: ../../calc.texi:4644
#, no-wrap
msgid ""
"1:  9 acre     1:  3 sqrt(acre)   1:  190.84 m   1:  190.84 m + 30 cm\n"
"    .              .                  .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4646
#, no-wrap
msgid ""
" ' 9 acre @key{RET}      Q                  u s            ' $+30 cm "
"@key{RET}\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4654
#, no-wrap
msgid ""
"1:  191.14 m     1:  36536.3046 m^2    1:  365363046 cm^2\n"
"    .                .                     .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4656
#, no-wrap
msgid "    u s              2 ^                   u c cgs\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4665
msgid ""
"Since units expressions are really just formulas, taking the square root of "
"@samp{acre} is undefined.  After all, @code{acre} might be an algebraic "
"variable that you will someday assign a value.  We use the "
"``units-simplify'' command to simplify the expression with variables being "
"interpreted as unit names."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4669
msgid ""
"In the final step, we have converted not to a particular unit, but to a "
"units system.  The ``cgs'' system uses centimeters instead of meters as its "
"standard unit of length."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4671
msgid "There is a wide variety of units defined in the Calculator."
msgstr ""

#. type: group
#: ../../calc.texi:4676
#, no-wrap
msgid ""
"1:  55 mph     1:  88.5139 kph   1:   88.5139 km / hr   1:  8.201407e-8 c\n"
"    .              .                  .                     .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4678
#, no-wrap
msgid ""
" ' 55 mph @key{RET}      u c kph @key{RET}        u c km/hr @key{RET}         "
"u c c @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4685
msgid ""
"We express a speed first in miles per hour, then in kilometers per hour, "
"then again using a slightly more explicit notation, then finally in terms of "
"fractions of the speed of light."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4692
msgid ""
"Temperature conversions are a bit more tricky.  There are two ways to "
"interpret ``20 degrees Fahrenheit''---it could mean an actual temperature, "
"or it could mean a change in temperature.  For normal units there is no "
"difference, but temperature units have an offset as well as a scale factor "
"and so there must be two explicit commands for them."
msgstr ""

#. type: group
#: ../../calc.texi:4697
#, no-wrap
msgid ""
"1:  20 degF       1:  11.1111 degC     1:  -6.666 degC\n"
"    .                 .                    .                 .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4699
#, no-wrap
msgid ""
"  ' 20 degF @key{RET}       u c degC @key{RET}         U u t degC "
"@key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4706
msgid ""
"First we convert a change of 20 degrees Fahrenheit into an equivalent change "
"in degrees Celsius (or Centigrade).  Then, we convert the absolute "
"temperature 20 degrees Fahrenheit into Celsius."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4711
msgid ""
"For simple unit conversions, you can put a plain number on the stack.  Then "
"@kbd{u c} and @kbd{u t} will prompt for both old and new units.  When you "
"use this method, you're responsible for remembering which numbers are in "
"which units:"
msgstr ""

#. type: group
#: ../../calc.texi:4716
#, no-wrap
msgid ""
"1:  55         1:  88.5139              1:  8.201407e-8\n"
"    .              .                        .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4718
#, no-wrap
msgid ""
"    55             u c mph @key{RET} kph @key{RET}      u c km/hr @key{RET} "
"c @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4724
msgid ""
"To see a complete list of built-in units, type @kbd{u v}.  Press @w{@kbd{C-x "
"* c}} again to re-enter the Calculator when you're done looking at the units "
"table."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4727
msgid ""
"(@bullet{}) @strong{Exercise 13.} How many seconds are there really in a "
"year? @xref{Types Answer 13, 13}. (@bullet{})"
msgstr ""

#. type: cindex
#: ../../calc.texi:4728
#, no-wrap
msgid "Speed of light"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4734
msgid ""
"(@bullet{}) @strong{Exercise 14.} Supercomputer designs are limited by the "
"speed of light (and of electricity, which is nearly as fast).  Suppose a "
"computer has a 4.1 ns (nanosecond) clock cycle, and its cabinet is one meter "
"across.  Is speed of light going to be a significant factor in its design? "
"@xref{Types Answer 14, 14}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4740
msgid ""
"(@bullet{}) @strong{Exercise 15.} Sam the Slug normally travels about five "
"yards in an hour.  He has obtained a supply of Power Pills; each Power Pill "
"he eats doubles his speed.  How many Power Pills can he swallow and still "
"travel legally on most US highways? @xref{Types Answer 15, 15}. (@bullet{})"
msgstr ""

#. type: section
#: ../../calc.texi:4742
#, no-wrap
msgid "Algebra and Calculus Tutorial"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4748
msgid ""
"This section shows how to use Calc's algebra facilities to solve equations, "
"do simple calculus problems, and manipulate algebraic formulas."
msgstr ""

#. type: menuentry
#: ../../calc.texi:4752
msgid "Basic Algebra Tutorial::"
msgstr ""

#. type: node
#: ../../calc.texi:4752 ../../calc.texi:4754 ../../calc.texi:5249
#, no-wrap
msgid "Rewrites Tutorial"
msgstr ""

#. type: node
#: ../../calc.texi:4754 ../../calc.texi:5249
#, no-wrap
msgid "Basic Algebra Tutorial"
msgstr ""

#. type: subsection
#: ../../calc.texi:4755
#, no-wrap
msgid "Basic Algebra"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4761
msgid ""
"If you enter a formula in Algebraic mode that refers to variables, the "
"formula itself is pushed onto the stack.  You can manipulate formulas as "
"regular data objects."
msgstr ""

#. type: group
#: ../../calc.texi:4766
#, no-wrap
msgid ""
"1:  2 x^2 - 6       1:  6 - 2 x^2       1:  (3 x^2 + y) (6 - 2 x^2)\n"
"    .                   .                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4768
#, no-wrap
msgid "    ' 2x^2-6 @key{RET}        n                   ' 3x^2+y @key{RET} *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4774
msgid ""
"(@bullet{}) @strong{Exercise 1.} Do @kbd{' x @key{RET} Q 2 ^} and @kbd{' x "
"@key{RET} 2 ^ Q} both wind up with the same result (@samp{x})? Why or why "
"not? @xref{Algebra Answer 1, 1}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4777
msgid ""
"There are also commands for doing common algebraic operations on formulas.  "
"Continuing with the formula from the last example,"
msgstr ""

#. type: group
#: ../../calc.texi:4782
#, no-wrap
msgid ""
"1:  18 x^2 - 6 x^4 + 6 y - 2 y x^2    1:  (18 - 2 y) x^2 - 6 x^4 + 6 y\n"
"    .                                     .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4784
#, no-wrap
msgid "    a x                                   a c x @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4790
msgid ""
"First we ``expand'' using the distributive law, then we ``collect'' terms "
"involving like powers of @expr{x}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4793
msgid ""
"Let's find the value of this expression when @expr{x} is 2 and @expr{y} is "
"one-half."
msgstr ""

#. type: group
#: ../../calc.texi:4798
#, no-wrap
msgid ""
"1:  17 x^2 - 6 x^4 + 3      1:  -25\n"
"    .                           .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4800
#, no-wrap
msgid "    1:2 s l y @key{RET}               2 s l x @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4809
msgid ""
"The @kbd{s l} command means ``let''; it takes a number from the top of the "
"stack and temporarily assigns it as the value of the variable you specify.  "
"It then evaluates (as if by the @kbd{=} key) the next expression on the "
"stack.  After this command, the variable goes back to its original value, if "
"any."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4814
msgid ""
"(An earlier exercise in this tutorial involved storing a value in the "
"variable @code{x}; if this value is still there, you will have to unstore it "
"with @kbd{s u x @key{RET}} before the above example will work properly.)"
msgstr ""

#. type: cindex
#: ../../calc.texi:4815
#, no-wrap
msgid "Maximum of a function using Calculus"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4822
msgid ""
"Let's find the maximum value of our original expression when @expr{y} is "
"one-half and @expr{x} ranges over all possible values.  We can do this by "
"taking the derivative with respect to @expr{x} and examining values of "
"@expr{x} for which the derivative is zero.  If the second derivative of the "
"function at that value of @expr{x} is negative, the function has a local "
"maximum there."
msgstr ""

#. type: group
#: ../../calc.texi:4827
#, no-wrap
msgid ""
"1:  17 x^2 - 6 x^4 + 3      1:  34 x - 24 x^3\n"
"    .                           .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4829
#, no-wrap
msgid "    U @key{DEL}  s 1                  a d x @key{RET}   s 2\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4835
msgid ""
"Well, the derivative is clearly zero when @expr{x} is zero.  To find the "
"other root(s), let's divide through by @expr{x} and then solve:"
msgstr ""

#. type: group
#: ../../calc.texi:4840
#, no-wrap
msgid ""
"1:  (34 x - 24 x^3) / x    1:  34 - 24 x^2\n"
"    .                          .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4842
#, no-wrap
msgid ""
"    ' x @key{RET} /                  a x\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4850
#, no-wrap
msgid ""
"1:  0.70588 x^2 = 1        1:  x = 1.19023\n"
"    .                          .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4852
#, no-wrap
msgid "    0 a =  s 3                 a S x @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4857
msgid "Now we compute the second derivative and plug in our values of @expr{x}:"
msgstr ""

#. type: group
#: ../../calc.texi:4863
#, no-wrap
msgid ""
"1:  1.19023        2:  1.19023         2:  1.19023\n"
"    .              1:  34 x - 24 x^3   1:  34 - 72 x^2\n"
"                       .                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4865
#, no-wrap
msgid "    a .                r 2                 a d x @key{RET} s 4\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4873
msgid ""
"(The @kbd{a .} command extracts just the righthand side of an equation.  "
"Another method would have been to use @kbd{v u} to unpack the equation "
"@w{@samp{x = 1.19}} to @samp{x} and @samp{1.19}, then use @kbd{M-- M-2 "
"@key{DEL}} to delete the @samp{x}.)"
msgstr ""

#. type: group
#: ../../calc.texi:4879
#, no-wrap
msgid ""
"2:  34 - 72 x^2   1:  -68.         2:  34 - 72 x^2     1:  34\n"
"1:  1.19023           .            1:  0                   .\n"
"    .                                  .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4881
#, no-wrap
msgid ""
"    @key{TAB}               s l x @key{RET}        U @key{DEL} 0             "
"s l x @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4888
msgid ""
"The first of these second derivatives is negative, so we know the function "
"has a maximum value at @expr{x = 1.19023}.  (The function also has a local "
"@emph{minimum} at @expr{x = 0}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4896
msgid ""
"When we solved for @expr{x}, we got only one value even though @expr{0.70588 "
"x^2 = 1} is a quadratic equation that ought to have two solutions.  The "
"reason is that @w{@kbd{a S}} normally returns a single ``principal'' "
"solution.  If it needs to come up with an arbitrary sign (as occurs in the "
"quadratic formula) it picks @expr{+}.  If it needs an arbitrary integer, it "
"picks zero.  We can get a full solution by pressing @kbd{H} (the Hyperbolic "
"flag) before @kbd{a S}."
msgstr ""

#. type: group
#: ../../calc.texi:4901
#, no-wrap
msgid ""
"1:  0.70588 x^2 = 1    1:  x = 1.19023 s1      1:  x = -1.19023\n"
"    .                      .                       .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4903
#, no-wrap
msgid ""
"    r 3                    H a S x @key{RET}  s 5        1 n  s l s1 "
"@key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4912
msgid ""
"Calc has invented the variable @samp{s1} to represent an unknown sign; it is "
"supposed to be either @mathit{+1} or @mathit{-1}.  Here we have used the "
"``let'' command to evaluate the expression when the sign is negative.  If we "
"plugged this into our second derivative we would get the same, negative, "
"answer, so @expr{x = -1.19023} is also a maximum."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4915
msgid ""
"To find the actual maximum value, we must plug our two values of @expr{x} "
"into the original formula."
msgstr ""

#. type: group
#: ../../calc.texi:4921
#, no-wrap
msgid ""
"2:  17 x^2 - 6 x^4 + 3    1:  24.08333 s1^2 - 12.04166 s1^4 + 3\n"
"1:  x = 1.19023 s1            .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4923
#, no-wrap
msgid "    r 1 r 5                   s l @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4930
msgid ""
"(Here we see another way to use @kbd{s l}; if its input is an equation with "
"a variable on the lefthand side, then @kbd{s l} treats the equation like an "
"assignment to that variable if you don't give a variable name.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4933
msgid ""
"It's clear that this will have the same value for either sign of @code{s1}, "
"but let's work it out anyway, just for the exercise:"
msgstr ""

#. type: group
#: ../../calc.texi:4939
#, no-wrap
msgid ""
"2:  [-1, 1]              1:  [15.04166, 15.04166]\n"
"1:  24.08333 s1^2 ...        .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4941
#, no-wrap
msgid "  [ 1 n , 1 ] @key{TAB}            V M $ @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4955
msgid ""
"Here we have used a vector mapping operation to evaluate the function at "
"several values of @samp{s1} at once.  @kbd{V M $} is like @kbd{V M '} except "
"that it takes the formula from the top of the stack.  The formula is "
"interpreted as a function to apply across the vector at the next-to-top "
"stack level.  Since a formula on the stack can't contain @samp{$} signs, "
"Calc assumes the variables in the formula stand for different arguments.  It "
"prompts you for an @dfn{argument list}, giving the list of all variables in "
"the formula in alphabetical order as the default list.  In this case the "
"default is @samp{(s1)}, which is just what we want so we simply press "
"@key{RET} at the prompt."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4958
msgid ""
"If there had been several different values, we could have used @w{@kbd{V R "
"X}} to find the global maximum."
msgstr ""

#. type: Plain text
#: ../../calc.texi:4967
msgid ""
"Calc has a built-in @kbd{a P} command that solves an equation using "
"@w{@kbd{H a S}} and returns a vector of all the solutions.  It simply "
"automates the job we just did by hand.  Applied to our original cubic "
"polynomial, it would produce the vector of solutions @expr{[1.19023, "
"-1.19023, 0]}.  (There is also an @kbd{a X} command which finds a local "
"maximum of a function.  It uses a numerical search method rather than "
"examining the derivatives, and thus requires you to provide some kind of "
"initial guess to show it where to look.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4974
msgid ""
"(@bullet{}) @strong{Exercise 2.} Given a vector of the roots of a polynomial "
"(such as the output of an @kbd{a P} command), what sequence of commands "
"would you use to reconstruct the original polynomial? (The answer will be "
"unique to within a constant multiple; choose the solution where the leading "
"coefficient is one.)  @xref{Algebra Answer 2, 2}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4979
msgid ""
"The @kbd{m s} command enables Symbolic mode, in which formulas like "
"@samp{sqrt(5)} that can't be evaluated exactly are left in symbolic form "
"rather than giving a floating-point approximate answer.  Fraction mode "
"(@kbd{m f}) is also useful when doing algebra."
msgstr ""

#. type: group
#: ../../calc.texi:4985
#, no-wrap
msgid ""
"2:  34 x - 24 x^3        2:  34 x - 24 x^3\n"
"1:  34 x - 24 x^3        1:  [sqrt(51) / 6, sqrt(51) / -6, 0]\n"
"    .                        .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:4987
#, no-wrap
msgid "    r 2  @key{RET}     m s  m f    a P x @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:4991
msgid "One more mode that makes reading formulas easier is Big mode."
msgstr ""

#. type: group
#: ../../calc.texi:4996
#, no-wrap
msgid ""
"               3\n"
"2:  34 x - 24 x\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5001
#, no-wrap
msgid ""
"      ____   ____\n"
"     V 51   V 51\n"
"1:  [-----, -----, 0]\n"
"       6     -6\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5003
#, no-wrap
msgid ""
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5005
#, no-wrap
msgid "    d B\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5012
msgid ""
"Here things like powers, square roots, and quotients and fractions are "
"displayed in a two-dimensional pictorial form.  Calc has other language "
"modes as well, such as C mode, FORTRAN mode, @TeX{} mode and @LaTeX{} mode."
msgstr ""

#. type: group
#: ../../calc.texi:5018
#, no-wrap
msgid ""
"2:  34*x - 24*pow(x, 3)               2:  34*x - 24*x**3\n"
"1:  @{sqrt(51) / 6, sqrt(51) / -6, 0@}  1:  /sqrt(51) / 6, sqrt(51) / -6, "
"0/\n"
"    .                                     .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5020
#, no-wrap
msgid ""
"    d C                                   d F\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5030
#, no-wrap
msgid ""
"3:  34 x - 24 x^3\n"
"2:  [@{\\sqrt@{51@} \\over 6@}, @{\\sqrt@{51@} \\over -6@}, 0]\n"
"1:  @{2 \\over 3@} \\sqrt@{5@}\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5032
#, no-wrap
msgid "    d T   ' 2 \\sqrt@{5@} \\over 3 @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5040
msgid ""
"As you can see, language modes affect both entry and display of formulas.  "
"They affect such things as the names used for built-in functions, the set of "
"arithmetic operators and their precedences, and notations for vectors and "
"matrices."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5046
msgid ""
"Notice that @samp{sqrt(51)} may cause problems with older implementations of "
"C and FORTRAN, which would require something more like @samp{sqrt(51.0)}.  "
"It is always wise to check over the formulas produced by the various "
"language modes to make sure they are fully correct."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5050
msgid ""
"Type @kbd{m s}, @kbd{m f}, and @kbd{d N} to reset these modes.  (You may "
"prefer to remain in Big mode, but all the examples in the tutorial are shown "
"in normal mode.)"
msgstr ""

#. type: cindex
#: ../../calc.texi:5051
#, no-wrap
msgid "Area under a curve"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5054
msgid ""
"What is the area under the portion of this curve from @expr{x = 1} to "
"@expr{2}? This is simply the integral of the function:"
msgstr ""

#. type: group
#: ../../calc.texi:5059
#, no-wrap
msgid ""
"1:  17 x^2 - 6 x^4 + 3     1:  5.6666 x^3 - 1.2 x^5 + 3 x\n"
"    .                          .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5061
#, no-wrap
msgid "    r 1                        a i x\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5067
msgid ""
"We want to evaluate this at our two values for @expr{x} and subtract.  One "
"way to do it is again with vector mapping and reduction:"
msgstr ""

#. type: group
#: ../../calc.texi:5072
#, no-wrap
msgid ""
"2:  [2, 1]            1:  [12.93333, 7.46666]    1:  5.46666\n"
"1:  5.6666 x^3 ...        .                          .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5074
#, no-wrap
msgid "   [ 2 , 1 ] @key{TAB}          V M $ @key{RET}                  V R -\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5084
msgid ""
"(@bullet{}) @strong{Exercise 3.} Find the integral from 1 to @expr{y} of "
"@texline @math{x \\sin \\pi x} @infoline @w{@expr{x sin(pi x)}} (where the "
"sine is calculated in radians).  Find the values of the integral for "
"integers @expr{y} from 1 to 5.  @xref{Algebra Answer 3, 3}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5094
msgid ""
"Calc's integrator can do many simple integrals symbolically, but many others "
"are beyond its capabilities.  Suppose we wish to find the area under the "
"curve @texline @math{\\sin x \\ln x} @infoline @expr{sin(x) ln(x)} over the "
"same range of @expr{x}.  If you entered this formula and typed @kbd{a i x "
"@key{RET}} (don't bother to try this), Calc would work for a long time but "
"would be unable to find a solution.  In fact, there is no closed-form "
"solution to this integral.  Now what do we do?"
msgstr ""

#. type: cindex
#: ../../calc.texi:5095
#, no-wrap
msgid "Integration, numerical"
msgstr ""

#. type: cindex
#: ../../calc.texi:5096
#, no-wrap
msgid "Numerical integration"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5101
msgid ""
"One approach would be to do the integral numerically.  It is not hard to do "
"this by hand using vector mapping and reduction.  It is rather slow, though, "
"since the sine and logarithm functions take a long time.  We can save some "
"time by reducing the working precision."
msgstr ""

#. type: group
#: ../../calc.texi:5108
#, no-wrap
msgid ""
"3:  10                  1:  [1, 1.1, 1.2,  ...  , 1.8, 1.9]\n"
"2:  1                       .\n"
"1:  0.1\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5110
#, no-wrap
msgid " 10 @key{RET} 1 @key{RET} .1 @key{RET}        C-u v x\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5116
msgid ""
"(Note that we have used the extended version of @kbd{v x}; we could also "
"have used plain @kbd{v x} as follows: @kbd{v x 10 @key{RET} 9 + .1 *}.)"
msgstr ""

#. type: group
#: ../../calc.texi:5122
#, no-wrap
msgid ""
"2:  [1, 1.1, ... ]              1:  [0., 0.084941, 0.16993, ... ]\n"
"1:  ln(x) sin(x)                    .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5124
#, no-wrap
msgid ""
"    ' sin(x) ln(x) @key{RET}  s 1    m r  p 5 @key{RET}   V M $ @key{RET}\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5132
#, no-wrap
msgid ""
"1:  3.4195     0.34195\n"
"    .          .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5134
#, no-wrap
msgid "    V R +      0.1 *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5140
msgid ""
"(If you got wildly different results, did you remember to switch to Radians "
"mode?)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5147
msgid ""
"Here we have divided the curve into ten segments of equal width; "
"approximating these segments as rectangular boxes (i.e., assuming the curve "
"is nearly flat at that resolution), we compute the areas of the boxes "
"(height times width), then sum the areas.  (It is faster to sum first, then "
"multiply by the width, since the width is the same for every box.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5150
msgid ""
"The true value of this integral turns out to be about 0.374, so we're not "
"doing too well.  Let's try another approach."
msgstr ""

#. type: group
#: ../../calc.texi:5155
#, no-wrap
msgid ""
"1:  ln(x) sin(x)    1:  0.84147 x + 0.11957 (x - 1)^2 - ...\n"
"    .                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5157
#, no-wrap
msgid "    r 1                 a t x=1 @key{RET} 4 @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5164
msgid ""
"Here we have computed the Taylor series expansion of the function about the "
"point @expr{x=1}.  We can now integrate this polynomial approximation, since "
"polynomials are easy to integrate."
msgstr ""

#. type: group
#: ../../calc.texi:5169
#, no-wrap
msgid ""
"1:  0.42074 x^2 + ...    1:  [-0.0446, -0.42073]      1:  0.3761\n"
"    .                        .                            .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5171
#, no-wrap
msgid ""
"    a i x @key{RET}            [ 2 , 1 ] @key{TAB}  V M $ @key{RET}         "
"V R -\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5181
msgid ""
"Better! By increasing the precision and/or asking for more terms in the "
"Taylor series, we can get a result as accurate as we like.  (Taylor series "
"converge better away from singularities in the function such as the one at "
"@code{ln(0)}, so it would also help to expand the series about the points "
"@expr{x=2} or @expr{x=1.5} instead of @expr{x=1}.)"
msgstr ""

#. type: menuentry
#: ../../calc.texi:5182 ../../calc.texi:6425
#, no-wrap
msgid "Simpson's rule"
msgstr ""

#. type: cindex
#: ../../calc.texi:5183
#, no-wrap
msgid "Integration by Simpson's rule"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5192
msgid ""
"(@bullet{}) @strong{Exercise 4.} Our first method approximated the curve by "
"stairsteps of width 0.1; the total area was then the sum of the areas of the "
"rectangles under these stairsteps.  Our second method approximated the "
"function by a polynomial, which turned out to be a better approximation than "
"stairsteps.  A third method is @dfn{Simpson's rule}, which is like the "
"stairstep method except that the steps are not required to be flat.  "
"Simpson's rule boils down to the formula,"
msgstr ""

#. type: example
#: ../../calc.texi:5197
#, no-wrap
msgid ""
"(h/3) * (f(a) + 4 f(a+h) + 2 f(a+2h) + 4 f(a+3h) + ...\n"
"              + 2 f(a+(n-2)*h) + 4 f(a+(n-1)*h) + f(a+n*h))\n"
msgstr ""

#. type: tex
#: ../../calc.texi:5206
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ \\displaylines{\n"
"      \\qquad {h \\over 3} (f(a) + 4 f(a+h) + 2 f(a+2h) + 4 f(a+3h) + "
"\\cdots\n"
"   \\hfill \\cr \\hfill    {} + 2 f(a+(n-2)h) + 4 f(a+(n-1)h) + f(a+n h)) "
"\\qquad\n"
"} $$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5213
msgid ""
"where @expr{n} (which must be even) is the number of slices and @expr{h} is "
"the width of each slice.  These are 10 and 0.1 in our example.  For "
"reference, here is the corresponding formula for the stairstep method:"
msgstr ""

#. type: example
#: ../../calc.texi:5218
#, no-wrap
msgid ""
"h * (f(a) + f(a+h) + f(a+2h) + f(a+3h) + ...\n"
"          + f(a+(n-2)*h) + f(a+(n-1)*h))\n"
msgstr ""

#. type: tex
#: ../../calc.texi:5225
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ h (f(a) + f(a+h) + f(a+2h) + f(a+3h) + \\cdots\n"
"           + f(a+(n-2)h) + f(a+(n-1)h)) $$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5232
msgid ""
"Compute the integral from 1 to 2 of @texline @math{\\sin x \\ln x} @infoline "
"@expr{sin(x) ln(x)} using Simpson's rule with 10 slices.  @xref{Algebra "
"Answer 4, 4}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5237
msgid ""
"Calc has a built-in @kbd{a I} command for doing numerical integration.  It "
"uses @dfn{Romberg's method}, which is a more sophisticated cousin of "
"Simpson's rule.  In particular, it knows how to keep refining the result "
"until the current precision is satisfied."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5245
msgid ""
"Aside from the commands we've seen so far, Calc also provides a large set of "
"commands for operating on parts of formulas.  You indicate the desired "
"sub-formula by placing the cursor on any part of the formula before giving a "
"@dfn{selection} command.  Selections won't be covered in the tutorial; "
"@pxref{Selecting Subformulas}, for details and examples."
msgstr ""

#. type: node
#: ../../calc.texi:5250 ../../calc.texi:21545 ../../calc.texi:25610 ../../calc.texi:25988 ../../calc.texi:25989 ../../calc.texi:26030 ../../calc.texi:26096 ../../calc.texi:26140 ../../calc.texi:26223 ../../calc.texi:26562 ../../calc.texi:26964 ../../calc.texi:27133 ../../calc.texi:27217 ../../calc.texi:27338 ../../calc.texi:27411 ../../calc.texi:27463 ../../calc.texi:27637 ../../calc.texi:27657
#, no-wrap
msgid "Rewrite Rules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5257
msgid ""
"No matter how many built-in commands Calc provided for doing algebra, there "
"would always be something you wanted to do that Calc didn't have in its "
"repertoire.  So Calc also provides a @dfn{rewrite rule} system that you can "
"use to define your own algebraic manipulations."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5259
msgid "Suppose we want to simplify this trigonometric formula:"
msgstr ""

#. type: group
#: ../../calc.texi:5264
#, no-wrap
msgid ""
"1:  2 sec(x)^2 / tan(x)^2 - 2 / tan(x)^2\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5266
#, no-wrap
msgid "    ' 2sec(x)^2/tan(x)^2 - 2/tan(x)^2 @key{RET}   s 1\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5273
msgid ""
"If we were simplifying this by hand, we'd probably combine over the common "
"denominator.  The @kbd{a n} algebra command will do this, but we'll do it "
"with a rewrite rule just for practice."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5275
msgid "Rewrite rules are written with the @samp{:=} symbol."
msgstr ""

#. type: group
#: ../../calc.texi:5280
#, no-wrap
msgid ""
"1:  (2 sec(x)^2 - 2) / tan(x)^2\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5282
#, no-wrap
msgid "    a r a/x + b/x := (a+b)/x @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5290
msgid ""
"(The ``assignment operator'' @samp{:=} has several uses in Calc.  All by "
"itself the formula @samp{a/x + b/x := (a+b)/x} doesn't do anything, but when "
"it is given to the @kbd{a r} command, that command interprets it as a "
"rewrite rule.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5299
msgid ""
"The lefthand side, @samp{a/x + b/x}, is called the @dfn{pattern} of the "
"rewrite rule.  Calc searches the formula on the stack for parts that match "
"the pattern.  Variables in a rewrite pattern are called "
"@dfn{meta-variables}, and when matching the pattern each meta-variable can "
"match any sub-formula.  Here, the meta-variable @samp{a} matched the "
"expression @samp{2 sec(x)^2}, the meta-variable @samp{b} matched the "
"constant @samp{-2} and the meta-variable @samp{x} matched the expression "
"@samp{tan(x)^2}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5305
msgid ""
"This rule points out several interesting features of rewrite patterns.  "
"First, if a meta-variable appears several times in a pattern, it must match "
"the same thing everywhere.  This rule detects common denominators because "
"the same meta-variable @samp{x} is used in both of the denominators."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5310
msgid ""
"Second, meta-variable names are independent from variables in the target "
"formula.  Notice that the meta-variable @samp{x} here matches the subformula "
"@samp{tan(x)^2}; Calc never confuses the two meanings of @samp{x}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5315
msgid ""
"And third, rewrite patterns know a little bit about the algebraic properties "
"of formulas.  The pattern called for a sum of two quotients; Calc was able "
"to match a difference of two quotients by matching @samp{a = 2 sec(x)^2}, "
"@samp{b = -2}, and @samp{x = tan(x)^2}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5320
msgid ""
"When the pattern part of a rewrite rule matches a part of the formula, that "
"part is replaced by the righthand side with all the meta-variables "
"substituted with the things they matched.  So the result is @samp{(2 "
"sec(x)^2 - 2) / tan(x)^2}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5327
msgid ""
"We could just as easily have written @samp{a/x - b/x := (a-b)/x} for the "
"rule.  It would have worked just the same in all cases.  (If we really "
"wanted the rule to apply only to @samp{+} or only to @samp{-}, we could have "
"used the @code{plain} symbol.  @xref{Algebraic Properties of Rewrite Rules}, "
"for some examples of this.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5335
msgid ""
"One more rewrite will complete the job.  We want to use the identity "
"@samp{tan(x)^2 + 1 = sec(x)^2}, but of course we must first rearrange the "
"identity in a way that matches our formula.  The obvious rule would be "
"@samp{@w{2 sec(x)^2 - 2} := 2 tan(x)^2}, but a little thought shows that the "
"rule @samp{sec(x)^2 := 1 + tan(x)^2} will also work.  The latter rule has a "
"more general pattern so it will work in many other situations, too."
msgstr ""

#. type: group
#: ../../calc.texi:5340
#, no-wrap
msgid ""
"1:  2\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5342
#, no-wrap
msgid "    a r sec(x)^2 := 1 + tan(x)^2 @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5353
msgid ""
"You may ask, what's the point of using the most general rule if you have to "
"type it in every time anyway? The answer is that Calc allows you to store a "
"rewrite rule in a variable, then give the variable name in the @kbd{a r} "
"command.  In fact, this is the preferred way to use rewrites.  For one, if "
"you need a rule once you'll most likely need it again later.  Also, if the "
"rule doesn't work quite right you can simply Undo, edit the variable, and "
"run the rule again without having to retype it."
msgstr ""

#. type: group
#: ../../calc.texi:5358
#, no-wrap
msgid ""
"' a/x + b/x := (a+b)/x @key{RET}          s t merge @key{RET}\n"
"' sec(x)^2 := 1 + tan(x)^2 @key{RET}      s t secsqr @key{RET}\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5361
#, no-wrap
msgid ""
"1:  2 sec(x)^2 / tan(x)^2 - 2 / tan(x)^2    1:  2\n"
"    .                                  .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5363
#, no-wrap
msgid "    r 1                  a r merge @key{RET}  a r secsqr @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5370
msgid ""
"To edit a variable, type @kbd{s e} and the variable name, use regular Emacs "
"editing commands as necessary, then type @kbd{C-c C-c} to store the edited "
"value back into the variable.  You can also use @w{@kbd{s e}} to create a "
"new variable if you wish."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5379
msgid ""
"Notice that the first time you use each rule, Calc puts up a ``compiling'' "
"message briefly.  The pattern matcher converts rules into a special "
"optimized pattern-matching language rather than using them directly.  This "
"allows @kbd{a r} to apply even rather complicated rules very efficiently.  "
"If the rule is stored in a variable, Calc compiles it only once and stores "
"the compiled form along with the variable.  That's another good reason to "
"store your rules in variables rather than entering them on the fly."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5386
msgid ""
"(@bullet{}) @strong{Exercise 1.} Type @kbd{m s} to get Symbolic mode, then "
"enter the formula @samp{@w{(2 + sqrt(2))} / @w{(1 + sqrt(2))}}.  Using a "
"rewrite rule, simplify this formula by multiplying the top and bottom by the "
"conjugate @w{@samp{1 - sqrt(2)}}.  The result will have to be expanded by "
"the distributive law; do this with another rewrite.  @xref{Rewrites Answer "
"1, 1}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5389
msgid ""
"The @kbd{a r} command can also accept a vector of rewrite rules, or a "
"variable containing a vector of rules."
msgstr ""

#. type: group
#: ../../calc.texi:5394
#, no-wrap
msgid ""
"1:  [merge, secsqr]          1:  [a/x + b/x := (a + b)/x, ... ]\n"
"    .                                 .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5396
#, no-wrap
msgid ""
"    ' [merge,sinsqr] @key{RET}          =\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5404
#, no-wrap
msgid ""
"1:  2 sec(x)^2 / tan(x)^2 - 2 / tan(x)^2     1:  2\n"
"    .                                 .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5406
#, no-wrap
msgid "    s t trig @key{RET}  r 1                  a r trig @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5415
msgid ""
"Calc tries all the rules you give against all parts of the formula, "
"repeating until no further change is possible.  (The exact order in which "
"things are tried is rather complex, but for simple rules like the ones we've "
"used here the order doesn't really matter.  @xref{Nested Formulas with "
"Rewrite Rules}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5420
msgid ""
"Calc actually repeats only up to 100 times, just in case your rule set has "
"gotten into an infinite loop.  You can give a numeric prefix argument to "
"@kbd{a r} to specify any limit.  In particular, @kbd{M-1 a r} does only one "
"rewrite at a time."
msgstr ""

#. type: group
#: ../../calc.texi:5425
#, no-wrap
msgid ""
"1:  (2 sec(x)^2 - 2) / tan(x)^2         1:  2\n"
"    .                                       .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5427
#, no-wrap
msgid "    r 1  M-1 a r trig @key{RET}                   M-1 a r trig @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5432
msgid ""
"You can type @kbd{M-0 a r} if you want no limit at all on the number of "
"rewrites that occur."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5435
msgid ""
"Rewrite rules can also be @dfn{conditional}.  Simply follow the rule with a "
"@samp{::} symbol and the desired condition.  For example,"
msgstr ""

#. type: group
#: ../../calc.texi:5440
#, no-wrap
msgid ""
"1:  sin(x + 2 pi) + sin(x + 3 pi) + sin(x + 4 pi)\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5442
#, no-wrap
msgid ""
"    ' sin(x+2pi) + sin(x+3pi) + sin(x+4pi) @key{RET}\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5450
#, no-wrap
msgid ""
"1:  sin(x + 3 pi) + 2 sin(x)\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5452
#, no-wrap
msgid "    a r sin(a + k pi) := sin(a) :: k % 2 = 0 @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5458
msgid ""
"(Recall, @samp{k % 2} is the remainder from dividing @samp{k} by 2, which "
"will be zero only when @samp{k} is an even integer.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5467
msgid ""
"An interesting point is that the variable @samp{pi} was matched literally "
"rather than acting as a meta-variable.  This is because it is a "
"special-constant variable.  The special constants @samp{e}, @samp{i}, "
"@samp{phi}, and so on also match literally.  A common error with rewrite "
"rules is to write, say, @samp{f(a,b,c,d,e) := g(a+b+c+d+e)}, expecting to "
"match any @samp{f} with five arguments but in fact matching only when the "
"fifth argument is literally @samp{e}!"
msgstr ""

#. type: cindex
#: ../../calc.texi:5468 ../../calc.texi:5872
#, no-wrap
msgid "Fibonacci numbers"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5478
msgid ""
"@tindex fib Rewrite rules provide an interesting way to define your own "
"functions.  Suppose we want to define @samp{fib(n)} to produce the @var{n}th "
"Fibonacci number.  The first two Fibonacci numbers are each 1; later numbers "
"are formed by summing the two preceding numbers in the sequence.  This is "
"easy to express in a set of three rules:"
msgstr ""

#. type: group
#: ../../calc.texi:5482
#, no-wrap
msgid ""
"' [fib(1) := 1, fib(2) := 1, fib(n) := fib(n-1) + fib(n-2)] @key{RET}  s t "
"fib\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5485
#, no-wrap
msgid ""
"1:  fib(7)               1:  13\n"
"    .                        .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5487
#, no-wrap
msgid "    ' fib(7) @key{RET}             a r fib @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5495
msgid ""
"One thing that is guaranteed about the order that rewrites are tried is "
"that, for any given subformula, earlier rules in the rule set will be tried "
"for that subformula before later ones.  So even though the first and third "
"rules both match @samp{fib(1)}, we know the first will be used "
"preferentially."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5503
msgid ""
"This rule set has one dangerous bug: Suppose we apply it to the formula "
"@samp{fib(x)}? (Don't actually try this.)  The third rule will match "
"@samp{fib(x)} and replace it with @w{@samp{fib(x-1) + fib(x-2)}}.  Each of "
"these will then be replaced to get @samp{fib(x-2) + 2 fib(x-3) + fib(x-4)}, "
"and so on, expanding forever.  What we really want is to apply the third "
"rule only when @samp{n} is an integer greater than two.  Type @w{@kbd{s e "
"fib @key{RET}}}, then edit the third rule to:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:5506
#, no-wrap
msgid "fib(n) := fib(n-1) + fib(n-2) :: integer(n) :: n > 2\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5510
msgid "Now:"
msgstr ""

#. type: group
#: ../../calc.texi:5515
#, no-wrap
msgid ""
"1:  fib(6) + fib(x) + fib(0)      1:  fib(x) + fib(0) + 8\n"
"    .                                 .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5517
#, no-wrap
msgid "    ' fib(6)+fib(x)+fib(0) @key{RET}        a r fib @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5526
msgid ""
"We've created a new function, @code{fib}, and a new command, @w{@kbd{a r fib "
"@key{RET}}}, which means ``evaluate all @code{fib} calls in this formula.'' "
"To make things easier still, we can tell Calc to apply these rules "
"automatically by storing them in the special variable @code{EvalRules}."
msgstr ""

#. type: group
#: ../../calc.texi:5531
#, no-wrap
msgid ""
"1:  [fib(1) := ...]    .                1:  [8, 13]\n"
"    .                                       .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5533
#, no-wrap
msgid ""
"    s r fib @key{RET}        s t EvalRules @key{RET}    ' [fib(6), fib(7)] "
"@key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5539
msgid ""
"It turns out that this rule set has the problem that it does far more work "
"than it needs to when @samp{n} is large.  Consider the first few steps of "
"the computation of @samp{fib(6)}:"
msgstr ""

#. type: group
#: ../../calc.texi:5546
#, no-wrap
msgid ""
"fib(6) =\n"
"fib(5)              +               fib(4) =\n"
"fib(4)     +      fib(3)     +      fib(3)     +      fib(2) =\n"
"fib(3) + fib(2) + fib(2) + fib(1) + fib(2) + fib(1) + 1 = ...\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5556
msgid ""
"Note that @samp{fib(3)} appears three times here.  Unless Calc's algebraic "
"simplifier notices the multiple @samp{fib(3)}s and combines them (and, as it "
"happens, it doesn't), this rule set does lots of needless recomputation.  To "
"cure the problem, type @code{s e EvalRules} to edit the rules (or just "
"@kbd{s E}, a shorthand command for editing @code{EvalRules}) and add another "
"condition:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:5559
#, no-wrap
msgid "fib(n) := fib(n-1) + fib(n-2) :: integer(n) :: n > 2 :: remember\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5568
msgid ""
"If a @samp{:: remember} condition appears anywhere in a rule, then if that "
"rule succeeds Calc will add another rule that describes that match to the "
"front of the rule set.  (Remembering works in any rule set, but for "
"technical reasons it is most effective in @code{EvalRules}.)  For example, "
"if the rule rewrites @samp{fib(7)} to something that evaluates to 13, then "
"the rule @samp{fib(7) := 13} will be added to the rule set."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5571
msgid ""
"Type @kbd{' fib(8) @key{RET}} to compute the eighth Fibonacci number, then "
"type @kbd{s E} again to see what has happened to the rule set."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5577
msgid ""
"With the @code{remember} feature, our rule set can now compute "
"@samp{fib(@var{n})} in just @var{n} steps.  In the process it builds up a "
"table of all Fibonacci numbers up to @var{n}.  After we have computed the "
"result for a particular @var{n}, we can get it back (and the results for all "
"smaller @var{n}) later in just one step."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5581
msgid ""
"All Calc operations will run somewhat slower whenever @code{EvalRules} "
"contains any rules.  You should type @kbd{s u EvalRules @key{RET}} now to "
"un-store the variable."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5591
msgid ""
"(@bullet{}) @strong{Exercise 2.} Sometimes it is possible to reformulate a "
"problem to reduce the amount of recursion necessary to solve it.  Create a "
"rule that, in about @var{n} simple steps and without recourse to the "
"@code{remember} option, replaces @samp{fib(@var{n}, 1, 1)} with @samp{fib(1, "
"@var{x}, @var{y})} where @var{x} and @var{y} are the @var{n}th and "
"@var{n+1}st Fibonacci numbers, respectively.  This rule is rather clunky to "
"use, so add a couple more rules to make the ``user interface'' the same as "
"for our first version: enter @samp{fib(@var{n})}, get back a plain number.  "
"@xref{Rewrites Answer 2, 2}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5596
msgid ""
"There are many more things that rewrites can do.  For example, there are "
"@samp{&&&} and @samp{|||} pattern operators that create ``and'' and ``or'' "
"combinations of rules.  As one really simple example, we could combine our "
"first two Fibonacci rules thusly:"
msgstr ""

#. type: example
#: ../../calc.texi:5599
#, no-wrap
msgid "[fib(1 ||| 2) := 1, fib(n) := ... ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5604
msgid "That means ``@code{fib} of something matching either 1 or 2 rewrites to 1.''"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5610
msgid ""
"You can also make meta-variables optional by enclosing them in @code{opt}.  "
"For example, the pattern @samp{a + b x} matches @samp{2 + 3 x} but not "
"@samp{2 + x} or @samp{3 x} or @samp{x}.  The pattern @samp{opt(a) + opt(b) "
"x} matches all of these forms, filling in a default of zero for @samp{a} and "
"one for @samp{b}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5615
msgid ""
"(@bullet{}) @strong{Exercise 3.} Your friend Joe had @samp{2 + 3 x} on the "
"stack and tried to use the rule @samp{opt(a) + opt(b) x := f(a, b, x)}.  "
"What happened? @xref{Rewrites Answer 3, 3}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5630
msgid ""
"(@bullet{}) @strong{Exercise 4.} Starting with a positive integer @expr{a}, "
"divide @expr{a} by two if it is even, otherwise compute @expr{3 a + 1}.  Now "
"repeat this step over and over.  A famous unproved conjecture is that for "
"any starting @expr{a}, the sequence always eventually reaches 1.  Given the "
"formula @samp{seq(@var{a}, 0)}, write a set of rules that convert this into "
"@samp{seq(1, @var{n})} where @var{n} is the number of steps it took the "
"sequence to reach the value 1.  Now enhance the rules to accept "
"@samp{seq(@var{a})} as a starting configuration, and to stop with just the "
"number @var{n} by itself.  Now make the result be a vector of values in the "
"sequence, from @var{a} to 1.  (The formula @samp{@var{x}|@var{y}} appends "
"the vectors @var{x} and @var{y}.)  For example, rewriting @samp{seq(6)} "
"should yield the vector @expr{[6, 3, 10, 5, 16, 8, 4, 2, 1]}.  "
"@xref{Rewrites Answer 4, 4}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5637
msgid ""
"(@bullet{}) @strong{Exercise 5.} Define, using rewrite rules, a function "
"@samp{nterms(@var{x})} that returns the number of terms in the sum @var{x}, "
"or 1 if @var{x} is not a sum.  (A @dfn{sum} for our purposes is one or more "
"non-sum terms separated by @samp{+} or @samp{-} signs, so that @expr{2 - 3 "
"(x + y) + x y} is a sum of three terms.)  @xref{Rewrites Answer 5, "
"5}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5641
msgid ""
"(@bullet{}) @strong{Exercise 6.} A Taylor series for a function is an "
"infinite series that exactly equals the value of that function at values of "
"@expr{x} near zero."
msgstr ""

#. type: example
#: ../../calc.texi:5645
#, no-wrap
msgid "cos(x) = 1 - x^2 / 2! + x^4 / 4! - x^6 / 6! + ...\n"
msgstr ""

#. type: tex
#: ../../calc.texi:5651
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ \\cos x = 1 - {x^2 \\over 2!} + {x^4 \\over 4!} - {x^6 \\over 6!} + "
"\\cdots $$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5658
msgid ""
"The @kbd{a t} command produces a @dfn{truncated Taylor series} which is "
"obtained by dropping all the terms higher than, say, @expr{x^2}.  Calc "
"represents the truncated Taylor series as a polynomial in @expr{x}.  "
"Mathematicians often write a truncated series using a ``big-O'' notation "
"that records what was the lowest term that was truncated."
msgstr ""

#. type: example
#: ../../calc.texi:5662
#, no-wrap
msgid "cos(x) = 1 - x^2 / 2! + O(x^3)\n"
msgstr ""

#. type: tex
#: ../../calc.texi:5668
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ \\cos x = 1 - {x^2 \\over 2!} + O(x^3) $$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5673
msgid ""
"The meaning of @expr{O(x^3)} is ``a quantity which is negligibly small if "
"@expr{x^3} is considered negligibly small as @expr{x} goes to zero.''"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5683
msgid ""
"The exercise is to create rewrite rules that simplify sums and products of "
"power series represented as @samp{@var{polynomial} + O(@var{var}^@var{n})}.  "
"For example, given @samp{1 - x^2 / 2 + O(x^3)} and @samp{x - x^3 / 6 + "
"O(x^4)} on the stack, we want to be able to type @kbd{*} and get the result "
"@samp{x - 2:3 x^3 + O(x^4)}.  Don't worry if the terms of the sum are "
"rearranged.  (This one is rather tricky; the solution at the end of this "
"chapter uses 6 rewrite rules.  Hint: The @samp{constant(x)} condition tests "
"whether @samp{x} is a number.)  @xref{Rewrites Answer 6, 6}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5687
msgid ""
"Just for kicks, try adding the rule @code{2+3 := 6} to @code{EvalRules}.  "
"What happens? (Be sure to remove this rule afterward, or you might get a "
"nasty surprise when you use Calc to balance your checkbook!)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5689
msgid "@xref{Rewrite Rules}, for the whole story on rewrite rules."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5700
msgid ""
"The Calculator is written entirely in Emacs Lisp, a highly extensible "
"language.  If you know Lisp, you can program the Calculator to do anything "
"you like.  Rewrite rules also work as a powerful programming system.  But "
"Lisp and rewrite rules take a while to master, and often all you want to do "
"is define a new function or repeat a command a few times.  Calc has features "
"that allow you to do these things easily."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5706
msgid ""
"One very limited form of programming is defining your own functions.  Calc's "
"@kbd{Z F} command allows you to define a function name and key sequence to "
"correspond to any formula.  Programming commands use the shift-@kbd{Z} "
"prefix; the user commands they create use the lower case @kbd{z} prefix."
msgstr ""

#. type: group
#: ../../calc.texi:5711
#, no-wrap
msgid ""
"1:  x + x^2 / 2 + x^3 / 6 + 1         1:  x + x^2 / 2 + x^3 / 6 + 1\n"
"    .                                     .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5713
#, no-wrap
msgid ""
"    ' 1 + x + x^2/2! + x^3/3! @key{RET}         Z F e myexp @key{RET} "
"@key{RET} @key{RET} y\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5724
msgid ""
"This polynomial is a Taylor series approximation to @samp{exp(x)}.  The "
"@kbd{Z F} command asks a number of questions.  The above answers say that "
"the key sequence for our function should be @kbd{z e}; the @kbd{M-x} "
"equivalent should be @code{calc-myexp}; the name of the function in "
"algebraic formulas should also be @code{myexp}; the default argument list "
"@samp{(x)} is acceptable; and finally @kbd{y} answers the question ``leave "
"it in symbolic form for non-constant arguments?''"
msgstr ""

#. type: group
#: ../../calc.texi:5731
#, no-wrap
msgid ""
"1:  1.3495     2:  1.3495     3:  1.3495\n"
"    .          1:  1.34986    2:  1.34986\n"
"                   .          1:  myexp(a + 1)\n"
"                                  .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5733
#, no-wrap
msgid "    .3 z e         .3 E           ' a+1 @key{RET} z e\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5744
msgid ""
"First we call our new @code{exp} approximation with 0.3 as an argument, and "
"compare it with the true @code{exp} function.  Then we note that, as "
"requested, if we try to give @kbd{z e} an argument that isn't a plain "
"number, it leaves the @code{myexp} function call in symbolic form.  If we "
"had answered @kbd{n} to the final question, @samp{myexp(a + 1)} would have "
"evaluated by plugging in @samp{a + 1} for @samp{x} in the defining formula."
msgstr ""

#. type: cindex
#: ../../calc.texi:5745
#, no-wrap
msgid "Sine integral Si(x)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5766
msgid ""
"@tindex Si (@bullet{}) @strong{Exercise 1.} The ``sine integral'' function "
"@texline @math{{\\rm Si}(x)} @infoline @expr{Si(x)} is defined as the "
"integral of @samp{sin(t)/t} for @expr{t = 0} to @expr{x} in radians.  (It "
"was invented because this integral has no solution in terms of basic "
"functions; if you give it to Calc's @kbd{a i} command, it will ponder it for "
"a long time and then give up.)  We can use the numerical integration "
"command, however, which in algebraic notation is written like "
"@samp{ninteg(f(t), t, 0, x)} with any integrand @samp{f(t)}.  Define a "
"@kbd{z s} command and @code{Si} function that implement this.  You will need "
"to edit the default argument list a bit.  As a test, @samp{Si(1)} should "
"return 0.946083. (If you don't get this answer, you might want to check that "
"Calc is in Radians mode.  Also, @code{ninteg} will run a lot faster if you "
"reduce the precision to, say, six digits beforehand.)  @xref{Programming "
"Answer 1, 1}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5772
msgid ""
"The simplest way to do real ``programming'' of Emacs is to define a "
"@dfn{keyboard macro}.  A keyboard macro is simply a sequence of keystrokes "
"which Emacs has stored away and can play back on demand.  For example, if "
"you find yourself typing @kbd{H a S x @key{RET}} often, you may wish to "
"program a keyboard macro to type this for you."
msgstr ""

#. type: group
#: ../../calc.texi:5777
#, no-wrap
msgid ""
"1:  y = sqrt(x)          1:  x = y^2\n"
"    .                        .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5779
#, no-wrap
msgid ""
"    ' y=sqrt(x) @key{RET}       C-x ( H a S x @key{RET} C-x )\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5782
#, no-wrap
msgid ""
"1:  y = cos(x)           1:  x = s1 arccos(y) + 2 n1 pi\n"
"    .                        .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5784
#, no-wrap
msgid "    ' y=cos(x) @key{RET}           X\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5793
msgid ""
"When you type @kbd{C-x (}, Emacs begins recording.  But it is also still "
"ready to execute your keystrokes, so you're really ``training'' Emacs by "
"walking it through the procedure once.  When you type @w{@kbd{C-x )}}, the "
"macro is recorded.  You can now type @kbd{X} to re-execute the same "
"keystrokes."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5795
msgid "You can give a name to your macro by typing @kbd{Z K}."
msgstr ""

#. type: group
#: ../../calc.texi:5800
#, no-wrap
msgid ""
"1:  .              1:  y = x^4         1:  x = s2 sqrt(s1 sqrt(y))\n"
"                       .                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5802
#, no-wrap
msgid "  Z K x @key{RET}            ' y=x^4 @key{RET}         z x\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5808
msgid ""
"Notice that we use shift-@kbd{Z} to define the command, and lower-case "
"@kbd{z} to call it up."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5810
msgid "Keyboard macros can call other macros."
msgstr ""

#. type: group
#: ../../calc.texi:5815
#, no-wrap
msgid ""
"1:  abs(x)        1:  x = s1 y                1:  2 / x    1:  x = 2 / y\n"
"    .                 .                           .            .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5817
#, no-wrap
msgid ""
" ' abs(x) @key{RET}   C-x ( ' y @key{RET} a = z x C-x )    ' 2/x @key{RET}       "
"X\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5823
msgid ""
"(@bullet{}) @strong{Exercise 2.} Define a keyboard macro to negate the item "
"in level 3 of the stack, without disturbing the rest of the stack.  "
"@xref{Programming Answer 2, 2}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5826
msgid ""
"(@bullet{}) @strong{Exercise 3.} Define keyboard macros to compute the "
"following functions:"
msgstr ""

#. type: enumerate
#: ../../calc.texi:5833
msgid ""
"Compute @texline @math{\\displaystyle{\\sin x \\over x}}, @infoline "
"@expr{sin(x) / x}, where @expr{x} is the number on the top of the stack."
msgstr ""

#. type: enumerate
#: ../../calc.texi:5837
msgid ""
"Compute the base-@expr{b} logarithm, just like the @kbd{B} key except the "
"arguments are taken in the opposite order."
msgstr ""

#. type: enumerate
#: ../../calc.texi:5841
msgid "Produce a vector of integers from 1 to the integer on the top of the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5844
msgid "@xref{Programming Answer 3, 3}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5848
msgid ""
"(@bullet{}) @strong{Exercise 4.} Define a keyboard macro to compute the "
"average (mean) value of a list of numbers.  @xref{Programming Answer 4, "
"4}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5852
msgid ""
"In many programs, some of the steps must execute several times.  Calc has "
"@dfn{looping} commands that allow this.  Loops are useful inside keyboard "
"macros, but actually work at any time."
msgstr ""

#. type: group
#: ../../calc.texi:5858
#, no-wrap
msgid ""
"1:  x^6          2:  x^6        1: 360 x^2\n"
"    .            1:  4             .\n"
"                     .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5860
#, no-wrap
msgid "  ' x^6 @key{RET}          4         Z < a d x @key{RET} Z >\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5868
msgid ""
"Here we have computed the fourth derivative of @expr{x^6} by enclosing a "
"derivative command in a ``repeat loop'' structure.  This structure pops a "
"repeat count from the stack, then executes the body of the loop that many "
"times."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5871
msgid ""
"If you make a mistake while entering the body of the loop, type @w{@kbd{Z "
"C-g}} to cancel the loop command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5874
msgid "Here's another example:"
msgstr ""

#. type: group
#: ../../calc.texi:5881
#, no-wrap
msgid ""
"3:  1               2:  10946\n"
"2:  1               1:  17711\n"
"1:  20                  .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5883
#, no-wrap
msgid "1 @key{RET} @key{RET} 20       Z < @key{TAB} C-j + Z >\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5891
msgid ""
"The numbers in levels 2 and 1 should be the 21st and 22nd Fibonacci numbers, "
"respectively.  (To see what's going on, try a few repetitions of the loop "
"body by hand; @kbd{C-j}, also on the Line-Feed or @key{LFD} key if you have "
"one, makes a copy of the number in level 2.)"
msgstr ""

#. type: cindex
#: ../../calc.texi:5892 ../../calc.texi:18269
#, no-wrap
msgid "Golden ratio"
msgstr ""

#. type: cindex
#: ../../calc.texi:5893 ../../calc.texi:18268
#, no-wrap
msgid "Phi, golden ratio"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5906
msgid ""
"A fascinating property of the Fibonacci numbers is that the @expr{n}th "
"Fibonacci number can be found directly by computing @texline @math{\\phi^n / "
"\\sqrt{5}} @infoline @expr{phi^n / sqrt(5)} and then rounding to the nearest "
"integer, where @texline @math{\\phi} (``phi''), @infoline @expr{phi}, the "
"``golden ratio,'' is @texline @math{(1 + \\sqrt{5}) / 2}.  @infoline "
"@expr{(1 + sqrt(5)) / 2}.  (For convenience, this constant is available from "
"the @code{phi} variable, or the @kbd{I H P} command.)"
msgstr ""

#. type: group
#: ../../calc.texi:5911
#, no-wrap
msgid ""
"1:  1.61803         1:  24476.0000409    1:  10945.9999817    1:  10946\n"
"    .                   .                    .                    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5913
#, no-wrap
msgid "    I H P               21 ^                 5 Q /                R\n"
msgstr ""

#. type: cindex
#: ../../calc.texi:5916
#, no-wrap
msgid "Continued fractions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5933
msgid ""
"(@bullet{}) @strong{Exercise 5.} The @dfn{continued fraction} representation "
"of @texline @math{\\phi} @infoline @expr{phi} is @texline @math{1 + 1/(1 + "
"1/(1 + 1/( \\ldots )))}.  @infoline @expr{1 + 1/(1 + 1/(1 + 1/( ...@: )))}.  "
"We can compute an approximate value by carrying this however far and then "
"replacing the innermost @texline @math{1/( \\ldots )} @infoline @expr{1/( "
"...@: )} by 1.  Approximate @texline @math{\\phi} @infoline @expr{phi} using "
"a twenty-term continued fraction.  @xref{Programming Answer 5, "
"5}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5941
msgid ""
"(@bullet{}) @strong{Exercise 6.} Linear recurrences like the one for "
"Fibonacci numbers can be expressed in terms of matrices.  Given a vector "
"@w{@expr{[a, b]}} determine a matrix which, when multiplied by this vector, "
"produces the vector @expr{[b, c]}, where @expr{a}, @expr{b} and @expr{c} are "
"three successive Fibonacci numbers.  Now write a program that, given an "
"integer @expr{n}, computes the @expr{n}th Fibonacci number using matrix "
"arithmetic.  @xref{Programming Answer 6, 6}. (@bullet{})"
msgstr ""

#. type: cindex
#: ../../calc.texi:5942
#, no-wrap
msgid "Harmonic numbers"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5946
msgid ""
"A more sophisticated kind of loop is the @dfn{for} loop.  Suppose we wish to "
"compute the 20th ``harmonic'' number, which is equal to the sum of the "
"reciprocals of the integers from 1 to 20."
msgstr ""

#. type: group
#: ../../calc.texi:5953
#, no-wrap
msgid ""
"3:  0               1:  3.597739\n"
"2:  1                   .\n"
"1:  20\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5955
#, no-wrap
msgid "0 @key{RET} 1 @key{RET} 20         Z ( & + 1 Z )\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5966
msgid ""
"The ``for'' loop pops two numbers, the lower and upper limits, then repeats "
"the body of the loop as an internal counter increases from the lower limit "
"to the upper one.  Just before executing the loop body, it pushes the "
"current loop counter.  When the loop body finishes, it pops the ``step,'' "
"i.e., the amount by which to increment the loop counter.  As you can see, "
"our loop always uses a step of one."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5970
msgid ""
"This harmonic number function uses the stack to hold the running total as "
"well as for the various loop housekeeping functions.  If you find this "
"disorienting, you can sum in a variable instead:"
msgstr ""

#. type: group
#: ../../calc.texi:5976
#, no-wrap
msgid ""
"1:  0         2:  1                  .            1:  3.597739\n"
"    .         1:  20                                  .\n"
"                  .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:5978
#, no-wrap
msgid "    0 t 7       1 @key{RET} 20      Z ( & s + 7 1 Z )       r 7\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5984
msgid ""
"The @kbd{s +} command adds the top-of-stack into the value in a variable "
"(and removes that value from the stack)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:5992
msgid ""
"It's worth noting that many jobs that call for a ``for'' loop can also be "
"done more easily by Calc's high-level operations.  Two other ways to compute "
"harmonic numbers are to use vector mapping and reduction (@kbd{v x 20}, then "
"@w{@kbd{V M &}}, then @kbd{V R +}), or to use the summation command @kbd{a "
"+}.  Both of these are probably easier than using loops.  However, there are "
"some situations where loops really are the way to go:"
msgstr ""

#. type: Plain text
#: ../../calc.texi:5996
msgid ""
"(@bullet{}) @strong{Exercise 7.} Use a ``for'' loop to find the first "
"harmonic number which is greater than 4.0.  @xref{Programming Answer 7, "
"7}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6001
msgid ""
"Of course, if we're going to be using variables in our programs, we have to "
"worry about the programs clobbering values that the caller was keeping in "
"those same variables.  This is easy to fix, though:"
msgstr ""

#. type: group
#: ../../calc.texi:6008
#, no-wrap
msgid ""
"    .        1:  0.6667       1:  0.6667     3:  0.6667\n"
"                 .                .          2:  3.597739\n"
"                                             1:  0.6667\n"
"                                                 .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6010
#, no-wrap
msgid ""
"   Z `    p 4 @key{RET} 2 @key{RET} 3 /   s 7 s s a @key{RET}    Z '  r 7 s "
"r a @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6023
msgid ""
"When we type @kbd{Z `} (that's a grave accent), Calc saves its mode settings "
"and the contents of the ten ``quick variables'' for later reference.  When "
"we type @kbd{Z '} (that's an apostrophe now), Calc restores those saved "
"values.  Thus the @kbd{p 4} and @kbd{s 7} commands have no effect outside "
"this sequence.  Wrapping this around the body of a keyboard macro ensures "
"that it doesn't interfere with what the user of the macro was doing.  Notice "
"that the contents of the stack, and the values of named variables, survive "
"past the @kbd{Z '} command."
msgstr ""

#. type: cindex
#: ../../calc.texi:6024
#, no-wrap
msgid "Bernoulli numbers, approximate"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6035
msgid ""
"The @dfn{Bernoulli numbers} are a sequence with the interesting property "
"that all of the odd Bernoulli numbers are zero, and the even ones, while "
"difficult to compute, can be roughly approximated by the formula @texline "
"@math{\\displaystyle{2 n! \\over (2 \\pi)^n}}.  @infoline @expr{2 n!@: / (2 "
"pi)^n}.  Let's write a keyboard macro to compute (approximate) Bernoulli "
"numbers.  (Calc has a command, @kbd{k b}, to compute exact Bernoulli "
"numbers, but this command is very slow for large @expr{n} since the higher "
"Bernoulli numbers are very large fractions.)"
msgstr ""

#. type: group
#: ../../calc.texi:6040
#, no-wrap
msgid ""
"1:  10               1:  0.0756823\n"
"    .                    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6042
#, no-wrap
msgid ""
"    10     C-x ( @key{RET} 2 % Z [ @key{DEL} 0 Z : ' 2 $! / (2 pi)^$ "
"@key{RET} = Z ] C-x )\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6053
msgid ""
"You can read @kbd{Z [} as ``then,'' @kbd{Z :} as ``else,'' and @kbd{Z ]} as "
"``end-if.'' There is no need for an explicit ``if'' command.  For the "
"purposes of @w{@kbd{Z [}}, the condition is ``true'' if the value it pops "
"from the stack is a nonzero number, or ``false'' if it pops zero or "
"something that is not a number (like a formula).  Here we take our integer "
"argument modulo 2; this will be nonzero if we're asking for an odd Bernoulli "
"number."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6055
msgid "The actual tenth Bernoulli number is @expr{5/66}."
msgstr ""

#. type: group
#: ../../calc.texi:6062
#, no-wrap
msgid ""
"3:  0.0756823    1:  0          1:  0.25305    1:  0          1:  1.16659\n"
"2:  5:66             .              .              .              .\n"
"1:  0.0757575\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6064
#, no-wrap
msgid ""
"10 k b @key{RET} c f   M-0 @key{DEL} 11 X   @key{DEL} 12 X       @key{DEL} "
"13 X       @key{DEL} 14 X\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6069
msgid ""
"Just to exercise loops a bit more, let's compute a table of even Bernoulli "
"numbers."
msgstr ""

#. type: group
#: ../../calc.texi:6076
#, no-wrap
msgid ""
"3:  []             1:  [0.10132, 0.03079, 0.02340, 0.033197, ...]\n"
"2:  2                  .\n"
"1:  30\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6078
#, no-wrap
msgid " [ ] 2 @key{RET} 30          Z ( X | 2 Z )\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6089
msgid ""
"The vertical-bar @kbd{|} is the vector-concatenation command.  When we "
"execute it, the list we are building will be in stack level 2 (initially "
"this is an empty list), and the next Bernoulli number will be in level 1.  "
"The effect is to append the Bernoulli number onto the end of the list.  (To "
"create a table of exact fractional Bernoulli numbers, just replace @kbd{X} "
"with @kbd{k b} in the above sequence of keystrokes.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6095
msgid ""
"With loops and conditionals, you can program essentially anything in Calc.  "
"One other command that makes looping easier is @kbd{Z /}, which takes a "
"condition from the stack and breaks out of the enclosing loop if the "
"condition is true (non-zero).  You can use this to make ``while'' and "
"``until'' style loops."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6100
msgid ""
"If you make a mistake when entering a keyboard macro, you can edit it using "
"@kbd{Z E}.  First, you must attach it to a key with @kbd{Z K}.  One "
"technique is to enter a throwaway dummy definition for the macro, then enter "
"the real one in the edit command."
msgstr ""

#. type: group
#: ../../calc.texi:6105
#, no-wrap
msgid ""
"1:  3                   1:  3           Calc Macro Edit Mode.\n"
"    .                       .           Original keys: 1 <return> 2 +\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6110
#, no-wrap
msgid ""
"                                        1                          ;; calc "
"digits\n"
"                                        RET                        ;; "
"calc-enter\n"
"                                        2                          ;; calc "
"digits\n"
"                                        +                          ;; "
"calc-plus\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6112
#, no-wrap
msgid "C-x ( 1 @key{RET} 2 + C-x )    Z K h @key{RET}      Z E h\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6126
msgid ""
"A keyboard macro is stored as a pure keystroke sequence.  The @file{edmacro} "
"package (invoked by @kbd{Z E}) scans along the macro and tries to decode it "
"back into human-readable steps.  Descriptions of the keystrokes are given as "
"comments, which begin with @samp{;;}, and which are ignored when the edited "
"macro is saved.  Spaces and line breaks are also ignored when the edited "
"macro is saved.  To enter a space into the macro, type @code{SPC}.  All the "
"special characters @code{RET}, @code{LFD}, @code{TAB}, @code{SPC}, "
"@code{DEL}, and @code{NUL} must be written in all uppercase, as must the "
"prefixes @code{C-} and @code{M-}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6132
msgid ""
"Let's edit in a new definition, for computing harmonic numbers.  First, "
"erase the four lines of the old definition.  Then, type in the new "
"definition (or use Emacs @kbd{M-w} and @kbd{C-y} commands to copy it from "
"this page of the Info file; you can of course skip typing the comments, "
"which begin with @samp{;;})."
msgstr ""

#. type: smallexample
#: ../../calc.texi:6149
#, no-wrap
msgid ""
"Z`                      ;; calc-kbd-push     (Save local values)\n"
"0                       ;; calc digits       (Push a zero onto the stack)\n"
"st                      ;; calc-store-into   (Store it in the following "
"variable)\n"
"1                       ;; calc quick variable  (Quick variable q1)\n"
"1                       ;; calc digits       (Initial value for the loop)\n"
"TAB                     ;; calc-roll-down    (Swap initial and final)\n"
"Z(                      ;; calc-kbd-for      (Begin the \"for\" loop)\n"
"&                       ;; calc-inv          (Take the reciprocal)\n"
"s+                      ;; calc-store-plus   (Add to the following "
"variable)\n"
"1                       ;; calc quick variable  (Quick variable q1)\n"
"1                       ;; calc digits       (The loop step is 1)\n"
"Z)                      ;; calc-kbd-end-for  (End the \"for\" loop)\n"
"sr                      ;; calc-recall       (Recall the final accumulated "
"value)\n"
"1                       ;; calc quick variable (Quick variable q1)\n"
"Z'                      ;; calc-kbd-pop      (Restore values)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6153
msgid "Press @kbd{C-c C-c} to finish editing and return to the Calculator."
msgstr ""

#. type: group
#: ../../calc.texi:6158
#, no-wrap
msgid ""
"1:  20         1:  3.597739\n"
"    .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6160
#, no-wrap
msgid "    20             z h\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6170
msgid ""
"The @file{edmacro} package defines a handy @code{read-kbd-macro} command "
"which reads the current region of the current buffer as a sequence of "
"keystroke names, and defines that sequence on the @kbd{X} (and @kbd{C-x e}) "
"key.  Because this is so useful, Calc puts this command on the @kbd{C-x * m} "
"key.  Try reading in this macro in the following form: Press @kbd{C-@@} (or "
"@kbd{C-@key{SPC}}) at one end of the text below, then type @kbd{C-x * m} at "
"the other."
msgstr ""

#. type: group
#: ../../calc.texi:6178
#, no-wrap
msgid ""
"Z ` 0 t 1\n"
"    1 TAB\n"
"    Z (  & s + 1  1 Z )\n"
"    r 1\n"
"Z '\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6186
msgid ""
"(@bullet{}) @strong{Exercise 8.} A general algorithm for solving equations "
"numerically is @dfn{Newton's Method}.  Given the equation @expr{f(x) = 0} "
"for any function @expr{f}, and an initial guess @expr{x_0} which is "
"reasonably close to the desired solution, apply this formula over and over:"
msgstr ""

#. type: example
#: ../../calc.texi:6190
#, no-wrap
msgid "new_x = x - f(x)/f'(x)\n"
msgstr ""

#. type: tex
#: ../../calc.texi:6196
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ x_{\\rm new} = x - {f(x) \\over f^{\\prime}(x)} $$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6213
msgid ""
"where @expr{f'(x)} is the derivative of @expr{f}.  The @expr{x} values will "
"quickly converge to a solution, i.e., eventually @texline @math{x_{\\rm "
"new}} @infoline @expr{new_x} and @expr{x} will be equal to within the limits "
"of the current precision.  Write a program which takes a formula involving "
"the variable @expr{x}, and an initial guess @expr{x_0}, on the stack, and "
"produces a value of @expr{x} for which the formula is zero.  Use it to find "
"a solution of @texline @math{\\sin(\\cos x) = 0.5} @infoline "
"@expr{sin(cos(x)) = 0.5} near @expr{x = 4.5}.  (Use angles measured in "
"radians.)  Note that the built-in @w{@kbd{a R}} (@code{calc-find-root}) "
"command uses Newton's method when it is able.  @xref{Programming Answer 8, "
"8}. (@bullet{})"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6214 ../../calc.texi:6425
#, no-wrap
msgid "Digamma function"
msgstr ""

#. type: cindex
#: ../../calc.texi:6215 ../../calc.texi:18264
#, no-wrap
msgid "Gamma constant, Euler's"
msgstr ""

#. type: cindex
#: ../../calc.texi:6216 ../../calc.texi:18265
#, no-wrap
msgid "Euler's gamma constant"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6224
msgid ""
"(@bullet{}) @strong{Exercise 9.} The @dfn{digamma} function @texline "
"@math{\\psi(z) (``psi'')} @infoline @expr{psi(z)} is defined as the "
"derivative of @texline @math{\\ln \\Gamma(z)}.  @infoline "
"@expr{ln(gamma(z))}.  For large values of @expr{z}, it can be approximated "
"by the infinite sum"
msgstr ""

#. type: example
#: ../../calc.texi:6228
#, no-wrap
msgid "psi(z) ~= ln(z) - 1/2z - sum(bern(2 n) / 2 n z^(2 n), n, 1, inf)\n"
msgstr ""

#. type: tex
#: ../../calc.texi:6236
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ \\psi(z) \\approx \\ln z - {1\\over2z} -\n"
"   \\sum_{n=1}^\\infty {\\code{bern}(2 n) \\over 2 n z^{2n}}\n"
"$$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6273
msgid ""
"where @texline @math{\\sum} @infoline @expr{sum} represents the sum over "
"@expr{n} from 1 to infinity (or to some limit high enough to give the "
"desired accuracy), and the @code{bern} function produces (exact) Bernoulli "
"numbers.  While this sum is not guaranteed to converge, in practice it is "
"safe.  An interesting mathematical constant is Euler's gamma, which is equal "
"to about 0.5772.  One way to compute it is by the formula, @texline "
"@math{\\gamma = -\\psi(1)}.  @infoline @expr{gamma = -psi(1)}.  "
"Unfortunately, 1 isn't a large enough argument for the above formula to work "
"(5 is a much safer value for @expr{z}).  Fortunately, we can compute "
"@texline @math{\\psi(1)} @infoline @expr{psi(1)} from @texline "
"@math{\\psi(5)} @infoline @expr{psi(5)} using the recurrence @texline "
"@math{\\psi(z+1) = \\psi(z) + {1 \\over z}}.  @infoline @expr{psi(z+1) = "
"psi(z) + 1/z}.  Your task: Develop a program to compute @texline "
"@math{\\psi(z)}; @infoline @expr{psi(z)}; it should ``pump up'' @expr{z} if "
"necessary to be greater than 5, then use the above summation formula.  Use "
"looping commands to compute the sum.  Use your function to compute @texline "
"@math{\\gamma} @infoline @expr{gamma} to twelve decimal places.  (Calc has a "
"built-in command for Euler's constant, @kbd{I P}, which you can use to check "
"your answer.)  @xref{Programming Answer 9, 9}. (@bullet{})"
msgstr ""

#. type: cindex
#: ../../calc.texi:6274
#, no-wrap
msgid "Polynomial, list of coefficients"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6283
msgid ""
"(@bullet{}) @strong{Exercise 10.} Given a polynomial in @expr{x} and a "
"number @expr{m} on the stack, where the polynomial is of degree @expr{m} or "
"less (i.e., does not have any terms higher than @expr{x^m}), write a program "
"to convert the polynomial into a list-of-coefficients notation.  For "
"example, @expr{5 x^4 + (x + 1)^2} with @expr{m = 6} should produce the list "
"@expr{[1, 2, 1, 0, 5, 0, 0]}.  Also develop a way to convert from this form "
"back to the standard algebraic form.  @xref{Programming Answer 10, "
"10}. (@bullet{})"
msgstr ""

#. type: cindex
#: ../../calc.texi:6284
#, no-wrap
msgid "Recursion"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6287
msgid ""
"(@bullet{}) @strong{Exercise 11.} The @dfn{Stirling numbers of the first "
"kind} are defined by the recurrences,"
msgstr ""

#. type: example
#: ../../calc.texi:6293
#, no-wrap
msgid ""
"s(n,n) = 1   for n >= 0,\n"
"s(n,0) = 0   for n > 0,\n"
"s(n+1,m) = s(n,m-1) - n s(n,m)   for n >= m >= 1.\n"
msgstr ""

#. type: tex
#: ../../calc.texi:6305
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ \\eqalign{ s(n,n)   &= 1 \\qquad \\hbox{for } n \\ge 0,  \\cr\n"
"             s(n,0)   &= 0 \\qquad \\hbox{for } n > 0, \\cr\n"
"             s(n+1,m) &= s(n,m-1) - n \\, s(n,m) \\qquad\n"
"                          \\hbox{for } n \\ge m \\ge 1.}\n"
"$$\n"
"\\afterdisplay\n"
"\\vskip5pt\n"
"(These numbers are also sometimes written $\\displaystyle{n \\brack m}$.)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6325
msgid ""
"This can be implemented using a @dfn{recursive} program in Calc; the program "
"must invoke itself in order to calculate the two righthand terms in the "
"general formula.  Since it always invokes itself with ``simpler'' arguments, "
"it's easy to see that it must eventually finish the computation.  Recursion "
"is a little difficult with Emacs keyboard macros since the macro is executed "
"before its definition is complete.  So here's the recommended strategy: "
"Create a ``dummy macro'' and assign it to a key with, e.g., @kbd{Z K s}.  "
"Now enter the true definition, using the @kbd{z s} command to call itself "
"recursively, then assign it to the same key with @kbd{Z K s}.  Now the "
"@kbd{z s} command will run the complete recursive program.  (Another way is "
"to use @w{@kbd{Z E}} or @kbd{C-x * m} (@code{read-kbd-macro}) to read the "
"whole macro at once, thus avoiding the ``training'' phase.)  The task: Write "
"a program that computes Stirling numbers of the first kind, given @expr{n} "
"and @expr{m} on the stack.  Test it with @emph{small} inputs like "
"@expr{s(4,2)}.  (There is a built-in command for Stirling numbers, @kbd{k "
"s}, which you can use to check your answers.)  @xref{Programming Answer 11, "
"11}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6331
msgid ""
"The programming commands we've seen in this part of the tutorial are "
"low-level, general-purpose operations.  Often you will find that a "
"higher-level function, such as vector mapping or rewrite rules, will do the "
"job much more easily than a detailed, step-by-step program can:"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6336
msgid ""
"(@bullet{}) @strong{Exercise 12.} Write another program for computing "
"Stirling numbers of the first kind, this time using rewrite rules.  Once "
"again, @expr{n} and @expr{m} should be taken from the stack.  "
"@xref{Programming Answer 12, 12}. (@bullet{})"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6347
msgid ""
"This ends the tutorial section of the Calc manual.  Now you know enough "
"about Calc to use it effectively for many kinds of calculations.  But Calc "
"has many features that were not even touched upon in this tutorial.  The "
"rest of this manual tells the whole story."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6354
msgid "This section includes answers to all the exercises in the Calc tutorial."
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6436 ../../calc.texi:6446
#, no-wrap
msgid "RPN Answer 1"
msgstr ""

#. type: kbd{#1}
#: ../../calc.texi:6425 ../../calc.texi:6441
msgid "1 @key{RET} 2 @key{RET} 3 @key{RET} 4 + * -"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6436 ../../calc.texi:6446 ../../calc.texi:6503
#, no-wrap
msgid "RPN Answer 2"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "2*4 + 7*9.5 + 5/4"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6446 ../../calc.texi:6503 ../../calc.texi:6534
#, no-wrap
msgid "RPN Answer 3"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Operating on levels 2 and 3"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6503 ../../calc.texi:6534 ../../calc.texi:6572
#, no-wrap
msgid "RPN Answer 4"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Joe's complex problems"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6534 ../../calc.texi:6572 ../../calc.texi:6585
#, no-wrap
msgid "Algebraic Answer 1"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Simulating Q command"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6572 ../../calc.texi:6585 ../../calc.texi:6594
#, no-wrap
msgid "Algebraic Answer 2"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Joe's algebraic woes"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6585 ../../calc.texi:6594 ../../calc.texi:6611
#, no-wrap
msgid "Algebraic Answer 3"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "1 / 0"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6594 ../../calc.texi:6611 ../../calc.texi:6671
#, no-wrap
msgid "Modes Answer 1"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "3#0.1 = 3#0.0222222?"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6611 ../../calc.texi:6671 ../../calc.texi:6691
#, no-wrap
msgid "Modes Answer 2"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "16#f.e8fe15"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6671 ../../calc.texi:6691 ../../calc.texi:6733
#, no-wrap
msgid "Modes Answer 3"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Joe's rounding bug"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6691 ../../calc.texi:6733 ../../calc.texi:6754
#, no-wrap
msgid "Modes Answer 4"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Why floating point?"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6733 ../../calc.texi:6754 ../../calc.texi:6774
#, no-wrap
msgid "Arithmetic Answer 1"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Why the \\ command?"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6754 ../../calc.texi:6774 ../../calc.texi:6786
#, no-wrap
msgid "Arithmetic Answer 2"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Tripping up the B command"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6774 ../../calc.texi:6786 ../../calc.texi:6806
#, no-wrap
msgid "Vector Answer 1"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6786 ../../calc.texi:6806 ../../calc.texi:6815
#, no-wrap
msgid "Vector Answer 2"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Average position"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6806 ../../calc.texi:6815 ../../calc.texi:6822
#, no-wrap
msgid "Matrix Answer 1"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Row and column sums"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6815 ../../calc.texi:6822 ../../calc.texi:6868
#, no-wrap
msgid "Matrix Answer 2"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Symbolic system of equations"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6822 ../../calc.texi:6868 ../../calc.texi:6986
#, no-wrap
msgid "Matrix Answer 3"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Over-determined system"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6868 ../../calc.texi:6986 ../../calc.texi:7018
#, no-wrap
msgid "List Answer 1"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Powers of two"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:6986 ../../calc.texi:7018 ../../calc.texi:7101
#, no-wrap
msgid "List Answer 2"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Least-squares fit with matrices"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:7018 ../../calc.texi:7101 ../../calc.texi:7145
#, no-wrap
msgid "List Answer 3"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:7101 ../../calc.texi:7145 ../../calc.texi:7185
#, no-wrap
msgid "List Answer 4"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Divisor function"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:7145 ../../calc.texi:7185 ../../calc.texi:7224
#, no-wrap
msgid "List Answer 5"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Duplicate factors"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:7185 ../../calc.texi:7224 ../../calc.texi:7231
#, no-wrap
msgid "List Answer 6"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Triangular list"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:7224 ../../calc.texi:7231 ../../calc.texi:7304
#, no-wrap
msgid "List Answer 7"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Another triangular list"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:7231 ../../calc.texi:7304 ../../calc.texi:7393
#, no-wrap
msgid "List Answer 8"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Maximum of Bessel function"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:7304 ../../calc.texi:7393 ../../calc.texi:7515
#, no-wrap
msgid "List Answer 9"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Integers the hard way"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:7393 ../../calc.texi:7515 ../../calc.texi:7546
#, no-wrap
msgid "List Answer 10"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "All elements equal"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:7515 ../../calc.texi:7546 ../../calc.texi:7613
#, no-wrap
msgid "List Answer 11"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Estimating pi with darts"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:7546 ../../calc.texi:7613 ../../calc.texi:7724
#, no-wrap
msgid "List Answer 12"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Estimating pi with matchsticks"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:7613 ../../calc.texi:7724 ../../calc.texi:7864
#, no-wrap
msgid "List Answer 13"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Hash codes"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:7724 ../../calc.texi:7864 ../../calc.texi:7929
#, no-wrap
msgid "List Answer 14"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Random walk"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:7864 ../../calc.texi:7929 ../../calc.texi:7973
#, no-wrap
msgid "Types Answer 1"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Square root of pi times rational"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:7929 ../../calc.texi:7973 ../../calc.texi:8009
#, no-wrap
msgid "Types Answer 2"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:10649 ../../calc.texi:10687 ../../calc.texi:10688 ../../calc.texi:10774
#, no-wrap
msgid "Infinities"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:7973 ../../calc.texi:8009 ../../calc.texi:8031
#, no-wrap
msgid "Types Answer 3"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "What can \"nan\" be?"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8009 ../../calc.texi:8031 ../../calc.texi:8060
#, no-wrap
msgid "Types Answer 4"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Abbey Road"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8031 ../../calc.texi:8060 ../../calc.texi:8112
#, no-wrap
msgid "Types Answer 5"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Friday the 13th"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8060 ../../calc.texi:8112 ../../calc.texi:8158
#, no-wrap
msgid "Types Answer 6"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Leap years"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8112 ../../calc.texi:8158 ../../calc.texi:8203
#, no-wrap
msgid "Types Answer 7"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Erroneous donut"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8158 ../../calc.texi:8203 ../../calc.texi:8235
#, no-wrap
msgid "Types Answer 8"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Dividing intervals"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8203 ../../calc.texi:8235 ../../calc.texi:8259
#, no-wrap
msgid "Types Answer 9"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Squaring intervals"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8235 ../../calc.texi:8259 ../../calc.texi:8307
#, no-wrap
msgid "Types Answer 10"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Fermat's primality test"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8259 ../../calc.texi:8307 ../../calc.texi:8355
#, no-wrap
msgid "Types Answer 11"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "pi * 10^7 seconds"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8307 ../../calc.texi:8355 ../../calc.texi:8385
#, no-wrap
msgid "Types Answer 12"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Abbey Road on CD"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8355 ../../calc.texi:8385 ../../calc.texi:8391
#, no-wrap
msgid "Types Answer 13"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Not quite pi * 10^7 seconds"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8385 ../../calc.texi:8391 ../../calc.texi:8425
#, no-wrap
msgid "Types Answer 14"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Supercomputers and c"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8391 ../../calc.texi:8425 ../../calc.texi:8459
#, no-wrap
msgid "Types Answer 15"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Sam the Slug"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8425 ../../calc.texi:8459 ../../calc.texi:8471
#, no-wrap
msgid "Algebra Answer 1"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Squares and square roots"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8459 ../../calc.texi:8471 ../../calc.texi:8514
#, no-wrap
msgid "Algebra Answer 2"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Building polynomial from roots"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8471 ../../calc.texi:8514 ../../calc.texi:8577
#, no-wrap
msgid "Algebra Answer 3"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Integral of x sin(pi x)"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8514 ../../calc.texi:8577 ../../calc.texi:8647
#, no-wrap
msgid "Algebra Answer 4"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8577 ../../calc.texi:8647 ../../calc.texi:8699
#, no-wrap
msgid "Rewrites Answer 1"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Multiplying by conjugate"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8647 ../../calc.texi:8699 ../../calc.texi:8735
#, no-wrap
msgid "Rewrites Answer 2"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Alternative fib rule"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8699 ../../calc.texi:8735 ../../calc.texi:8757
#, no-wrap
msgid "Rewrites Answer 3"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Rewriting opt(a) + opt(b) x"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8735 ../../calc.texi:8757 ../../calc.texi:8830
#, no-wrap
msgid "Rewrites Answer 4"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Sequence of integers"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8757 ../../calc.texi:8830 ../../calc.texi:8854
#, no-wrap
msgid "Rewrites Answer 5"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Number of terms in sum"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8830 ../../calc.texi:8854 ../../calc.texi:8929
#, no-wrap
msgid "Rewrites Answer 6"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Truncated Taylor series"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8854 ../../calc.texi:8929 ../../calc.texi:8942
#, no-wrap
msgid "Programming Answer 1"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Fresnel's C(x)"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8929 ../../calc.texi:8942 ../../calc.texi:8959
#, no-wrap
msgid "Programming Answer 2"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Negate third stack element"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8942 ../../calc.texi:8959 ../../calc.texi:8995
#, no-wrap
msgid "Programming Answer 3"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Compute sin(x) / x, etc."
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8959 ../../calc.texi:8995 ../../calc.texi:9001
#, no-wrap
msgid "Programming Answer 4"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Average value of a list"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:8995 ../../calc.texi:9001 ../../calc.texi:9017
#, no-wrap
msgid "Programming Answer 5"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Continued fraction phi"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:9001 ../../calc.texi:9017 ../../calc.texi:9046
#, no-wrap
msgid "Programming Answer 6"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Matrix Fibonacci numbers"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:9017 ../../calc.texi:9046 ../../calc.texi:9087
#, no-wrap
msgid "Programming Answer 7"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Harmonic number greater than 4"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:9046 ../../calc.texi:9087 ../../calc.texi:9203
#, no-wrap
msgid "Programming Answer 8"
msgstr ""

#. type: cindex
#: ../../calc.texi:6425 ../../calc.texi:24181
#, no-wrap
msgid "Newton's method"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:9087 ../../calc.texi:9203 ../../calc.texi:9326
#, no-wrap
msgid "Programming Answer 9"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:9203 ../../calc.texi:9326 ../../calc.texi:9424
#, no-wrap
msgid "Programming Answer 10"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Unpacking a polynomial"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:9326 ../../calc.texi:9424 ../../calc.texi:9529
#, no-wrap
msgid "Programming Answer 11"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Recursive Stirling numbers"
msgstr ""

#. type: node
#: ../../calc.texi:6425 ../../calc.texi:9424 ../../calc.texi:9529
#, no-wrap
msgid "Programming Answer 12"
msgstr ""

#. type: menuentry
#: ../../calc.texi:6425
msgid "Stirling numbers with rewrites"
msgstr ""

#. type: tex
#: ../../calc.texi:6434
#, no-wrap
msgid ""
"\\global\\let\\oldwrite=\\write\n"
"\\gdef\\skipwrite#1#2{\\let\\write=\\oldwrite}\n"
"\\global\\let\\oldchapternofonts=\\chapternofonts\n"
"\\gdef\\chapternofonts{\\let\\write=\\skipwrite\\oldchapternofonts}\n"
msgstr ""

#. type: subsection
#: ../../calc.texi:6437
#, no-wrap
msgid "RPN Tutorial Exercise 1"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6445
msgid ""
"The result is @texline @math{1 - (2 \\times (3 + 4)) = -13}.  @infoline "
"@expr{1 - (2 * (3 + 4)) = -13}."
msgstr ""

#. type: subsection
#: ../../calc.texi:6447
#, no-wrap
msgid "RPN Tutorial Exercise 2"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6452
msgid ""
"@texline @math{2\\times4 + 7\\times9.5 + {5\\over4} = 75.75} @infoline "
"@expr{2*4 + 7*9.5 + 5/4 = 75.75}"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6459
msgid ""
"After computing the intermediate term @texline @math{2\\times4 = 8}, "
"@infoline @expr{2*4 = 8}, you can leave that result on the stack while you "
"compute the second term.  With both of these results waiting on the stack "
"you can then compute the final term, then press @kbd{+ +} to add everything "
"up."
msgstr ""

#. type: group
#: ../../calc.texi:6466
#, no-wrap
msgid ""
"2:  2          1:  8          3:  8          2:  8\n"
"1:  4              .          2:  7          1:  66.5\n"
"    .                         1:  9.5            .\n"
"                                  .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6468
#, no-wrap
msgid ""
"  2 @key{RET} 4          *          7 @key{RET} 9.5          *\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6479
#, no-wrap
msgid ""
"4:  8          3:  8          2:  8          1:  75.75\n"
"3:  66.5       2:  66.5       1:  67.75          .\n"
"2:  5          1:  1.25           .\n"
"1:  4              .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6481
#, no-wrap
msgid "  5 @key{RET} 4          /              +              +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6486
msgid ""
"Alternatively, you could add the first two terms before going on with the "
"third term."
msgstr ""

#. type: group
#: ../../calc.texi:6493
#, no-wrap
msgid ""
"2:  8          1:  74.5       3:  74.5       2:  74.5       1:  75.75\n"
"1:  66.5           .          2:  5          1:  1.25           .\n"
"    .                         1:  4              .\n"
"                                  .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6495
#, no-wrap
msgid "   ...             +            5 @key{RET} 4          /              +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6502
msgid ""
"On an old-style RPN calculator this second method would have the advantage "
"of using only three stack levels.  But since Calc's stack can grow "
"arbitrarily large this isn't really an issue.  Which method you choose is "
"purely a matter of taste."
msgstr ""

#. type: subsection
#: ../../calc.texi:6504
#, no-wrap
msgid "RPN Tutorial Exercise 3"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6508
msgid "The @key{TAB} key provides a way to operate on the number in level 2."
msgstr ""

#. type: group
#: ../../calc.texi:6516
#, no-wrap
msgid ""
"3:  10         3:  10         4:  10         3:  10         3:  10\n"
"2:  20         2:  30         3:  30         2:  30         2:  21\n"
"1:  30         1:  20         2:  20         1:  21         1:  30\n"
"    .              .          1:  1              .              .\n"
"                                  .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6518
#, no-wrap
msgid ""
"                  @key{TAB}             1              +             "
"@key{TAB}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6522
msgid "Similarly, @kbd{M-@key{TAB}} gives you access to the number in level 3."
msgstr ""

#. type: group
#: ../../calc.texi:6529
#, no-wrap
msgid ""
"3:  10         3:  21         3:  21         3:  30         3:  11\n"
"2:  21         2:  30         2:  30         2:  11         2:  21\n"
"1:  30         1:  10         1:  11         1:  21         1:  30\n"
"    .              .              .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6531
#, no-wrap
msgid ""
"                  M-@key{TAB}           1 +           M-@key{TAB}          "
"M-@key{TAB}\n"
msgstr ""

#. type: subsection
#: ../../calc.texi:6535
#, no-wrap
msgid "RPN Tutorial Exercise 4"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6540
msgid ""
"Either @kbd{( 2 , 3 )} or @kbd{( 2 @key{SPC} 3 )} would have worked, but "
"using both the comma and the space at once yields:"
msgstr ""

#. type: group
#: ../../calc.texi:6546
#, no-wrap
msgid ""
"1:  ( ...      2:  ( ...      1:  (2, ...    2:  (2, ...    2:  (2, ...\n"
"    .          1:  2              .          1:  (2, ...    1:  (2, 3)\n"
"                   .                             .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6548
#, no-wrap
msgid "    (              2              ,             @key{SPC}            3 )\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6556
msgid ""
"Joe probably tried to type @kbd{@key{TAB} @key{DEL}} to swap the extra "
"incomplete object to the top of the stack and delete it.  But a feature of "
"Calc is that @key{DEL} on an incomplete object deletes just one component "
"out of that object, so he had to press @key{DEL} twice to finish the job."
msgstr ""

#. type: group
#: ../../calc.texi:6562
#, no-wrap
msgid ""
"2:  (2, ...    2:  (2, 3)     2:  (2, 3)     1:  (2, 3)\n"
"1:  (2, 3)     1:  (2, ...    1:  ( ...          .\n"
"    .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6564
#, no-wrap
msgid "                  @key{TAB}            @key{DEL}            @key{DEL}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6571
msgid ""
"(As it turns out, deleting the second-to-top stack entry happens often "
"enough that Calc provides a special key, @kbd{M-@key{DEL}}, to do just "
"that.  @kbd{M-@key{DEL}} is just like @kbd{@key{TAB} @key{DEL}}, except that "
"it doesn't exhibit the ``feature'' that tripped poor Joe.)"
msgstr ""

#. type: subsection
#: ../../calc.texi:6573
#, no-wrap
msgid "Algebraic Entry Tutorial Exercise 1"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6577
msgid "Type @kbd{' sqrt($) @key{RET}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6580
msgid ""
"If the @kbd{Q} key is broken, you could use @kbd{' $^0.5 @key{RET}}.  Or, "
"RPN style, @kbd{0.5 ^}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6584
msgid ""
"(Actually, @samp{$^1:2}, using the fraction one-half as the power, is a "
"closer equivalent, since @samp{9^0.5} yields @expr{3.0} whereas "
"@samp{sqrt(9)} and @samp{9^1:2} yield the exact integer @expr{3}.)"
msgstr ""

#. type: subsection
#: ../../calc.texi:6586
#, no-wrap
msgid "Algebraic Entry Tutorial Exercise 2"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6593
msgid ""
"In the formula @samp{2 x (1+y)}, @samp{x} was interpreted as a function name "
"with @samp{1+y} as its argument.  Assigning a value to a variable has no "
"relation to a function by the same name.  Joe needed to use an explicit "
"@samp{*} symbol here: @samp{2 x*(1+y)}."
msgstr ""

#. type: subsection
#: ../../calc.texi:6595
#, no-wrap
msgid "Algebraic Entry Tutorial Exercise 3"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6603
msgid ""
"The result from @kbd{1 @key{RET} 0 /} will be the formula @expr{1 / 0}.  The "
"``function'' @samp{/} cannot be evaluated when its second argument is zero, "
"so it is left in symbolic form.  When you now type @kbd{0 *}, the result "
"will be zero because Calc uses the general rule that ``zero times anything "
"is zero.''"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6610
msgid ""
"The @kbd{m i} command enables an @dfn{Infinite mode} in which @expr{1 / 0} "
"results in a special symbol that represents ``infinity.'' If you multiply "
"infinity by zero, Calc uses another special new symbol to show that the "
"answer is ``indeterminate.'' @xref{Infinities}, for further discussion of "
"infinite and indeterminate values."
msgstr ""

#. type: subsection
#: ../../calc.texi:6612
#, no-wrap
msgid "Modes Tutorial Exercise 1"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6621
msgid ""
"Calc always stores its numbers in decimal, so even though one-third has an "
"exact base-3 representation (@samp{3#0.1}), it is still stored as 0.3333333 "
"(chopped off after 12 or however many decimal digits) inside the "
"calculator's memory.  When this inexact number is converted back to base 3 "
"for display, it may still be slightly inexact.  When we multiply this number "
"by 3, we get 0.999999, also an inexact value."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6633
msgid ""
"When Calc displays a number in base 3, it has to decide how many digits to "
"show.  If the current precision is 12 (decimal) digits, that corresponds to "
"@samp{12 / log10(3) = 25.15} base-3 digits.  Because 25.15 is not an exact "
"integer, Calc shows only 25 digits, with the result that stored numbers "
"carry a little bit of extra information that may not show up on the screen.  "
"When Joe entered @samp{3#0.2}, the stored number 0.666666 happened to round "
"to a pleasing value when it lost that last 0.15 of a digit, but it was still "
"inexact in Calc's memory.  When he divided by 2, he still got the dreaded "
"inexact value 0.333333.  (Actually, he divided 0.666667 by 2 to get "
"0.333334, which is why he got something a little higher than @code{3#0.1} "
"instead of a little lower.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6644
msgid ""
"If Joe didn't want to be bothered with all this, he could have typed "
"@kbd{M-24 d n} to display with one less digit than the default.  (If you "
"give @kbd{d n} a negative argument, it uses default-minus-that, so @kbd{M-- "
"d n} would be an easier way to get the same effect.)  Those inexact results "
"would still be lurking there, but they would now be rounded to nice, "
"natural-looking values for display purposes.  (Remember, @samp{0.022222} in "
"base 3 is like @samp{0.099999} in base 10; rounding off one digit will round "
"the number up to @samp{0.1}.)  Depending on the nature of your work, this "
"hiding of the inexactness may be a benefit or a danger.  With the @kbd{d n} "
"command, Calc gives you the choice."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6655
msgid ""
"Incidentally, another consequence of all this is that if you type @kbd{M-30 "
"d n} to display more digits than are ``really there,'' you'll see garbage "
"digits at the end of the number.  (In decimal display mode, with "
"decimally-stored numbers, these garbage digits are always zero so they "
"vanish and you don't notice them.)  Because Calc rounds off that 0.15 digit, "
"there is the danger that two numbers could be slightly different internally "
"but still look the same.  If you feel uneasy about this, set the @kbd{d n} "
"precision to be a little higher than normal; you'll get ugly garbage digits, "
"but you'll always be able to tell two distinct numbers apart."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6665
msgid ""
"An interesting side note is that most computers store their floating-point "
"numbers in binary, and convert to decimal for display.  Thus everyday "
"programs have the same problem: Decimal 0.1 cannot be represented exactly in "
"binary (try it: @kbd{0.1 d 2}), so @samp{0.1 * 10} comes out as an inexact "
"approximation to 1 on some machines (though they generally arrange to hide "
"it from you by rounding off one digit as we did above).  Because Calc works "
"in decimal instead of binary, you can be sure that numbers that look exact "
"@emph{are} exact as long as you stay in decimal display mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6670
msgid ""
"It's not hard to show that any number that can be represented exactly in "
"binary, octal, or hexadecimal is also exact in decimal, so the kinds of "
"problems we saw in this exercise are likely to be severe only when you use a "
"relatively unusual radix like 3."
msgstr ""

#. type: subsection
#: ../../calc.texi:6672
#, no-wrap
msgid "Modes Tutorial Exercise 2"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6682
msgid ""
"If the radix is 15 or higher, we can't use the letter @samp{e} to mark the "
"exponent because @samp{e} is interpreted as a digit.  When Calc needs to "
"display scientific notation in a high radix, it writes "
"@samp{16#F.E8F*16.^15}.  You can enter a number like this as an algebraic "
"entry.  Also, pressing @kbd{e} without any digits before it normally types "
"@kbd{1e}, but in a high radix it types @kbd{16.^} and puts you in algebraic "
"entry: @kbd{16#f.e8f @key{RET} e 15 @key{RET} *} is another way to enter "
"this number."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6690
msgid ""
"The reason Calc puts a decimal point in the @samp{16.^} is to prevent huge "
"integers from being generated if the exponent is large (consider "
"@samp{16#1.23*16^1000}, where we compute @samp{16^1000} as a giant exact "
"integer and then throw away most of the digits when we multiply it by the "
"floating-point @samp{16#1.23}).  While this wouldn't normally matter for "
"display purposes, it could give you a nasty surprise if you copied that "
"number into a file and later moved it back into Calc."
msgstr ""

#. type: subsection
#: ../../calc.texi:6692
#, no-wrap
msgid "Modes Tutorial Exercise 3"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6696
msgid "The answer he got was @expr{0.5000000000006399}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6701
msgid ""
"The problem is not that the square operation is inexact, but that the sine "
"of 45 that was already on the stack was accurate to only 12 places.  "
"Arbitrary-precision calculations still only give answers as good as their "
"inputs."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6707
msgid ""
"The real problem is that there is no 12-digit number which, when squared, "
"comes out to 0.5 exactly.  The @kbd{f [} and @kbd{f ]} commands decrease or "
"increase a number by one unit in the last place (according to the current "
"precision).  They are useful for determining facts like this."
msgstr ""

#. type: group
#: ../../calc.texi:6712
#, no-wrap
msgid ""
"1:  0.707106781187      1:  0.500000000001\n"
"    .                       .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6714
#, no-wrap
msgid ""
"    45 S                    2 ^\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6722
#, no-wrap
msgid ""
"1:  0.707106781187      1:  0.707106781186      1:  0.499999999999\n"
"    .                       .                       .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6724
#, no-wrap
msgid "    U  @key{DEL}                  f [                     2 ^\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6732
msgid ""
"A high-precision calculation must be carried out in high precision all the "
"way.  The only number in the original problem which was known exactly was "
"the quantity 45 degrees, so the precision must be raised before anything is "
"done after the number 45 has been entered in order for the higher precision "
"to be meaningful."
msgstr ""

#. type: subsection
#: ../../calc.texi:6734
#, no-wrap
msgid "Modes Tutorial Exercise 4"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6742
msgid ""
"Many calculations involve real-world quantities, like the width and height "
"of a piece of wood or the volume of a jar.  Such quantities can't be "
"measured exactly anyway, and if the data that is input to a calculation is "
"inexact, doing exact arithmetic on it is a waste of time."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6749
msgid ""
"Fractions become unwieldy after too many calculations have been done with "
"them.  For example, the sum of the reciprocals of the integers from 1 to 10 "
"is 7381:2520.  The sum from 1 to 30 is 9304682830147:2329089562800.  After a "
"point it will take a long time to add even one more term to this sum, but a "
"floating-point calculation of the sum will not have this problem."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6753
msgid ""
"Also, rational numbers cannot express the results of all calculations.  "
"There is no fractional form for the square root of two, so if you type "
"@w{@kbd{2 Q}}, Calc has no choice but to give you a floating-point answer."
msgstr ""

#. type: subsection
#: ../../calc.texi:6755
#, no-wrap
msgid "Arithmetic Tutorial Exercise 1"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6766
msgid ""
"Dividing two integers that are larger than the current precision may give a "
"floating-point result that is inaccurate even when rounded down to an "
"integer.  Consider @expr{123456789 / 2} when the current precision is 6 "
"digits.  The true answer is @expr{61728394.5}, but with a precision of 6 "
"this will be rounded to @texline @math{12345700.0/2.0 = 61728500.0}.  "
"@infoline @expr{12345700.@: / 2.@: = 61728500.}.  The result, when converted "
"to an integer, will be off by 106."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6773
msgid ""
"Here are two solutions: Raise the precision enough that the floating-point "
"round-off error is strictly to the right of the decimal point.  Or, convert "
"to Fraction mode so that @expr{123456789 / 2} produces the exact fraction "
"@expr{123456789:2}, which can be rounded down by the @kbd{F} command without "
"ever switching to floating-point format."
msgstr ""

#. type: subsection
#: ../../calc.texi:6775
#, no-wrap
msgid "Arithmetic Tutorial Exercise 2"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6780
msgid ""
"@kbd{27 @key{RET} 9 B} could give the exact result @expr{3:2}, but it does a "
"floating-point calculation instead and produces @expr{1.5}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6785
msgid ""
"Calc will find an exact result for a logarithm if the result is an integer "
"or (when in Fraction mode) the reciprocal of an integer.  But there is no "
"efficient way to search the space of all possible rational numbers for an "
"exact answer, so Calc doesn't try."
msgstr ""

#. type: subsection
#: ../../calc.texi:6787
#, no-wrap
msgid "Vector Tutorial Exercise 1"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6792
msgid ""
"Duplicate the vector, compute its length, then divide the vector by its "
"length: @kbd{@key{RET} A /}."
msgstr ""

#. type: group
#: ../../calc.texi:6798
#, no-wrap
msgid ""
"1:  [1, 2, 3]  2:  [1, 2, 3]      1:  [0.27, 0.53, 0.80]  1:  1.\n"
"    .          1:  3.74165738677      .                       .\n"
"                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6800
#, no-wrap
msgid "    r 1            @key{RET} A              /                       A\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6805
msgid ""
"The final @kbd{A} command shows that the normalized vector does indeed have "
"unit length."
msgstr ""

#. type: subsection
#: ../../calc.texi:6807
#, no-wrap
msgid "Vector Tutorial Exercise 2"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6814
msgid ""
"The average position is equal to the sum of the products of the positions "
"times their corresponding probabilities.  This is the definition of the dot "
"product operation.  So all you need to do is to put the two vectors on the "
"stack and press @kbd{*}."
msgstr ""

#. type: subsection
#: ../../calc.texi:6816
#, no-wrap
msgid "Matrix Tutorial Exercise 1"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6821
msgid ""
"The trick is to multiply by a vector of ones.  Use @kbd{r 4 [1 1 1] *} to "
"get the row sum.  Similarly, use @kbd{[1 1] r 4 *} to get the column sum."
msgstr ""

#. type: subsection
#: ../../calc.texi:6823
#, no-wrap
msgid "Matrix Tutorial Exercise 2"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6843
msgid ""
"Just enter the righthand side vector, then divide by the lefthand side "
"matrix as usual."
msgstr ""

#. type: group
#: ../../calc.texi:6850
#, no-wrap
msgid ""
"1:  [6, 10]    2:  [6, 10]         1:  [4 a / (a - b) + 6, 4 / (b - a) ]\n"
"    .          1:  [ [ 1, a ]          .\n"
"                     [ 1, b ] ]\n"
"                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6852
#, no-wrap
msgid "' [6 10] @key{RET}     ' [1 a; 1 b] @key{RET}      /\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6857
msgid "This can be made more readable using @kbd{d B} to enable Big display mode:"
msgstr ""

#. type: group
#: ../../calc.texi:6863
#, no-wrap
msgid ""
"      4 a         4\n"
"1:  [----- + 6, -----]\n"
"     a - b      b - a\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6867
msgid "Type @kbd{d N} to return to Normal display mode afterwards."
msgstr ""

#. type: subsection
#: ../../calc.texi:6869
#, no-wrap
msgid "Matrix Tutorial Exercise 3"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6885
msgid ""
"To solve @texline @math{A^T A \\, X = A^T B}, @infoline @expr{trn(A) * A * X "
"= trn(A) * B}, first we compute @texline @math{A' = A^T A} @infoline "
"@expr{A2 = trn(A) * A} and @texline @math{B' = A^T B}; @infoline @expr{B2 = "
"trn(A) * B}; now, we have a system @texline @math{A' X = B'} @infoline "
"@expr{A2 * X = B2} which we can solve using Calc's @samp{/} command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:6916
msgid ""
"The first step is to enter the coefficient matrix.  We'll store it in quick "
"variable number 7 for later reference.  Next, we compute the @texline "
"@math{B'} @infoline @expr{B2} vector."
msgstr ""

#. type: group
#: ../../calc.texi:6924
#, no-wrap
msgid ""
"1:  [ [ 1, 2, 3 ]             2:  [ [ 1, 4, 7, 2 ]     1:  [57, 84, 96]\n"
"      [ 4, 5, 6 ]                   [ 2, 5, 6, 4 ]         .\n"
"      [ 7, 6, 0 ]                   [ 3, 6, 0, 6 ] ]\n"
"      [ 2, 4, 6 ] ]           1:  [6, 2, 3, 11]\n"
"    .                             .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6926
#, no-wrap
msgid "' [1 2 3; 4 5 6; 7 6 0; 2 4 6] @key{RET}  s 7  v t  [6 2 3 11]   *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6934
msgid "Now we compute the matrix @texline @math{A'} @infoline @expr{A2} and divide."
msgstr ""

#. type: group
#: ../../calc.texi:6942
#, no-wrap
msgid ""
"2:  [57, 84, 96]          1:  [-11.64, 14.08, -3.64]\n"
"1:  [ [ 70, 72, 39 ]          .\n"
"      [ 72, 81, 60 ]\n"
"      [ 39, 60, 81 ] ]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6944
#, no-wrap
msgid "    r 7 v t r 7 *             /\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6950
msgid ""
"(The actual computed answer will be slightly inexact due to round-off "
"error.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6964
msgid ""
"Notice that the answers are similar to those for the @texline "
"@math{3\\times3} @infoline 3x3 system solved in the text.  That's because "
"the fourth equation that was added to the system is almost identical to the "
"first one multiplied by two.  (If it were identical, we would have gotten "
"the exact same answer since the @texline @math{4\\times3} @infoline 4x3 "
"system would be equivalent to the original @texline @math{3\\times3} "
"@infoline 3x3 system.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6968
msgid ""
"Since the first and fourth equations aren't quite equivalent, they can't "
"both be satisfied at once.  Let's plug our answers back into the original "
"system of equations to see how well they match."
msgstr ""

#. type: group
#: ../../calc.texi:6977
#, no-wrap
msgid ""
"2:  [-11.64, 14.08, -3.64]     1:  [5.6, 2., 3., 11.2]\n"
"1:  [ [ 1, 2, 3 ]                  .\n"
"      [ 4, 5, 6 ]\n"
"      [ 7, 6, 0 ]\n"
"      [ 2, 4, 6 ] ]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:6979
#, no-wrap
msgid "    r 7                            @key{TAB} *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6985
msgid ""
"This is reasonably close to our original @expr{B} vector, @expr{[6, 2, 3, "
"11]}."
msgstr ""

#. type: subsection
#: ../../calc.texi:6987
#, no-wrap
msgid "List Tutorial Exercise 1"
msgstr ""

#. type: Plain text
#: ../../calc.texi:6994
msgid ""
"We can use @kbd{v x} to build a vector of integers.  This needs to be "
"adjusted to get the range of integers we desire.  Mapping @samp{-} across "
"the vector will accomplish this, although it turns out the plain @samp{-} "
"key will work just as well."
msgstr ""

#. type: group
#: ../../calc.texi:7000
#, no-wrap
msgid ""
"2:  2                              2:  2\n"
"1:  [1, 2, 3, 4, 5, 6, 7, 8, 9]    1:  [-4, -3, -2, -1, 0, 1, 2, 3, 4]\n"
"    .                                  .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7002
#, no-wrap
msgid "    2  v x 9 @key{RET}                       5 V M -   or   5 -\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7008
msgid "Now we use @kbd{V M ^} to map the exponentiation operator across the vector."
msgstr ""

#. type: group
#: ../../calc.texi:7013
#, no-wrap
msgid ""
"1:  [0.0625, 0.125, 0.25, 0.5, 1, 2, 4, 8, 16]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7015
#, no-wrap
msgid "    V M ^\n"
msgstr ""

#. type: subsection
#: ../../calc.texi:7019
#, no-wrap
msgid "List Tutorial Exercise 2"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7024
msgid ""
"Given @expr{x} and @expr{y} vectors in quick variables 1 and 2 as before, "
"the first job is to form the matrix that describes the problem."
msgstr ""

#. type: example
#: ../../calc.texi:7028
#, no-wrap
msgid "   m*x + b*1 = y\n"
msgstr ""

#. type: tex
#: ../../calc.texi:7034
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ m \\times x + b \\times 1 = y $$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7042
msgid ""
"Thus we want a @texline @math{19\\times2} @infoline 19x2 matrix with our "
"@expr{x} vector as one column and ones as the other column.  So, first we "
"build the column of ones, then we combine the two columns to form our "
"@expr{A} matrix."
msgstr ""

#. type: group
#: ../../calc.texi:7049
#, no-wrap
msgid ""
"2:  [1.34, 1.41, 1.49, ... ]    1:  [ [ 1.34, 1 ]\n"
"1:  [1, 1, 1, ...]                    [ 1.41, 1 ]\n"
"    .                                 [ 1.49, 1 ]\n"
"                                      @dots{}\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7051
#, no-wrap
msgid "    r 1 1 v b 19 @key{RET}                M-2 v p v t   s 3\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7062
msgid ""
"Now we compute @texline @math{A^T y} @infoline @expr{trn(A) * y} and "
"@texline @math{A^T A} @infoline @expr{trn(A) * A} and divide."
msgstr ""

#. type: group
#: ../../calc.texi:7069
#, no-wrap
msgid ""
"1:  [33.36554, 13.613]    2:  [33.36554, 13.613]\n"
"    .                     1:  [ [ 98.0003, 41.63 ]\n"
"                                [  41.63,   19   ] ]\n"
"                              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7071
#, no-wrap
msgid " v t r 2 *                    r 3 v t r 3 *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7076
msgid "(Hey, those numbers look familiar!)"
msgstr ""

#. type: group
#: ../../calc.texi:7081
#, no-wrap
msgid ""
"1:  [0.52141679, -0.425978]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7083
#, no-wrap
msgid "    /\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7092
msgid ""
"Since we were solving equations of the form @texline @math{m \\times x + b "
"\\times 1 = y}, @infoline @expr{m*x + b*1 = y}, these numbers should be "
"@expr{m} and @expr{b}, respectively.  Sure enough, they agree exactly with "
"the result computed using @kbd{V M} and @kbd{V R}!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7096
msgid ""
"The moral of this story: @kbd{V M} and @kbd{V R} will probably solve your "
"problem, but there is often an easier way using the higher-level arithmetic "
"functions!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7100
msgid ""
"In fact, there is a built-in @kbd{a F} command that does least-squares "
"fits.  @xref{Curve Fitting}."
msgstr ""

#. type: subsection
#: ../../calc.texi:7102
#, no-wrap
msgid "List Tutorial Exercise 3"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7108
msgid ""
"Move to one end of the list and press @kbd{C-@@} (or @kbd{C-@key{SPC}} or "
"whatever) to set the mark, then move to the other end of the list and type "
"@w{@kbd{C-x * g}}."
msgstr ""

#. type: group
#: ../../calc.texi:7113
#, no-wrap
msgid ""
"1:  [2.3, 6, 22, 15.1, 7, 15, 14, 7.5, 2.5]\n"
"    .\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7118
msgid ""
"To make things interesting, let's assume we don't know at a glance how many "
"numbers are in this list.  Then we could type:"
msgstr ""

#. type: group
#: ../../calc.texi:7124
#, no-wrap
msgid ""
"2:  [2.3, 6, 22, ... ]     2:  [2.3, 6, 22, ... ]\n"
"1:  [2.3, 6, 22, ... ]     1:  126356422.5\n"
"    .                          .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7126
#, no-wrap
msgid ""
"    @key{RET}                        V R *\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7135
#, no-wrap
msgid ""
"2:  126356422.5            2:  126356422.5     1:  7.94652913734\n"
"1:  [2.3, 6, 22, ... ]     1:  9                   .\n"
"    .                          .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7137
#, no-wrap
msgid "    @key{TAB}                        v l                 I ^\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7144
msgid ""
"(The @kbd{I ^} command computes the @var{n}th root of a number.  You could "
"also type @kbd{& ^} to take the reciprocal of 9 and then raise the number to "
"that power.)"
msgstr ""

#. type: subsection
#: ../../calc.texi:7146
#, no-wrap
msgid "List Tutorial Exercise 4"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7153
msgid ""
"A number @expr{j} is a divisor of @expr{n} if @texline @math{n "
"\\mathbin{\\hbox{\\code{\\%}}} j = 0}.  @infoline @samp{n % j = 0}.  The "
"first step is to get a vector that identifies the divisors."
msgstr ""

#. type: group
#: ../../calc.texi:7159
#, no-wrap
msgid ""
"2:  30                  2:  [0, 0, 0, 2, ...]    1:  [1, 1, 1, 0, ...]\n"
"1:  [1, 2, 3, 4, ...]   1:  0                        .\n"
"    .                       .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7161
#, no-wrap
msgid ""
" 30 @key{RET} v x 30 @key{RET}   s 1    V M %  0                 V M a =  s "
"2\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7166
msgid "This vector has 1's marking divisors of 30 and 0's marking non-divisors."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7169
msgid ""
"The zeroth divisor function is just the total number of divisors.  The first "
"divisor function is the sum of the divisors."
msgstr ""

#. type: group
#: ../../calc.texi:7176
#, no-wrap
msgid ""
"1:  8      3:  8                    2:  8                    2:  8\n"
"           2:  [1, 2, 3, 4, ...]    1:  [1, 2, 3, 0, ...]    1:  72\n"
"           1:  [1, 1, 1, 0, ...]        .                        .\n"
"               .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7178
#, no-wrap
msgid "   V R +       r 1 r 2                  V M *                  V R +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7184
msgid ""
"Once again, the last two steps just compute a dot product for which a simple "
"@kbd{*} would have worked equally well."
msgstr ""

#. type: subsection
#: ../../calc.texi:7186
#, no-wrap
msgid "List Tutorial Exercise 5"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7193
msgid ""
"The obvious first step is to obtain the list of factors with @kbd{k f}.  "
"This list will always be in sorted order, so if there are duplicates they "
"will be right next to each other.  A suitable method is to compare the list "
"with a copy of itself shifted over by one."
msgstr ""

#. type: group
#: ../../calc.texi:7199
#, no-wrap
msgid ""
"1:  [3, 7, 7, 7, 19]   2:  [3, 7, 7, 7, 19]     2:  [3, 7, 7, 7, 19, 0]\n"
"    .                  1:  [3, 7, 7, 7, 19, 0]  1:  [0, 3, 7, 7, 7, 19]\n"
"                           .                        .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7201
#, no-wrap
msgid ""
"    19551 k f              @key{RET} 0 |                  @key{TAB} 0 "
"@key{TAB} |\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7209
#, no-wrap
msgid ""
"1:  [0, 0, 1, 1, 0, 0]   1:  2          1:  0\n"
"    .                        .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7211
#, no-wrap
msgid "    V M a =                  V R +          0 a =\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7219
msgid ""
"Note that we have to arrange for both vectors to have the same length so "
"that the mapping operation works; no prime factor will ever be zero, so "
"adding zeros on the left and right is safe.  From then on the job is pretty "
"straightforward."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7223
msgid ""
"Incidentally, Calc provides the @dfn{Möbius μ} function which is zero if and "
"only if its argument is square-free.  It would be a much more convenient way "
"to do the above test in practice."
msgstr ""

#. type: subsection
#: ../../calc.texi:7225
#, no-wrap
msgid "List Tutorial Exercise 6"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7230
msgid ""
"First use @kbd{v x 6 @key{RET}} to get a list of integers, then @kbd{V M v "
"x} to get a list of lists of integers!"
msgstr ""

#. type: subsection
#: ../../calc.texi:7232
#, no-wrap
msgid "List Tutorial Exercise 7"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7237
msgid ""
"Here's one solution.  First, compute the triangular list from the previous "
"exercise and type @kbd{1 -} to subtract one from all the elements."
msgstr ""

#. type: group
#: ../../calc.texi:7244
#, no-wrap
msgid ""
"1:  [ [0],\n"
"      [0, 1],\n"
"      [0, 1, 2],\n"
"      @dots{}\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7246
#, no-wrap
msgid "    1 -\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7255
msgid ""
"The numbers down the lefthand edge of the list we desire are called the "
"``triangular numbers'' (now you know why!).  The @expr{n}th triangular "
"number is the sum of the integers from 1 to @expr{n}, and can be computed "
"directly by the formula @texline @math{n (n+1) \\over 2}.  @infoline @expr{n "
"* (n+1) / 2}."
msgstr ""

#. type: group
#: ../../calc.texi:7261
#, no-wrap
msgid ""
"2:  [ [0], [0, 1], ... ]    2:  [ [0], [0, 1], ... ]\n"
"1:  [0, 1, 2, 3, 4, 5]      1:  [0, 1, 3, 6, 10, 15]\n"
"    .                           .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7263
#, no-wrap
msgid "    v x 6 @key{RET} 1 -               V M ' $ ($+1)/2 @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7269
msgid "Adding this list to the above list of lists produces the desired result:"
msgstr ""

#. type: group
#: ../../calc.texi:7279
#, no-wrap
msgid ""
"1:  [ [0],\n"
"      [1, 2],\n"
"      [3, 4, 5],\n"
"      [6, 7, 8, 9],\n"
"      [10, 11, 12, 13, 14],\n"
"      [15, 16, 17, 18, 19, 20] ]\n"
"      .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7281
#, no-wrap
msgid "      V M +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7288
msgid ""
"If we did not know the formula for triangular numbers, we could have "
"computed them using a @kbd{V U +} command.  We could also have gotten them "
"the hard way by mapping a reduction across the original triangular list."
msgstr ""

#. type: group
#: ../../calc.texi:7294
#, no-wrap
msgid ""
"2:  [ [0], [0, 1], ... ]    2:  [ [0], [0, 1], ... ]\n"
"1:  [ [0], [0, 1], ... ]    1:  [0, 1, 3, 6, 10, 15]\n"
"    .                           .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7296
#, no-wrap
msgid "    @key{RET}                         V M V R +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7303
msgid ""
"(This means ``map a @kbd{V R +} command across the vector,'' and since each "
"element of the main vector is itself a small vector, @kbd{V R +} computes "
"the sum of its elements.)"
msgstr ""

#. type: subsection
#: ../../calc.texi:7305
#, no-wrap
msgid "List Tutorial Exercise 8"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7309
msgid "The first step is to build a list of values of @expr{x}."
msgstr ""

#. type: group
#: ../../calc.texi:7314
#, no-wrap
msgid ""
"1:  [1, 2, 3, ..., 21]  1:  [0, 1, 2, ..., 20]  1:  [0, 0.25, 0.5, ..., 5]\n"
"    .                       .                       .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7316
#, no-wrap
msgid "    v x 21 @key{RET}              1 -                     4 /  s 1\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7320
msgid "Next, we compute the Bessel function values."
msgstr ""

#. type: group
#: ../../calc.texi:7325
#, no-wrap
msgid ""
"1:  [0., 0.124, 0.242, ..., -0.328]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7327
#, no-wrap
msgid "    V M ' besJ(1,$) @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7332
msgid "(Another way to do this would be @kbd{1 @key{TAB} V M f j}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7335
msgid ""
"A way to isolate the maximum value is to compute the maximum using @kbd{V R "
"X}, then compare all the Bessel values with that maximum."
msgstr ""

#. type: group
#: ../../calc.texi:7341
#, no-wrap
msgid ""
"2:  [0., 0.124, 0.242, ... ]   1:  [0, 0, 0, ... ]    2:  [0, 0, 0, ... ]\n"
"1:  0.5801562                      .                  1:  1\n"
"    .                                                     .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7343
#, no-wrap
msgid ""
"    @key{RET} V R X                      V M a =                @key{RET} V "
"R +    @key{DEL}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7352
msgid ""
"It's a good idea to verify, as in the last step above, that only one value "
"is equal to the maximum.  (After all, a plot of @texline @math{\\sin x} "
"@infoline @expr{sin(x)} might have many points all equal to the maximum "
"value, 1.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7356
msgid ""
"The vector we have now has a single 1 in the position that indicates the "
"maximum value of @expr{x}.  Now it is a simple matter to convert this back "
"into the corresponding value itself."
msgstr ""

#. type: group
#: ../../calc.texi:7362
#, no-wrap
msgid ""
"2:  [0, 0, 0, ... ]         1:  [0, 0., 0., ... ]    1:  1.75\n"
"1:  [0, 0.25, 0.5, ... ]        .                        .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7364
#, no-wrap
msgid "    r 1                         V M *                    V R +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7373
msgid ""
"If @kbd{a =} had produced more than one @expr{1} value, this method would "
"have given the sum of all maximum @expr{x} values; not very useful! In this "
"case we could have used @kbd{v m} (@code{calc-mask-vector})  instead.  This "
"command deletes all elements of a ``data'' vector that correspond to zeros "
"in a ``mask'' vector, leaving us with, in this example, a vector of maximum "
"@expr{x} values."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7377
msgid ""
"The built-in @kbd{a X} command maximizes a function using more efficient "
"methods.  Just for illustration, let's use @kbd{a X} to maximize "
"@samp{besJ(1,x)} over this same interval."
msgstr ""

#. type: group
#: ../../calc.texi:7383
#, no-wrap
msgid ""
"2:  besJ(1, x)                 1:  [1.84115, 0.581865]\n"
"1:  [0 .. 5]                       .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7385
#, no-wrap
msgid "' besJ(1,x), [0..5] @key{RET}            a X x @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7392
msgid ""
"The output from @kbd{a X} is a vector containing the value of @expr{x} that "
"maximizes the function, and the function's value at that maximum.  As you "
"can see, our simple search got quite close to the right answer."
msgstr ""

#. type: subsection
#: ../../calc.texi:7394
#, no-wrap
msgid "List Tutorial Exercise 9"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7398
msgid "Step one is to convert our integer into vector notation."
msgstr ""

#. type: group
#: ../../calc.texi:7405
#, no-wrap
msgid ""
"1:  25129925999           3:  25129925999\n"
"    .                     2:  10\n"
"                          1:  [11, 10, 9, ..., 1, 0]\n"
"                              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7407
#, no-wrap
msgid ""
"    25129925999 @key{RET}           10 @key{RET} 12 @key{RET} v x 12 "
"@key{RET} -\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7416
#, no-wrap
msgid ""
"1:  25129925999              1:  [0, 2, 25, 251, 2512, ... ]\n"
"2:  [100000000000, ... ]         .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7418
#, no-wrap
msgid "    V M ^   s 1                  V M \\\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7423
msgid "(Recall, the @kbd{\\} command computes an integer quotient.)"
msgstr ""

#. type: group
#: ../../calc.texi:7428
#, no-wrap
msgid ""
"1:  [0, 2, 5, 1, 2, 9, 9, 2, 5, 9, 9, 9]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7430
#, no-wrap
msgid "    10 V M %   s 2\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7437
msgid ""
"Next we must increment this number.  This involves adding one to the last "
"digit, plus handling carries.  There is a carry to the left out of a digit "
"if that digit is a nine and all the digits to the right of it are nines."
msgstr ""

#. type: group
#: ../../calc.texi:7442
#, no-wrap
msgid ""
"1:  [0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1]   1:  [1, 1, 1, 0, 0, 1, ... ]\n"
"    .                                          .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7444
#, no-wrap
msgid ""
"    9 V M a =                                  v v\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7452
#, no-wrap
msgid ""
"1:  [1, 1, 1, 0, 0, 0, ... ]   1:  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]\n"
"    .                              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7454
#, no-wrap
msgid "    V U *                          v v 1 |\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7463
msgid ""
"Accumulating @kbd{*} across a vector of ones and zeros will preserve only "
"the initial run of ones.  These are the carries into all digits except the "
"rightmost digit.  Concatenating a one on the right takes care of aligning "
"the carries properly, and also adding one to the rightmost digit."
msgstr ""

#. type: group
#: ../../calc.texi:7469
#, no-wrap
msgid ""
"2:  [0, 0, 0, 0, ... ]     1:  [0, 0, 2, 5, 1, 2, 9, 9, 2, 6, 0, 0, 0]\n"
"1:  [0, 0, 2, 5, ... ]         .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7471
#, no-wrap
msgid "    0 r 2 |                    V M +  10 V M %\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7478
msgid ""
"Here we have concatenated 0 to the @emph{left} of the original number; this "
"takes care of shifting the carries by one with respect to the digits that "
"generated them."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7480
msgid "Finally, we must convert this list back into an integer."
msgstr ""

#. type: group
#: ../../calc.texi:7487
#, no-wrap
msgid ""
"3:  [0, 0, 2, 5, ... ]        2:  [0, 0, 2, 5, ... ]\n"
"2:  1000000000000             1:  [1000000000000, 100000000000, ... ]\n"
"1:  [100000000000, ... ]          .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7489
#, no-wrap
msgid ""
"    10 @key{RET} 12 ^  r 1              |\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7497
#, no-wrap
msgid ""
"1:  [0, 0, 20000000000, 5000000000, ... ]    1:  25129926000\n"
"    .                                            .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7499
#, no-wrap
msgid "    V M *                                        V R +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7505
msgid ""
"Another way to do this final step would be to reduce the formula @w{@samp{10 "
"$$ + $}} across the vector of digits."
msgstr ""

#. type: group
#: ../../calc.texi:7510
#, no-wrap
msgid ""
"1:  [0, 0, 2, 5, ... ]        1:  25129926000\n"
"    .                             .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7512
#, no-wrap
msgid "                                  V R ' 10 $$ + $ @key{RET}\n"
msgstr ""

#. type: subsection
#: ../../calc.texi:7516
#, no-wrap
msgid "List Tutorial Exercise 10"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7523
msgid ""
"For the list @expr{[a, b, c, d]}, the result is @expr{((a = b) = c) = d}, "
"which will compare @expr{a} and @expr{b} to produce a 1 or 0, which is then "
"compared with @expr{c} to produce another 1 or 0, which is then compared "
"with @expr{d}.  This is not at all what Joe wanted."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7525
msgid "Here's a more correct method:"
msgstr ""

#. type: group
#: ../../calc.texi:7531
#, no-wrap
msgid ""
"1:  [7, 7, 7, 8, 7]      2:  [7, 7, 7, 8, 7]\n"
"    .                    1:  7\n"
"                             .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7533
#, no-wrap
msgid ""
"  ' [7,7,7,8,7] @key{RET}          @key{RET} v r 1 @key{RET}\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7541
#, no-wrap
msgid ""
"1:  [1, 1, 1, 0, 1]      1:  0\n"
"    .                        .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7543
#, no-wrap
msgid "    V M a =                  V R *\n"
msgstr ""

#. type: subsection
#: ../../calc.texi:7547
#, no-wrap
msgid "List Tutorial Exercise 11"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7553
msgid ""
"The circle of unit radius consists of those points @expr{(x,y)} for which "
"@expr{x^2 + y^2 < 1}.  We start by generating a vector of @expr{x^2} and a "
"vector of @expr{y^2}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7556 ../../calc.texi:7650
msgid ""
"We can make this go a bit faster by using the @kbd{v .} and @kbd{t .} "
"commands."
msgstr ""

#. type: group
#: ../../calc.texi:7562
#, no-wrap
msgid ""
"2:  [2., 2., ..., 2.]          2:  [2., 2., ..., 2.]\n"
"1:  [2., 2., ..., 2.]          1:  [1.16, 1.98, ..., 0.81]\n"
"    .                              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7564
#, no-wrap
msgid ""
" v . t .  2. v b 100 @key{RET} @key{RET}       V M k r\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7573
#, no-wrap
msgid ""
"2:  [2., 2., ..., 2.]          1:  [0.026, 0.96, ..., 0.036]\n"
"1:  [0.026, 0.96, ..., 0.036]  2:  [0.53, 0.81, ..., 0.094]\n"
"    .                              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7575
#, no-wrap
msgid "    1 -  2 V M ^                   @key{TAB}  V M k r  1 -  2 V M ^\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7580
msgid ""
"Now we sum the @expr{x^2} and @expr{y^2} values, compare with 1 to get a "
"vector of 1/0 truth values, then sum the truth values."
msgstr ""

#. type: group
#: ../../calc.texi:7585
#, no-wrap
msgid ""
"1:  [0.56, 1.78, ..., 0.13]    1:  [1, 0, ..., 1]    1:  84\n"
"    .                              .                     .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7587
#, no-wrap
msgid "    +                              1 V M a <             V R +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7592
msgid "The ratio @expr{84/100} should approximate the ratio @cpiover{4}."
msgstr ""

#. type: group
#: ../../calc.texi:7597
#, no-wrap
msgid ""
"1:  0.84       1:  3.36       2:  3.36       1:  1.0695\n"
"    .              .          1:  3.14159        .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7599
#, no-wrap
msgid "    100 /          4 *            P              /\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7606
msgid ""
"Our estimate, 3.36, is off by about 7%.  We could get a better estimate by "
"taking more points (say, 1000), but it's clear that this method is not very "
"efficient!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7609
msgid ""
"(Naturally, since this example uses random numbers your own answer will be "
"slightly different from the one shown here!)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7612 ../../calc.texi:7723
msgid ""
"If you typed @kbd{v .} and @kbd{t .} before, type them again to return to "
"full-sized display of vectors."
msgstr ""

#. type: subsection
#: ../../calc.texi:7614
#, no-wrap
msgid "List Tutorial Exercise 12"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7629
msgid ""
"This problem can be made a lot easier by taking advantage of some "
"symmetries.  First of all, after some thought it's clear that the @expr{y} "
"axis can be ignored altogether.  Just pick a random @expr{x} component for "
"one end of the match, pick a random direction @texline @math{\\theta}, "
"@infoline @expr{theta}, and see if @expr{x} and @texline @math{x + \\cos "
"\\theta} @infoline @expr{x + cos(theta)} (which is the @expr{x} coordinate "
"of the other endpoint) cross a line.  The lines are at integer coordinates, "
"so this happens when the two numbers surround an integer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7635
msgid ""
"Since the two endpoints are equivalent, we may as well choose the leftmost "
"of the two endpoints as @expr{x}.  Then @expr{theta} is an angle pointing to "
"the right, in the range -90 to 90 degrees.  (We could use radians, but it "
"would feel like cheating to refer to @cpiover{2} radians while trying to "
"estimate @cpi{}!)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7647
msgid ""
"In fact, since the field of lines is infinite we can choose the coordinates "
"0 and 1 for the lines on either side of the leftmost endpoint.  The "
"rightmost endpoint will be between 0 and 1 if the match does not cross a "
"line, or between 1 and 2 if it does.  So: Pick random @expr{x} and @texline "
"@math{\\theta}, @infoline @expr{theta}, compute @texline @math{x + \\cos "
"\\theta}, @infoline @expr{x + cos(theta)}, and count how many of the results "
"are greater than one.  Simple!"
msgstr ""

#. type: group
#: ../../calc.texi:7656
#, no-wrap
msgid ""
"1:  [0.52, 0.71, ..., 0.72]    2:  [0.52, 0.71, ..., 0.72]\n"
"    .                          1:  [78.4, 64.5, ..., -42.9]\n"
"                                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7658
#, no-wrap
msgid ""
"v . t . 1. v b 100 @key{RET}  V M k r    180. v b 100 @key{RET}  V M k r  90 "
"-\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7663
msgid "(The next step may be slow, depending on the speed of your computer.)"
msgstr ""

#. type: group
#: ../../calc.texi:7669
#, no-wrap
msgid ""
"2:  [0.52, 0.71, ..., 0.72]    1:  [0.72, 1.14, ..., 1.45]\n"
"1:  [0.20, 0.43, ..., 0.73]        .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7671
#, no-wrap
msgid ""
"    m d  V M C                     +\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7679
#, no-wrap
msgid ""
"1:  [0, 1, ..., 1]       1:  0.64            1:  3.125\n"
"    .                        .                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7681
#, no-wrap
msgid "    1 V M a >                V R + 100 /         2 @key{TAB} /\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7687
msgid ""
"Let's try the third method, too.  We'll use random integers up to one "
"million.  The @kbd{k r} command with an integer argument picks a random "
"integer."
msgstr ""

#. type: group
#: ../../calc.texi:7693
#, no-wrap
msgid ""
"2:  [1000000, 1000000, ..., 1000000]   2:  [78489, 527587, ..., 814975]\n"
"1:  [1000000, 1000000, ..., 1000000]   1:  [324014, 358783, ..., 955450]\n"
"    .                                      .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7695
#, no-wrap
msgid ""
"    1000000 v b 100 @key{RET} @key{RET}                V M k r  @key{TAB}  V "
"M k r\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7703
#, no-wrap
msgid ""
"1:  [1, 1, ..., 25]      1:  [1, 1, ..., 0]     1:  0.56\n"
"    .                        .                      .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7705
#, no-wrap
msgid ""
"    V M k g                  1 V M a =              V R + 100 /\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7713
#, no-wrap
msgid ""
"1:  10.714        1:  3.273\n"
"    .                 .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7715
#, no-wrap
msgid "    6 @key{TAB} /           Q\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7720
msgid ""
"For a proof of this property of the GCD function, see section 4.5.2, "
"exercise 10, of Knuth's @emph{Art of Computer Programming}, volume II."
msgstr ""

#. type: subsection
#: ../../calc.texi:7725
#, no-wrap
msgid "List Tutorial Exercise 13"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7729
msgid "First, we put the string on the stack as a vector of ASCII codes."
msgstr ""

#. type: group
#: ../../calc.texi:7734
#, no-wrap
msgid ""
"1:  [84, 101, 115, ..., 51]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7736
#, no-wrap
msgid "    \"Testing, 1, 2, 3 @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7744
msgid ""
"Note that the @kbd{\"} key, like @kbd{$}, initiates algebraic entry so there "
"was no need to type an apostrophe.  Also, Calc didn't mind that we omitted "
"the closing @kbd{\"}.  (The same goes for all closing delimiters like "
"@kbd{)} and @kbd{]} at the end of a formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7749
msgid ""
"We'll show two different approaches here.  In the first, we note that if the "
"input vector is @expr{[a, b, c, d]}, then the hash code is @expr{3 (3 (3a + "
"b) + c) + d = 27a + 9b + 3c + d}.  In other words, it's a sum of descending "
"powers of three times the ASCII codes."
msgstr ""

#. type: group
#: ../../calc.texi:7755
#, no-wrap
msgid ""
"2:  [84, 101, 115, ..., 51]    2:  [84, 101, 115, ..., 51]\n"
"1:  16                         1:  [15, 14, 13, ..., 0]\n"
"    .                              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7757
#, no-wrap
msgid ""
"    @key{RET} v l                        v x 16 @key{RET} -\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7766
#, no-wrap
msgid ""
"2:  [84, 101, 115, ..., 51]    1:  1960915098    1:  121\n"
"1:  [14348907, ..., 1]             .                 .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7768
#, no-wrap
msgid "    3 @key{TAB} V M ^                    *                 511 %\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7777
msgid ""
"Once again, @kbd{*} elegantly summarizes most of the computation.  But "
"there's an even more elegant approach: Reduce the formula @kbd{3 $$ + $} "
"across the vector.  Recall that this represents a function of two arguments "
"that computes its first argument times three plus its second argument."
msgstr ""

#. type: group
#: ../../calc.texi:7782
#, no-wrap
msgid ""
"1:  [84, 101, 115, ..., 51]    1:  1960915098\n"
"    .                              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7784
#, no-wrap
msgid "    \"Testing, 1, 2, 3 @key{RET}          V R ' 3$$+$ @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7791
msgid ""
"If you did the decimal arithmetic exercise, this will be familiar.  "
"Basically, we're turning a base-3 vector of digits into an integer, except "
"that our ``digits'' are much larger than real digits."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7798
msgid ""
"Instead of typing @kbd{511 %} again to reduce the result, we can be cleverer "
"still and notice that rather than computing a huge integer and taking the "
"modulo at the end, we can take the modulo at each step without affecting the "
"result.  While this means there are more arithmetic operations, the numbers "
"we operate on remain small so the operations are faster."
msgstr ""

#. type: group
#: ../../calc.texi:7803
#, no-wrap
msgid ""
"1:  [84, 101, 115, ..., 51]    1:  121\n"
"    .                              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7805
#, no-wrap
msgid "    \"Testing, 1, 2, 3 @key{RET}          V R ' (3$$+$)%511 @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7812
msgid ""
"Why does this work? Think about a two-step computation: @w{@expr{3 (3a + b) "
"+ c}}.  Taking a result modulo 511 basically means subtracting off enough "
"511's to put the result in the desired range.  So the result when we take "
"the modulo after every step is,"
msgstr ""

#. type: example
#: ../../calc.texi:7816
#, no-wrap
msgid "3 (3 a + b - 511 m) + c - 511 n\n"
msgstr ""

#. type: tex
#: ../../calc.texi:7822
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ 3 (3 a + b - 511 m) + c - 511 n $$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7827
msgid ""
"for some suitable integers @expr{m} and @expr{n}.  Expanding out by the "
"distributive law yields"
msgstr ""

#. type: example
#: ../../calc.texi:7831
#, no-wrap
msgid "9 a + 3 b + c - 511*3 m - 511 n\n"
msgstr ""

#. type: tex
#: ../../calc.texi:7837
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ 9 a + 3 b + c - 511\\times3 m - 511 n $$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7844
msgid ""
"The @expr{m} term in the latter formula is redundant because any "
"contribution it makes could just as easily be made by the @expr{n} term.  So "
"we can take it out to get an equivalent formula with @expr{n' = 3m + n},"
msgstr ""

#. type: example
#: ../../calc.texi:7848
#, no-wrap
msgid "9 a + 3 b + c - 511 n'\n"
msgstr ""

#. type: tex
#: ../../calc.texi:7854
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ 9 a + 3 b + c - 511 n^{\\prime} $$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7859
msgid ""
"which is just the formula for taking the modulo only at the end of the "
"calculation.  Therefore the two methods are essentially the same."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7863
msgid ""
"Later in the tutorial we will encounter @dfn{modulo forms}, which basically "
"automate the idea of reducing every intermediate result modulo some value "
"@var{m}."
msgstr ""

#. type: subsection
#: ../../calc.texi:7865
#, no-wrap
msgid "List Tutorial Exercise 14"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7870
msgid ""
"We want to use @kbd{H V U} to nest a function which adds a random step to an "
"@expr{(x,y)} coordinate.  The function is a bit long, but otherwise the "
"problem is quite straightforward."
msgstr ""

#. type: group
#: ../../calc.texi:7877
#, no-wrap
msgid ""
"2:  [0, 0]     1:  [ [    0,       0    ]\n"
"1:  50               [  0.4288, -0.1695 ]\n"
"    .                [ -0.4787, -0.9027 ]\n"
"                     ...\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7879
#, no-wrap
msgid "    [0,0] 50       H V U ' <# + [random(2.0)-1, random(2.0)-1]> @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7885
msgid ""
"Just as the text recommended, we used @samp{< >} nameless function notation "
"to keep the two @code{random} calls from being evaluated before nesting even "
"begins."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7889
msgid ""
"We now have a vector of @expr{[x, y]} sub-vectors, which by Calc's rules "
"acts like a matrix.  We can transpose this matrix and unpack to get a pair "
"of vectors, @expr{x} and @expr{y}, suitable for graphing."
msgstr ""

#. type: group
#: ../../calc.texi:7895
#, no-wrap
msgid ""
"2:  [ 0, 0.4288, -0.4787, ... ]\n"
"1:  [ 0, -0.1696, -0.9027, ... ]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7897
#, no-wrap
msgid "    v t  v u  g f\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7903
msgid ""
"Incidentally, because the @expr{x} and @expr{y} are completely independent "
"in this case, we could have done two separate commands to create our "
"@expr{x} and @expr{y} vectors of numbers directly."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7908
msgid ""
"To make a random walk of unit steps, we note that @code{sincos} of a random "
"direction exactly gives us an @expr{[x, y]} step of unit length; in fact, "
"the new nesting function is even briefer, though we might want to lower the "
"precision a bit for it."
msgstr ""

#. type: group
#: ../../calc.texi:7915
#, no-wrap
msgid ""
"2:  [0, 0]     1:  [ [    0,      0    ]\n"
"1:  50               [  0.1318, 0.9912 ]\n"
"    .                [ -0.5965, 0.3061 ]\n"
"                     ...\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7917
#, no-wrap
msgid ""
"    [0,0] 50   m d  p 6 @key{RET}   H V U ' <# + sincos(random(360.0))> "
"@key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7921
msgid "Another @kbd{v t v u g f} sequence will graph this new random walk."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7928
msgid ""
"An interesting twist on these random walk functions would be to use complex "
"numbers instead of 2-vectors to represent points on the plane.  In the first "
"example, we'd use something like @samp{random + random*(0,1)}, and in the "
"second we could use polar complex numbers with random phase angles.  (This "
"exercise was first suggested in this form by Randal Schwartz.)"
msgstr ""

#. type: subsection
#: ../../calc.texi:7930
#, no-wrap
msgid "Types Tutorial Exercise 1"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7935
msgid ""
"If the number is the square root of @cpi{} times a rational number, then its "
"square, divided by @cpi{}, should be a rational number."
msgstr ""

#. type: group
#: ../../calc.texi:7940
#, no-wrap
msgid ""
"1:  1.26508260337    1:  0.509433962268   1:  2486645810:4881193627\n"
"    .                    .                    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7942
#, no-wrap
msgid "                         2 ^ P /              c F\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7950
msgid ""
"Technically speaking this is a rational number, but not one that is likely "
"to have arisen in the original problem.  More likely, it just happens to be "
"the fraction which most closely represents some irrational number to within "
"12 digits."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7953
msgid ""
"But perhaps our result was not quite exact.  Let's reduce the precision "
"slightly and try again:"
msgstr ""

#. type: group
#: ../../calc.texi:7958
#, no-wrap
msgid ""
"1:  0.509433962268     1:  27:53\n"
"    .                      .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:7960
#, no-wrap
msgid "    U p 10 @key{RET}             c F\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7968
msgid ""
"Aha! It's unlikely that an irrational number would equal a fraction this "
"simple to within ten digits, so our original number was probably @texline "
"@math{\\sqrt{27 \\pi / 53}}.  @infoline @expr{sqrt(27 pi / 53)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7972
msgid ""
"Notice that we didn't need to re-round the number when we reduced the "
"precision.  Remember, arithmetic operations always round their inputs to the "
"current precision before they begin."
msgstr ""

#. type: subsection
#: ../../calc.texi:7974
#, no-wrap
msgid "Types Tutorial Exercise 2"
msgstr ""

#. type: Plain text
#: ../../calc.texi:7979
msgid ""
"@samp{inf / inf = nan}.  Perhaps @samp{1} is the ``obvious'' answer.  But if "
"@w{@samp{17 inf = inf}}, then @samp{17 inf / inf = inf / inf = 17}, too."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7986
msgid ""
"@samp{exp(inf) = inf}.  It's tempting to say that the exponential of "
"infinity must be ``bigger'' than ``regular'' infinity, but as far as Calc is "
"concerned all infinities are the same size.  In other words, as @expr{x} "
"goes to infinity, @expr{e^x} also goes to infinity, but the fact the "
"@expr{e^x} grows much faster than @expr{x} is not relevant here."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7989
msgid ""
"@samp{exp(-inf) = 0}.  Here we have a finite answer even though the input is "
"infinite."
msgstr ""

#. type: Plain text
#: ../../calc.texi:7995
msgid ""
"@samp{sqrt(-inf) = (0, 1) inf}.  Remember that @expr{(0, 1)} represents the "
"imaginary number @expr{i}.  Here's a derivation: @samp{sqrt(-inf) = "
"@w{sqrt((-1) * inf)} = sqrt(-1) * sqrt(inf)}.  The first part is, by "
"definition, @expr{i}; the second is @code{inf} because, once again, all "
"infinities are the same size."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8000
msgid ""
"@samp{sqrt(uinf) = uinf}.  In fact, we do know something about the direction "
"because @code{sqrt} is defined to return a value in the right half of the "
"complex plane.  But Calc has no notation for this, so it settles for the "
"conservative answer @code{uinf}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8003
msgid ""
"@samp{abs(uinf) = inf}.  No matter which direction @expr{x} points, "
"@samp{abs(x)} always points along the positive real axis."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8008
msgid ""
"@samp{ln(0) = -inf}.  Here we have an infinite answer to a finite input.  As "
"in the @expr{1 / 0} case, Calc will only use infinities here if you have "
"turned on Infinite mode.  Otherwise, it will treat @samp{ln(0)} as an error."
msgstr ""

#. type: subsection
#: ../../calc.texi:8010
#, no-wrap
msgid "Types Tutorial Exercise 3"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8019
msgid ""
"We can make @samp{inf - inf} be any real number we like, say, @expr{a}, just "
"by claiming that we added @expr{a} to the first infinity but not to the "
"second.  This is just as true for complex values of @expr{a}, so @code{nan} "
"can stand for a complex number.  (And, similarly, @code{uinf} can stand for "
"an infinity that points in any direction in the complex plane, such as "
"@samp{(0, 1) inf})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8024
msgid ""
"In fact, we can multiply the first @code{inf} by two.  Surely @w{@samp{2 inf "
"- inf = inf}}, but also @samp{2 inf - inf = inf - inf = nan}.  So @code{nan} "
"can even stand for infinity.  Obviously it's just as easy to make it stand "
"for minus infinity as for plus infinity."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8030
msgid ""
"The moral of this story is that ``infinity'' is a slippery fish indeed, and "
"Calc tries to handle it by having a very simple model for infinities (only "
"the direction counts, not the ``size''); but Calc is careful to write "
"@code{nan} any time this simple model is unable to tell what the true answer "
"is."
msgstr ""

#. type: subsection
#: ../../calc.texi:8032
#, no-wrap
msgid "Types Tutorial Exercise 4"
msgstr ""

#. type: group
#: ../../calc.texi:8039
#, no-wrap
msgid ""
"2:  0@@ 47' 26\"              1:  0@@ 2' 47.411765\"\n"
"1:  17                          .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8041
#, no-wrap
msgid "    0@@ 47' 26\" @key{RET} 17           /\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8046
msgid "The average song length is two minutes and 47.4 seconds."
msgstr ""

#. type: group
#: ../../calc.texi:8052
#, no-wrap
msgid ""
"2:  0@@ 2' 47.411765\"     1:  0@@ 3' 7.411765\"    1:  0@@ 53' 6.000005\"\n"
"1:  0@@ 0' 20\"                .                      .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8054
#, no-wrap
msgid "    20\"                      +                      17 *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8059
msgid "The album would be 53 minutes and 6 seconds long."
msgstr ""

#. type: subsection
#: ../../calc.texi:8061
#, no-wrap
msgid "Types Tutorial Exercise 5"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8067
msgid ""
"Let's suppose it's January 14, 1991.  The easiest thing to do is to keep "
"trying 13ths of months until Calc reports a Friday.  We can do this by "
"manually entering dates, or by using @kbd{t I}:"
msgstr ""

#. type: group
#: ../../calc.texi:8072
#, no-wrap
msgid ""
"1:  <Wed Feb 13, 1991>    1:  <Wed Mar 13, 1991>   1:  <Sat Apr 13, 1991>\n"
"    .                         .                        .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8074
#, no-wrap
msgid ""
"    ' <2/13> @key{RET}       @key{DEL}    ' <3/13> @key{RET}             t "
"I\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8079
msgid "(Calc assumes the current year if you don't say otherwise.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8085
msgid ""
"This is getting tedious---we can keep advancing the date by typing @kbd{t I} "
"over and over again, but let's automate the job by using vector mapping.  "
"The @kbd{t I} command actually takes a second ``how-many-months'' argument, "
"which defaults to one.  This argument is exactly what we want to map over:"
msgstr ""

#. type: group
#: ../../calc.texi:8092
#, no-wrap
msgid ""
"2:  <Sat Apr 13, 1991>     1:  [<Mon May 13, 1991>, <Thu Jun 13, 1991>,\n"
"1:  [1, 2, 3, 4, 5, 6]          <Sat Jul 13, 1991>, <Tue Aug 13, 1991>,\n"
"    .                           <Fri Sep 13, 1991>, <Sun Oct 13, 1991>]\n"
"                               .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8094
#, no-wrap
msgid "    v x 6 @key{RET}                  V M t I\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8099
msgid "Et voilà, September 13, 1991 is a Friday."
msgstr ""

#. type: group
#: ../../calc.texi:8104
#, no-wrap
msgid ""
"1:  242\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8106
#, no-wrap
msgid "' <sep 13> - <jan 14> @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8111
msgid "And the answer to our original question: 242 days to go."
msgstr ""

#. type: subsection
#: ../../calc.texi:8113
#, no-wrap
msgid "Types Tutorial Exercise 6"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8122
msgid ""
"The full rule for leap years is that they occur in every year divisible by "
"four, except that they don't occur in years divisible by 100, except that "
"they @emph{do} in years divisible by 400.  We could work out the answer by "
"carefully counting the years divisible by four and the exceptions, but there "
"is a much simpler way that works even if we don't know the leap year rule."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8128
msgid ""
"Let's assume the present year is 1991.  Years have 365 days, except that "
"leap years (whenever they occur) have 366 days.  So let's count the number "
"of days between now and then, and compare that to the number of years times "
"365.  The number of extra days we find must be equal to the number of leap "
"years there were."
msgstr ""

#. type: group
#: ../../calc.texi:8134
#, no-wrap
msgid ""
"1:  <Mon Jan 1, 10001>     2:  <Mon Jan 1, 10001>     1:  2925593\n"
"    .                      1:  <Tue Jan 1, 1991>          .\n"
"                               .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8136
#, no-wrap
msgid ""
"  ' <jan 1 10001> @key{RET}         ' <jan 1 1991> @key{RET}          -\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8146
#, no-wrap
msgid ""
"3:  2925593       2:  2925593     2:  2925593     1:  1943\n"
"2:  10001         1:  8010        1:  2923650         .\n"
"1:  1991              .               .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8148
#, no-wrap
msgid "  10001 @key{RET} 1991      -               365 *           -\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8157
msgid ""
"There will be 1943 leap years before the year 10001.  (Assuming, of course, "
"that the algorithm for computing leap years remains unchanged for that "
"long.  @xref{Date Forms}, for some interesting background information in "
"that regard.)"
msgstr ""

#. type: subsection
#: ../../calc.texi:8159
#, no-wrap
msgid "Types Tutorial Exercise 7"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8164
msgid ""
"The relative errors must be converted to absolute errors so that @samp{+/-} "
"notation may be used."
msgstr ""

#. type: group
#: ../../calc.texi:8170
#, no-wrap
msgid ""
"1:  1.              2:  1.\n"
"    .               1:  0.2\n"
"                        .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8172
#, no-wrap
msgid "    20 @key{RET} .05 *        4 @key{RET} .05 *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8176
msgid "Now we simply chug through the formula."
msgstr ""

#. type: group
#: ../../calc.texi:8181
#, no-wrap
msgid ""
"1:  19.7392088022    1:  394.78 +/- 19.739    1:  6316.5 +/- 706.21\n"
"    .                    .                        .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8183
#, no-wrap
msgid "    2 P 2 ^ *            20 p 1 *                 4 p .2 @key{RET} 2 ^ *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8188
msgid ""
"It turns out the @kbd{v u} command will unpack an error form as well as a "
"vector.  This saves us some retyping of numbers."
msgstr ""

#. type: group
#: ../../calc.texi:8195
#, no-wrap
msgid ""
"3:  6316.5 +/- 706.21     2:  6316.5 +/- 706.21\n"
"2:  6316.5                1:  0.1118\n"
"1:  706.21                    .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8197
#, no-wrap
msgid "    @key{RET} v u                   @key{TAB} /\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8202
msgid "Thus the volume is 6316 cubic centimeters, within about 11 percent."
msgstr ""

#. type: subsection
#: ../../calc.texi:8204
#, no-wrap
msgid "Types Tutorial Exercise 8"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8212
msgid ""
"The first answer is pretty simple: @samp{1 / (0 .. 10) = (0.1 .. inf)}.  "
"Since a number in the interval @samp{(0 .. 10)} can get arbitrarily close to "
"zero, its reciprocal can get arbitrarily large, so the answer is an interval "
"that effectively means, ``any number greater than 0.1'' but with no upper "
"bound."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8214
msgid "The second answer, similarly, is @samp{1 / (-10 .. 0) = (-inf .. -0.1)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8219
msgid ""
"Calc normally treats division by zero as an error, so that the formula "
"@w{@samp{1 / 0}} is left unsimplified.  Our third problem, @w{@samp{1 / [0 "
".. 10]}}, also (potentially) divides by zero because zero is now a member of "
"the interval.  So Calc leaves this one unevaluated, too."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8223
msgid ""
"If you turn on Infinite mode by pressing @kbd{m i}, you will instead get the "
"answer @samp{[0.1 .. inf]}, which includes infinity as a possible value."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8234
msgid ""
"The fourth calculation, @samp{1 / (-10 .. 10)}, has the same problem.  Zero "
"is buried inside the interval, but it's still a possible value.  It's not "
"hard to see that the actual result of @samp{1 / (-10 .. 10)} will be either "
"greater than @mathit{0.1}, or less than @mathit{-0.1}.  Thus the interval "
"goes from minus infinity to plus infinity, with a ``hole'' in it from "
"@mathit{-0.1} to @mathit{0.1}.  Calc doesn't have any way to represent this, "
"so it just reports @samp{[-inf .. inf]} as the answer.  It may be "
"disappointing to hear ``the answer lies somewhere between minus infinity and "
"plus infinity, inclusive,'' but that's the best that interval arithmetic can "
"do in this case."
msgstr ""

#. type: subsection
#: ../../calc.texi:8236
#, no-wrap
msgid "Types Tutorial Exercise 9"
msgstr ""

#. type: group
#: ../../calc.texi:8243
#, no-wrap
msgid ""
"1:  [-3 .. 3]       2:  [-3 .. 3]     2:  [0 .. 9]\n"
"    .               1:  [0 .. 9]      1:  [-9 .. 9]\n"
"                        .                 .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8245
#, no-wrap
msgid "    [ 3 n .. 3 ]        @key{RET} 2 ^           @key{TAB} @key{RET} *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8252
msgid ""
"In the first case the result says, ``if a number is between @mathit{-3} and "
"3, its square is between 0 and 9.'' The second case says, ``the product of "
"two numbers each between @mathit{-3} and 3 is between @mathit{-9} and 9.''"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8256
msgid ""
"An interval form is not a number; it is a symbol that can stand for many "
"different numbers.  Two identical-looking interval forms can stand for "
"different numbers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8258
msgid "The same issue arises when you try to square an error form."
msgstr ""

#. type: subsection
#: ../../calc.texi:8260
#, no-wrap
msgid "Types Tutorial Exercise 10"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8264
msgid "Testing the first number, we might arbitrarily choose 17 for @expr{x}."
msgstr ""

#. type: group
#: ../../calc.texi:8270
#, no-wrap
msgid ""
"1:  17 mod 811749613   2:  17 mod 811749613   1:  533694123 mod 811749613\n"
"    .                      811749612              .\n"
"                           .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8272
#, no-wrap
msgid "    17 M 811749613 @key{RET}     811749612              ^\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8278
msgid ""
"Since 533694123 is (considerably) different from 1, the number 811749613 "
"must not be prime."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8283
msgid ""
"It's awkward to type the number in twice as we did above.  There are various "
"ways to avoid this, and algebraic entry is one.  In fact, using a vector "
"mapping operation we can perform several tests at once.  Let's use this "
"method to test the second number."
msgstr ""

#. type: group
#: ../../calc.texi:8289
#, no-wrap
msgid ""
"2:  [17, 42, 100000]               1:  [1 mod 15485863, 1 mod ... ]\n"
"1:  15485863                           .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8291
#, no-wrap
msgid ""
" [17 42 100000] 15485863 @key{RET}           V M ' ($$ mod $)^($-1) "
"@key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8297
msgid ""
"The result is three ones (modulo @expr{n}), so it's very probable that "
"15485863 is prime.  (In fact, this number is the millionth prime.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8301
msgid ""
"Note that the functions @samp{($$^($-1)) mod $} or @samp{$$^($-1) % $} would "
"have been hopelessly inefficient, since they would have calculated the power "
"using full integer arithmetic."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8306
msgid ""
"Calc has a @kbd{k p} command that does primality testing.  For small numbers "
"it does an exact test; for large numbers it uses a variant of the Fermat "
"test we used here.  You can use @kbd{k p} repeatedly to prove that a large "
"integer is prime with any desired probability."
msgstr ""

#. type: subsection
#: ../../calc.texi:8308
#, no-wrap
msgid "Types Tutorial Exercise 11"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8314
msgid ""
"There are several ways to insert a calculated number into an HMS form.  One "
"way to convert a number of seconds to an HMS form is simply to multiply the "
"number by an HMS form representing one second:"
msgstr ""

#. type: group
#: ../../calc.texi:8320
#, no-wrap
msgid ""
"1:  31415926.5359     2:  31415926.5359     1:  8726@@ 38' 46.5359\"\n"
"    .                 1:  0@@ 0' 1\"              .\n"
"                          .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8322
#, no-wrap
msgid ""
"    P 1e7 *               0@@ 0' 1\"              *\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8331
#, no-wrap
msgid ""
"2:  8726@@ 38' 46.5359\"             1:  6@@ 6' 2.5359\" mod 24@@ 0' 0\"\n"
"1:  15@@ 27' 16\" mod 24@@ 0' 0\"          .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8333
#, no-wrap
msgid "    x time @key{RET}                         +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8338
msgid "It will be just after six in the morning."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8341
msgid "The algebraic @code{hms} function can also be used to build an HMS form:"
msgstr ""

#. type: group
#: ../../calc.texi:8346
#, no-wrap
msgid ""
"1:  hms(0, 0, 10000000. pi)       1:  8726@@ 38' 46.5359\"\n"
"    .                                 .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8348
#, no-wrap
msgid "  ' hms(0, 0, 1e7 pi) @key{RET}             =\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8354
msgid ""
"The @kbd{=} key is necessary to evaluate the symbol @samp{pi} to the actual "
"number 3.14159..."
msgstr ""

#. type: subsection
#: ../../calc.texi:8356
#, no-wrap
msgid "Types Tutorial Exercise 12"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8361
msgid "As we recall, there are 17 songs of about 2 minutes and 47 seconds each."
msgstr ""

#. type: group
#: ../../calc.texi:8367
#, no-wrap
msgid ""
"2:  0@@ 2' 47\"                    1:  [0@@ 3' 7\" .. 0@@ 3' 47\"]\n"
"1:  [0@@ 0' 20\" .. 0@@ 1' 0\"]          .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8369
#, no-wrap
msgid ""
"    [ 0@@ 20\" .. 0@@ 1' ]              +\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8377
#, no-wrap
msgid ""
"1:  [0@@ 52' 59.\" .. 1@@ 4' 19.\"]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8379
#, no-wrap
msgid "    17 *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8384
msgid "No matter how long it is, the album will fit nicely on one CD."
msgstr ""

#. type: subsection
#: ../../calc.texi:8386
#, no-wrap
msgid "Types Tutorial Exercise 13"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8390
msgid ""
"Type @kbd{' 1 yr @key{RET} u c s @key{RET}}.  The answer is 31557600 "
"seconds."
msgstr ""

#. type: subsection
#: ../../calc.texi:8392
#, no-wrap
msgid "Types Tutorial Exercise 14"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8397
msgid ""
"How long will it take for a signal to get from one end of the computer to "
"the other?"
msgstr ""

#. type: group
#: ../../calc.texi:8402
#, no-wrap
msgid ""
"1:  m / c         1:  3.3356 ns\n"
"    .                 .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8404
#, no-wrap
msgid " ' 1 m / c @key{RET}        u c ns @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8409
msgid "(Recall, @samp{c} is a ``unit'' corresponding to the speed of light.)"
msgstr ""

#. type: group
#: ../../calc.texi:8415
#, no-wrap
msgid ""
"1:  3.3356 ns     1:  0.81356\n"
"2:  4.1 ns            .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8417
#, no-wrap
msgid "  ' 4.1 ns @key{RET}        /\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8424
msgid ""
"Thus a signal could take up to 81 percent of a clock cycle just to go from "
"one place to another inside the computer, assuming the signal could actually "
"attain the full speed of light.  Pretty tight!"
msgstr ""

#. type: subsection
#: ../../calc.texi:8426
#, no-wrap
msgid "Types Tutorial Exercise 15"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8431
msgid ""
"The speed limit is 55 miles per hour on most highways.  We want to find the "
"ratio of Sam's speed to the US speed limit."
msgstr ""

#. type: group
#: ../../calc.texi:8437
#, no-wrap
msgid ""
"1:  55 mph         2:  55 mph           3:  11 hr mph / yd\n"
"    .              1:  5 yd / hr            .\n"
"                       .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8439
#, no-wrap
msgid "  ' 55 mph @key{RET}       ' 5 yd/hr @key{RET}          /\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8445
msgid ""
"The @kbd{u s} command cancels out these units to get a plain number.  Now we "
"take the logarithm base two to find the final answer, assuming that each "
"successive pill doubles his speed."
msgstr ""

#. type: group
#: ../../calc.texi:8451
#, no-wrap
msgid ""
"1:  19360.       2:  19360.       1:  14.24\n"
"    .            1:  2                .\n"
"                     .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8453
#, no-wrap
msgid "    u s              2                B\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8458
msgid "Thus Sam can take up to 14 pills without a worry."
msgstr ""

#. type: subsection
#: ../../calc.texi:8460
#, no-wrap
msgid "Algebra Tutorial Exercise 1"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8470
msgid ""
"The result @samp{sqrt(x)^2} is simplified back to @expr{x} by the "
"Calculator, but @samp{sqrt(x^2)} is not.  (Consider what happens if "
"@w{@expr{x = -4}}.)  If @expr{x} is real, this formula could be simplified "
"to @samp{abs(x)}, but for general complex arguments even that is not safe.  "
"(@xref{Declarations}, for a way to tell Calc that @expr{x} is known to be "
"real.)"
msgstr ""

#. type: subsection
#: ../../calc.texi:8472
#, no-wrap
msgid "Algebra Tutorial Exercise 2"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8480
msgid ""
"Suppose our roots are @expr{[a, b, c]}.  We want a polynomial which is zero "
"when @expr{x} is any of these values.  The trivial polynomial @expr{x-a} is "
"zero when @expr{x=a}, so the product @expr{(x-a)(x-b)(x-c)} will do the "
"job.  We can use @kbd{a c x} to write this in a more familiar form."
msgstr ""

#. type: group
#: ../../calc.texi:8485
#, no-wrap
msgid ""
"1:  34 x - 24 x^3          1:  [1.19023, -1.19023, 0]\n"
"    .                          .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8487
#, no-wrap
msgid ""
"    r 2                        a P x @key{RET}\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8495
#, no-wrap
msgid ""
"1:  [x - 1.19023, x + 1.19023, x]     1:  x*(x + 1.19023) (x - 1.19023)\n"
"    .                                     .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8497
#, no-wrap
msgid ""
"    V M ' x-$ @key{RET}                         V R *\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8505
#, no-wrap
msgid ""
"1:  x^3 - 1.41666 x        1:  34 x - 24 x^3\n"
"    .                          .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8507
#, no-wrap
msgid "    a c x @key{RET}                  24 n *  a x\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8513
msgid ""
"Sure enough, our answer (multiplied by a suitable constant) is the same as "
"the original polynomial."
msgstr ""

#. type: subsection
#: ../../calc.texi:8515
#, no-wrap
msgid "Algebra Tutorial Exercise 3"
msgstr ""

#. type: group
#: ../../calc.texi:8521
#, no-wrap
msgid ""
"1:  x sin(pi x)         1:  sin(pi x) / pi^2 - x cos(pi x) / pi\n"
"    .                       .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8523
#, no-wrap
msgid ""
"  ' x sin(pi x) @key{RET}   m r   a i x @key{RET}\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8532
#, no-wrap
msgid ""
"1:  [y, 1]\n"
"2:  sin(pi x) / pi^2 - x cos(pi x) / pi\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8534
#, no-wrap
msgid ""
"  ' [y,1] @key{RET} @key{TAB}\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8542
#, no-wrap
msgid ""
"1:  [sin(pi y) / pi^2 - y cos(pi y) / pi, 1 / pi]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8544
#, no-wrap
msgid ""
"    V M $ @key{RET}\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8552
#, no-wrap
msgid ""
"1:  sin(pi y) / pi^2 - y cos(pi y) / pi - 1 / pi\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8554
#, no-wrap
msgid ""
"    V R -\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8562
#, no-wrap
msgid ""
"1:  sin(3.14159 y) / 9.8696 - y cos(3.14159 y) / 3.14159 - 0.3183\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8564
#, no-wrap
msgid ""
"    =\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8572
#, no-wrap
msgid ""
"1:  [0., -0.95493, 0.63662, -1.5915, 1.2732]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8574
#, no-wrap
msgid "    v x 5 @key{RET}  @key{TAB}  V M $ @key{RET}\n"
msgstr ""

#. type: subsection
#: ../../calc.texi:8578
#, no-wrap
msgid "Algebra Tutorial Exercise 4"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8585
msgid ""
"The hard part is that @kbd{V R +} is no longer sufficient to add up all the "
"contributions from the slices, since the slices have varying coefficients.  "
"So first we must come up with a vector of these coefficients.  Here's one "
"way:"
msgstr ""

#. type: group
#: ../../calc.texi:8591
#, no-wrap
msgid ""
"2:  -1                 2:  3                    1:  [4, 2, ..., 4]\n"
"1:  [1, 2, ..., 9]     1:  [-1, 1, ..., -1]         .\n"
"    .                      .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8593
#, no-wrap
msgid ""
"    1 n v x 9 @key{RET}          V M ^  3 @key{TAB}             -\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8601
#, no-wrap
msgid ""
"1:  [4, 2, ..., 4, 1]      1:  [1, 4, 2, ..., 4, 1]\n"
"    .                          .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8603
#, no-wrap
msgid "    1 |                        1 @key{TAB} |\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8609
msgid ""
"Now we compute the function values.  Note that for this method we need "
"eleven values, including both endpoints of the desired interval."
msgstr ""

#. type: group
#: ../../calc.texi:8615
#, no-wrap
msgid ""
"2:  [1, 4, 2, ..., 4, 1]\n"
"1:  [1, 1.1, 1.2,  ...  , 1.8, 1.9, 2.]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8617
#, no-wrap
msgid ""
" 11 @key{RET} 1 @key{RET} .1 @key{RET}  C-u v x\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8626
#, no-wrap
msgid ""
"2:  [1, 4, 2, ..., 4, 1]\n"
"1:  [0., 0.084941, 0.16993, ... ]\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8628
#, no-wrap
msgid "    ' sin(x) ln(x) @key{RET}   m r  p 5 @key{RET}   V M $ @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8634
msgid ""
"Once again this calls for @kbd{V M * V R +}; a simple @kbd{*} does the same "
"thing."
msgstr ""

#. type: group
#: ../../calc.texi:8639
#, no-wrap
msgid ""
"1:  11.22      1:  1.122      1:  0.374\n"
"    .              .              .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8641
#, no-wrap
msgid "    *              .1 *           3 /\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8646
msgid "Wow! That's even better than the result from the Taylor series method."
msgstr ""

#. type: subsection
#: ../../calc.texi:8648
#, no-wrap
msgid "Rewrites Tutorial Exercise 1"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8652
msgid "We'll use Big mode to make the formulas more readable."
msgstr ""

#. type: group
#: ../../calc.texi:8660
#, no-wrap
msgid ""
"                                           ___\n"
"                                          V 2  + 2\n"
"1:  (2 + sqrt(2)) / (1 + sqrt(2))     1:  ---------\n"
"    .                                      ___\n"
"                                          V 2  + 1\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8662
#, no-wrap
msgid ""
"                                          .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8664
#, no-wrap
msgid "  ' (2+sqrt(2)) / (1+sqrt(2)) @key{RET}         d B\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8669
msgid "Multiplying by the conjugate helps because @expr{(a+b) (a-b) = a^2 - b^2}."
msgstr ""

#. type: group
#: ../../calc.texi:8675
#, no-wrap
msgid ""
"          ___    ___\n"
"1:  (2 + V 2 ) (V 2  - 1)\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8677
#, no-wrap
msgid ""
"  a r a/(b+c) := a*(b-c) / (b^2-c^2) @key{RET}\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8686
#, no-wrap
msgid ""
"     ___\n"
"1:  V 2\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:8688
#, no-wrap
msgid "  a r a*(b+c) := a*b + a*c\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8694
msgid ""
"(We could have used @kbd{a x} instead of a rewrite rule for the second "
"step.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8698
msgid ""
"The multiply-by-conjugate rule turns out to be useful in many different "
"circumstances, such as when the denominator involves sines and cosines or "
"the imaginary constant @code{i}."
msgstr ""

#. type: subsection
#: ../../calc.texi:8700
#, no-wrap
msgid "Rewrites Tutorial Exercise 2"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8704
msgid "Here is the rule set:"
msgstr ""

#. type: group
#: ../../calc.texi:8710
#, no-wrap
msgid ""
"[ fib(n) := fib(n, 1, 1) :: integer(n) :: n >= 1,\n"
"  fib(1, x, y) := x,\n"
"  fib(n, x, y) := fib(n-1, y, x+y) ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8721
msgid ""
"The first rule turns a one-argument @code{fib} that people like to write "
"into a three-argument @code{fib} that makes computation easier.  The second "
"rule converts back from three-argument form once the computation is done.  "
"The third rule does the computation itself.  It basically says that if "
"@expr{x} and @expr{y} are two consecutive Fibonacci numbers, then @expr{y} "
"and @expr{x+y} are the next (overlapping) pair of Fibonacci numbers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8727
msgid ""
"Notice that because the number @expr{n} was ``validated'' by the conditions "
"on the first rule, there is no need to put conditions on the other rules "
"because the rule set would never get that far unless the input were valid.  "
"That further speeds computation, since no extra conditions need to be "
"checked at every step."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8734
msgid ""
"Actually, a user with a nasty sense of humor could enter a bad "
"three-argument @code{fib} call directly, say, @samp{fib(0, 1, 1)}, which "
"would get the rules into an infinite loop.  One thing that would help keep "
"this from happening by accident would be to use something like @samp{ZzFib} "
"instead of @code{fib} as the name of the three-argument function."
msgstr ""

#. type: subsection
#: ../../calc.texi:8736
#, no-wrap
msgid "Rewrites Tutorial Exercise 3"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8746
msgid ""
"He got an infinite loop.  First, Calc did as expected and rewrote @w{@samp{2 "
"+ 3 x}} to @samp{f(2, 3, x)}.  Then it looked for ways to apply the rule "
"again, and found that @samp{f(2, 3, x)} looks like @samp{a + b x} with "
"@w{@samp{a = 0}} and @samp{b = 1}, so it rewrote to @samp{f(0, 1, f(2, 3, "
"x))}.  It then wrapped another @samp{f(0, 1, ...)} around that, and so on, "
"ad infinitum.  Joe should have used @kbd{M-1 a r} to make sure the rule "
"applied only once."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8756
msgid ""
"(Actually, even the first step didn't work as he expected.  What Calc really "
"gives for @kbd{M-1 a r} in this situation is @samp{f(3 x, 1, 2)}, treating 2 "
"as the ``variable,'' and @samp{3 x} as a constant being added to it.  While "
"this may seem odd, it's just as valid a solution as the ``obvious'' one.  "
"One way to fix this would be to add the condition @samp{:: variable(x)} to "
"the rule, to make sure the thing that matches @samp{x} is indeed a variable, "
"or to change @samp{x} to @samp{quote(x)} on the lefthand side, so that the "
"rule matches the actual variable @samp{x} rather than letting @samp{x} stand "
"for something else.)"
msgstr ""

#. type: subsection
#: ../../calc.texi:8758
#, no-wrap
msgid "Rewrites Tutorial Exercise 4"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8766
msgid ""
"@tindex seq Here is a suitable set of rules to solve the first part of the "
"problem:"
msgstr ""

#. type: group
#: ../../calc.texi:8771
#, no-wrap
msgid ""
"[ seq(n, c) := seq(n/2,  c+1) :: n%2 = 0,\n"
"  seq(n, c) := seq(3n+1, c+1) :: n%2 = 1 :: n > 1 ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8776
msgid ""
"Given the initial formula @samp{seq(6, 0)}, application of these rules "
"produces the following sequence of formulas:"
msgstr ""

#. type: example
#: ../../calc.texi:8786
#, no-wrap
msgid ""
"seq( 3, 1)\n"
"seq(10, 2)\n"
"seq( 5, 3)\n"
"seq(16, 4)\n"
"seq( 8, 5)\n"
"seq( 4, 6)\n"
"seq( 2, 7)\n"
"seq( 1, 8)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8790
msgid "whereupon neither of the rules match, and rewriting stops."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8792
msgid "We can pretty this up a bit with a couple more rules:"
msgstr ""

#. type: group
#: ../../calc.texi:8798
#, no-wrap
msgid ""
"[ seq(n) := seq(n, 0),\n"
"  seq(1, c) := c,\n"
"  ... ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8804
msgid ""
"Now, given @samp{seq(6)} as the starting configuration, we get 8 as the "
"result."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8806
msgid "The change to return a vector is quite simple:"
msgstr ""

#. type: group
#: ../../calc.texi:8813
#, no-wrap
msgid ""
"[ seq(n) := seq(n, []) :: integer(n) :: n > 0,\n"
"  seq(1, v) := v | 1,\n"
"  seq(n, v) := seq(n/2,  v | n) :: n%2 = 0,\n"
"  seq(n, v) := seq(3n+1, v | n) :: n%2 = 1 ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8818
msgid "Given @samp{seq(6)}, the result is @samp{[6, 3, 10, 5, 16, 8, 4, 2, 1]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8823
msgid ""
"Notice that the @expr{n > 1} guard is no longer necessary on the last rule "
"since the @expr{n = 1} case is now detected by another rule.  But a guard "
"has been added to the initial rule to make sure the initial value is "
"suitable before the computation begins."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8829
msgid ""
"While still a good idea, this guard is not as vitally important as it was "
"for the @code{fib} function, since calling, say, @samp{seq(x, [])} will not "
"get into an infinite loop.  Calc will not be able to prove the symbol "
"@samp{x} is either even or odd, so none of the rules will apply and the "
"rewrites will stop right away."
msgstr ""

#. type: subsection
#: ../../calc.texi:8831
#, no-wrap
msgid "Rewrites Tutorial Exercise 5"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8841
msgid ""
"@tindex nterms If @expr{x} is the sum @expr{a + b}, then "
"`@tfn{nterms(}@var{x}@tfn{)}' must be `@tfn{nterms(}@var{a}@tfn{)}' plus "
"`@tfn{nterms(}@var{b}@tfn{)}'.  If @expr{x} is not a sum, then "
"`@tfn{nterms(}@var{x}@tfn{)}' = 1."
msgstr ""

#. type: group
#: ../../calc.texi:8846
#, no-wrap
msgid ""
"[ nterms(a + b) := nterms(a) + nterms(b),\n"
"  nterms(x)     := 1 ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8853
msgid ""
"Here we have taken advantage of the fact that earlier rules always match "
"before later rules; @samp{nterms(x)} will only be tried if we already know "
"that @samp{x} is not a sum."
msgstr ""

#. type: subsection
#: ../../calc.texi:8855
#, no-wrap
msgid "Rewrites Tutorial Exercise 6"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8859
msgid "Here is a rule set that will do the job:"
msgstr ""

#. type: group
#: ../../calc.texi:8870
#, no-wrap
msgid ""
"[ a*(b + c) := a*b + a*c,\n"
"  opt(a) O(x^n) + opt(b) O(x^m) := O(x^n) :: n <= m\n"
"     :: constant(a) :: constant(b),\n"
"  opt(a) O(x^n) + opt(b) x^m := O(x^n) :: n <= m\n"
"     :: constant(a) :: constant(b),\n"
"  a O(x^n) := O(x^n) :: constant(a),\n"
"  x^opt(m) O(x^n) := O(x^(n+m)),\n"
"  O(x^n) O(x^m) := O(x^(n+m)) ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8877
msgid ""
"If we really want the @kbd{+} and @kbd{*} keys to operate naturally on power "
"series, we should put these rules in @code{EvalRules}.  For testing "
"purposes, it is better to put them in a different variable, say, @code{O}, "
"first."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8883
msgid ""
"The first rule just expands products of sums so that the rest of the rules "
"can assume they have an expanded-out polynomial to work with.  Note that "
"this rule does not mention @samp{O} at all, so it will apply to any "
"product-of-sum it encounters---this rule may surprise you if you put it into "
"@code{EvalRules}!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8888
msgid ""
"In the second rule, the sum of two O's is changed to the smaller O@.  The "
"optional constant coefficients are there mostly so that @samp{O(x^2) - "
"O(x^3)} and @samp{O(x^3) - O(x^2)} are handled as well as @samp{O(x^2) + "
"O(x^3)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8890
msgid "The third rule absorbs higher powers of @samp{x} into O's."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8894
msgid ""
"The fourth rule says that a constant times a negligible quantity is still "
"negligible.  (This rule will also match @samp{O(x^3) / 4}, with @samp{a = "
"1/4}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8900
msgid ""
"The fifth rule rewrites, for example, @samp{x^2 O(x^3)} to @samp{O(x^5)}.  "
"(It is easy to see that if one of these forms is negligible, the other is, "
"too.)  Notice the @samp{x^opt(m)} to pick up terms like @w{@samp{x "
"O(x^3)}}.  Optional powers will match @samp{x} as @samp{x^1} but not 1 as "
"@samp{x^0}.  This turns out to be exactly what we want here."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8902
msgid "The sixth rule is the corresponding rule for products of two O's."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8914
msgid ""
"Another way to solve this problem would be to create a new ``data type'' "
"that represents truncated power series.  We might represent these as "
"function calls @samp{series(@var{coefs}, @var{x})} where @var{coefs} is a "
"vector of coefficients for @expr{x^0}, @expr{x^1}, @expr{x^2}, and so on.  "
"Rules would exist for sums and products of such @code{series} objects, and "
"as an optional convenience could also know how to combine a @code{series} "
"object with a normal polynomial.  (With this, and with a rule that rewrites "
"@samp{O(x^n)} to the equivalent @code{series} form, you could still enter "
"power series in exactly the same notation as before.)  Operations on such "
"objects would probably be more efficient, although the objects would be a "
"bit harder to read."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8928
msgid ""
"Some other symbolic math programs provide a power series data type similar "
"to this.  Mathematica, for example, has an object that looks like "
"@samp{PowerSeries[@var{x}, @var{x0}, @var{coefs}, @var{nmin}, @var{nmax}, "
"@var{den}]}, where @var{x0} is the point about which the power series is "
"taken (we've been assuming this was always zero), and @var{nmin}, "
"@var{nmax}, and @var{den} allow pseudo-power-series with fractional or "
"negative powers.  Also, the @code{PowerSeries} objects have a special "
"display format that makes them look like @samp{2 x^2 + O(x^4)} when they are "
"printed out.  (@xref{Compositions}, for a way to do this in Calc, although "
"for something as involved as this it would probably be better to write the "
"formatting routine in Lisp.)"
msgstr ""

#. type: subsection
#: ../../calc.texi:8930
#, no-wrap
msgid "Programming Tutorial Exercise 1"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8938
msgid ""
"Just enter the formula @samp{ninteg(sin(t)/t, t, 0, x)}, type @kbd{Z F}, and "
"answer the questions.  Since this formula contains two variables, the "
"default argument list will be @samp{(t x)}.  We want to change this to "
"@samp{(x)} since @expr{t} is really a dummy variable to be used within "
"@code{ninteg}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8941
msgid ""
"The exact keystrokes are @kbd{Z F s Si @key{RET} @key{RET} C-b C-b @key{DEL} "
"@key{DEL} @key{RET} y}.  (The @kbd{C-b C-b @key{DEL} @key{DEL}} are what fix "
"the argument list.)"
msgstr ""

#. type: subsection
#: ../../calc.texi:8943
#, no-wrap
msgid "Programming Tutorial Exercise 2"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8948
msgid ""
"One way is to move the number to the top of the stack, operate on it, then "
"move it back: @kbd{C-x ( M-@key{TAB} n M-@key{TAB} M-@key{TAB} C-x )}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8951
msgid ""
"Another way is to negate the top three stack entries, then negate again the "
"top two stack entries: @kbd{C-x ( M-3 n M-2 n C-x )}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8955
msgid ""
"Finally, it turns out that a negative prefix argument causes a command like "
"@kbd{n} to operate on the specified stack entry only, which is just what we "
"want: @kbd{C-x ( M-- 3 n C-x )}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8958
msgid ""
"Just for kicks, let's also do it algebraically: @w{@kbd{C-x ( ' -$$$, $$, $ "
"@key{RET} C-x )}}."
msgstr ""

#. type: subsection
#: ../../calc.texi:8960
#, no-wrap
msgid "Programming Tutorial Exercise 3"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8965
msgid ""
"Each of these functions can be computed using the stack, or using algebraic "
"entry, whichever way you prefer:"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8970
msgid ""
"Computing @texline @math{\\displaystyle{\\sin x \\over x}}: @infoline "
"@expr{sin(x) / x}:"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8972
msgid "Using the stack: @kbd{C-x ( @key{RET} S @key{TAB} / C-x )}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8974
msgid "Using algebraic entry: @kbd{C-x ( ' sin($)/$ @key{RET} C-x )}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8977
msgid "Computing the logarithm:"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8979
msgid "Using the stack: @kbd{C-x ( @key{TAB} B C-x )}"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8981
msgid "Using algebraic entry: @kbd{C-x ( ' log($,$$) @key{RET} C-x )}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:8984
msgid "Computing the vector of integers:"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8988
msgid ""
"Using the stack: @kbd{C-x ( 1 @key{RET} 1 C-u v x C-x )}.  (Recall that "
"@kbd{C-u v x} takes the vector size, starting value, and increment from the "
"stack.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8992
msgid ""
"Alternatively: @kbd{C-x ( ~ v x C-x )}.  (The @kbd{~} key pops a number from "
"the stack and uses it as the prefix argument for the next command.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:8994
msgid "Using algebraic entry: @kbd{C-x ( ' index($) @key{RET} C-x )}."
msgstr ""

#. type: subsection
#: ../../calc.texi:8996
#, no-wrap
msgid "Programming Tutorial Exercise 4"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9000
msgid "Here's one way: @kbd{C-x ( @key{RET} V R + @key{TAB} v l / C-x )}."
msgstr ""

#. type: subsection
#: ../../calc.texi:9002
#, no-wrap
msgid "Programming Tutorial Exercise 5"
msgstr ""

#. type: group
#: ../../calc.texi:9009
#, no-wrap
msgid ""
"2:  1              1:  1.61803398502         2:  1.61803398502\n"
"1:  20                 .                     1:  1.61803398875\n"
"    .                                            .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9011
#, no-wrap
msgid "   1 @key{RET} 20         Z < & 1 + Z >                I H P\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9016
msgid "This answer is quite accurate."
msgstr ""

#. type: subsection
#: ../../calc.texi:9018
#, no-wrap
msgid "Programming Tutorial Exercise 6"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9022
msgid "Here is the matrix:"
msgstr ""

#. type: example
#: ../../calc.texi:9026
#, no-wrap
msgid ""
"[ [ 0, 1 ]   * [a, b] = [b, a + b]\n"
"  [ 1, 1 ] ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9031
msgid ""
"Thus @samp{[0, 1; 1, 1]^n * [1, 1]} computes Fibonacci numbers @expr{n+1} "
"and @expr{n+2}.  Here's one program that does the job:"
msgstr ""

#. type: example
#: ../../calc.texi:9034
#, no-wrap
msgid "C-x ( ' [0, 1; 1, 1] ^ ($-1) * [1, 1] @key{RET} v u @key{DEL} C-x )\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9045
msgid ""
"This program is quite efficient because Calc knows how to raise a matrix (or "
"other value) to the power @expr{n} in only @texline @math{\\log_2 n} "
"@infoline @expr{log(n,2)} steps.  For example, this program can compute the "
"1000th Fibonacci number (a 209-digit integer!)@: in about 10 steps; even "
"though the @kbd{Z < ... Z >} solution had much simpler steps, it would have "
"required so many steps that it would not have been practical."
msgstr ""

#. type: subsection
#: ../../calc.texi:9047
#, no-wrap
msgid "Programming Tutorial Exercise 7"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9053
msgid ""
"The trick here is to compute the harmonic numbers differently, so that the "
"loop counter itself accumulates the sum of reciprocals.  We use a separate "
"variable to hold the integer counter."
msgstr ""

#. type: group
#: ../../calc.texi:9059
#, no-wrap
msgid ""
"1:  1          2:  1       1:  .\n"
"    .          1:  4\n"
"                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9061
#, no-wrap
msgid "    1 t 1       1 @key{RET} 4      Z ( t 2 r 1 1 + s 1 & Z )\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9072
msgid ""
"The body of the loop goes as follows: First save the harmonic sum so far in "
"variable 2.  Then delete it from the stack; the for loop itself will take "
"care of remembering it for us.  Next, recall the count from variable 1, add "
"one to it, and feed its reciprocal to the for loop to use as the step "
"value.  The for loop will increase the ``loop counter'' by that amount and "
"keep going until the loop counter exceeds 4."
msgstr ""

#. type: group
#: ../../calc.texi:9079
#, no-wrap
msgid ""
"2:  31                  3:  31\n"
"1:  3.99498713092       2:  3.99498713092\n"
"    .                   1:  4.02724519544\n"
"                            .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9081
#, no-wrap
msgid "    r 1 r 2                 @key{RET} 31 & +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9086
msgid ""
"Thus we find that the 30th harmonic number is 3.99, and the 31st harmonic "
"number is 4.02."
msgstr ""

#. type: subsection
#: ../../calc.texi:9088
#, no-wrap
msgid "Programming Tutorial Exercise 8"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9095
msgid ""
"The first step is to compute the derivative @expr{f'(x)} and thus the "
"formula @texline @math{\\displaystyle{x - {f(x) \\over f'(x)}}}.  @infoline "
"@expr{x - f(x)/f'(x)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9102 ../../calc.texi:9224 ../../calc.texi:9345
msgid ""
"(Because this definition is long, it will be repeated in concise form "
"below.  You can use @w{@kbd{C-x * m}} to load it from there.  While you are "
"entering a @kbd{Z ` Z '} body in a macro, Calc simply collects keystrokes "
"without executing them.  In the following diagrams we'll pretend Calc "
"actually executed the keystrokes as you typed them, just for purposes of "
"illustration.)"
msgstr ""

#. type: group
#: ../../calc.texi:9109
#, no-wrap
msgid ""
"2:  sin(cos(x)) - 0.5            3:  4.5\n"
"1:  4.5                          2:  sin(cos(x)) - 0.5\n"
"    .                            1:  -(sin(x) cos(cos(x)))\n"
"                                     .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9111
#, no-wrap
msgid ""
"' sin(cos(x))-0.5 @key{RET} 4.5  m r  C-x ( Z `  @key{TAB} @key{RET} a d x "
"@key{RET}\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9120
#, no-wrap
msgid ""
"2:  4.5\n"
"1:  x + (sin(cos(x)) - 0.5) / sin(x) cos(cos(x))\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9122
#, no-wrap
msgid "    /  ' x @key{RET} @key{TAB} -   t 1\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9129
msgid ""
"Now, we enter the loop.  We'll use a repeat loop with a 20-repetition limit "
"just in case the method fails to converge for some reason.  (Normally, the "
"@w{@kbd{Z /}} command will stop the loop before all 20 repetitions are "
"done.)"
msgstr ""

#. type: group
#: ../../calc.texi:9136
#, no-wrap
msgid ""
"1:  4.5         3:  4.5                     2:  4.5\n"
"    .           2:  x + (sin(cos(x)) ...    1:  5.24196456928\n"
"                1:  4.5                         .\n"
"                    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9138
#, no-wrap
msgid "  20 Z <          @key{RET} r 1 @key{TAB}                 s l x @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9143
msgid ""
"This is the new guess for @expr{x}.  Now we compare it with the old one to "
"see if we've converged."
msgstr ""

#. type: group
#: ../../calc.texi:9150
#, no-wrap
msgid ""
"3:  5.24196     2:  5.24196     1:  5.24196     1:  5.26345856348\n"
"2:  5.24196     1:  0               .               .\n"
"1:  4.5             .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9152
#, no-wrap
msgid ""
"  @key{RET} M-@key{TAB}         a =             Z /             Z > Z ' C-x "
")\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9157
msgid ""
"The loop converges in just a few steps to this value.  To check the result, "
"we can simply substitute it back into the equation."
msgstr ""

#. type: group
#: ../../calc.texi:9163
#, no-wrap
msgid ""
"2:  5.26345856348\n"
"1:  0.499999999997\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9165
#, no-wrap
msgid " @key{RET} ' sin(cos($)) @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9169
msgid "Let's test the new definition again:"
msgstr ""

#. type: group
#: ../../calc.texi:9175
#, no-wrap
msgid ""
"2:  x^2 - 9           1:  3.\n"
"1:  1                     .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9177
#, no-wrap
msgid "  ' x^2-9 @key{RET} 1           X\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9181
msgid "Once again, here's the full Newton's Method definition:"
msgstr ""

#. type: group
#: ../../calc.texi:9190
#, no-wrap
msgid ""
"C-x ( Z `  @key{TAB} @key{RET} a d x @key{RET}  /  ' x @key{RET} @key{TAB} -  "
"t 1\n"
"           20 Z <  @key{RET} r 1 @key{TAB}  s l x @key{RET}\n"
"                   @key{RET} M-@key{TAB}  a =  Z /\n"
"              Z >\n"
"      Z '\n"
"C-x )\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9197
msgid ""
"It turns out that Calc has a built-in command for applying a formula "
"repeatedly until it converges to a number.  @xref{Nesting and Fixed Points}, "
"to see how to use it."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9202
msgid ""
"Also, of course, @kbd{a R} is a built-in command that uses Newton's method "
"(among others) to look for numerical solutions to any equation.  @xref{Root "
"Finding}."
msgstr ""

#. type: subsection
#: ../../calc.texi:9204
#, no-wrap
msgid "Programming Tutorial Exercise 9"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9217
msgid ""
"The first step is to adjust @expr{z} to be greater than 5.  A simple ``for'' "
"loop will do the job here.  If @expr{z} is less than 5, we reduce the "
"problem using @texline @math{\\psi(z) = \\psi(z+1) - 1/z}.  @infoline "
"@expr{psi(z) = psi(z+1) - 1/z}.  We go on to compute @texline "
"@math{\\psi(z+1)}, @infoline @expr{psi(z+1)}, and remember to add back a "
"factor of @expr{-1/z} when we're done.  This step is repeated until @expr{z "
"> 5}."
msgstr ""

#. type: group
#: ../../calc.texi:9229
#, no-wrap
msgid ""
"1:  1.             1:  1.\n"
"    .                  .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9231
#, no-wrap
msgid " 1.0 @key{RET}       C-x ( Z `  s 1  0 t 2\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9236
msgid ""
"Here, variable 1 holds @expr{z} and variable 2 holds the adjustment factor.  "
"If @expr{z < 5}, we use a loop to increase it."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9241
msgid ""
"(By the way, we started with @samp{1.0} instead of the integer 1 because "
"otherwise the calculation below will try to do exact fractional arithmetic, "
"and will never converge because fractions compare equal only if they are "
"exactly equal, not just equal to within the current precision.)"
msgstr ""

#. type: group
#: ../../calc.texi:9248
#, no-wrap
msgid ""
"3:  1.      2:  1.       1:  6.\n"
"2:  1.      1:  1            .\n"
"1:  5           .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9250
#, no-wrap
msgid "  @key{RET} 5        a <    Z [  5 Z (  & s + 2  1 s + 1  1 Z ) r 1  Z ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9257
msgid ""
"Now we compute the initial part of the sum: @texline @math{\\ln z - {1 "
"\\over 2z}} @infoline @expr{ln(z) - 1/2z} minus the adjustment factor."
msgstr ""

#. type: group
#: ../../calc.texi:9263
#, no-wrap
msgid ""
"2:  1.79175946923      2:  1.7084261359      1:  -0.57490719743\n"
"1:  0.0833333333333    1:  2.28333333333         .\n"
"    .                      .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9265
#, no-wrap
msgid "    L  r 1 2 * &           -  r 2                -\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9271
msgid ""
"Now we evaluate the series.  We'll use another ``for'' loop counting up the "
"value of @expr{2 n}.  (Calc does have a summation command, @kbd{a +}, but "
"we'll use loops just to get more practice with them.)"
msgstr ""

#. type: group
#: ../../calc.texi:9279
#, no-wrap
msgid ""
"3:  -0.5749       3:  -0.5749        4:  -0.5749      2:  -0.5749\n"
"2:  2             2:  1:6            3:  1:6          1:  2.3148e-3\n"
"1:  40            1:  2              2:  2                .\n"
"    .                 .              1:  36.\n"
"                                         .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9281
#, no-wrap
msgid ""
"   2 @key{RET} 40        Z ( @key{RET} k b @key{TAB}     @key{RET} r 1 "
"@key{TAB} ^      * /\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9291
#, no-wrap
msgid ""
"3:  -0.5749       3:  -0.5772      2:  -0.5772     1:  -0.577215664892\n"
"2:  -0.5749       2:  -0.5772      1:  0               .\n"
"1:  2.3148e-3     1:  -0.5749          .\n"
"    .                 .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9293
#, no-wrap
msgid ""
"  @key{TAB} @key{RET} M-@key{TAB}       - @key{RET} M-@key{TAB}      a =     "
"Z /    2  Z )  Z ' C-x )\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9301
msgid ""
"This is the value of @texline @math{-\\gamma}, @infoline @expr{- gamma}, "
"with a slight bit of roundoff error.  To get a full 12 digits, let's use a "
"higher precision:"
msgstr ""

#. type: group
#: ../../calc.texi:9306
#, no-wrap
msgid ""
"2:  -0.577215664892      2:  -0.577215664892\n"
"1:  1.                   1:  -0.577215664901532\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9308
#, no-wrap
msgid "    1. @key{RET}                   p 16 @key{RET} X\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9312
msgid "Here's the complete sequence of keystrokes:"
msgstr ""

#. type: group
#: ../../calc.texi:9323
#, no-wrap
msgid ""
"C-x ( Z `  s 1  0 t 2\n"
"           @key{RET} 5 a <  Z [  5 Z (  & s + 2  1 s + 1  1 Z ) r 1  Z ]\n"
"           L r 1 2 * & - r 2 -\n"
"           2 @key{RET} 40  Z (  @key{RET} k b @key{TAB} @key{RET} r 1 "
"@key{TAB} ^ * /\n"
"                          @key{TAB} @key{RET} M-@key{TAB} - @key{RET} "
"M-@key{TAB} a = Z /\n"
"                  2  Z )\n"
"      Z '\n"
"C-x )\n"
msgstr ""

#. type: subsection
#: ../../calc.texi:9327
#, no-wrap
msgid "Programming Tutorial Exercise 10"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9338
msgid ""
"Taking the derivative of a term of the form @expr{x^n} will produce a term "
"like @texline @math{n x^{n-1}}.  @infoline @expr{n x^(n-1)}.  Taking the "
"derivative of a constant produces zero.  From this it is easy to see that "
"the @expr{n}th derivative of a polynomial, evaluated at @expr{x = 0}, will "
"equal the coefficient on the @expr{x^n} term times @expr{n!}."
msgstr ""

#. type: group
#: ../../calc.texi:9352
#, no-wrap
msgid ""
"2:  5 x^4 + (x + 1)^2          3:  5 x^4 + (x + 1)^2\n"
"1:  6                          2:  0\n"
"    .                          1:  6\n"
"                                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9354
#, no-wrap
msgid "  ' 5 x^4 + (x+1)^2 @key{RET} 6        C-x ( Z `  [ ] t 1  0 @key{TAB}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9359
msgid "Variable 1 will accumulate the vector of coefficients."
msgstr ""

#. type: group
#: ../../calc.texi:9366
#, no-wrap
msgid ""
"2:  0              3:  0                  2:  5 x^4 + ...\n"
"1:  5 x^4 + ...    2:  5 x^4 + ...        1:  1\n"
"    .              1:  1                      .\n"
"                       .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9368
#, no-wrap
msgid ""
"   Z ( @key{TAB}         @key{RET} 0 s l x @key{RET}            M-@key{TAB} "
"! /  s | 1\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9375
msgid ""
"Note that @kbd{s | 1} appends the top-of-stack value to the vector in a "
"variable; it is completely analogous to @kbd{s + 1}.  We could have written "
"instead, @kbd{r 1 @key{TAB} | t 1}."
msgstr ""

#. type: group
#: ../../calc.texi:9380
#, no-wrap
msgid ""
"1:  20 x^3 + 2 x + 2      1:  0         1:  [1, 2, 1, 0, 5, 0, 0]\n"
"    .                         .             .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9382
#, no-wrap
msgid "    a d x @key{RET}                 1 Z )         @key{DEL} r 1  Z ' C-x )\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9387
msgid ""
"To convert back, a simple method is just to map the coefficients against a "
"table of powers of @expr{x}."
msgstr ""

#. type: group
#: ../../calc.texi:9393
#, no-wrap
msgid ""
"2:  [1, 2, 1, 0, 5, 0, 0]    2:  [1, 2, 1, 0, 5, 0, 0]\n"
"1:  6                        1:  [0, 1, 2, 3, 4, 5, 6]\n"
"    .                            .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9395
#, no-wrap
msgid ""
"    6 @key{RET}                        1 + 0 @key{RET} 1 C-u v x\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9404
#, no-wrap
msgid ""
"2:  [1, 2, 1, 0, 5, 0, 0]    2:  1 + 2 x + x^2 + 5 x^4\n"
"1:  [1, x, x^2, x^3, ... ]       .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9406
#, no-wrap
msgid "    ' x @key{RET} @key{TAB} V M ^            *\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9410
msgid "Once again, here are the whole polynomial to/from vector programs:"
msgstr ""

#. type: group
#: ../../calc.texi:9419
#, no-wrap
msgid ""
"C-x ( Z `  [ ] t 1  0 @key{TAB}\n"
"           Z (  @key{TAB} @key{RET} 0 s l x @key{RET} M-@key{TAB} ! /  s | "
"1\n"
"                a d x @key{RET}\n"
"         1 Z ) r 1\n"
"      Z '\n"
"C-x )\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9421
#, no-wrap
msgid "C-x (  1 + 0 @key{RET} 1 C-u v x ' x @key{RET} @key{TAB} V M ^ *  C-x )\n"
msgstr ""

#. type: subsection
#: ../../calc.texi:9425
#, no-wrap
msgid "Programming Tutorial Exercise 11"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9432
msgid ""
"First we define a dummy program to go on the @kbd{z s} key.  The true "
"@w{@kbd{z s}} key is supposed to take two numbers from the stack and return "
"one number, so @key{DEL} as a dummy definition will make sure the stack "
"comes out right."
msgstr ""

#. type: group
#: ../../calc.texi:9438
#, no-wrap
msgid ""
"2:  4          1:  4                         2:  4\n"
"1:  2              .                         1:  2\n"
"    .                                            .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9440
#, no-wrap
msgid "  4 @key{RET} 2       C-x ( @key{DEL} C-x )  Z K s @key{RET}       2\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9447
msgid ""
"The last step replaces the 2 that was eaten during the creation of the dummy "
"@kbd{z s} command.  Now we move on to the real definition.  The recurrence "
"needs to be rewritten slightly, to the form @expr{s(n,m) = s(n-1,m-1) - "
"(n-1) s(n-1,m)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9450
msgid ""
"(Because this definition is long, it will be repeated in concise form "
"below.  You can use @kbd{C-x * m} to load it from there.)"
msgstr ""

#. type: group
#: ../../calc.texi:9458
#, no-wrap
msgid ""
"2:  4        4:  4       3:  4       2:  4\n"
"1:  2        3:  2       2:  2       1:  2\n"
"    .        2:  4       1:  0           .\n"
"             1:  2           .\n"
"                 .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9460
#, no-wrap
msgid ""
"  C-x (       M-2 @key{RET}        a =         Z [  @key{DEL} @key{DEL} 1  Z "
":\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9471
#, no-wrap
msgid ""
"4:  4       2:  4                     2:  3      4:  3    4:  3    3:  3\n"
"3:  2       1:  2                     1:  2      3:  2    3:  2    2:  2\n"
"2:  2           .                         .      2:  3    2:  3    1:  3\n"
"1:  0                                            1:  2    1:  1        .\n"
"    .                                                .        .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9473
#, no-wrap
msgid ""
"  @key{RET} 0   a = Z [  @key{DEL} @key{DEL} 0  Z :  @key{TAB} 1 - @key{TAB}   "
"M-2 @key{RET}     1 -      z s\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9479
msgid ""
"(Note that the value 3 that our dummy @kbd{z s} produces is not correct; it "
"is merely a placeholder that will do just as well for now.)"
msgstr ""

#. type: group
#: ../../calc.texi:9487
#, no-wrap
msgid ""
"3:  3               4:  3           3:  3       2:  3      1:  -6\n"
"2:  3               3:  3           2:  3       1:  9          .\n"
"1:  2               2:  3           1:  3           .\n"
"    .               1:  2               .\n"
"                        .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9489
#, no-wrap
msgid ""
" M-@key{TAB} M-@key{TAB}     @key{TAB} @key{RET} M-@key{TAB}         z s          "
"*          -\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9498
#, no-wrap
msgid ""
"1:  -6                          2:  4          1:  11      2:  11\n"
"    .                           1:  2              .       1:  11\n"
"                                    .                          .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9500
#, no-wrap
msgid ""
"  Z ] Z ] C-x )   Z K s @key{RET}      @key{DEL} 4 @key{RET} 2       z s      "
"M-@key{RET} k s\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9506
msgid ""
"Even though the result that we got during the definition was highly bogus, "
"once the definition is complete the @kbd{z s} command gets the right "
"answers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9508
msgid "Here's the full program once again:"
msgstr ""

#. type: group
#: ../../calc.texi:9520
#, no-wrap
msgid ""
"C-x (  M-2 @key{RET} a =\n"
"       Z [  @key{DEL} @key{DEL} 1\n"
"       Z :  @key{RET} 0 a =\n"
"            Z [  @key{DEL} @key{DEL} 0\n"
"            Z :  @key{TAB} 1 - @key{TAB} M-2 @key{RET} 1 - z s\n"
"                 M-@key{TAB} M-@key{TAB} @key{TAB} @key{RET} M-@key{TAB} z s "
"* -\n"
"            Z ]\n"
"       Z ]\n"
"C-x )\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9528
msgid ""
"You can read this definition using @kbd{C-x * m} (@code{read-kbd-macro})  "
"followed by @kbd{Z K s}, without having to make a dummy definition first, "
"because @code{read-kbd-macro} doesn't need to execute the definition as it "
"reads it in.  For this reason, @code{C-x * m} is often the easiest way to "
"create recursive programs in Calc."
msgstr ""

#. type: subsection
#: ../../calc.texi:9530
#, no-wrap
msgid "Programming Tutorial Exercise 12"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9535
msgid ""
"This turns out to be a much easier way to solve the problem.  Let's denote "
"Stirling numbers as calls of the function @samp{s}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9538
msgid ""
"First, we store the rewrite rules corresponding to the definition of "
"Stirling numbers in a convenient variable:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:9545
#, no-wrap
msgid ""
"s e StirlingRules @key{RET}\n"
"[ s(n,n) := 1  :: n >= 0,\n"
"  s(n,0) := 0  :: n > 0,\n"
"  s(n,m) := s(n-1,m-1) - (n-1) s(n-1,m) :: n >= m :: m >= 1 ]\n"
"C-c C-c\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9548
msgid "Now, it's just a matter of applying the rules:"
msgstr ""

#. type: group
#: ../../calc.texi:9554
#, no-wrap
msgid ""
"2:  4          1:  s(4, 2)              1:  11\n"
"1:  2              .                        .\n"
"    .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:9556
#, no-wrap
msgid ""
"  4 @key{RET} 2       C-x (  ' s($$,$) @key{RET}     a r StirlingRules "
"@key{RET}  C-x )\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9562
msgid ""
"As in the case of the @code{fib} rules, it would be useful to put these "
"rules in @code{EvalRules} and to add a @samp{:: remember} condition to the "
"last rule."
msgstr ""

#. type: tex
#: ../../calc.texi:9566
#, no-wrap
msgid "\\global\\let\\chapternofonts=\\oldchapternofonts\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9577
msgid ""
"This chapter is the beginning of the Calc reference manual.  It covers basic "
"concepts such as the stack, algebraic and numeric entry, undo, numeric "
"prefix arguments, etc."
msgstr ""

#. type: menuentry
#: ../../calc.texi:9593
msgid "Basic Commands::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:9593
msgid "Help Commands::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:9593
msgid "Stack Basics::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:9593
msgid "Numeric Entry::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:9593
msgid "Algebraic Entry::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:9593
msgid "Quick Calculator::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:9593
msgid "Prefix Arguments::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:9593
msgid "Undo::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:9593
msgid "Error Messages::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:9593
msgid "Multiple Calculators::"
msgstr ""

#. type: node
#: ../../calc.texi:9593 ../../calc.texi:10322 ../../calc.texi:10349 ../../calc.texi:10350 ../../calc.texi:10366 ../../calc.texi:10383 ../../calc.texi:10411 ../../calc.texi:10440
#, no-wrap
msgid "Troubleshooting Commands"
msgstr ""

#. type: node
#: ../../calc.texi:9595 ../../calc.texi:9596 ../../calc.texi:9764
#, no-wrap
msgid "Basic Commands"
msgstr ""

#. type: node
#: ../../calc.texi:9595 ../../calc.texi:9764 ../../calc.texi:9765 ../../calc.texi:9909
#, no-wrap
msgid "Help Commands"
msgstr ""

#. type: pindex
#: ../../calc.texi:9599
#, no-wrap
msgid "calc"
msgstr ""

#. type: pindex
#: ../../calc.texi:9600
#, no-wrap
msgid "calc-mode"
msgstr ""

#. type: cindex
#: ../../calc.texi:9601
#, no-wrap
msgid "Starting the Calculator"
msgstr ""

#. type: cindex
#: ../../calc.texi:9602
#, no-wrap
msgid "Running the Calculator"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9615
msgid ""
"To start the Calculator in its standard interface, type @kbd{M-x calc}.  By "
"default this creates a pair of small windows, @file{*Calculator*} and "
"@file{*Calc Trail*}.  The former displays the contents of the Calculator "
"stack and is manipulated exclusively through Calc commands.  It is possible "
"(though not usually necessary) to create several Calc mode buffers each of "
"which has an independent stack, undo list, and mode settings.  There is "
"exactly one Calc Trail buffer; it records a list of the results of all "
"calculations that have been done.  The Calc Trail buffer uses a variant of "
"Calc mode, so Calculator commands still work when the trail buffer's window "
"is selected.  It is possible to turn the trail window off, but the "
"@file{*Calc Trail*} buffer itself still exists and is updated silently.  "
"@xref{Trail Commands}."
msgstr ""

#. type: kindex
#: ../../calc.texi:9616
#, no-wrap
msgid "C-x * c"
msgstr ""

#. type: kindex
#: ../../calc.texi:9617
#, no-wrap
msgid "C-x * *"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9625
msgid ""
"In most installations, the @kbd{C-x * c} key sequence is a more convenient "
"way to start the Calculator.  Also, @kbd{C-x * *} is a synonym for @kbd{C-x "
"* c} unless you last used Calc in its Keypad mode."
msgstr ""

#. type: item
#: ../../calc.texi:9626 ../../calc.texi:24835
#, no-wrap
msgid "x"
msgstr ""

#. type: kindex
#: ../../calc.texi:9627
#, no-wrap
msgid "M-x"
msgstr ""

#. type: pindex
#: ../../calc.texi:9628
#, no-wrap
msgid "calc-execute-extended-command"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9636
msgid ""
"Most Calc commands use one or two keystrokes.  Lower- and upper-case letters "
"are distinct.  Commands may also be entered in full @kbd{M-x} form; for some "
"commands this is the only form.  As a convenience, the @kbd{x} key "
"(@code{calc-execute-extended-command})  is like @kbd{M-x} except that it "
"enters the initial string @samp{calc-} for you.  For example, the following "
"key sequences are equivalent: @kbd{S}, @kbd{M-x calc-sin @key{RET}}, @kbd{x "
"sin @key{RET}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9641
msgid ""
"Although Calc is designed to be used from the keyboard, some of Calc's more "
"common commands are available from a menu.  In the menu, the arguments to "
"the functions are given by referring to their stack level numbers."
msgstr ""

#. type: cindex
#: ../../calc.texi:9642
#, no-wrap
msgid "Extensions module"
msgstr ""

#. type: cindex
#: ../../calc.texi:9643
#, no-wrap
msgid "@file{calc-ext} module"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9654
msgid ""
"The Calculator exists in many parts.  When you type @kbd{C-x * c}, the Emacs "
"``auto-load'' mechanism will bring in only the first part, which contains "
"the basic arithmetic functions.  The other parts will be auto-loaded the "
"first time you use the more advanced commands like trig functions or matrix "
"operations.  This is done to improve the response time of the Calculator in "
"the common case when all you need to do is a little arithmetic.  If for some "
"reason the Calculator fails to load an extension module automatically, you "
"can force it to load all the extensions by using the @kbd{C-x * L} "
"(@code{calc-load-everything})  command.  @xref{Mode Settings}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9661
msgid ""
"If you type @kbd{M-x calc} or @kbd{C-x * c} with any numeric prefix "
"argument, the Calculator is loaded if necessary, but it is not actually "
"started.  If the argument is positive, the @file{calc-ext} extensions are "
"also loaded if necessary.  User-written Lisp code that wishes to make use of "
"Calc's arithmetic routines can use @samp{(calc 0)} or @samp{(calc 1)} to "
"auto-load the Calculator."
msgstr ""

#. type: kindex
#: ../../calc.texi:9662
#, no-wrap
msgid "C-x * b"
msgstr ""

#. type: pindex
#: ../../calc.texi:9663
#, no-wrap
msgid "full-calc"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9671
msgid ""
"If you type @kbd{C-x * b}, then next time you use @kbd{C-x * c} you will get "
"a Calculator that uses the full height of the Emacs screen.  When "
"full-screen mode is on, @kbd{C-x * c} runs the @code{full-calc} command "
"instead of @code{calc}.  From the Unix shell you can type @samp{emacs -f "
"full-calc} to start a new Emacs specifically for use as a calculator.  When "
"Calc is started from the Emacs command line like this, Calc's normal "
"``quit'' commands actually quit Emacs itself."
msgstr ""

#. type: kindex
#: ../../calc.texi:9672
#, no-wrap
msgid "C-x * o"
msgstr ""

#. type: pindex
#: ../../calc.texi:9673
#, no-wrap
msgid "calc-other-window"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9680
msgid ""
"The @kbd{C-x * o} command is like @kbd{C-x * c} except that the Calc window "
"is not actually selected.  If you are already in the Calc window, @kbd{C-x * "
"o} switches you out of it.  (The regular Emacs @kbd{C-x o} command would "
"also work for this, but it has a tendency to drop you into the Calc Trail "
"window instead, which @kbd{C-x * o} takes care not to do.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9688
msgid ""
"For one quick calculation, you can type @kbd{C-x * q} (@code{quick-calc})  "
"which prompts you for a formula (like @samp{2+3/4}).  The result is "
"displayed at the bottom of the Emacs screen without ever creating any "
"special Calculator windows.  @xref{Quick Calculator}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9696
msgid ""
"Finally, if you are using the X window system you may want to try @kbd{C-x * "
"k} (@code{calc-keypad}) which runs Calc with a ``calculator keypad'' picture "
"as well as a stack display.  Click on the keys with the mouse to operate the "
"calculator.  @xref{Keypad Mode}."
msgstr ""

#. type: item
#: ../../calc.texi:9697 ../../calc.texi:24847
#, no-wrap
msgid "q"
msgstr ""

#. type: pindex
#: ../../calc.texi:9698
#, no-wrap
msgid "calc-quit"
msgstr ""

#. type: cindex
#: ../../calc.texi:9699
#, no-wrap
msgid "Quitting the Calculator"
msgstr ""

#. type: cindex
#: ../../calc.texi:9700
#, no-wrap
msgid "Exiting the Calculator"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9708
msgid ""
"The @kbd{q} key (@code{calc-quit}) exits Calc mode and closes the "
"Calculator's window(s).  It does not delete the Calculator buffers.  If you "
"type @kbd{M-x calc} again, the Calculator will reappear with the contents of "
"the stack intact.  Typing @kbd{C-x * c} or @kbd{C-x * *} again from inside "
"the Calculator buffer is equivalent to executing @code{calc-quit}; you can "
"think of @kbd{C-x * *} as toggling the Calculator on and off."
msgstr ""

#. type: kindex
#: ../../calc.texi:9709
#, no-wrap
msgid "C-x * x"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9713
msgid ""
"The @kbd{C-x * x} command also turns the Calculator off, no matter which "
"user interface (standard, Keypad, or Embedded) is currently active.  It also "
"cancels @code{calc-edit} mode if used from there."
msgstr ""

#. type: kindex
#: ../../calc.texi:9714
#, no-wrap
msgid "d SPC"
msgstr ""

#. type: defun
#: ../../calc.texi:9715 ../../calc.texi:33683
#, no-wrap
msgid "calc-refresh"
msgstr ""

#. type: cindex
#: ../../calc.texi:9716
#, no-wrap
msgid "Refreshing a garbled display"
msgstr ""

#. type: cindex
#: ../../calc.texi:9717
#, no-wrap
msgid "Garbled displays, refreshing"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9721
msgid ""
"The @kbd{d @key{SPC}} key sequence (@code{calc-refresh}) redraws the "
"contents of the Calculator buffer from memory.  Use this if the contents of "
"the buffer have been damaged somehow."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9727
msgid ""
"The @kbd{o} key (@code{calc-realign}) moves the cursor back to its ``home'' "
"position at the bottom of the Calculator buffer."
msgstr ""

#. type: kindex
#: ../../calc.texi:9728
#, no-wrap
msgid "<"
msgstr ""

#. type: kindex
#: ../../calc.texi:9729
#, no-wrap
msgid ">"
msgstr ""

#. type: pindex
#: ../../calc.texi:9730
#, no-wrap
msgid "calc-scroll-left"
msgstr ""

#. type: pindex
#: ../../calc.texi:9731
#, no-wrap
msgid "calc-scroll-right"
msgstr ""

#. type: cindex
#: ../../calc.texi:9732
#, no-wrap
msgid "Horizontal scrolling"
msgstr ""

#. type: cindex
#: ../../calc.texi:9733
#, no-wrap
msgid "Scrolling"
msgstr ""

#. type: cindex
#: ../../calc.texi:9734
#, no-wrap
msgid "Wide text, scrolling"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9740
msgid ""
"The @kbd{<} and @kbd{>} keys are bound to @code{calc-scroll-left} and "
"@code{calc-scroll-right}.  These are just like the normal horizontal "
"scrolling commands except that they scroll one half-screen at a time by "
"default.  (Calc formats its output to fit within the bounds of the window "
"whenever it can.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:9741
#, no-wrap
msgid "@{"
msgstr ""

#. type: kindex
#: ../../calc.texi:9742
#, no-wrap
msgid "@}"
msgstr ""

#. type: pindex
#: ../../calc.texi:9743
#, no-wrap
msgid "calc-scroll-down"
msgstr ""

#. type: pindex
#: ../../calc.texi:9744
#, no-wrap
msgid "calc-scroll-up"
msgstr ""

#. type: cindex
#: ../../calc.texi:9745
#, no-wrap
msgid "Vertical scrolling"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9749
msgid ""
"The @kbd{@{} and @kbd{@}} keys are bound to @code{calc-scroll-down} and "
"@code{calc-scroll-up}.  They scroll up or down by one-half the height of the "
"Calc window."
msgstr ""

#. type: kindex
#: ../../calc.texi:9750
#, no-wrap
msgid "C-x * 0"
msgstr ""

#. type: pindex
#: ../../calc.texi:9751
#, no-wrap
msgid "calc-reset"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9763
msgid ""
"The @kbd{C-x * 0} command (@code{calc-reset}; that's @kbd{C-x *} followed by "
"a zero) resets the Calculator to its initial state.  This clears the stack, "
"resets all the modes to their initial values (the values that were saved "
"with @kbd{m m} (@code{calc-save-modes})), clears the caches "
"(@pxref{Caches}), and so on.  (It does @emph{not} erase the values of any "
"variables.) With an argument of 0, Calc will be reset to its default state; "
"namely, the modes will be given their default values.  With a positive "
"prefix argument, @kbd{C-x * 0} preserves the contents of the stack but "
"resets everything else to its initial state; with a negative prefix "
"argument, @kbd{C-x * 0} preserves the contents of the stack but resets "
"everything else to its default state."
msgstr ""

#. type: node
#: ../../calc.texi:9764 ../../calc.texi:9909 ../../calc.texi:9910 ../../calc.texi:9961
#, no-wrap
msgid "Stack Basics"
msgstr ""

#. type: cindex
#: ../../calc.texi:9768
#, no-wrap
msgid "Help commands"
msgstr ""

#. type: kindex
#: ../../calc.texi:9769
#, no-wrap
msgid "?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9770
#, no-wrap
msgid "a ?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9771
#, no-wrap
msgid "b ?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9772
#, no-wrap
msgid "c ?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9773
#, no-wrap
msgid "d ?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9774
#, no-wrap
msgid "f ?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9775
#, no-wrap
msgid "g ?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9776
#, no-wrap
msgid "j ?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9777
#, no-wrap
msgid "k ?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9778
#, no-wrap
msgid "m ?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9779
#, no-wrap
msgid "r ?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9780
#, no-wrap
msgid "s ?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9781
#, no-wrap
msgid "t ?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9782
#, no-wrap
msgid "u ?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9783
#, no-wrap
msgid "v ?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9784
#, no-wrap
msgid "V ?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9785
#, no-wrap
msgid "z ?"
msgstr ""

#. type: kindex
#: ../../calc.texi:9786
#, no-wrap
msgid "Z ?"
msgstr ""

#. type: pindex
#: ../../calc.texi:9787
#, no-wrap
msgid "calc-help"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9794
msgid ""
"The @kbd{?} key (@code{calc-help}) displays a series of brief help "
"messages.  Some keys (such as @kbd{b} and @kbd{d}) are prefix keys, like "
"Emacs's @key{ESC} and @kbd{C-x} prefixes.  You can type @kbd{?} after a "
"prefix to see a list of commands beginning with that prefix.  (If the "
"message includes @samp{[MORE]}, press @kbd{?} again to see additional "
"commands for that prefix.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:9795
#, no-wrap
msgid "h h"
msgstr ""

#. type: pindex
#: ../../calc.texi:9796
#, no-wrap
msgid "calc-full-help"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9800
msgid ""
"The @kbd{h h} (@code{calc-full-help}) command displays all the @kbd{?} "
"responses at once.  When printed, this makes a nice, compact (three pages)  "
"summary of Calc keystrokes."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9804
msgid ""
"In general, the @kbd{h} key prefix introduces various commands that provide "
"help within Calc.  Many of the @kbd{h} key functions are Calc-specific "
"analogues to the @kbd{C-h} functions for Emacs help."
msgstr ""

#. type: kindex
#: ../../calc.texi:9805
#, no-wrap
msgid "h i"
msgstr ""

#. type: kindex
#: ../../calc.texi:9806
#, no-wrap
msgid "C-x * i"
msgstr ""

#. type: vindex
#: ../../calc.texi:9807 ../../calc.texi:11541 ../../calc.texi:13317
#, no-wrap
msgid "i"
msgstr ""

#. type: pindex
#: ../../calc.texi:9808
#, no-wrap
msgid "calc-info"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9818
msgid ""
"The @kbd{h i} (@code{calc-info}) command runs the Emacs Info system to read "
"this manual on-line.  This is basically the same as typing @kbd{C-h i} (the "
"regular way to run the Info system), then, if Info is not already in the "
"Calc manual, selecting the beginning of the manual.  The @kbd{C-x * i} "
"command is another way to read the Calc manual; it is different from @kbd{h "
"i} in that it works any time, not just inside Calc.  The plain @kbd{i} key "
"is also equivalent to @kbd{h i}, though this key is obsolete and may be "
"replaced with a different command in a future version of Calc."
msgstr ""

#. type: kindex
#: ../../calc.texi:9819
#, no-wrap
msgid "h t"
msgstr ""

#. type: kindex
#: ../../calc.texi:9820
#, no-wrap
msgid "C-x * t"
msgstr ""

#. type: pindex
#: ../../calc.texi:9821
#, no-wrap
msgid "calc-tutorial"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9830
msgid ""
"The @kbd{h t} (@code{calc-tutorial}) command runs the Info system on the "
"Tutorial section of the Calc manual.  It is like @kbd{h i}, except that it "
"selects the starting node of the tutorial rather than the beginning of the "
"whole manual.  (It actually selects the node ``Interactive Tutorial'' which "
"tells a few things about using the Info system before going on to the actual "
"tutorial.)  The @kbd{C-x * t} key is equivalent to @kbd{h t} (but it works "
"at all times)."
msgstr ""

#. type: kindex
#: ../../calc.texi:9831
#, no-wrap
msgid "h s"
msgstr ""

#. type: kindex
#: ../../calc.texi:9832
#, no-wrap
msgid "C-x * s"
msgstr ""

#. type: pindex
#: ../../calc.texi:9833
#, no-wrap
msgid "calc-info-summary"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9837
msgid ""
"The @kbd{h s} (@code{calc-info-summary}) command runs the Info system on the "
"Summary node of the Calc manual.  @xref{Summary}.  The @kbd{C-x * s} key is "
"equivalent to @kbd{h s}."
msgstr ""

#. type: kindex
#: ../../calc.texi:9838
#, no-wrap
msgid "h k"
msgstr ""

#. type: pindex
#: ../../calc.texi:9839
#, no-wrap
msgid "calc-describe-key"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9846
msgid ""
"The @kbd{h k} (@code{calc-describe-key}) command looks up a key sequence in "
"the Calc manual.  For example, @kbd{h k H a S} looks up the documentation on "
"the @kbd{H a S} (@code{calc-solve-for})  command.  This works by looking up "
"the textual description of the key(s) in the Key Index of the manual, then "
"jumping to the node indicated by the index."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9851
msgid ""
"Most Calc commands do not have traditional Emacs documentation strings, "
"since the @kbd{h k} command is both more convenient and more instructive.  "
"This means the regular Emacs @kbd{C-h k} (@code{describe-key}) command will "
"not be useful for Calc keystrokes."
msgstr ""

#. type: kindex
#: ../../calc.texi:9852
#, no-wrap
msgid "h c"
msgstr ""

#. type: pindex
#: ../../calc.texi:9853
#, no-wrap
msgid "calc-describe-key-briefly"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9861
msgid ""
"The @kbd{h c} (@code{calc-describe-key-briefly}) command reads a key "
"sequence and displays a brief one-line description of it at the bottom of "
"the screen.  It looks for the key sequence in the Summary node of the Calc "
"manual; if it doesn't find the sequence there, it acts just like its regular "
"Emacs counterpart @kbd{C-h c} (@code{describe-key-briefly}).  For example, "
"@kbd{h c H a S} gives the description:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:9864
#, no-wrap
msgid "H a S runs calc-solve-for:  a `H a S' v  => fsolve(a,v)  (?=notes)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9872
msgid ""
"which means the command @kbd{H a S} or @kbd{H M-x calc-solve-for} takes a "
"value @expr{a} from the stack, prompts for a value @expr{v}, then applies "
"the algebraic function @code{fsolve} to these values.  The @samp{?=notes} "
"message means you can now type @kbd{?} to see additional notes from the "
"summary that apply to this command."
msgstr ""

#. type: kindex
#: ../../calc.texi:9873
#, no-wrap
msgid "h f"
msgstr ""

#. type: pindex
#: ../../calc.texi:9874
#, no-wrap
msgid "calc-describe-function"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9882
msgid ""
"The @kbd{h f} (@code{calc-describe-function}) command looks up an algebraic "
"function or a command name in the Calc manual.  Enter an algebraic function "
"name to look up that function in the Function Index or enter a command name "
"beginning with @samp{calc-} to look it up in the Command Index.  This "
"command will also look up operator symbols that can appear in algebraic "
"formulas, like @samp{%} and @samp{=>}."
msgstr ""

#. type: kindex
#: ../../calc.texi:9883
#, no-wrap
msgid "h v"
msgstr ""

#. type: pindex
#: ../../calc.texi:9884
#, no-wrap
msgid "calc-describe-variable"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9888
msgid ""
"The @kbd{h v} (@code{calc-describe-variable}) command looks up a variable in "
"the Calc manual.  Enter a variable name like @code{pi} or "
"@code{PlotRejects}."
msgstr ""

#. type: kindex
#: ../../calc.texi:9889
#, no-wrap
msgid "h b"
msgstr ""

#. type: pindex
#: ../../calc.texi:9890
#, no-wrap
msgid "describe-bindings"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9894
msgid ""
"The @kbd{h b} (@code{calc-describe-bindings}) command is just like @kbd{C-h "
"b}, except that only local (Calc-related) key bindings are listed."
msgstr ""

#. type: kindex
#: ../../calc.texi:9895
#, no-wrap
msgid "h n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9900
msgid ""
"The @kbd{h n} or @kbd{h C-n} (@code{calc-view-news}) command displays the "
"``news'' or change history of Emacs, and jumps to the most recent portion "
"concerning Calc (if present).  For older history, see the file "
"@file{etc/CALC-NEWS} in the Emacs distribution."
msgstr ""

#. type: kindex
#: ../../calc.texi:9901
#, no-wrap
msgid "h C-c"
msgstr ""

#. type: kindex
#: ../../calc.texi:9902
#, no-wrap
msgid "h C-d"
msgstr ""

#. type: kindex
#: ../../calc.texi:9903
#, no-wrap
msgid "h C-w"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9908
msgid ""
"The @kbd{h C-c}, @kbd{h C-d}, and @kbd{h C-w} keys display copying, "
"distribution, and warranty information about Calc.  These work by pulling up "
"the appropriate parts of the ``Copying'' or ``Reporting Bugs'' sections of "
"the manual."
msgstr ""

#. type: node
#: ../../calc.texi:9909 ../../calc.texi:9961 ../../calc.texi:9962 ../../calc.texi:9998
#, no-wrap
msgid "Numeric Entry"
msgstr ""

#. type: cindex
#: ../../calc.texi:9913
#, no-wrap
msgid "Stack basics"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9917
msgid ""
"Calc uses RPN notation.  If you are not familiar with RPN, @pxref{RPN "
"Tutorial}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9926
msgid ""
"To add the numbers 1 and 2 in Calc you would type the keys: @kbd{1 @key{RET} "
"2 +}.  (@key{RET} corresponds to the @key{ENTER} key on most calculators.)  "
"The first three keystrokes ``push'' the numbers 1 and 2 onto the stack.  The "
"@kbd{+} key always ``pops'' the top two numbers from the stack, adds them, "
"and pushes the result (3) back onto the stack.  This number is ready for "
"further calculations: @kbd{5 -} pushes 5 onto the stack, then pops the 3 and "
"5, subtracts them, and pushes the result (@mathit{-2})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9933
msgid ""
"Note that the ``top'' of the stack actually appears at the @emph{bottom} of "
"the buffer.  A line containing a single @samp{.} character signifies the end "
"of the buffer; Calculator commands operate on the number(s)  directly above "
"this line.  The @kbd{d t} (@code{calc-truncate-stack})  command allows you "
"to move the @samp{.} marker up and down in the stack; @pxref{Truncating the "
"Stack}."
msgstr ""

#. type: kindex
#: ../../calc.texi:9934
#, no-wrap
msgid "d l"
msgstr ""

#. type: pindex
#: ../../calc.texi:9935
#, no-wrap
msgid "calc-line-numbering"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9941
msgid ""
"Stack elements are numbered consecutively, with number 1 being the top of "
"the stack.  These line numbers are ordinarily displayed on the lefthand side "
"of the window.  The @kbd{d l} (@code{calc-line-numbering}) command controls "
"whether these numbers appear.  (Line numbers may be turned off since they "
"slow the Calculator down a bit and also clutter the display.)"
msgstr ""

#. type: item
#: ../../calc.texi:9942 ../../calc.texi:24861
#, no-wrap
msgid "o"
msgstr ""

#. type: pindex
#: ../../calc.texi:9943
#, no-wrap
msgid "calc-realign"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9948
msgid ""
"The unshifted letter @kbd{o} (@code{calc-realign}) command repositions the "
"cursor to its top-of-stack ``home'' position.  It also undoes any horizontal "
"scrolling in the window.  If you give it a numeric prefix argument, it "
"instead moves the cursor to the specified stack element."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9955
msgid ""
"The @key{RET} (or equivalent @key{SPC}) key is only required to separate two "
"consecutive numbers.  (After all, if you typed @kbd{1 2} by themselves the "
"Calculator would enter the number 12.)  If you press @key{RET} or @key{SPC} "
"@emph{not} right after typing a number, the key duplicates the number on the "
"top of the stack.  @kbd{@key{RET} *} is thus a handy way to square a number."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9960
msgid ""
"The @key{DEL} key pops and throws away the top number on the stack.  The "
"@key{TAB} key swaps the top two objects on the stack.  @xref{Stack and "
"Trail}, for descriptions of these and other stack-related commands."
msgstr ""

#. type: node
#: ../../calc.texi:9961 ../../calc.texi:9998 ../../calc.texi:9999 ../../calc.texi:10116
#, no-wrap
msgid "Algebraic Entry"
msgstr ""

#. type: kindex
#: ../../calc.texi:9965
#, no-wrap
msgid "0-9"
msgstr ""

#. type: kindex
#: ../../calc.texi:9966
#, no-wrap
msgid "."
msgstr ""

#. type: findex
#: ../../calc.texi:9967 ../../calc.texi:11539 ../../calc.texi:18260 ../../calc.texi:24831 ../../calc.texi:34145
#, no-wrap
msgid "e"
msgstr ""

#. type: cindex
#: ../../calc.texi:9968
#, no-wrap
msgid "Numeric entry"
msgstr ""

#. type: cindex
#: ../../calc.texi:9969
#, no-wrap
msgid "Entering numbers"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9975
msgid ""
"Pressing a digit or other numeric key begins numeric entry using the "
"minibuffer.  The number is pushed on the stack when you press the @key{RET} "
"or @key{SPC} keys.  If you press any other non-numeric key, the number is "
"pushed onto the stack and the appropriate operation is performed.  If you "
"press a numeric key which is not valid, the key is ignored."
msgstr ""

#. type: cindex
#: ../../calc.texi:9976
#, no-wrap
msgid "Minus signs"
msgstr ""

#. type: cindex
#: ../../calc.texi:9977
#, no-wrap
msgid "Negative numbers, entering"
msgstr ""

#. type: Plain text
#: ../../calc.texi:9990
msgid ""
"There are three different concepts corresponding to the word ``minus,'' "
"typified by @expr{a-b} (subtraction), @expr{-x} (change-sign), and @expr{-5} "
"(negative number).  Calc uses three different keys for these operations, "
"respectively: @kbd{-}, @kbd{n}, and @kbd{_} (the underscore).  The @kbd{-} "
"key subtracts the two numbers on the top of the stack.  The @kbd{n} key "
"changes the sign of the number on the top of the stack or the number "
"currently being entered.  The @kbd{_} key begins entry of a negative number "
"or changes the sign of the number currently being entered.  The following "
"sequences all enter the number @mathit{-5} onto the stack: @kbd{0 @key{RET} "
"5 -}, @kbd{5 n @key{RET}}, @kbd{5 @key{RET} n}, @kbd{_ 5 @key{RET}}, @kbd{5 "
"_ @key{RET}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9995
msgid ""
"Some other keys are active during numeric entry, such as @kbd{#} for "
"non-decimal numbers, @kbd{:} for fractions, and @kbd{@@} for HMS forms.  "
"These notations are described later in this manual with the corresponding "
"data types.  @xref{Data Types}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:9997
msgid "During numeric entry, the only editing key available is @key{DEL}."
msgstr ""

#. type: node
#: ../../calc.texi:9998 ../../calc.texi:10116 ../../calc.texi:10122 ../../calc.texi:10185
#, no-wrap
msgid "Quick Calculator"
msgstr ""

#. type: kindex
#: ../../calc.texi:10002
#, no-wrap
msgid "'"
msgstr ""

#. type: pindex
#: ../../calc.texi:10003
#, no-wrap
msgid "calc-algebraic-entry"
msgstr ""

#. type: cindex
#: ../../calc.texi:10004
#, no-wrap
msgid "Algebraic notation"
msgstr ""

#. type: cindex
#: ../../calc.texi:10005
#, no-wrap
msgid "Formulas, entering"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10009
msgid ""
"The @kbd{'} (@code{calc-algebraic-entry}) command can be used to enter "
"calculations in algebraic form.  This is accomplished by typing the "
"apostrophe key, ', followed by the expression in standard format:"
msgstr ""

#. type: example
#: ../../calc.texi:10012
#, no-wrap
msgid "' 2+3*4 @key{RET}.\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10022
msgid ""
"This will compute @texline @math{2+(3\\times4) = 14} @infoline @expr{2+(3*4) "
"= 14} and push it on the stack.  If you wish you can ignore the RPN aspect "
"of Calc altogether and simply enter algebraic expressions in this way.  You "
"may want to use @key{DEL} every so often to clear previous results off the "
"stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10027
msgid ""
"You can press the apostrophe key during normal numeric entry to switch the "
"half-entered number into Algebraic entry mode.  One reason to do this would "
"be to fix a typo, as the full Emacs cursor motion and editing keys are "
"available during algebraic entry but not during numeric entry."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10032
msgid ""
"In the same vein, during either numeric or algebraic entry you can press "
"@kbd{`} (grave accent) to switch to @code{calc-edit} mode, where you "
"complete your half-finished entry in a separate buffer.  @xref{Editing Stack "
"Entries}."
msgstr ""

#. type: kindex
#: ../../calc.texi:10033
#, no-wrap
msgid "m a"
msgstr ""

#. type: pindex
#: ../../calc.texi:10034
#, no-wrap
msgid "calc-algebraic-mode"
msgstr ""

#. type: cindex
#: ../../calc.texi:10035
#, no-wrap
msgid "Algebraic Mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10045
msgid ""
"If you prefer algebraic entry, you can use the command @kbd{m a} "
"(@code{calc-algebraic-mode}) to set Algebraic mode.  In this mode, digits "
"and other keys that would normally start numeric entry instead start full "
"algebraic entry; as long as your formula begins with a digit you can omit "
"the apostrophe.  Open parentheses and square brackets also begin algebraic "
"entry.  You can still do RPN calculations in this mode, but you will have to "
"press @key{RET} to terminate every number: @kbd{2 @key{RET} 3 @key{RET} * 4 "
"@key{RET} +} would accomplish the same thing as @kbd{2*3+4 @key{RET}}."
msgstr ""

#. type: cindex
#: ../../calc.texi:10046
#, no-wrap
msgid "Incomplete Algebraic Mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10051
msgid ""
"If you give a numeric prefix argument like @kbd{C-u} to the @kbd{m a} "
"command, it enables Incomplete Algebraic mode; this is like regular "
"Algebraic mode except that it applies to the @kbd{(} and @kbd{[} keys only.  "
"Numeric keys still begin a numeric entry in this mode."
msgstr ""

#. type: kindex
#: ../../calc.texi:10052
#, no-wrap
msgid "m t"
msgstr ""

#. type: pindex
#: ../../calc.texi:10053
#, no-wrap
msgid "calc-total-algebraic-mode"
msgstr ""

#. type: cindex
#: ../../calc.texi:10054
#, no-wrap
msgid "Total Algebraic Mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10066
msgid ""
"The @kbd{m t} (@code{calc-total-algebraic-mode}) gives you an even stronger "
"algebraic-entry mode, in which @emph{all} regular letter and punctuation "
"keys begin algebraic entry.  Use this if you prefer typing @w{@kbd{sqrt( )}} "
"instead of @kbd{Q}, @w{@kbd{factor( )}} instead of @kbd{a f}, and so on.  To "
"type regular Calc commands when you are in Total Algebraic mode, hold down "
"the @key{META} key.  Thus @kbd{M-q} is the command to quit Calc, @kbd{M-p} "
"sets the precision, and @kbd{M-m t} (or @kbd{M-m M-t}, if you prefer) turns "
"Total Algebraic mode back off again.  Meta keys also terminate algebraic "
"entry, so that @kbd{2+3 M-S} is equivalent to @kbd{2+3 @key{RET} M-S}.  The "
"symbol @samp{Alg*} will appear in the mode line whenever you are in this "
"mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10070
msgid ""
"Pressing @kbd{'} (the apostrophe) a second time re-enters the previous "
"algebraic formula.  You can then use the normal Emacs editing keys to modify "
"this formula to your liking before pressing @key{RET}."
msgstr ""

#. type: kindex
#: ../../calc.texi:10071
#, no-wrap
msgid "$"
msgstr ""

#. type: cindex
#: ../../calc.texi:10072
#, no-wrap
msgid "Formulas, referring to stack"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10081
msgid ""
"Within a formula entered from the keyboard, the symbol @kbd{$} represents "
"the number on the top of the stack.  If an entered formula contains any "
"@kbd{$} characters, the Calculator replaces the top of stack with that "
"formula rather than simply pushing the formula onto the stack.  Thus, @kbd{' "
"1+2 @key{RET}} pushes 3 on the stack, and @kbd{$*2 @key{RET}} replaces it "
"with 6.  Note that the @kbd{$} key always initiates algebraic entry; the "
"@kbd{'} is unnecessary if @kbd{$} is the first character in the new formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10089
msgid ""
"Higher stack elements can be accessed from an entered formula with the "
"symbols @kbd{$$}, @kbd{$$$}, and so on.  The number of stack elements "
"removed (to be replaced by the entered values) equals the number of dollar "
"signs in the longest such symbol in the formula.  For example, @samp{$$+$$$} "
"adds the second and third stack elements, replacing the top three elements "
"with the answer.  (All information about the top stack element is thus lost "
"since no single @samp{$} appears in this formula.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10096
msgid ""
"A slightly different way to refer to stack elements is with a dollar sign "
"followed by a number: @samp{$1}, @samp{$2}, and so on are much like "
"@samp{$}, @samp{$$}, etc., except that stack entries referred to numerically "
"are not replaced by the algebraic entry.  That is, while @samp{$+1} replaces "
"5 on the stack with 6, @samp{$1+1} leaves the 5 on the stack and pushes an "
"additional 6."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10103
msgid ""
"If a sequence of formulas are entered separated by commas, each formula is "
"pushed onto the stack in turn.  For example, @samp{1,2,3} pushes those three "
"numbers onto the stack (leaving the 3 at the top), and @samp{$+1,$-1} "
"replaces a 5 on the stack with 4 followed by 6.  Also, @samp{$,$$} exchanges "
"the top two elements of the stack, just like the @key{TAB} key."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10108
msgid ""
"You can finish an algebraic entry with @kbd{M-=} or @kbd{M-@key{RET}} "
"instead of @key{RET}.  This uses @kbd{=} to evaluate the variables in each "
"formula that goes onto the stack.  (Thus @kbd{' pi @key{RET}} pushes the "
"variable @samp{pi}, but @kbd{' pi M-@key{RET}} pushes 3.1415.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10115
msgid ""
"If you finish your algebraic entry by pressing @key{LFD} (or @kbd{C-j})  "
"instead of @key{RET}, Calc disables simplification (as if by @kbd{m O}; "
"@pxref{Simplification Modes}) while the entry is being pushed on the stack.  "
"Thus @kbd{' 1+2 @key{RET}} pushes 3 on the stack, but @kbd{' 1+2 @key{LFD}} "
"pushes the formula @expr{1+2}; you might then press @kbd{=} when it is time "
"to evaluate this formula."
msgstr ""

#. type: node
#: ../../calc.texi:10116 ../../calc.texi:10185 ../../calc.texi:10233
#, no-wrap
msgid "Prefix Arguments"
msgstr ""

#. type: section
#: ../../calc.texi:10117
#, no-wrap
msgid "``Quick Calculator'' Mode"
msgstr ""

#. type: kindex
#: ../../calc.texi:10120
#, no-wrap
msgid "C-x * q"
msgstr ""

#. type: pindex
#: ../../calc.texi:10121
#, no-wrap
msgid "quick-calc"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10128
msgid ""
"There is another way to invoke the Calculator if all you need to do is make "
"one or two quick calculations.  Type @kbd{C-x * q} (or @kbd{M-x "
"quick-calc}), then type any formula as an algebraic entry.  The Calculator "
"will compute the result and display it in the echo area, without ever "
"actually putting up a Calc window."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10135
msgid ""
"You can use the @kbd{$} character in a Quick Calculator formula to refer to "
"the previous Quick Calculator result.  Older results are not retained; the "
"Quick Calculator has no effect on the full Calculator's stack or trail.  If "
"you compute a result and then forget what it was, just run @code{C-x * q} "
"again and enter @samp{$} as the formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10144
msgid ""
"If this is the first time you have used the Calculator in this Emacs "
"session, the @kbd{C-x * q} command will create the @file{*Calculator*} "
"buffer and perform all the usual initializations; it simply will refrain "
"from putting that buffer up in a new window.  The Quick Calculator refers to "
"the @file{*Calculator*} buffer for all mode settings.  Thus, for example, to "
"set the precision that the Quick Calculator uses, simply run the full "
"Calculator momentarily and use the regular @kbd{p} command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10147
msgid ""
"If you use @code{C-x * q} from inside the Calculator buffer, the effect is "
"the same as pressing the apostrophe key (algebraic entry)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10154
msgid ""
"The result of a Quick calculation is placed in the Emacs ``kill ring'' as "
"well as being displayed.  A subsequent @kbd{C-y} command will yank the "
"result into the editing buffer.  You can also use this to yank the result "
"into the next @kbd{C-x * q} input line as a more explicit alternative to "
"@kbd{$} notation, or to yank the result into the Calculator stack after "
"typing @kbd{C-x * c}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10159
msgid ""
"If you give a prefix argument to @kbd{C-x * q} or finish your formula by "
"typing @key{LFD} (or @kbd{C-j}) instead of @key{RET}, the result is inserted "
"immediately into the current buffer rather than going into the kill ring."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10166
msgid ""
"Quick Calculator results are actually evaluated as if by the @kbd{=} key "
"(which replaces variable names by their stored values, if any).  If the "
"formula you enter is an assignment to a variable using the @samp{:=} "
"operator, say, @samp{foo := 2 + 3} or @samp{foo := foo + 1}, then the result "
"of the evaluation is stored in that Calc variable.  @xref{Store and Recall}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10171
msgid ""
"If the result is an integer and the current display radix is decimal, the "
"number will also be displayed in hex, octal and binary formats.  If the "
"integer is in the range from 1 to 126, it will also be displayed as an ASCII "
"character."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10179
msgid ""
"For example, the quoted character @samp{\"x\"} produces the vector result "
"@samp{[120]} (because 120 is the ASCII code of the lower-case ``x''; "
"@pxref{Strings}).  Since this is a vector, not an integer, it is displayed "
"only according to the current mode settings.  But running Quick Calc again "
"and entering @samp{120} will produce the result @samp{120 (16#78, 8#170, x)} "
"which shows the number in its decimal, hexadecimal, octal, and ASCII forms."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10184
msgid ""
"Please note that the Quick Calculator is not any faster at loading or "
"computing the answer than the full Calculator; the name ``quick'' merely "
"refers to the fact that it's much less hassle to use for small calculations."
msgstr ""

#. type: node
#: ../../calc.texi:10185 ../../calc.texi:10233 ../../calc.texi:10291
#, no-wrap
msgid "Undo"
msgstr ""

#. type: section
#: ../../calc.texi:10186
#, no-wrap
msgid "Numeric Prefix Arguments"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10194
msgid ""
"Many Calculator commands use numeric prefix arguments.  Some, such as @kbd{d "
"s} (@code{calc-sci-notation}), set a parameter to the value of the prefix "
"argument or use a default if you don't use a prefix.  Others (like @kbd{d f} "
"(@code{calc-fix-notation})) require an argument and prompt for a number if "
"you don't give one as a prefix."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10200
msgid ""
"As a rule, stack-manipulation commands accept a numeric prefix argument "
"which is interpreted as an index into the stack.  A positive argument "
"operates on the top @var{n} stack entries; a negative argument operates on "
"the @var{n}th stack entry in isolation; and a zero argument operates on the "
"entire stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10216
msgid ""
"Most commands that perform computations (such as the arithmetic and "
"scientific functions) accept a numeric prefix argument that allows the "
"operation to be applied across many stack elements.  For unary operations "
"(that is, functions of one argument like absolute value or complex "
"conjugate), a positive prefix argument applies that function to the top "
"@var{n} stack entries simultaneously, and a negative argument applies it to "
"the @var{n}th stack entry only.  For binary operations (functions of two "
"arguments like addition, GCD, and vector concatenation), a positive prefix "
"argument ``reduces'' the function across the top @var{n} stack elements (for "
"example, @kbd{C-u 5 +} sums the top 5 stack entries; @pxref{Reducing and "
"Mapping}), and a negative argument maps the next-to-top @var{n} stack "
"elements with the top stack element as a second argument (for example, "
"@kbd{7 c-u -5 +} adds 7 to the top 5 stack elements).  This feature is not "
"available for operations which use the numeric prefix argument for some "
"other purpose."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10221
msgid ""
"Numeric prefixes are specified the same way as always in Emacs: Press a "
"sequence of @key{META}-digits, or press @key{ESC} followed by digits, or "
"press @kbd{C-u} followed by digits.  Some commands treat plain @kbd{C-u} "
"(without any actual digits) specially."
msgstr ""

#. type: kindex
#: ../../calc.texi:10222
#, no-wrap
msgid "~"
msgstr ""

#. type: pindex
#: ../../calc.texi:10223
#, no-wrap
msgid "calc-num-prefix"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10229
msgid ""
"You can type @kbd{~} (@code{calc-num-prefix}) to pop an integer from the top "
"of the stack and enter it as the numeric prefix for the next command.  For "
"example, @kbd{C-u 16 p} sets the precision to 16 digits; an alternate "
"(silly) way to do this would be @kbd{2 @key{RET} 4 ^ ~ p}, i.e., compute 2 "
"to the fourth power and set the precision to that value."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10232
msgid ""
"Conversely, if you have typed a numeric prefix argument the @kbd{~} key "
"pushes it onto the stack in the form of an integer."
msgstr ""

#. type: node
#: ../../calc.texi:10233 ../../calc.texi:10291 ../../calc.texi:10292 ../../calc.texi:10322
#, no-wrap
msgid "Error Messages"
msgstr ""

#. type: section
#: ../../calc.texi:10234
#, no-wrap
msgid "Undoing Mistakes"
msgstr ""

#. type: kindex
#: ../../calc.texi:10238
#, no-wrap
msgid "C-_"
msgstr ""

#. type: pindex
#: ../../calc.texi:10239
#, no-wrap
msgid "calc-undo"
msgstr ""

#. type: cindex
#: ../../calc.texi:10240
#, no-wrap
msgid "Mistakes, undoing"
msgstr ""

#. type: cindex
#: ../../calc.texi:10241
#, no-wrap
msgid "Undoing mistakes"
msgstr ""

#. type: cindex
#: ../../calc.texi:10242
#, no-wrap
msgid "Errors, undoing"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10256
msgid ""
"The shift-@kbd{U} key (@code{calc-undo}) undoes the most recent operation.  "
"If that operation added or dropped objects from the stack, those objects are "
"removed or restored.  If it was a ``store'' operation, you are queried "
"whether or not to restore the variable to its original value.  The @kbd{U} "
"key may be pressed any number of times to undo successively farther back in "
"time; with a numeric prefix argument it undoes a specified number of "
"operations.  When the Calculator is quit, as with the @kbd{q} "
"(@code{calc-quit}) command, the undo history will be truncated to the length "
"of the customizable variable @code{calc-undo-length} (@pxref{Customizing "
"Calc}), which by default is @expr{100}. (Recall that @kbd{C-x * c} is "
"synonymous with @code{calc-quit} while inside the Calculator; this also "
"truncates the undo history.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10260
msgid ""
"Currently the mode-setting commands (like @code{calc-precision}) are not "
"undoable.  You can undo past a point where you changed a mode, but you will "
"need to reset the mode yourself."
msgstr ""

#. type: pindex
#: ../../calc.texi:10262
#, no-wrap
msgid "calc-redo"
msgstr ""

#. type: cindex
#: ../../calc.texi:10263
#, no-wrap
msgid "Redoing after an Undo"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10271
msgid ""
"The shift-@kbd{D} key (@code{calc-redo}) redoes an operation that was "
"mistakenly undone.  Pressing @kbd{U} with a negative prefix argument is "
"equivalent to executing @code{calc-redo}.  You can redo any number of times, "
"up to the number of recent consecutive undo commands.  Redo information is "
"cleared whenever you give any command that adds new undo information, i.e., "
"if you undo, then enter a number on the stack or make any other change, then "
"it will be too late to redo."
msgstr ""

#. type: kindex
#: ../../calc.texi:10272
#, no-wrap
msgid "M-RET"
msgstr ""

#. type: pindex
#: ../../calc.texi:10273
#, no-wrap
msgid "calc-last-args"
msgstr ""

#. type: cindex
#: ../../calc.texi:10274
#, no-wrap
msgid "Last-arguments feature"
msgstr ""

#. type: cindex
#: ../../calc.texi:10275
#, no-wrap
msgid "Arguments, restoring"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10282
msgid ""
"The @kbd{M-@key{RET}} key (@code{calc-last-args}) is like undo in that it "
"restores the arguments of the most recent command onto the stack; however, "
"it does not remove the result of that command.  Given a numeric prefix "
"argument, this command applies to the @expr{n}th most recent command which "
"removed items from the stack; it pushes those items back onto the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10285
msgid ""
"The @kbd{K} (@code{calc-keep-args}) command provides a related function to "
"@kbd{M-@key{RET}}.  @xref{Stack and Trail}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10288
msgid ""
"It is also possible to recall previous results or inputs using the trail.  "
"@xref{Trail Commands}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10290
msgid ""
"The standard Emacs @kbd{C-_} undo key is recognized as a synonym for "
"@kbd{U}."
msgstr ""

#. type: node
#: ../../calc.texi:10291 ../../calc.texi:10322 ../../calc.texi:10323 ../../calc.texi:10349
#, no-wrap
msgid "Multiple Calculators"
msgstr ""

#. type: item
#: ../../calc.texi:10295 ../../calc.texi:13593
#, no-wrap
msgid "w"
msgstr ""

#. type: pindex
#: ../../calc.texi:10296
#, no-wrap
msgid "calc-why"
msgstr ""

#. type: cindex
#: ../../calc.texi:10297
#, no-wrap
msgid "Errors, messages"
msgstr ""

#. type: cindex
#: ../../calc.texi:10298
#, no-wrap
msgid "Why did an error occur?"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10304
msgid ""
"Many situations that would produce an error message in other calculators "
"simply create unsimplified formulas in the Emacs Calculator.  For example, "
"@kbd{1 @key{RET} 0 /} pushes the formula @expr{1 / 0}; @w{@kbd{0 L}} pushes "
"the formula @samp{ln(0)}.  Floating-point overflow and underflow are also "
"reasons for this to happen."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10312
msgid ""
"When a function call must be left in symbolic form, Calc usually produces a "
"message explaining why.  Messages that are probably surprising or indicative "
"of user errors are displayed automatically.  Other messages are simply kept "
"in Calc's memory and are displayed only if you type @kbd{w} "
"(@code{calc-why}).  You can also press @kbd{w} if the same computation "
"results in several messages.  (The first message will end with "
"@samp{[w=more]} in this case.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:10313
#, no-wrap
msgid "d w"
msgstr ""

#. type: pindex
#: ../../calc.texi:10314
#, no-wrap
msgid "calc-auto-why"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10321
msgid ""
"The @kbd{d w} (@code{calc-auto-why}) command controls when error messages "
"are displayed automatically.  (Calc effectively presses @kbd{w} for you "
"after your computation finishes.)  By default, this occurs only for "
"``important'' messages.  The other possible modes are to report @emph{all} "
"messages automatically, or to report none automatically (so that you must "
"always press @kbd{w} yourself to see the messages)."
msgstr ""

#. type: pindex
#: ../../calc.texi:10326
#, no-wrap
msgid "another-calc"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10334
msgid ""
"It is possible to have any number of Calc mode buffers at once.  Usually "
"this is done by executing @kbd{M-x another-calc}, which is similar to "
"@kbd{C-x * c} except that if a @file{*Calculator*} buffer already exists, a "
"new, independent one with a name of the form @file{*Calculator*<@var{n}>} is "
"created.  You can also use the command @code{calc-mode} to put any buffer "
"into Calculator mode, but this would ordinarily never be done."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10338
msgid ""
"The @kbd{q} (@code{calc-quit}) command does not destroy a Calculator buffer; "
"it only closes its window.  Use @kbd{M-x kill-buffer} to destroy a "
"Calculator buffer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10345
msgid ""
"Each Calculator buffer keeps its own stack, undo list, and mode settings "
"such as precision, angular mode, and display formats.  In Emacs terms, "
"variables such as @code{calc-stack} are buffer-local variables.  The global "
"default values of these variables are used only when a new Calculator buffer "
"is created.  The @code{calc-quit} command saves the stack and mode settings "
"of the buffer being quit as the new defaults."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10348
msgid ""
"There is only one trail buffer, @file{*Calc Trail*}, used by all Calculator "
"buffers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10355
msgid ""
"This section describes commands you can use in case a computation "
"incorrectly fails or gives the wrong answer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10358
msgid ""
"@xref{Reporting Bugs}, if you find a problem that appears to be due to a bug "
"or deficiency in Calc."
msgstr ""

#. type: menuentry
#: ../../calc.texi:10364
msgid "Autoloading Problems::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:10364
msgid "Recursion Depth::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:10364
msgid "Caches::"
msgstr ""

#. type: subsection
#: ../../calc.texi:10364 ../../calc.texi:10411 ../../calc.texi:10440 ../../calc.texi:10441
#, no-wrap
msgid "Debugging Calc"
msgstr ""

#. type: node
#: ../../calc.texi:10366 ../../calc.texi:10367 ../../calc.texi:10383
#, no-wrap
msgid "Autoloading Problems"
msgstr ""

#. type: node
#: ../../calc.texi:10366 ../../calc.texi:10383 ../../calc.texi:10384 ../../calc.texi:10411
#, no-wrap
msgid "Recursion Depth"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10375
msgid ""
"The Calc program is split into many component files; components are loaded "
"automatically as you use various commands that require them.  Occasionally "
"Calc may lose track of when a certain component is necessary; typically this "
"means you will type a command and it won't work because some function you've "
"never heard of was undefined."
msgstr ""

#. type: kindex
#: ../../calc.texi:10376
#, no-wrap
msgid "C-x * L"
msgstr ""

#. type: pindex
#: ../../calc.texi:10377
#, no-wrap
msgid "calc-load-everything"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10382
msgid ""
"If this happens, the easiest workaround is to type @kbd{C-x * L} "
"(@code{calc-load-everything}) to force all the parts of Calc to be loaded "
"right away.  This will cause Emacs to take up a lot more memory than it "
"would otherwise, but it's guaranteed to fix the problem."
msgstr ""

#. type: node
#: ../../calc.texi:10383 ../../calc.texi:10411 ../../calc.texi:10412 ../../calc.texi:10415 ../../calc.texi:10440
#, no-wrap
msgid "Caches"
msgstr ""

#. type: kindex
#: ../../calc.texi:10388
#, no-wrap
msgid "I M"
msgstr ""

#. type: pindex
#: ../../calc.texi:10389
#, no-wrap
msgid "calc-more-recursion-depth"
msgstr ""

#. type: pindex
#: ../../calc.texi:10390
#, no-wrap
msgid "calc-less-recursion-depth"
msgstr ""

#. type: cindex
#: ../../calc.texi:10391
#, no-wrap
msgid "Recursion depth"
msgstr ""

#. type: cindex
#: ../../calc.texi:10392
#, no-wrap
msgid "``Computation got stuck'' message"
msgstr ""

#. type: code{#1}
#: ../../calc.texi:10393
#, no-wrap
msgid "max-lisp-eval-depth"
msgstr ""

#. type: code{#1}
#: ../../calc.texi:10394
#, no-wrap
msgid "max-specpdl-size"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10402
msgid ""
"Calc uses recursion in many of its calculations.  Emacs Lisp keeps a "
"variable @code{max-lisp-eval-depth} which limits the amount of recursion "
"possible in an attempt to recover from program bugs.  If a calculation ever "
"halts incorrectly with the message ``Computation got stuck or ran too "
"long,'' use the @kbd{M} command (@code{calc-more-recursion-depth})  to "
"increase this limit.  (Of course, this will not help if the calculation "
"really did get stuck due to some problem inside Calc.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10407
msgid ""
"The limit is always increased (multiplied) by a factor of two.  There is "
"also an @kbd{I M} (@code{calc-less-recursion-depth}) command which decreases "
"this limit by a factor of two, down to a minimum value of 200.  The default "
"value is 1000."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10410
msgid ""
"These commands also double or halve @code{max-specpdl-size}, another "
"internal Lisp recursion limit.  The minimum value for this limit is 600."
msgstr ""

#. type: cindex
#: ../../calc.texi:10416
#, no-wrap
msgid "Flushing caches"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10432
msgid ""
"Calc saves certain values after they have been computed once.  For example, "
"the @kbd{P} (@code{calc-pi}) command initially ``knows'' the constant @cpi{} "
"to about 20 decimal places; if the current precision is greater than this, "
"it will recompute @cpi{} using a series approximation.  This value will not "
"need to be recomputed ever again unless you raise the precision still "
"further.  Many operations such as logarithms and sines make use of similarly "
"cached values such as @cpiover{4} and @texline @math{\\ln 2}.  @infoline "
"@expr{ln(2)}.  The visible effect of caching is that high-precision "
"computations may seem to do extra work the first time.  Other things cached "
"include powers of two (for the binary arithmetic functions), matrix inverses "
"and determinants, symbolic integrals, and data points computed by the "
"graphing commands."
msgstr ""

#. type: pindex
#: ../../calc.texi:10433
#, no-wrap
msgid "calc-flush-caches"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10439
msgid ""
"If you suspect a Calculator cache has become corrupt, you can use the "
"@code{calc-flush-caches} command to reset all caches to the empty state.  "
"(This should only be necessary in the event of bugs in the Calculator.)  The "
"@kbd{C-x * 0} (with the zero key) command also resets caches along with all "
"other aspects of the Calculator's state."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10447
msgid ""
"A few commands exist to help in the debugging of Calc commands.  "
"@xref{Programming}, to see the various ways that you can write your own Calc "
"commands."
msgstr ""

#. type: kindex
#: ../../calc.texi:10448
#, no-wrap
msgid "Z T"
msgstr ""

#. type: pindex
#: ../../calc.texi:10449
#, no-wrap
msgid "calc-timing"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10455
msgid ""
"The @kbd{Z T} (@code{calc-timing}) command turns on and off a mode in which "
"the timing of slow commands is reported in the Trail.  Any Calc command that "
"takes two seconds or longer writes a line to the Trail showing how many "
"seconds it took.  This value is accurate only to within one second."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10465
msgid ""
"All steps of executing a command are included; in particular, time taken to "
"format the result for display in the stack and trail is counted.  Some "
"prompts also count time taken waiting for them to be answered, while others "
"do not; this depends on the exact implementation of the command.  For best "
"results, if you are timing a sequence that includes prompts or multiple "
"commands, define a keyboard macro to run the whole sequence at once.  Calc's "
"@kbd{X} command (@pxref{Keyboard Macros}) will then report the time taken to "
"execute the whole macro."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10473
msgid ""
"Another advantage of the @kbd{X} command is that while it is executing, the "
"stack and trail are not updated from step to step.  So if you expect the "
"output of your test sequence to leave a result that may take a long time to "
"format and you don't wish to count this formatting time, end your sequence "
"with a @key{DEL} keystroke to clear the result from the stack.  When you run "
"the sequence with @kbd{X}, Calc will never bother to format the large "
"result."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10481
msgid ""
"Another thing @kbd{Z T} does is to increase the Emacs variable "
"@code{gc-cons-threshold} to a much higher value (two million; the usual "
"default in Calc is 250,000) for the duration of each command.  This "
"generally prevents garbage collection during the timing of the command, "
"though it may cause your Emacs process to grow abnormally large.  (Garbage "
"collection time is a major unpredictable factor in the timing of Emacs "
"operations.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10492
msgid ""
"Another command that is useful when debugging your own Lisp extensions to "
"Calc is @kbd{M-x calc-pass-errors}, which disables the error handler that "
"changes the ``@code{max-lisp-eval-depth} exceeded'' message to the much more "
"friendly ``Computation got stuck or ran too long.'' This handler interferes "
"with the Emacs Lisp debugger's @code{debug-on-error} mode.  Errors are "
"reported in the handler itself rather than at the true location of the "
"error.  After you have executed @code{calc-pass-errors}, Lisp errors will be "
"reported correctly but the user-friendly message will be lost."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10501
msgid ""
"This chapter discusses the various types of objects that can be placed on "
"the Calculator stack, how they are displayed, and how they are entered.  "
"(@xref{Data Type Formats}, for information on how these data types are "
"represented as underlying Lisp objects.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10509
msgid ""
"Integers, fractions, and floats are various ways of describing real "
"numbers.  HMS forms also for many purposes act as real numbers.  These types "
"can be combined to form complex numbers, modulo forms, error forms, or "
"interval forms.  (But these last four types cannot be combined arbitrarily: "
"error forms may not contain modulo forms, for example.)  Finally, all these "
"types of numbers may be combined into vectors, matrices, or algebraic "
"formulas."
msgstr ""

#. type: node
#: ../../calc.texi:10526 ../../calc.texi:10528 ../../calc.texi:10529 ../../calc.texi:10532 ../../calc.texi:10554
#, no-wrap
msgid "Integers"
msgstr ""

#. type: menuentry
#: ../../calc.texi:10526
msgid "The most basic data type."
msgstr ""

#. type: node
#: ../../calc.texi:10526 ../../calc.texi:10528 ../../calc.texi:10554 ../../calc.texi:10555 ../../calc.texi:10558 ../../calc.texi:10575
#, no-wrap
msgid "Fractions"
msgstr ""

#. type: menuentry
#: ../../calc.texi:10526
msgid "This and above are called @dfn{rationals}."
msgstr ""

#. type: node
#: ../../calc.texi:10526 ../../calc.texi:10554 ../../calc.texi:10575 ../../calc.texi:10576 ../../calc.texi:10649
#, no-wrap
msgid "Floats"
msgstr ""

#. type: menuentry
#: ../../calc.texi:10526
msgid "This and above are called @dfn{reals}."
msgstr ""

#. type: node
#: ../../calc.texi:10526 ../../calc.texi:10575 ../../calc.texi:10649 ../../calc.texi:10650 ../../calc.texi:10687
#, no-wrap
msgid "Complex Numbers"
msgstr ""

#. type: menuentry
#: ../../calc.texi:10526
msgid "This and above are called @dfn{numbers}."
msgstr ""

#. type: menuentry
#: ../../calc.texi:10526
msgid "Infinities::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:10526
msgid "Vectors and Matrices::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:10526
msgid "Strings::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:10526
msgid "HMS Forms::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:10526
msgid "Date Forms::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:10526
msgid "Modulo Forms::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:10526
msgid "Error Forms::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:10526
msgid "Interval Forms::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:10526
msgid "Incomplete Objects::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:10526
msgid "Variables::"
msgstr ""

#. type: cindex
#: ../../calc.texi:10526 ../../calc.texi:11488 ../../calc.texi:11559 ../../calc.texi:11560 ../../calc.texi:11563
#, no-wrap
msgid "Formulas"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10539
msgid ""
"The Calculator stores integers to arbitrary precision.  Addition, "
"subtraction, and multiplication of integers always yields an exact integer "
"result.  (If the result of a division or exponentiation of integers is not "
"an integer, it is expressed in fractional or floating-point form according "
"to the current Fraction mode.  @xref{Fraction Mode}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10544
msgid ""
"A decimal integer is represented as an optional sign followed by a sequence "
"of digits.  Grouping (@pxref{Grouping Digits}) can be used to insert a comma "
"at every third digit for display purposes, but you must not type commas "
"during the entry of numbers."
msgstr ""

#. type: kindex
#: ../../calc.texi:10545
#, no-wrap
msgid "#"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10553
msgid ""
"A non-decimal integer is represented as an optional sign, a radix between 2 "
"and 36, a @samp{#} symbol, and one or more digits.  For radix 11 and above, "
"the letters A through Z (upper- or lower-case) count as digits and do not "
"terminate numeric entry mode.  @xref{Radix Modes}, for how to set the "
"default radix for display of integers.  Numbers of any radix may be entered "
"at any time.  If you press @kbd{#} at the beginning of a number, the current "
"display radix is used."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10566
msgid ""
"A @dfn{fraction} is a ratio of two integers.  Fractions are traditionally "
"written ``2/3'' but Calc uses the notation @samp{2:3}.  (The @kbd{/} key "
"performs RPN division; the following two sequences push the number "
"@samp{2:3} on the stack: @kbd{2 :@: 3 @key{RET}}, or @kbd{2 @key{RET} 3 /} "
"assuming Fraction mode has been enabled.)  When the Calculator produces a "
"fractional result it always reduces it to simplest form, which may in fact "
"be an integer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10570
msgid ""
"Fractions may also be entered in a three-part form, where @samp{2:3:4} "
"represents two-and-three-quarters.  @xref{Fraction Formats}, for fraction "
"display formats."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10574
msgid ""
"Non-decimal fractions are entered and displayed as "
"@samp{@var{radix}#@var{num}:@var{denom}} (or in the analogous three-part "
"form).  The numerator and denominator always use the same radix."
msgstr ""

#. type: cindex
#: ../../calc.texi:10579
#, no-wrap
msgid "Floating-point numbers"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10590
msgid ""
"A floating-point number or @dfn{float} is a number stored in scientific "
"notation.  The number of significant digits in the fractional part is "
"governed by the current floating precision (@pxref{Precision}).  The range "
"of acceptable values is from @texline @math{10^{-3999999}} @infoline "
"@expr{10^-3999999} (inclusive) to @texline @math{10^{4000000}} @infoline "
"@expr{10^4000000} (exclusive), plus the corresponding negative values and "
"zero."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10600
msgid ""
"Calculations that would exceed the allowable range of values (such as "
"@samp{exp(exp(20))}) are left in symbolic form by Calc.  The messages "
"``floating-point overflow'' or ``floating-point underflow'' indicate that "
"during the calculation a number would have been produced that was too large "
"or too close to zero, respectively, to be represented by Calc.  This does "
"not necessarily mean the final result would have overflowed, just that an "
"overflow occurred while computing the result.  (In fact, it could report an "
"underflow even though the final result would have overflowed!)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10605
msgid ""
"If a rational number and a float are mixed in a calculation, the result will "
"in general be expressed as a float.  Commands that require an integer value "
"(such as @kbd{k g} [@code{gcd}]) will also accept integer-valued floats, "
"i.e., floating-point numbers with nothing after the decimal point."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10612
msgid ""
"Floats are identified by the presence of a decimal point and/or an "
"exponent.  In general a float consists of an optional sign, digits including "
"an optional decimal point, and an optional exponent consisting of an "
"@samp{e}, an optional sign, and up to seven exponent digits.  For example, "
"@samp{23.5e-2} is 23.5 times ten to the minus-second power, or 0.235."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10617
msgid ""
"Floating-point numbers are normally displayed in decimal notation with all "
"significant figures shown.  Exceedingly large or small numbers are displayed "
"in scientific notation.  Various other display options are available.  "
"@xref{Float Formats}."
msgstr ""

#. type: cindex
#: ../../calc.texi:10618 ../../calc.texi:12208
#, no-wrap
msgid "Accuracy of calculations"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10631
msgid ""
"Floating-point numbers are stored in decimal, not binary.  The result of "
"each operation is rounded to the nearest value representable in the number "
"of significant digits specified by the current precision, rounding away from "
"zero in the case of a tie.  Thus (in the default display mode) what you see "
"is exactly what you get.  Some operations such as square roots and "
"transcendental functions are performed with several digits of extra "
"precision and then rounded down, in an effort to make the final result "
"accurate to the full requested precision.  However, accuracy is not "
"rigorously guaranteed.  If you suspect the validity of a result, try doing "
"the same calculation in a higher precision.  The Calculator's arithmetic is "
"not intended to be IEEE-conformant in any way."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10648
msgid ""
"While floats are always @emph{stored} in decimal, they can be entered and "
"displayed in any radix just like integers and fractions.  Since a float that "
"is entered in a radix other that 10 will be converted to decimal, the number "
"that Calc stores may not be exactly the number that was entered, it will be "
"the closest decimal approximation given the current precision.  The notation "
"@samp{@var{radix}#@var{ddd}.@var{ddd}} is a floating-point number whose "
"digits are in the specified radix.  Note that the @samp{.} is more aptly "
"referred to as a ``radix point'' than as a decimal point in this case.  The "
"number @samp{8#123.4567} is defined as @samp{8#1234567 * 8^-4}.  If the "
"radix is 14 or less, you can use @samp{e} notation to write a non-decimal "
"number in scientific notation.  The exponent is written in decimal, and is "
"considered to be a power of the radix: @samp{8#1234567e-4}.  If the radix is "
"15 or above, the letter @samp{e} is a digit, so scientific notation must be "
"written out, e.g., @samp{16#123.4567*16^2}.  The first two exercises of the "
"Modes Tutorial explore some of the properties of non-decimal floats."
msgstr ""

#. type: cindex
#: ../../calc.texi:10653
#, no-wrap
msgid "Complex numbers"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10660
msgid ""
"There are two supported formats for complex numbers: rectangular and polar.  "
"The default format is rectangular, displayed in the form "
"@samp{(@var{real},@var{imag})} where @var{real} is the real part and "
"@var{imag} is the imaginary part, each of which may be any real number.  "
"Rectangular complex numbers can also be displayed in @samp{@var{a}+@var{b}i} "
"notation; @pxref{Complex Formats}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10673
msgid ""
"Polar complex numbers are displayed in the form @texline "
"`@tfn{(}@var{r}@tfn{;}@math{\\theta}@tfn{)}' @infoline "
"`@tfn{(}@var{r}@tfn{;}@var{theta}@tfn{)}' where @var{r} is the nonnegative "
"magnitude and @texline @math{\\theta} @infoline @var{theta} is the argument "
"or phase angle.  The range of @texline @math{\\theta} @infoline @var{theta} "
"depends on the current angular mode (@pxref{Angular Modes}); it is generally "
"between @mathit{-180} and @mathit{+180} degrees or the equivalent range in "
"radians."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10676
msgid ""
"Complex numbers are entered in stages using incomplete objects.  "
"@xref{Incomplete Objects}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10682
msgid ""
"Operations on rectangular complex numbers yield rectangular complex results, "
"and similarly for polar complex numbers.  Where the two types are mixed, or "
"where new complex numbers arise (as for the square root of a negative real), "
"the current @dfn{Polar mode} is used to determine the type.  @xref{Polar "
"Mode}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10686
msgid ""
"A complex result in which the imaginary part is zero (or the phase angle is "
"0 or 180 degrees or @cpi{} radians) is automatically converted to a real "
"number."
msgstr ""

#. type: node
#: ../../calc.texi:10687 ../../calc.texi:10774 ../../calc.texi:10775 ../../calc.texi:10816
#, no-wrap
msgid "Vectors and Matrices"
msgstr ""

#. type: cindex
#: ../../calc.texi:10691
#, no-wrap
msgid "Infinity"
msgstr ""

#. type: cindex
#: ../../calc.texi:10692
#, no-wrap
msgid "@code{inf} variable"
msgstr ""

#. type: cindex
#: ../../calc.texi:10693
#, no-wrap
msgid "@code{uinf} variable"
msgstr ""

#. type: cindex
#: ../../calc.texi:10694
#, no-wrap
msgid "@code{nan} variable"
msgstr ""

#. type: vindex
#: ../../calc.texi:10695
#, no-wrap
msgid "inf"
msgstr ""

#. type: vindex
#: ../../calc.texi:10696
#, no-wrap
msgid "uinf"
msgstr ""

#. type: vindex
#: ../../calc.texi:10697
#, no-wrap
msgid "nan"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10705
msgid ""
"The word @code{inf} represents the mathematical concept of @dfn{infinity}.  "
"Calc actually has three slightly different infinity-like values: @code{inf}, "
"@code{uinf}, and @code{nan}.  These are just regular variable names "
"(@pxref{Variables}); you should avoid using these names for your own "
"variables because Calc gives them special treatment.  Infinities, like all "
"variable names, are normally entered using algebraic entry."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10720
msgid ""
"Mathematically speaking, it is not rigorously correct to treat ``infinity'' "
"as if it were a number, but mathematicians often do so informally.  When "
"they say that @samp{1 / inf = 0}, what they really mean is that @expr{1 / "
"x}, as @expr{x} becomes larger and larger, becomes arbitrarily close to "
"zero.  So you can imagine that if @expr{x} got ``all the way to infinity,'' "
"then @expr{1 / x} would go all the way to zero.  Similarly, when they say "
"that @samp{exp(inf) = inf}, they mean that @texline @math{e^x} @infoline "
"@expr{exp(x)} grows without bound as @expr{x} grows.  The symbol @samp{-inf} "
"likewise stands for an infinitely negative real value; for example, we say "
"that @samp{exp(-inf) = 0}.  You can have an infinity pointing in any "
"direction on the complex plane: @samp{sqrt(-inf) = i inf}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10732
msgid ""
"The same concept of limits can be used to define @expr{1 / 0}.  We really "
"want the value that @expr{1 / x} approaches as @expr{x} approaches zero.  "
"But if all we have is @expr{1 / 0}, we can't tell which direction @expr{x} "
"was coming from.  If @expr{x} was positive and decreasing toward zero, then "
"we should say that @samp{1 / 0 = inf}.  But if @expr{x} was negative and "
"increasing toward zero, the answer is @samp{1 / 0 = -inf}.  In fact, "
"@expr{x} could be an imaginary number, giving the answer @samp{i inf} or "
"@samp{-i inf}.  Calc uses the special symbol @samp{uinf} to mean "
"@dfn{undirected infinity}, i.e., a value which is infinitely large but with "
"an unknown sign (or direction on the complex plane)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10743
msgid ""
"Calc actually has three modes that say how infinities are handled.  "
"Normally, infinities never arise from calculations that didn't already have "
"them.  Thus, @expr{1 / 0} is treated simply as an error and left "
"unevaluated.  The @kbd{m i} (@code{calc-infinite-mode})  command "
"(@pxref{Infinite Mode}) enables a mode in which @expr{1 / 0} evaluates to "
"@code{uinf} instead.  There is also an alternative type of infinite mode "
"which says to treat zeros as if they were positive, so that @samp{1 / 0 = "
"inf}.  While this is less mathematically correct, it may be the answer you "
"want in some cases."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10753
msgid ""
"Since all infinities are ``as large'' as all others, Calc simplifies, e.g., "
"@samp{5 inf} to @samp{inf}.  Another example is @samp{5 - inf = -inf}, where "
"the @samp{-inf} is so large that adding a finite number like five to it does "
"not affect it.  Note that @samp{a - inf} also results in @samp{-inf}; Calc "
"assumes that variables like @code{a} always stand for finite quantities.  "
"Just to show that infinities really are all the same size, note that "
"@samp{sqrt(inf) = inf^2 = exp(inf) = inf} in Calc's notation."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10770
msgid ""
"It's not so easy to define certain formulas like @samp{0 * inf} and "
"@samp{inf / inf}.  Depending on where these zeros and infinities came from, "
"the answer could be literally anything.  The latter formula could be the "
"limit of @expr{x / x} (giving a result of one), or @expr{2 x / x} (giving "
"two), or @expr{x^2 / x} (giving @code{inf}), or @expr{x / x^2} (giving "
"zero).  Calc uses the symbol @code{nan} to represent such an "
"@dfn{indeterminate} value.  (The name ``nan'' comes from analogy with the "
"``NAN'' concept of IEEE standard arithmetic; it stands for ``Not A Number.'' "
"This is somewhat of a misnomer, since @code{nan} @emph{does} stand for some "
"number or infinity, it's just that @emph{which} number it stands for cannot "
"be determined.)  In Calc's notation, @samp{0 * inf = nan} and @samp{inf / "
"inf = nan}.  A few other common indeterminate expressions are @samp{inf - "
"inf} and @samp{inf ^ 0}.  Also, @samp{0 / 0 = nan} if you have turned on "
"Infinite mode (as described above)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10773
msgid ""
"Infinities are especially useful as parts of @dfn{intervals}.  "
"@xref{Interval Forms}."
msgstr ""

#. type: node
#: ../../calc.texi:10774 ../../calc.texi:10816 ../../calc.texi:10817 ../../calc.texi:10821 ../../calc.texi:10893
#, no-wrap
msgid "Strings"
msgstr ""

#. type: cindex
#: ../../calc.texi:10778
#, no-wrap
msgid "Vectors"
msgstr ""

#. type: cindex
#: ../../calc.texi:10779
#, no-wrap
msgid "Plain vectors"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10786
msgid ""
"The @dfn{vector} data type is flexible and general.  A vector is simply a "
"list of zero or more data objects.  When these objects are numbers, the "
"whole is a vector in the mathematical sense.  When these objects are "
"themselves vectors of equal (nonzero) length, the whole is a @dfn{matrix}.  "
"A vector which is not a matrix is referred to here as a @dfn{plain vector}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10798
msgid ""
"A vector is displayed as a list of values separated by commas and enclosed "
"in square brackets: @samp{[1, 2, 3]}.  Thus the following is a 2 row by 3 "
"column matrix: @samp{[[1, 2, 3], [4, 5, 6]]}.  Vectors, like complex "
"numbers, are entered as incomplete objects.  @xref{Incomplete Objects}.  "
"During algebraic entry, vectors are entered all at once in the usual "
"brackets-and-commas form.  Matrices may be entered algebraically as nested "
"vectors, or using the shortcut notation @w{@samp{[1, 2, 3; 4, 5, 6]}}, with "
"rows separated by semicolons.  The commas may usually be omitted when "
"entering vectors: @samp{[1 2 3]}.  Curly braces may be used in place of "
"brackets: @samp{@{1, 2, 3@}}, but the commas are required in this case."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10804
msgid ""
"Traditional vector and matrix arithmetic is also supported; @pxref{Basic "
"Arithmetic} and @pxref{Matrix Functions}.  Many other operations are applied "
"to vectors element-wise.  For example, the complex conjugate of a vector is "
"a vector of the complex conjugates of its elements."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10815
msgid ""
"@tindex vec Algebraic functions for building vectors include @samp{vec(a, b, "
"c)} to build @samp{[a, b, c]}, @samp{cvec(a, n, m)} to build an @texline "
"@math{n\\times m} @infoline @var{n}x@var{m} matrix of @samp{a}s, and "
"@samp{index(n)} to build a vector of integers from 1 to @samp{n}."
msgstr ""

#. type: node
#: ../../calc.texi:10816 ../../calc.texi:10893 ../../calc.texi:10894 ../../calc.texi:10955
#, no-wrap
msgid "HMS Forms"
msgstr ""

#. type: kindex
#: ../../calc.texi:10820
#, no-wrap
msgid "\""
msgstr ""

#. type: cindex
#: ../../calc.texi:10822
#, no-wrap
msgid "Character strings"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10829
msgid ""
"Character strings are not a special data type in the Calculator.  Rather, a "
"string is represented simply as a vector all of whose elements are integers "
"in the range 0 to 255 (ASCII codes).  You can enter a string at any time by "
"pressing the @kbd{\"} key.  Quotation marks and backslashes are written "
"@samp{\\\"} and @samp{\\\\}, respectively, inside strings.  Other notations "
"introduced by backslashes are:"
msgstr ""

#. type: group
#: ../../calc.texi:10840
#, no-wrap
msgid ""
"\\a     7          \\^@@    0\n"
"\\b     8          \\^a-z  1-26\n"
"\\e     27         \\^[    27\n"
"\\f     12         \\^\\\\   28\n"
"\\n     10         \\^]    29\n"
"\\r     13         \\^^    30\n"
"\\t     9          \\^_    31\n"
"                  \\^?    127\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10846
msgid ""
"Finally, a backslash followed by three octal digits produces any character "
"from its ASCII code."
msgstr ""

#. type: kindex
#: ../../calc.texi:10847
#, no-wrap
msgid "d \""
msgstr ""

#. type: pindex
#: ../../calc.texi:10848
#, no-wrap
msgid "calc-display-strings"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10853
msgid ""
"Strings are normally displayed in vector-of-integers form.  The @w{@kbd{d "
"\"}} (@code{calc-display-strings}) command toggles a mode in which any "
"vectors of small integers are displayed as quoted strings instead."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10860
msgid ""
"The backslash notations shown above are also used for displaying strings.  "
"Characters 128 and above are not translated by Calc; unless you have an "
"Emacs modified for 8-bit fonts, these will show up in backslash-octal-digits "
"notation.  For characters below 32, and for character 127, Calc uses the "
"backslash-letter combination if there is one, or otherwise uses a @samp{\\^} "
"sequence."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10864
msgid ""
"The only Calc feature that uses strings is @dfn{compositions}; "
"@pxref{Compositions}.  Strings also provide a convenient way to do "
"conversions between ASCII characters and integers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10878
msgid ""
"@tindex string There is a @code{string} function which provides a different "
"display format for strings.  Basically, @samp{string(@var{s})}, where "
"@var{s} is a vector of integers in the proper range, is displayed as the "
"corresponding string of characters with no surrounding quotation marks or "
"other modifications.  Thus @samp{string(\"ABC\")} (or @samp{string([65 66 "
"67])}) will look like @samp{ABC} on the stack.  This happens regardless of "
"whether @w{@kbd{d \"}} has been used.  The only way to turn it off is to use "
"@kbd{d U} (unformatted language mode) which will display "
"@samp{string(\"ABC\")} instead."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10883
msgid ""
"Control characters are displayed somewhat differently by @code{string}.  "
"Characters below 32, and character 127, are shown using @samp{^} notation "
"(same as shown above, but without the backslash).  The quote and backslash "
"characters are left alone, as are characters 128 and above."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10892
msgid ""
"@tindex bstring The @code{bstring} function is just like @code{string} "
"except that the resulting string is breakable across multiple lines if it "
"doesn't fit all on one line.  Potential break points occur at every space "
"character in the string."
msgstr ""

#. type: node
#: ../../calc.texi:10893 ../../calc.texi:10955 ../../calc.texi:10956 ../../calc.texi:11111
#, no-wrap
msgid "Date Forms"
msgstr ""

#. type: cindex
#: ../../calc.texi:10897
#, no-wrap
msgid "Hours-minutes-seconds forms"
msgstr ""

#. type: cindex
#: ../../calc.texi:10898
#, no-wrap
msgid "Degrees-minutes-seconds forms"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10905
msgid ""
"@dfn{HMS} stands for Hours-Minutes-Seconds; when used as an angular "
"argument, the interpretation is Degrees-Minutes-Seconds.  All functions that "
"operate on angles accept HMS forms.  These are interpreted as degrees "
"regardless of the current angular mode.  It is also possible to use HMS as "
"the angular mode so that calculated angles are expressed in degrees, "
"minutes, and seconds."
msgstr ""

#. type: kindex
#: ../../calc.texi:10906
#, no-wrap
msgid "@@"
msgstr ""

#. type: kindex
#: ../../calc.texi:10910
#, no-wrap
msgid "' @r{(HMS forms)}"
msgstr ""

#. type: kindex
#: ../../calc.texi:10914
#, no-wrap
msgid "\" @r{(HMS forms)}"
msgstr ""

#. type: kindex
#: ../../calc.texi:10918
#, no-wrap
msgid "h @r{(HMS forms)}"
msgstr ""

#. type: kindex
#: ../../calc.texi:10922
#, no-wrap
msgid "o @r{(HMS forms)}"
msgstr ""

#. type: kindex
#: ../../calc.texi:10926
#, no-wrap
msgid "m @r{(HMS forms)}"
msgstr ""

#. type: kindex
#: ../../calc.texi:10930
#, no-wrap
msgid "s @r{(HMS forms)}"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10944
msgid ""
"The default format for HMS values is @samp{@var{hours}@@ @var{mins}' "
"@var{secs}\"}.  During entry, the letters @samp{h} (for ``hours'') or "
"@samp{o} (approximating the ``degrees'' symbol) are accepted as well as "
"@samp{@@}, @samp{m} is accepted in place of @samp{'}, and @samp{s} is "
"accepted in place of @samp{\"}.  The @var{hours} value is an integer (or "
"integer-valued float).  The @var{mins} value is an integer or integer-valued "
"float between 0 and 59.  The @var{secs} value is a real number between 0 "
"(inclusive) and 60 (exclusive).  A positive HMS form is interpreted as "
"@var{hours} + @var{mins}/60 + @var{secs}/3600.  A negative HMS form is "
"interpreted as @mathit{- @var{hours}} @mathit{-} @var{mins}/60 @mathit{-} "
"@var{secs}/3600.  Display format for HMS forms is quite flexible.  @xref{HMS "
"Formats}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10949
msgid ""
"HMS forms can be added and subtracted.  When they are added to numbers, the "
"numbers are interpreted according to the current angular mode.  HMS forms "
"can also be multiplied and divided by real numbers.  Dividing two HMS forms "
"produces a real-valued ratio of the two angles."
msgstr ""

#. type: pindex
#: ../../calc.texi:10950
#, no-wrap
msgid "calc-time"
msgstr ""

#. type: cindex
#: ../../calc.texi:10951
#, no-wrap
msgid "Time of day"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10954
msgid ""
"Just for kicks, @kbd{M-x calc-time} pushes the current time of day on the "
"stack as an HMS form."
msgstr ""

#. type: node
#: ../../calc.texi:10955 ../../calc.texi:11111 ../../calc.texi:11112 ../../calc.texi:11195
#, no-wrap
msgid "Modulo Forms"
msgstr ""

#. type: cindex
#: ../../calc.texi:10959
#, no-wrap
msgid "Date forms"
msgstr ""

#. type: Plain text
#: ../../calc.texi:10967
msgid ""
"A @dfn{date form} represents a date and possibly an associated time.  Simple "
"date arithmetic is supported: Adding a number to a date produces a new date "
"shifted by that many days; adding an HMS form to a date shifts it by that "
"many hours.  Subtracting two date forms computes the number of days between "
"them (represented as a simple number).  Many other operations, such as "
"multiplying two date forms, are nonsensical and are not allowed by Calc."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10973
msgid ""
"Date forms are entered and displayed enclosed in @samp{< >} brackets.  The "
"default format is, e.g., @samp{<Wed Jan 9, 1991>} for dates, or "
"@samp{<3:32:20pm Wed Jan 9, 1991>} for dates with times.  Input is flexible; "
"date forms can be entered in any of the usual notations for dates and "
"times.  @xref{Date Formats}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10982
msgid ""
"Date forms are stored internally as numbers, specifically the number of days "
"since midnight on the morning of December 31 of the year 1 BC@.  If the "
"internal number is an integer, the form represents a date only; if the "
"internal number is a fraction or float, the form represents a date and "
"time.  For example, @samp{<6:00am Thu Jan 10, 1991>} is represented by the "
"number 726842.25.  The standard precision of 12 decimal digits is enough to "
"ensure that a (reasonable) date and time can be stored without roundoff "
"error."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10992
msgid ""
"If the current precision is greater than 12, date forms will keep additional "
"digits in the seconds position.  For example, if the precision is 15, the "
"seconds will keep three digits after the decimal point.  Decreasing the "
"precision below 12 may cause the time part of a date form to become "
"inaccurate.  This can also happen if astronomically high years are used, "
"though this will not be an issue in everyday (or even everymillennium) use.  "
"Note that date forms without times are stored as exact integers, so roundoff "
"is never an issue for them."
msgstr ""

#. type: Plain text
#: ../../calc.texi:10996
msgid ""
"You can use the @kbd{v p} (@code{calc-pack}) and @kbd{v u} "
"(@code{calc-unpack}) commands to get at the numerical representation of a "
"date form.  @xref{Packing and Unpacking}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11005
msgid ""
"Date forms can go arbitrarily far into the future or past.  Negative year "
"numbers represent years BC@.  There is no ``year 0''; the day before "
"@samp{<Mon Jan 1, +1>} is @samp{<Sun Dec 31, -1>}.  These are days 1 and 0 "
"respectively in Calc's internal numbering scheme.  The Gregorian calendar is "
"used for all dates, including dates before the Gregorian calendar was "
"invented (although that can be configured; see below).  Thus Calc's use of "
"the day number @mathit{-10000} to represent August 15, 28 BC should be taken "
"with a grain of salt."
msgstr ""

#. type: cindex
#: ../../calc.texi:11006
#, no-wrap
msgid "Julian calendar"
msgstr ""

#. type: cindex
#: ../../calc.texi:11007
#, no-wrap
msgid "Gregorian calendar"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11028
msgid ""
"Some historical background: The Julian calendar was created by Julius Caesar "
"in the year 46 BC as an attempt to fix the confusion caused by the irregular "
"Roman calendar that was used before that time.  The Julian calendar "
"introduced an extra day in all years divisible by four.  After some initial "
"confusion, the calendar was adopted around the year we call 8 AD@.  Some "
"centuries later it became apparent that the Julian year of 365.25 days was "
"itself not quite right.  In 1582 Pope Gregory XIII introduced the Gregorian "
"calendar, which added the new rule that years divisible by 100, but not by "
"400, were not to be considered leap years despite being divisible by four.  "
"Many countries delayed adoption of the Gregorian calendar because of "
"religious differences.  For example, Great Britain and the British colonies "
"switched to the Gregorian calendar in September 1752, when the Julian "
"calendar was eleven days behind the Gregorian calendar.  That year in "
"Britain, the day after September 2 was September 14.  To take another "
"example, Russia did not adopt the Gregorian calendar until 1918, and that "
"year in Russia the day after January 31 was February 14.  Calc's reckoning "
"therefore matches English practice starting in 1752 and Russian practice "
"starting in 1918, but disagrees with earlier dates in both countries."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11035
msgid ""
"When the Julian calendar was introduced, it had January 1 as the first day "
"of the year.  By the Middle Ages, many European countries had changed the "
"beginning of a new year to a different date, often to a religious festival.  "
"Almost all countries reverted to using January 1 as the beginning of the "
"year by the time they adopted the Gregorian calendar."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11045
msgid ""
"Some calendars attempt to mimic the historical situation by using the "
"Gregorian calendar for recent dates and the Julian calendar for older "
"dates. The @code{cal} program in most Unix implementations does this, for "
"example. While January 1 wasn't always the beginning of a calendar year, "
"these hybrid calendars still use January 1 as the beginning of the year even "
"for older dates.  The customizable variable @code{calc-gregorian-switch} "
"(@pxref{Customizing Calc}) can be set to have Calc's date forms switch from "
"the Julian to Gregorian calendar at any specified date."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11052
msgid ""
"Today's timekeepers introduce an occasional ``leap second''.  These do not "
"occur regularly and Calc does not take these minor effects into account.  "
"(If it did, it would have to report a non-integer number of days between, "
"say, @samp{<12:00am Mon Jan 1, 1900>} and @samp{<12:00am Sat Jan 1, 2000>}.)"
msgstr ""

#. type: cindex
#: ../../calc.texi:11053
#, no-wrap
msgid "Julian day counting"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11064
msgid ""
"Another day counting system in common use is, confusingly, also called "
"``Julian.'' Julian days go from noon to noon.  The Julian day number is the "
"numbers of days since 12:00 noon (GMT) on November 24, 4714 BC in the "
"Gregorian calendar (i.e., January 1, 4713 BC in the Julian calendar).  In "
"Calc's scheme (in GMT) the Julian day origin is @mathit{-1721424.5}, because "
"Calc starts at midnight instead of noon.  Thus to convert a Calc date code "
"obtained by unpacking a date form into a Julian day number, simply add "
"1721424.5 after compensating for the time zone difference.  The built-in "
"@kbd{t J} command performs this conversion for you."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11094
msgid ""
"The Julian day number is based on the Julian cycle, which was invented in "
"1583 by Joseph Justus Scaliger.  Scaliger named it the Julian cycle since it "
"involves the Julian calendar, but some have suggested that Scaliger named it "
"in honor of his father, Julius Caesar Scaliger.  The Julian cycle is based "
"on three other cycles: the indiction cycle, the Metonic cycle, and the solar "
"cycle.  The indiction cycle is a 15 year cycle originally used by the Romans "
"for tax purposes but later used to date medieval documents.  The Metonic "
"cycle is a 19 year cycle; 19 years is close to being a common multiple of a "
"solar year and a lunar month, and so every 19 years the phases of the moon "
"will occur on the same days of the year.  The solar cycle is a 28 year "
"cycle; the Julian calendar repeats itself every 28 years.  The smallest time "
"period which contains multiples of all three cycles is the least common "
"multiple of 15 years, 19 years and 28 years, which (since they're pairwise "
"relatively prime) is @texline @math{15\\times 19\\times 28 = 7980} years.  "
"@infoline 15*19*28 = 7980 years.  This is the length of a Julian cycle.  "
"Working backwards, the previous year in which all three cycles began was "
"4713 BC, and so Scaliger chose that year as the beginning of a Julian "
"cycle.  Since at the time there were no historical records from before 4713 "
"BC, using this year as a starting point had the advantage of avoiding "
"negative year numbers.  In 1849, the astronomer John Herschel (son of "
"William Herschel) suggested using the number of days since the beginning of "
"the Julian cycle as an astronomical dating system; this idea was taken up by "
"other astronomers.  (At the time, noon was the start of the astronomical "
"day.  Herschel originally suggested counting the days since Jan 1, 4713 BC "
"at noon Alexandria time; this was later amended to noon GMT@.)  Julian day "
"numbering is largely used in astronomy."
msgstr ""

#. type: cindex
#: ../../calc.texi:11095
#, no-wrap
msgid "Unix time format"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11110
msgid ""
"The Unix operating system measures time as an integer number of seconds "
"since midnight, Jan 1, 1970.  To convert a Calc date value into a Unix time "
"stamp, first subtract 719163 (the code for @samp{<Jan 1, 1970>}), then "
"multiply by 86400 (the number of seconds in a day) and press @kbd{R} to "
"round to the nearest integer.  If you have a date form, you can simply "
"subtract the day @samp{<Jan 1, 1970>} instead of unpacking and subtracting "
"719163.  Likewise, divide by 86400 and add @samp{<Jan 1, 1970>} to convert "
"from Unix time to a Calc date form.  (Note that Unix normally maintains the "
"time in the GMT time zone; you may need to subtract five hours to get New "
"York time, or eight hours for California time.  The same is usually true of "
"Julian day counts.)  The built-in @kbd{t U} command performs these "
"conversions."
msgstr ""

#. type: node
#: ../../calc.texi:11111 ../../calc.texi:11195 ../../calc.texi:11196 ../../calc.texi:11310
#, no-wrap
msgid "Error Forms"
msgstr ""

#. type: cindex
#: ../../calc.texi:11115
#, no-wrap
msgid "Modulo forms"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11125
msgid ""
"A @dfn{modulo form} is a real number which is taken modulo (i.e., within an "
"integer multiple of) some value @var{M}.  Arithmetic modulo @var{M} often "
"arises in number theory.  Modulo forms are written `@var{a} @tfn{mod} "
"@var{M}', where @var{a} and @var{M} are real numbers or HMS forms, and "
"@texline @math{0 \\le a < M}.  @infoline @expr{0 <= a < @var{M}}.  In many "
"applications @expr{a} and @expr{M} will be integers but this is not "
"required."
msgstr ""

#. type: kindex
#: ../../calc.texi:11129
#, no-wrap
msgid "M @r{(modulo forms)}"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11140
msgid ""
"@tindex mod (operator)  To create a modulo form during numeric entry, press "
"the shift-@kbd{M} key to enter the word @samp{mod}.  As a special "
"convenience, pressing shift-@kbd{M} a second time automatically enters the "
"value of @expr{M} that was most recently used before.  During algebraic "
"entry, either type @samp{mod} by hand or press @kbd{M-m} (that's "
"@kbd{@key{META}-m}).  Once again, pressing this a second time enters the "
"current modulo."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11147
msgid ""
"Modulo forms are not to be confused with the modulo operator @samp{%}.  The "
"expression @samp{27 % 10} means to compute 27 modulo 10 to produce the "
"result 7.  Further computations treat this 7 as just a regular integer.  The "
"expression @samp{27 mod 10} produces the result @samp{7 mod 10}; further "
"computations with this value are again reduced modulo 10 so that the result "
"always lies in the desired range."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11156
msgid ""
"When two modulo forms with identical @expr{M}'s are added or multiplied, the "
"Calculator simply adds or multiplies the values, then reduces modulo "
"@expr{M}.  If one argument is a modulo form and the other a plain number, "
"the plain number is treated like a compatible modulo form.  It is also "
"possible to raise modulo forms to powers; the result is the value raised to "
"the power, then reduced modulo @expr{M}.  (When all values involved are "
"integers, this calculation is done much more efficiently than actually "
"computing the power and then reducing.)"
msgstr ""

#. type: cindex
#: ../../calc.texi:11157
#, no-wrap
msgid "Modulo division"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11172
msgid ""
"Two modulo forms `@var{a} @tfn{mod} @var{M}' and `@var{b} @tfn{mod} @var{M}' "
"can be divided if @expr{a}, @expr{b}, and @expr{M} are all integers.  The "
"result is the modulo form which, when multiplied by `@var{b} @tfn{mod} "
"@var{M}', produces `@var{a} @tfn{mod} @var{M}'.  If there is no solution to "
"this equation (which can happen only when @expr{M} is non-prime), or if any "
"of the arguments are non-integers, the division is left in symbolic form.  "
"Other operations, such as square roots, are not yet supported for modulo "
"forms.  (Note that, although @w{`@tfn{(}@var{a} @tfn{mod} "
"@var{M}@tfn{)^.5}'} will compute a ``modulo square root'' in the sense of "
"reducing @texline @math{\\sqrt a} @infoline @expr{sqrt(a)} modulo @expr{M}, "
"this is not a useful definition from the number-theoretical point of view.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11180
msgid ""
"It is possible to mix HMS forms and modulo forms.  For example, an HMS form "
"modulo 24 could be used to manipulate clock times; an HMS form modulo 360 "
"would be suitable for angles.  Making the modulo @expr{M} also be an HMS "
"form eliminates troubles that would arise if the angular mode were "
"inadvertently set to Radians, in which case @w{@samp{2@@ 0' 0\" mod 24}} "
"would be interpreted as two degrees modulo 24 radians!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11184
msgid ""
"Modulo forms cannot have variables or formulas for components.  If you enter "
"the formula @samp{(x + 2) mod 5}, Calc propagates the modulus to each of the "
"coefficients: @samp{(1 mod 5) x + (2 mod 5)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11187
msgid ""
"You can use @kbd{v p} and @kbd{%} to modify modulo forms.  @xref{Packing and "
"Unpacking}.  @xref{Basic Arithmetic}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11194
msgid ""
"@tindex makemod The algebraic function @samp{makemod(a, m)} builds the "
"modulo form @w{@samp{a mod m}}."
msgstr ""

#. type: node
#: ../../calc.texi:11195 ../../calc.texi:11310 ../../calc.texi:11311 ../../calc.texi:11425
#, no-wrap
msgid "Interval Forms"
msgstr ""

#. type: cindex
#: ../../calc.texi:11199
#, no-wrap
msgid "Error forms"
msgstr ""

#. type: cindex
#: ../../calc.texi:11200
#, no-wrap
msgid "Standard deviations"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11215
msgid ""
"An @dfn{error form} is a number with an associated standard deviation, as in "
"@samp{2.3 +/- 0.12}.  The notation @texline `@var{x} @tfn{+/-} "
"@math{\\sigma}' @infoline `@var{x} @tfn{+/-} sigma' stands for an uncertain "
"value which follows a normal or Gaussian distribution of mean @expr{x} and "
"standard deviation or ``error'' @texline @math{\\sigma}.  @infoline "
"@expr{sigma}.  Both the mean and the error can be either numbers or "
"formulas.  Generally these are real numbers but the mean may also be "
"complex.  If the error is negative or complex, it is changed to its absolute "
"value.  An error form with zero error is converted to a regular number by "
"the Calculator."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11225
msgid ""
"All arithmetic and transcendental functions accept error forms as input.  "
"Operations on the mean-value part work just like operations on regular "
"numbers.  The error part for any function @expr{f(x)} (such as @texline "
"@math{\\sin x} @infoline @expr{sin(x)})  is defined by the error of @expr{x} "
"times the derivative of @expr{f} evaluated at the mean value of @expr{x}.  "
"For a two-argument function @expr{f(x,y)} (such as addition) the error is "
"the square root of the sum of the squares of the errors due to @expr{x} and "
"@expr{y}."
msgstr ""

#. type: tex
#: ../../calc.texi:11236
#, no-wrap
msgid ""
"$$ \\eqalign{\n"
"  f(x \\hbox{\\code{ +/- }} \\sigma)\n"
"    &= f(x) \\hbox{\\code{ +/- }} \\sigma \\left| {df(x) \\over dx} \\right| "
"\\cr\n"
"  f(x \\hbox{\\code{ +/- }} \\sigma_x, y \\hbox{\\code{ +/- }} \\sigma_y)\n"
"    &= f(x,y) \\hbox{\\code{ +/- }}\n"
"        \\sqrt{\\left(\\sigma_x \\left| {\\partial f(x,y) \\over \\partial "
"x}\n"
"                             \\right| \\right)^2\n"
"             +\\left(\\sigma_y \\left| {\\partial f(x,y) \\over \\partial "
"y}\n"
"                             \\right| \\right)^2 } \\cr\n"
"} $$\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11245
msgid ""
"Note that this definition assumes the errors in @expr{x} and @expr{y} are "
"uncorrelated.  A side effect of this definition is that @samp{(2 +/- 1) * (2 "
"+/- 1)} is not the same as @samp{(2 +/- 1)^2}; the former represents the "
"product of two independent values which happen to have the same probability "
"distributions, and the latter is the product of one random value with "
"itself.  The former will produce an answer with less error, since on the "
"average the two independent errors can be expected to cancel out."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11280
msgid ""
"Consult a good text on error analysis for a discussion of the proper use of "
"standard deviations.  Actual errors often are neither Gaussian-distributed "
"nor uncorrelated, and the above formulas are valid only when errors are "
"small.  As an example, the error arising from @texline `@tfn{sin(}@var{x} "
"@tfn{+/-} @math{\\sigma}@tfn{)}' @infoline `@tfn{sin(}@var{x} @tfn{+/-} "
"@var{sigma}@tfn{)}' is @texline `@math{\\sigma} "
"@tfn{abs(cos(}@var{x}@tfn{))}'.  @infoline `@var{sigma} "
"@tfn{abs(cos(}@var{x}@tfn{))}'.  When @expr{x} is close to zero, @texline "
"@math{\\cos x} @infoline @expr{cos(x)} is close to one so the error in the "
"sine is close to @texline @math{\\sigma}; @infoline @expr{sigma}; this makes "
"sense, since @texline @math{\\sin x} @infoline @expr{sin(x)} is "
"approximately @expr{x} near zero, so a given error in @expr{x} will produce "
"about the same error in the sine.  Likewise, near 90 degrees @texline "
"@math{\\cos x} @infoline @expr{cos(x)} is nearly zero and so the computed "
"error is small: The sine curve is nearly flat in that region, so an error in "
"@expr{x} has relatively little effect on the value of @texline @math{\\sin "
"x}.  @infoline @expr{sin(x)}.  However, consider @samp{sin(90 +/- 1000)}.  "
"The cosine of 90 is zero, so Calc will report zero error! We get an "
"obviously wrong result because we have violated the small-error "
"approximation underlying the error analysis.  If the error in @expr{x} had "
"been small, the error in @texline @math{\\sin x} @infoline @expr{sin(x)} "
"would indeed have been negligible."
msgstr ""

#. type: kindex
#: ../../calc.texi:11284
#, no-wrap
msgid "p @r{(error forms)}"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11291
msgid ""
"@tindex +/- To enter an error form during regular numeric entry, use the "
"@kbd{p} (``plus-or-minus'') key to type the @samp{+/-} symbol.  (If you try "
"actually typing @samp{+/-} the @kbd{+} key will be interpreted as the "
"Calculator's @kbd{+} command!)  Within an algebraic formula, you can press "
"@kbd{M-+} to type the @samp{+/-} symbol, or type it out by hand."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11300
msgid ""
"Error forms and complex numbers can be mixed; the formulas shown above are "
"used for complex numbers, too; note that if the error part evaluates to a "
"complex number its absolute value (or the square root of the sum of the "
"squares of the absolute values of the two error contributions) is used.  "
"Mathematically, this corresponds to a radially symmetric Gaussian "
"distribution of numbers on the complex plane.  However, note that Calc "
"considers an error form with real components to represent a real number, not "
"a complex distribution around a real mean."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11303
msgid ""
"Error forms may also be composed of HMS forms.  For best results, both the "
"mean and the error should be HMS forms if either one is."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11309
msgid ""
"@tindex sdev The algebraic function @samp{sdev(a, b)} builds the error form "
"@samp{a +/- b}."
msgstr ""

#. type: node
#: ../../calc.texi:11310 ../../calc.texi:11425 ../../calc.texi:11426 ../../calc.texi:11488
#, no-wrap
msgid "Incomplete Objects"
msgstr ""

#. type: cindex
#: ../../calc.texi:11314
#, no-wrap
msgid "Interval forms"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11324
msgid ""
"An @dfn{interval} is a subset of consecutive real numbers.  For example, the "
"interval @samp{[2 ..@: 4]} represents all the numbers from 2 to 4, "
"inclusive.  If you multiply it by the interval @samp{[0.5 ..@: 2]} you "
"obtain @samp{[1 ..@: 8]}.  This calculation represents the fact that if you "
"multiply some number in the range @samp{[2 ..@: 4]} by some other number in "
"the range @samp{[0.5 ..@: 2]}, your result will lie in the range from 1 to "
"8.  Interval arithmetic is used to get a worst-case estimate of the possible "
"range of values a computation will produce, given the set of possible values "
"of the input."
msgstr ""

#. type: ifnottex
#: ../../calc.texi:11336
msgid ""
"Calc supports several varieties of intervals, including @dfn{closed} "
"intervals of the type shown above, @dfn{open} intervals such as @samp{(2 "
"..@: 4)}, which represents the range of numbers from 2 to 4 "
"@emph{exclusive}, and @dfn{semi-open} intervals in which one end uses a "
"round parenthesis and the other a square bracket.  In mathematical terms, "
"@samp{[2 ..@: 4]} means @expr{2 <= x <= 4}, whereas @samp{[2 ..@: 4)} "
"represents @expr{2 <= x < 4}, @samp{(2 ..@: 4]} represents @expr{2 < x <= "
"4}, and @samp{(2 ..@: 4)} represents @expr{2 < x < 4}."
msgstr ""

#. type: tex
#: ../../calc.texi:11350
#, no-wrap
msgid ""
"Calc supports several varieties of intervals, including \\dfn{closed}\n"
"intervals of the type shown above, \\dfn{open} intervals such as\n"
"\\samp{(2 ..\\: 4)}, which represents the range of numbers from 2 to 4\n"
"\\emph{exclusive}, and \\dfn{semi-open} intervals in which one end\n"
"uses a round parenthesis and the other a square bracket.  In mathematical\n"
"terms,\n"
"$$ \\eqalign{\n"
"   [2 \\hbox{\\cite{..}} 4]  &\\quad\\hbox{means}\\quad  2 \\le x \\le 4  "
"\\cr\n"
"   [2 \\hbox{\\cite{..}} 4)  &\\quad\\hbox{means}\\quad  2 \\le x  <  4  "
"\\cr\n"
"   (2 \\hbox{\\cite{..}} 4]  &\\quad\\hbox{means}\\quad  2  <  x \\le 4  "
"\\cr\n"
"   (2 \\hbox{\\cite{..}} 4)  &\\quad\\hbox{means}\\quad  2  <  x  <  4  "
"\\cr\n"
"} $$\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11364
msgid ""
"The lower and upper limits of an interval must be either real numbers (or "
"HMS or date forms), or symbolic expressions which are assumed to be "
"real-valued, or @samp{-inf} and @samp{inf}.  In general the lower limit must "
"be less than the upper limit.  A closed interval containing only one value, "
"@samp{[3 ..@: 3]}, is converted to a plain number (3)  automatically.  An "
"interval containing no values at all (such as @samp{[3 ..@: 2]} or @samp{[2 "
"..@: 2)}) can be represented but is not guaranteed to behave well when used "
"in arithmetic.  Note that the interval @samp{[3 .. inf)} represents all real "
"numbers greater than or equal to 3, and @samp{(-inf .. inf)} represents all "
"real numbers.  In fact, @samp{[-inf .. inf]} represents all real numbers "
"including the real infinities."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11372
msgid ""
"Intervals are entered in the notation shown here, either as algebraic "
"formulas, or using incomplete forms.  (@xref{Incomplete Objects}.)  In "
"algebraic formulas, multiple periods in a row are collected from left to "
"right, so that @samp{1...1e2} is interpreted as @samp{1.0 ..@: 1e2} rather "
"than @samp{1 ..@: 0.1e2}.  Add spaces or zeros if you want to get the other "
"interpretation.  If you omit the lower or upper limit, a default of "
"@samp{-inf} or @samp{inf} (respectively) is furnished."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11382
msgid ""
"Infinite mode also affects operations on intervals (@pxref{Infinities}).  "
"Calc will always introduce an open infinity, as in @samp{1 / (0 .. 2] = [0.5 "
".. inf)}.  But closed infinities, @w{@samp{1 / [0 .. 2] = [0.5 .. inf]}}, "
"arise only in Infinite mode; otherwise they are left unevaluated.  Note that "
"the ``direction'' of a zero is not an issue in this case since the zero is "
"always assumed to be continuous with the rest of the interval.  For "
"intervals that contain zero inside them Calc is forced to give the result, "
"@samp{1 / (-2 .. 2) = [-inf .. inf]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11398
msgid ""
"While it may seem that intervals and error forms are similar, they are based "
"on entirely different concepts of inexact quantities.  An error form "
"@texline `@var{x} @tfn{+/-} @math{\\sigma}' @infoline `@var{x} @tfn{+/-} "
"@var{sigma}' means a variable is random, and its value could be anything but "
"is ``probably'' within one @texline @math{\\sigma} @infoline @var{sigma} of "
"the mean value @expr{x}. An interval `@tfn{[}@var{a} @tfn{..@:} "
"@var{b}@tfn{]}' means a variable's value is unknown, but guaranteed to lie "
"in the specified range.  Error forms are statistical or ``average case'' "
"approximations; interval arithmetic tends to produce ``worst case'' bounds "
"on an answer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11401
msgid ""
"Intervals may not contain complex numbers, but they may contain HMS forms or "
"date forms."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11404
msgid ""
"@xref{Set Operations}, for commands that interpret interval forms as subsets "
"of the set of real numbers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11413
msgid ""
"@tindex intv The algebraic function @samp{intv(n, a, b)} builds an interval "
"form from @samp{a} to @samp{b}; @samp{n} is an integer code which must be 0 "
"for @samp{(..)}, 1 for @samp{(..]}, 2 for @samp{[..)}, or 3 for @samp{[..]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11424
msgid ""
"Please note that in fully rigorous interval arithmetic, care would be taken "
"to make sure that the computation of the lower bound rounds toward minus "
"infinity, while upper bound computations round toward plus infinity.  Calc's "
"arithmetic always uses a round-to-nearest mode, which means that roundoff "
"errors could creep into an interval calculation to produce intervals "
"slightly smaller than they ought to be.  For example, entering @samp{[1..2]} "
"and pressing @kbd{Q 2 ^} should yield the interval @samp{[1..2]} again, but "
"in fact it yields the (slightly too small) interval @samp{[1..1.9999999]} "
"due to roundoff error."
msgstr ""

#. type: node
#: ../../calc.texi:11425 ../../calc.texi:11488 ../../calc.texi:11489 ../../calc.texi:11559
#, no-wrap
msgid "Variables"
msgstr ""

#. type: kindex
#: ../../calc.texi:11432
#, no-wrap
msgid "["
msgstr ""

#. type: kindex
#: ../../calc.texi:11436
#, no-wrap
msgid "("
msgstr ""

#. type: kindex
#: ../../calc.texi:11437
#, no-wrap
msgid ","
msgstr ""

#. type: kindex
#: ../../calc.texi:11441
#, no-wrap
msgid "]"
msgstr ""

#. type: kindex
#: ../../calc.texi:11445
#, no-wrap
msgid ")"
msgstr ""

#. type: cindex
#: ../../calc.texi:11446
#, no-wrap
msgid "Incomplete vectors"
msgstr ""

#. type: cindex
#: ../../calc.texi:11447
#, no-wrap
msgid "Incomplete complex numbers"
msgstr ""

#. type: cindex
#: ../../calc.texi:11448
#, no-wrap
msgid "Incomplete interval forms"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11455
msgid ""
"When @kbd{(} or @kbd{[} is typed to begin entering a complex number or "
"vector, respectively, the effect is to push an @dfn{incomplete} complex "
"number or vector onto the stack.  The @kbd{,} key adds the value(s) at the "
"top of the stack onto the current incomplete object.  The @kbd{)} and "
"@kbd{]} keys ``close'' the incomplete object after adding any values on the "
"top of the stack in front of the incomplete object."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11459
msgid ""
"As a result, the sequence of keystrokes @kbd{[ 2 , 3 @key{RET} 2 * , 9 ]} "
"pushes the vector @samp{[2, 6, 9]} onto the stack.  Likewise, @kbd{( 1 , 2 Q "
")} pushes the complex number @samp{(1, 1.414)} (approximately)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11464
msgid ""
"If several values lie on the stack in front of the incomplete object, all "
"are collected and appended to the object.  Thus the @kbd{,} key is "
"redundant: @kbd{[ 2 @key{RET} 3 @key{RET} 2 * 9 ]}.  Some people prefer the "
"equivalent @key{SPC} key to @key{RET}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11469
msgid ""
"As a special case, typing @kbd{,} immediately after @kbd{(}, @kbd{[}, or "
"@kbd{,} adds a zero or duplicates the preceding value in the list being "
"formed.  Typing @key{DEL} during incomplete entry removes the last item from "
"the list."
msgstr ""

#. type: kindex
#: ../../calc.texi:11470
#, no-wrap
msgid ";"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11475
msgid ""
"The @kbd{;} key is used in the same way as @kbd{,} to create polar complex "
"numbers: @kbd{( 1 ; 2 )}.  When entering a vector, @kbd{;} is useful for "
"creating a matrix.  In particular, @kbd{[ [ 1 , 2 ; 3 , 4 ; 5 , 6 ] ]} is "
"equivalent to @kbd{[ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ]}."
msgstr ""

#. type: kindex
#: ../../calc.texi:11476
#, no-wrap
msgid ".."
msgstr ""

#. type: pindex
#: ../../calc.texi:11477
#, no-wrap
msgid "calc-dots"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11484
msgid ""
"Incomplete entry is also used to enter intervals.  For example, @kbd{[ 2 "
"..@: 4 )} enters a semi-open interval.  Note that when you type the first "
"period, it will be interpreted as a decimal point, but when you type a "
"second period immediately afterward, it is re-interpreted as part of the "
"interval symbol.  Typing @kbd{..} corresponds to executing the "
"@code{calc-dots} command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11487
msgid ""
"If you find incomplete entry distracting, you may wish to enter vectors and "
"complex numbers as algebraic formulas by pressing the apostrophe key."
msgstr ""

#. type: cindex
#: ../../calc.texi:11492
#, no-wrap
msgid "Variables, in formulas"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11507
msgid ""
"A @dfn{variable} is somewhere between a storage register on a conventional "
"calculator, and a variable in a programming language.  (In fact, a Calc "
"variable is really just an Emacs Lisp variable that contains a Calc number "
"or formula.)  A variable's name is normally composed of letters and digits.  "
"Calc also allows apostrophes and @code{#} signs in variable names.  (The "
"Calc variable @code{foo} corresponds to the Emacs Lisp variable "
"@code{var-foo}, but unless you access the variable from within Emacs Lisp, "
"you don't need to worry about it.  Variable names in algebraic formulas "
"implicitly have @samp{var-} prefixed to their names.  The @samp{#} character "
"in variable names used in algebraic formulas corresponds to a dash @samp{-} "
"in the Lisp variable name.  If the name contains any dashes, the prefix "
"@samp{var-} is @emph{not} automatically added.  Thus the two formulas "
"@samp{foo + 1} and @samp{var#foo + 1} both refer to the same variable.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11514
msgid ""
"In a command that takes a variable name, you can either type the full name "
"of a variable, or type a single digit to use one of the special convenience "
"variables @code{q0} through @code{q9}.  For example, @kbd{3 s s 2} stores "
"the number 3 in variable @code{q2}, and @w{@kbd{3 s s foo @key{RET}}} stores "
"that number in variable @code{foo}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11518
msgid ""
"To push a variable itself (as opposed to the variable's value) on the stack, "
"enter its name as an algebraic expression using the apostrophe (@key{'}) "
"key."
msgstr ""

#. type: kindex
#: ../../calc.texi:11519
#, no-wrap
msgid "="
msgstr ""

#. type: pindex
#: ../../calc.texi:11520
#, no-wrap
msgid "calc-evaluate"
msgstr ""

#. type: cindex
#: ../../calc.texi:11521
#, no-wrap
msgid "Evaluation of variables in a formula"
msgstr ""

#. type: cindex
#: ../../calc.texi:11522
#, no-wrap
msgid "Variables, evaluation"
msgstr ""

#. type: cindex
#: ../../calc.texi:11523
#, no-wrap
msgid "Formulas, evaluation"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11533
msgid ""
"The @kbd{=} (@code{calc-evaluate}) key ``evaluates'' a formula by replacing "
"all variables in the formula which have been given values by a "
"@code{calc-store} or @code{calc-let} command by their stored values.  Other "
"variables are left alone.  Thus a variable that has not been stored acts "
"like an abstract variable in algebra; a variable that has been stored acts "
"more like a register in a traditional calculator.  With a positive numeric "
"prefix argument, @kbd{=} evaluates the top @var{n} stack entries; with a "
"negative argument, @kbd{=} evaluates the @var{n}th stack entry."
msgstr ""

#. type: cindex
#: ../../calc.texi:11534 ../../calc.texi:18259
#, no-wrap
msgid "@code{e} variable"
msgstr ""

#. type: cindex
#: ../../calc.texi:11535 ../../calc.texi:18256
#, no-wrap
msgid "@code{pi} variable"
msgstr ""

#. type: cindex
#: ../../calc.texi:11536 ../../calc.texi:13316
#, no-wrap
msgid "@code{i} variable"
msgstr ""

#. type: cindex
#: ../../calc.texi:11537 ../../calc.texi:18267
#, no-wrap
msgid "@code{phi} variable"
msgstr ""

#. type: cindex
#: ../../calc.texi:11538 ../../calc.texi:18262
#, no-wrap
msgid "@code{gamma} variable"
msgstr ""

#. type: defun
#: ../../calc.texi:11540 ../../calc.texi:18257 ../../calc.texi:34156
#, no-wrap
msgid "pi"
msgstr ""

#. type: findex
#: ../../calc.texi:11542 ../../calc.texi:34149
#, no-wrap
msgid "phi"
msgstr ""

#. type: vindex
#: ../../calc.texi:11543 ../../calc.texi:18263
#, no-wrap
msgid "gamma"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11550
msgid ""
"A few variables are called @dfn{special constants}.  Their names are "
"@samp{e}, @samp{pi}, @samp{i}, @samp{phi}, and @samp{gamma}.  "
"(@xref{Scientific Functions}.)  When they are evaluated with @kbd{=}, their "
"values are calculated if necessary according to the current precision or "
"complex polar mode.  If you wish to use these symbols for other purposes, "
"simply undefine or redefine them using @code{calc-store}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11556
msgid ""
"The variables @samp{inf}, @samp{uinf}, and @samp{nan} stand for infinite or "
"indeterminate values.  It's best not to use them as regular variables, since "
"Calc uses special algebraic rules when it manipulates them.  Calc displays a "
"warning message if you store a value into any of these special variables."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11558
msgid ""
"@xref{Store and Recall}, for a discussion of commands dealing with "
"variables."
msgstr ""

#. type: cindex
#: ../../calc.texi:11564
#, no-wrap
msgid "Expressions"
msgstr ""

#. type: cindex
#: ../../calc.texi:11565
#, no-wrap
msgid "Operators in formulas"
msgstr ""

#. type: cindex
#: ../../calc.texi:11566
#, no-wrap
msgid "Precedence of operators"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11576
msgid ""
"When you press the apostrophe key you may enter any expression or formula in "
"algebraic form.  (Calc uses the terms ``expression'' and ``formula'' "
"interchangeably.)  An expression is built up of numbers, variable names, and "
"function calls, combined with various arithmetic operators.  Parentheses may "
"be used to indicate grouping.  Spaces are ignored within formulas, except "
"that spaces are not permitted within variable names or numbers.  Arithmetic "
"operators, in order from highest to lowest precedence, and with their "
"equivalent function names, are:"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11578
msgid "@samp{_} [@code{subscr}] (subscripts);"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11580
msgid "postfix @samp{%} [@code{percent}] (as in @samp{25% = 0.25});"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11582
msgid "prefix @samp{!} [@code{lnot}] (logical ``not,'' as in @samp{!x});"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11585
msgid ""
"@samp{+/-} [@code{sdev}] (the standard deviation symbol) and @samp{mod} "
"[@code{makemod}] (the symbol for modulo forms);"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11588
msgid ""
"postfix @samp{!} [@code{fact}] (factorial, as in @samp{n!})  and postfix "
"@samp{!!} [@code{dfact}] (double factorial);"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11590
msgid "@samp{^} [@code{pow}] (raised-to-the-power-of);"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11592
msgid "prefix @samp{+} and @samp{-} [@code{neg}] (as in @samp{-x});"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11594
msgid "@samp{*} [@code{mul}];"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11597
msgid ""
"@samp{/} [@code{div}], @samp{%} [@code{mod}] (modulo), and @samp{\\} "
"[@code{idiv}] (integer division);"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11599
msgid "infix @samp{+} [@code{add}] and @samp{-} [@code{sub}] (as in @samp{x-y});"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11601
msgid "@samp{|} [@code{vconcat}] (vector concatenation);"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11604
msgid ""
"relations @samp{=} [@code{eq}], @samp{!=} [@code{neq}], @samp{<} "
"[@code{lt}], @samp{>} [@code{gt}], @samp{<=} [@code{leq}], and @samp{>=} "
"[@code{geq}];"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11606
msgid "@samp{&&} [@code{land}] (logical ``and'');"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11608
msgid "@samp{||} [@code{lor}] (logical ``or'');"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11610
msgid "the C-style ``if'' operator @samp{a?b:c} [@code{if}];"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11612
msgid "@samp{!!!} [@code{pnot}] (rewrite pattern ``not'');"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11614
msgid "@samp{&&&} [@code{pand}] (rewrite pattern ``and'');"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11616
msgid "@samp{|||} [@code{por}] (rewrite pattern ``or'');"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11618
msgid "@samp{:=} [@code{assign}] (for assignments and rewrite rules);"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11620
msgid "@samp{::} [@code{condition}] (rewrite pattern condition);"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11622
msgid "@samp{=>} [@code{evalto}]."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11627
msgid ""
"Note that, unlike in usual computer notation, multiplication binds more "
"strongly than division: @samp{a*b/c*d} is equivalent to @texline @math{a b "
"\\over c d}.  @infoline @expr{(a*b)/(c*d)}."
msgstr ""

#. type: cindex
#: ../../calc.texi:11628
#, no-wrap
msgid "Multiplication, implicit"
msgstr ""

#. type: cindex
#: ../../calc.texi:11629
#, no-wrap
msgid "Implicit multiplication"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11641
msgid ""
"The multiplication sign @samp{*} may be omitted in many cases.  In "
"particular, if the righthand side is a number, variable name, or "
"parenthesized expression, the @samp{*} may be omitted.  Implicit "
"multiplication has the same precedence as the explicit @samp{*} operator.  "
"The one exception to the rule is that a variable name followed by a "
"parenthesized expression, as in @samp{f(x)}, is interpreted as a function "
"call, not an implicit @samp{*}.  In many cases you must use a space if you "
"omit the @samp{*}: @samp{2a} is the same as @samp{2*a}, and @samp{a b} is "
"the same as @samp{a*b}, but @samp{ab} is a variable called @code{ab}, "
"@emph{not} the product of @samp{a} and @samp{b}! Also note that @samp{f (x)} "
"is still a function call."
msgstr ""

#. type: cindex
#: ../../calc.texi:11642
#, no-wrap
msgid "Implicit comma in vectors"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11653
msgid ""
"The rules are slightly different for vectors written with square brackets.  "
"In vectors, the space character is interpreted (like the comma) as a "
"separator of elements of the vector.  Thus @w{@samp{[ 2a b+c d ]}} is "
"equivalent to @samp{[2*a, b+c, d]}, whereas @samp{2a b+c d} is equivalent to "
"@samp{2*a*b + c*d}.  Note that spaces around the brackets, and around "
"explicit commas, are ignored.  To force spaces to be interpreted as "
"multiplication you can enclose a formula in parentheses as in @samp{[(a b) "
"2(c d)]}, which is interpreted as @samp{[a*b, 2*c*d]}.  An implicit comma is "
"also inserted between @samp{][}, as in the matrix @samp{[[1 2][3 4]]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11664
msgid ""
"Vectors that contain commas (not embedded within nested parentheses or "
"brackets) do not treat spaces specially: @samp{[a b, 2 c d]} is a vector of "
"two elements.  Also, if it would be an error to treat spaces as separators, "
"but not otherwise, then Calc will ignore spaces: @w{@samp{[a - b]}} is a "
"vector of one element, but @w{@samp{[a -b]}} is a vector of two elements.  "
"Finally, vectors entered with curly braces instead of square brackets do not "
"give spaces any special treatment.  When Calc displays a vector that does "
"not contain any commas, it will insert parentheses if necessary to make the "
"meaning clear: @w{@samp{[(a b)]}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11669
msgid ""
"The expression @samp{5%-2} is ambiguous; is this five-percent minus two, or "
"five modulo minus-two? Calc always interprets the leftmost symbol as an "
"infix operator preferentially (modulo, in this case), so you would need to "
"write @samp{(5%)-2} to get the former interpretation."
msgstr ""

#. type: cindex
#: ../../calc.texi:11670
#, no-wrap
msgid "Function call notation"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11682
msgid ""
"A function call is, e.g., @samp{sin(1+x)}.  (The Calc algebraic function "
"@code{foo} corresponds to the Emacs Lisp function @code{calcFunc-foo}, but "
"unless you access the function from within Emacs Lisp, you don't need to "
"worry about it.)  Most mathematical Calculator commands like @code{calc-sin} "
"have function equivalents like @code{sin}.  If no Lisp function is defined "
"for a function called by a formula, the call is left as it is during "
"algebraic manipulation: @samp{f(x+y)} is left alone.  Beware that many "
"innocent-looking short names like @code{in} and @code{re} have predefined "
"meanings which could surprise you; however, single letters or single letters "
"followed by digits are always safe to use for your own function names.  "
"@xref{Function Index}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11687
msgid ""
"In the documentation for particular commands, the notation @kbd{H S} "
"(@code{calc-sinh}) [@code{sinh}] means that the key sequence @kbd{H S}, the "
"command @kbd{M-x calc-sinh}, and the algebraic function @code{sinh(x)} all "
"represent the same operation."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11695
msgid ""
"Commands that interpret (``parse'') text as algebraic formulas include "
"algebraic entry (@kbd{'}), editing commands like @kbd{`} which parse the "
"contents of the editing buffer when you finish, the @kbd{C-x * g} and "
"@w{@kbd{C-x * r}} commands, the @kbd{C-y} command, the X window system "
"``paste'' mouse operation, and Embedded mode.  All of these operations use "
"the same rules for parsing formulas; in particular, language modes "
"(@pxref{Language Modes}) affect them all in the same way."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11700
msgid ""
"When you read a large amount of text into the Calculator (say a vector which "
"represents a big set of rewrite rules; @pxref{Rewrite Rules}), you may wish "
"to include comments in the text.  Calc's formula parser ignores the symbol "
"@samp{%%} and anything following it on a line:"
msgstr ""

#. type: example
#: ../../calc.texi:11706
#, no-wrap
msgid ""
"[ a + b,   %% the sum of \"a\" and \"b\"\n"
"  c + d,\n"
"  %% last line is coming up:\n"
"  e + f ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11710
msgid "This is parsed exactly the same as @samp{[ a + b, c + d, e + f ]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11714
msgid ""
"@xref{Syntax Tables}, for a way to create your own operators and other input "
"notations.  @xref{Compositions}, for a way to create new display formats."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11716
msgid "@xref{Algebra}, for commands for manipulating formulas symbolically."
msgstr ""

#. type: chapter
#: ../../calc.texi:11718
#, no-wrap
msgid "Stack and Trail Commands"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11724
msgid ""
"This chapter describes the Calc commands for manipulating objects on the "
"stack and in the trail buffer.  (These commands operate on objects of any "
"type, such as numbers, vectors, formulas, and incomplete objects.)"
msgstr ""

#. type: menuentry
#: ../../calc.texi:11730
msgid "Stack Manipulation::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:11730
msgid "Editing Stack Entries::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:11730
msgid "Trail Commands::"
msgstr ""

#. type: section
#: ../../calc.texi:11730 ../../calc.texi:11915 ../../calc.texi:12036 ../../calc.texi:12037
#, no-wrap
msgid "Keep Arguments"
msgstr ""

#. type: node
#: ../../calc.texi:11732 ../../calc.texi:11861
#, no-wrap
msgid "Stack Manipulation"
msgstr ""

#. type: node
#: ../../calc.texi:11732 ../../calc.texi:11861 ../../calc.texi:11862 ../../calc.texi:11915
#, no-wrap
msgid "Editing Stack Entries"
msgstr ""

#. type: section
#: ../../calc.texi:11733
#, no-wrap
msgid "Stack Manipulation Commands"
msgstr ""

#. type: kindex
#: ../../calc.texi:11736
#, no-wrap
msgid "RET"
msgstr ""

#. type: kindex
#: ../../calc.texi:11737
#, no-wrap
msgid "SPC"
msgstr ""

#. type: pindex
#: ../../calc.texi:11738
#, no-wrap
msgid "calc-enter"
msgstr ""

#. type: cindex
#: ../../calc.texi:11739
#, no-wrap
msgid "Duplicating stack entries"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11752
msgid ""
"To duplicate the top object on the stack, press @key{RET} or @key{SPC} (two "
"equivalent keys for the @code{calc-enter} command).  Given a positive "
"numeric prefix argument, these commands duplicate several elements at the "
"top of the stack.  Given a negative argument, these commands duplicate the "
"specified element of the stack.  Given an argument of zero, they duplicate "
"the entire stack.  For example, with @samp{10 20 30} on the stack, @key{RET} "
"creates @samp{10 20 30 30}, @kbd{C-u 2 @key{RET}} creates @samp{10 20 30 20 "
"30}, @kbd{C-u - 2 @key{RET}} creates @samp{10 20 30 20}, and @kbd{C-u 0 "
"@key{RET}} creates @samp{10 20 30 10 20 30}."
msgstr ""

#. type: kindex
#: ../../calc.texi:11753
#, no-wrap
msgid "LFD"
msgstr ""

#. type: pindex
#: ../../calc.texi:11754
#, no-wrap
msgid "calc-over"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11762
msgid ""
"The @key{LFD} (@code{calc-over}) command (on a key marked Line-Feed if you "
"have it, else on @kbd{C-j}) is like @code{calc-enter} except that the sign "
"of the numeric prefix argument is interpreted oppositely.  Also, with no "
"prefix argument the default argument is 2.  Thus with @samp{10 20 30} on the "
"stack, @key{LFD} and @kbd{C-u 2 @key{LFD}} are both equivalent to @kbd{C-u - "
"2 @key{RET}}, producing @samp{10 20 30 20}."
msgstr ""

#. type: kindex
#: ../../calc.texi:11763
#, no-wrap
msgid "DEL"
msgstr ""

#. type: kindex
#: ../../calc.texi:11764
#, no-wrap
msgid "C-d"
msgstr ""

#. type: pindex
#: ../../calc.texi:11765
#, no-wrap
msgid "calc-pop"
msgstr ""

#. type: cindex
#: ../../calc.texi:11766
#, no-wrap
msgid "Removing stack entries"
msgstr ""

#. type: cindex
#: ../../calc.texi:11767
#, no-wrap
msgid "Deleting stack entries"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11780
msgid ""
"To remove the top element from the stack, press @key{DEL} "
"(@code{calc-pop}).  The @kbd{C-d} key is a synonym for @key{DEL}.  (If the "
"top element is an incomplete object with at least one element, the last "
"element is removed from it.)  Given a positive numeric prefix argument, "
"several elements are removed.  Given a negative argument, the specified "
"element of the stack is deleted.  Given an argument of zero, the entire "
"stack is emptied.  For example, with @samp{10 20 30} on the stack, @key{DEL} "
"leaves @samp{10 20}, @kbd{C-u 2 @key{DEL}} leaves @samp{10}, @kbd{C-u - 2 "
"@key{DEL}} leaves @samp{10 30}, and @kbd{C-u 0 @key{DEL}} leaves an empty "
"stack."
msgstr ""

#. type: kindex
#: ../../calc.texi:11781
#, no-wrap
msgid "M-DEL"
msgstr ""

#. type: pindex
#: ../../calc.texi:11782
#, no-wrap
msgid "calc-pop-above"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11789
msgid ""
"The @kbd{M-@key{DEL}} (@code{calc-pop-above}) command is to @key{DEL} what "
"@key{LFD} is to @key{RET}: It interprets the sign of the numeric prefix "
"argument in the opposite way, and the default argument is 2.  Thus "
"@kbd{M-@key{DEL}} by itself removes the second-from-top stack element, "
"leaving the first, third, fourth, and so on; @kbd{M-3 M-@key{DEL}} deletes "
"the third stack element."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11801
msgid ""
"The above commands do not depend on the location of the cursor.  If the "
"customizable variable @code{calc-context-sensitive-enter} is non-@code{nil} "
"(@pxref{Customizing Calc}), these commands will become context sensitive.  "
"For example, instead of duplicating the top of the stack, @key{RET} will "
"copy the element at the cursor to the top of the stack.  With a positive "
"numeric prefix, a copy of the element at the cursor and the appropriate "
"number of preceding elements will be placed at the top of the stack.  A "
"negative prefix will still duplicate the specified element of the stack "
"regardless of the cursor position.  Similarly, @key{DEL} will remove the "
"corresponding elements from the stack."
msgstr ""

#. type: kindex
#: ../../calc.texi:11802
#, no-wrap
msgid "TAB"
msgstr ""

#. type: pindex
#: ../../calc.texi:11803
#, no-wrap
msgid "calc-roll-down"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11815
msgid ""
"To exchange the top two elements of the stack, press @key{TAB} "
"(@code{calc-roll-down}).  Given a positive numeric prefix argument, the "
"specified number of elements at the top of the stack are rotated downward.  "
"Given a negative argument, the entire stack is rotated downward the "
"specified number of times.  Given an argument of zero, the entire stack is "
"reversed top-for-bottom.  For example, with @samp{10 20 30 40 50} on the "
"stack, @key{TAB} creates @samp{10 20 30 50 40}, @kbd{C-u 3 @key{TAB}} "
"creates @samp{10 20 50 30 40}, @kbd{C-u - 2 @key{TAB}} creates @samp{40 50 "
"10 20 30}, and @kbd{C-u 0 @key{TAB}} creates @samp{50 40 30 20 10}."
msgstr ""

#. type: kindex
#: ../../calc.texi:11816
#, no-wrap
msgid "M-TAB"
msgstr ""

#. type: pindex
#: ../../calc.texi:11817
#, no-wrap
msgid "calc-roll-up"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11826
msgid ""
"The command @kbd{M-@key{TAB}} (@code{calc-roll-up}) is analogous to "
"@key{TAB} except that it rotates upward instead of downward.  Also, the "
"default with no prefix argument is to rotate the top 3 elements.  For "
"example, with @samp{10 20 30 40 50} on the stack, @kbd{M-@key{TAB}} creates "
"@samp{10 20 40 50 30}, @kbd{C-u 4 M-@key{TAB}} creates @samp{10 30 40 50 "
"20}, @kbd{C-u - 2 M-@key{TAB}} creates @samp{30 40 50 10 20}, and @kbd{C-u 0 "
"M-@key{TAB}} creates @samp{50 40 30 20 10}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11834
msgid ""
"A good way to view the operation of @key{TAB} and @kbd{M-@key{TAB}} is in "
"terms of moving a particular element to a new position in the stack.  With a "
"positive argument @var{n}, @key{TAB} moves the top stack element down to "
"level @var{n}, making room for it by pulling all the intervening stack "
"elements toward the top.  @kbd{M-@key{TAB}} moves the element at level "
"@var{n} up to the top.  (Compare with @key{LFD}, which copies instead of "
"moving the element in level @var{n}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11840
msgid ""
"With a negative argument @mathit{-@var{n}}, @key{TAB} rotates the stack to "
"move the object in level @var{n} to the deepest place in the stack, and the "
"object in level @mathit{@var{n}+1} to the top.  @kbd{M-@key{TAB}} rotates "
"the deepest stack element to be in level @var{n}, also putting the top stack "
"element in level @mathit{@var{n}+1}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11843
msgid ""
"@xref{Selecting Subformulas}, for a way to apply these commands to any "
"portion of a vector or formula on the stack."
msgstr ""

#. type: kindex
#: ../../calc.texi:11844
#, no-wrap
msgid "C-xC-t"
msgstr ""

#. type: pindex
#: ../../calc.texi:11845
#, no-wrap
msgid "calc-transpose-lines"
msgstr ""

#. type: cindex
#: ../../calc.texi:11846
#, no-wrap
msgid "Moving stack entries"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11860
msgid ""
"The command @kbd{C-x C-t} (@code{calc-transpose-lines}) will transpose the "
"stack object determined by the point with the stack object at the next "
"higher level. For example, with @samp{10 20 30 40 50} on the stack and the "
"point on the line containing @samp{30}, @kbd{C-x C-t} creates @samp{10 20 40 "
"30 50}.  More generally, @kbd{C-x C-t} acts on the stack objects determined "
"by the current point (and mark) similar to how the text-mode command "
"@code{transpose-lines} acts on lines.  With argument @var{n}, @kbd{C-x C-t} "
"will move the stack object at the level above the current point and move it "
"past N other objects; for example, with @samp{10 20 30 40 50} on the stack "
"and the point on the line containing @samp{30}, @kbd{C-u 2 C-x C-t} creates "
"@samp{10 40 20 30 50}. With an argument of 0, @kbd{C-x C-t} will switch the "
"stack objects at the levels determined by the point and the mark."
msgstr ""

#. type: node
#: ../../calc.texi:11861 ../../calc.texi:11915 ../../calc.texi:11916 ../../calc.texi:12036
#, no-wrap
msgid "Trail Commands"
msgstr ""

#. type: pindex
#: ../../calc.texi:11866
#, no-wrap
msgid "calc-edit"
msgstr ""

#. type: pindex
#: ../../calc.texi:11867
#, no-wrap
msgid "calc-edit-finish"
msgstr ""

#. type: cindex
#: ../../calc.texi:11868
#, no-wrap
msgid "Editing the stack with Emacs"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11875
msgid ""
"The @kbd{`} (@code{calc-edit}) command creates a temporary buffer "
"(@file{*Calc Edit*}) for editing the top-of-stack value using regular Emacs "
"commands.  Note that @kbd{`} is a grave accent, not an apostrophe.  With a "
"numeric prefix argument, it edits the specified number of stack entries at "
"once.  (An argument of zero edits the entire stack; a negative argument "
"edits one specific stack entry.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11881
msgid ""
"When you are done editing, press @kbd{C-c C-c} to finish and return to "
"Calc.  The @key{RET} and @key{LFD} keys also work to finish most sorts of "
"editing, though in some cases Calc leaves @key{RET} with its usual meaning "
"(``insert a newline'') if it's a situation where you might want to insert "
"new lines into the editing buffer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11889
msgid ""
"When you finish editing, the Calculator parses the lines of text in the "
"@file{*Calc Edit*} buffer as numbers or formulas, replaces the original "
"stack elements in the original buffer with these new values, then kills the "
"@file{*Calc Edit*} buffer.  The original Calculator buffer continues to "
"exist during editing, but for best results you should be careful not to "
"change it until you have finished the edit.  You can also cancel the edit by "
"killing the buffer with @kbd{C-x k}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11894
msgid ""
"The formula is normally reevaluated as it is put onto the stack.  For "
"example, editing @samp{a + 2} to @samp{3 + 2} and pressing @kbd{C-c C-c} "
"will push 5 on the stack.  If you use @key{LFD} to finish, Calc will put the "
"result on the stack without evaluating it."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11904
msgid ""
"If you give a prefix argument to @kbd{C-c C-c}, Calc will not kill the "
"@file{*Calc Edit*} buffer.  You can switch back to that buffer and continue "
"editing if you wish.  However, you should understand that if you initiated "
"the edit with @kbd{`}, the @kbd{C-c C-c} operation will be programmed to "
"replace the top of the stack with the new edited value, and it will do this "
"even if you have rearranged the stack in the meanwhile.  This is not so much "
"of a problem with other editing commands, though, such as @kbd{s e} "
"(@code{calc-edit-variable}; @pxref{Operations on Variables})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:11910
msgid ""
"If the @code{calc-edit} command involves more than one stack entry, each "
"line of the @file{*Calc Edit*} buffer is interpreted as a separate formula.  "
"Otherwise, the entire buffer is interpreted as one formula, with line breaks "
"ignored.  (You can use @kbd{C-o} or @kbd{C-q C-j} to insert a newline in the "
"buffer without pressing @key{RET}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11914
msgid ""
"The @kbd{`} key also works during numeric or algebraic entry.  The text "
"entered so far is moved to the @file{*Calc Edit*} buffer for more extensive "
"editing than is convenient in the minibuffer."
msgstr ""

#. type: cindex
#: ../../calc.texi:11919
#, no-wrap
msgid "Trail buffer"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11922
msgid ""
"The commands for manipulating the Calc Trail buffer are two-key sequences "
"beginning with the @kbd{t} prefix."
msgstr ""

#. type: kindex
#: ../../calc.texi:11923
#, no-wrap
msgid "t d"
msgstr ""

#. type: pindex
#: ../../calc.texi:11924
#, no-wrap
msgid "calc-trail-display"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11934
msgid ""
"The @kbd{t d} (@code{calc-trail-display}) command turns display of the trail "
"on and off.  Normally the trail display is toggled on if it was off, off if "
"it was on.  With a numeric prefix of zero, this command always turns the "
"trail off; with a prefix of one, it always turns the trail on.  The other "
"trail-manipulation commands described here automatically turn the trail on.  "
"Note that when the trail is off values are still recorded there; they are "
"simply not displayed.  To set Emacs to turn the trail off by default, type "
"@kbd{t d} and then save the mode settings with @kbd{m m} "
"(@code{calc-save-modes})."
msgstr ""

#. type: kindex
#: ../../calc.texi:11935
#, no-wrap
msgid "t i"
msgstr ""

#. type: pindex
#: ../../calc.texi:11936
#, no-wrap
msgid "calc-trail-in"
msgstr ""

#. type: kindex
#: ../../calc.texi:11937
#, no-wrap
msgid "t o"
msgstr ""

#. type: pindex
#: ../../calc.texi:11938
#, no-wrap
msgid "calc-trail-out"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11945
msgid ""
"The @kbd{t i} (@code{calc-trail-in}) and @kbd{t o} (@code{calc-trail-out}) "
"commands switch the cursor into and out of the Calc Trail window.  In "
"practice they are rarely used, since the commands shown below are a more "
"convenient way to move around in the trail, and they work ``by remote "
"control'' when the cursor is still in the Calculator window."
msgstr ""

#. type: cindex
#: ../../calc.texi:11946
#, no-wrap
msgid "Trail pointer"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11951
msgid ""
"There is a @dfn{trail pointer} which selects some entry of the trail at any "
"given time.  The trail pointer looks like a @samp{>} symbol right before the "
"selected number.  The following commands operate on the trail pointer in "
"various ways."
msgstr ""

#. type: kindex
#: ../../calc.texi:11952
#, no-wrap
msgid "t y"
msgstr ""

#. type: pindex
#: ../../calc.texi:11953
#, no-wrap
msgid "calc-trail-yank"
msgstr ""

#. type: cindex
#: ../../calc.texi:11954
#, no-wrap
msgid "Retrieving previous results"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11960
msgid ""
"The @kbd{t y} (@code{calc-trail-yank}) command reads the selected value in "
"the trail and pushes it onto the Calculator stack.  It allows you to re-use "
"any previously computed value without retyping.  With a numeric prefix "
"argument @var{n}, it yanks the value @var{n} lines above the current trail "
"pointer."
msgstr ""

#. type: kindex
#: ../../calc.texi:11961
#, no-wrap
msgid "t <"
msgstr ""

#. type: pindex
#: ../../calc.texi:11962
#, no-wrap
msgid "calc-trail-scroll-left"
msgstr ""

#. type: kindex
#: ../../calc.texi:11963
#, no-wrap
msgid "t >"
msgstr ""

#. type: pindex
#: ../../calc.texi:11964
#, no-wrap
msgid "calc-trail-scroll-right"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11968
msgid ""
"The @kbd{t <} (@code{calc-trail-scroll-left}) and @kbd{t >} "
"(@code{calc-trail-scroll-right}) commands horizontally scroll the trail "
"window left or right by one half of its width."
msgstr ""

#. type: kindex
#: ../../calc.texi:11969
#, no-wrap
msgid "t n"
msgstr ""

#. type: pindex
#: ../../calc.texi:11970
#, no-wrap
msgid "calc-trail-next"
msgstr ""

#. type: kindex
#: ../../calc.texi:11971
#, no-wrap
msgid "t p"
msgstr ""

#. type: pindex
#: ../../calc.texi:11972
#, no-wrap
msgid "calc-trail-previous"
msgstr ""

#. type: kindex
#: ../../calc.texi:11973
#, no-wrap
msgid "t f"
msgstr ""

#. type: pindex
#: ../../calc.texi:11974
#, no-wrap
msgid "calc-trail-forward"
msgstr ""

#. type: kindex
#: ../../calc.texi:11975
#, no-wrap
msgid "t b"
msgstr ""

#. type: pindex
#: ../../calc.texi:11976
#, no-wrap
msgid "calc-trail-backward"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11983
msgid ""
"The @kbd{t n} (@code{calc-trail-next}) and @kbd{t p} "
"(@code{calc-trail-previous)} commands move the trail pointer down or up one "
"line.  The @kbd{t f} (@code{calc-trail-forward}) and @kbd{t b} "
"(@code{calc-trail-backward}) commands move the trail pointer down or up one "
"screenful at a time.  All of these commands accept numeric prefix arguments "
"to move several lines or screenfuls at a time."
msgstr ""

#. type: kindex
#: ../../calc.texi:11984
#, no-wrap
msgid "t ["
msgstr ""

#. type: pindex
#: ../../calc.texi:11985
#, no-wrap
msgid "calc-trail-first"
msgstr ""

#. type: kindex
#: ../../calc.texi:11986
#, no-wrap
msgid "t ]"
msgstr ""

#. type: pindex
#: ../../calc.texi:11987
#, no-wrap
msgid "calc-trail-last"
msgstr ""

#. type: kindex
#: ../../calc.texi:11988
#, no-wrap
msgid "t h"
msgstr ""

#. type: pindex
#: ../../calc.texi:11989
#, no-wrap
msgid "calc-trail-here"
msgstr ""

#. type: Plain text
#: ../../calc.texi:11995
msgid ""
"The @kbd{t [} (@code{calc-trail-first}) and @kbd{t ]} "
"(@code{calc-trail-last}) commands move the trail pointer to the first or "
"last line of the trail.  The @kbd{t h} (@code{calc-trail-here}) command "
"moves the trail pointer to the cursor position; unlike the other trail "
"commands, @kbd{t h} works only when Calc Trail is the selected window."
msgstr ""

#. type: kindex
#: ../../calc.texi:11996
#, no-wrap
msgid "t s"
msgstr ""

#. type: pindex
#: ../../calc.texi:11997
#, no-wrap
msgid "calc-trail-isearch-forward"
msgstr ""

#. type: kindex
#: ../../calc.texi:11998
#, no-wrap
msgid "t r"
msgstr ""

#. type: pindex
#: ../../calc.texi:11999
#, no-wrap
msgid "calc-trail-isearch-backward"
msgstr ""

#. type: ifnottex
#: ../../calc.texi:12007
msgid ""
"The @kbd{t s} (@code{calc-trail-isearch-forward}) and @kbd{t r} "
"(@code{calc-trail-isearch-backward}) commands perform an incremental search "
"forward or backward through the trail.  You can press @key{RET} to terminate "
"the search; the trail pointer moves to the current line.  If you cancel the "
"search with @kbd{C-g}, the trail pointer stays where it was when the search "
"began."
msgstr ""

#. type: tex
#: ../../calc.texi:12015
#, no-wrap
msgid ""
"The @kbd{t s} (@code{calc-trail-isearch-forward}) and @kbd{t r}\n"
"(@code{calc-trail-isearch-backward}) com\\-mands perform an incremental\n"
"search forward or backward through the trail.  You can press @key{RET}\n"
"to terminate the search; the trail pointer moves to the current line.\n"
"If you cancel the search with @kbd{C-g}, the trail pointer stays where\n"
"it was when the search began.\n"
msgstr ""

#. type: kindex
#: ../../calc.texi:12017
#, no-wrap
msgid "t m"
msgstr ""

#. type: pindex
#: ../../calc.texi:12018
#, no-wrap
msgid "calc-trail-marker"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12024
msgid ""
"The @kbd{t m} (@code{calc-trail-marker}) command allows you to enter a line "
"of text of your own choosing into the trail.  The text is inserted after the "
"line containing the trail pointer; this usually means it is added to the end "
"of the trail.  Trail markers are useful mainly as the targets for later "
"incremental searches in the trail."
msgstr ""

#. type: kindex
#: ../../calc.texi:12025
#, no-wrap
msgid "t k"
msgstr ""

#. type: pindex
#: ../../calc.texi:12026
#, no-wrap
msgid "calc-trail-kill"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12032
msgid ""
"The @kbd{t k} (@code{calc-trail-kill}) command removes the selected line "
"from the trail.  The line is saved in the Emacs kill ring suitable for "
"yanking into another buffer, but it is not easy to yank the text back into "
"the trail buffer.  With a numeric prefix argument, this command kills the "
"@var{n} lines below or above the selected one."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12035
msgid ""
"The @kbd{t .} (@code{calc-full-trail-vectors}) command is described "
"elsewhere; @pxref{Vector and Matrix Formats}."
msgstr ""

#. type: pindex
#: ../../calc.texi:12041
#, no-wrap
msgid "calc-keep-args"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12047
msgid ""
"The @kbd{K} (@code{calc-keep-args}) command acts like a prefix for the "
"following command.  It prevents that command from removing its arguments "
"from the stack.  For example, after @kbd{2 @key{RET} 3 +}, the stack "
"contains the sole number 5, but after @kbd{2 @key{RET} 3 K +}, the stack "
"contains the arguments and the result: @samp{2 3 5}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12060
msgid ""
"With the exception of keyboard macros, this works for all commands that take "
"arguments off the stack. (To avoid potentially unpleasant behavior, a "
"@kbd{K} prefix before a keyboard macro will be ignored.  A @kbd{K} prefix "
"called @emph{within} the keyboard macro will still take effect.)  As another "
"example, @kbd{K a s} simplifies a formula, pushing the simplified version of "
"the formula onto the stack after the original formula (rather than replacing "
"the original formula).  Note that you could get the same effect by typing "
"@kbd{@key{RET} a s}, copying the formula and then simplifying the copy. One "
"difference is that for a very large formula the time taken to format the "
"intermediate copy in @kbd{@key{RET} a s} could be noticeable; @kbd{K a s} "
"would avoid this extra work."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12064
msgid ""
"Even stack manipulation commands are affected.  @key{TAB} works by popping "
"two values and pushing them back in the opposite order, so @kbd{2 @key{RET} "
"3 K @key{TAB}} produces @samp{2 3 3 2}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12071
msgid ""
"A few Calc commands provide other ways of doing the same thing.  For "
"example, @kbd{' sin($)} replaces the number on the stack with its sine using "
"algebraic entry; to push the sine and keep the original argument you could "
"use either @kbd{' sin($1)} or @kbd{K ' sin($)}.  @xref{Algebraic Entry}.  "
"Also, the @kbd{s s} command is effectively the same as @kbd{K s t}.  "
"@xref{Storing Variables}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12078
msgid ""
"If you execute a command and then decide you really wanted to keep the "
"argument, you can press @kbd{M-@key{RET}} (@code{calc-last-args}).  This "
"command pushes the last arguments that were popped by any command onto the "
"stack.  Note that the order of things on the stack will be different than "
"with @kbd{K}: @kbd{2 @key{RET} 3 + M-@key{RET}} leaves @samp{5 2 3} on the "
"stack instead of @samp{2 3 5}.  @xref{Undo}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12086
msgid ""
"This chapter describes commands that set modes in the Calculator.  They do "
"not affect the contents of the stack, although they may change the "
"@emph{appearance} or @emph{interpretation} of the stack's contents."
msgstr ""

#. type: menuentry
#: ../../calc.texi:12098
msgid "General Mode Commands::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:12098
msgid "Precision::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:12098
msgid "Inverse and Hyperbolic::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:12098
msgid "Calculation Modes::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:12098
msgid "Simplification Modes::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:12098
msgid "Declarations::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:12098
msgid "Display Modes::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:12098
msgid "Language Modes::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:12098
msgid "Modes Variable::"
msgstr ""

#. type: node
#: ../../calc.texi:12098 ../../calc.texi:15806 ../../calc.texi:15908
#, no-wrap
msgid "Calc Mode Line"
msgstr ""

#. type: node
#: ../../calc.texi:12100 ../../calc.texi:12101 ../../calc.texi:12182
#, no-wrap
msgid "General Mode Commands"
msgstr ""

#. type: node
#: ../../calc.texi:12100 ../../calc.texi:12182 ../../calc.texi:12183 ../../calc.texi:12239
#, no-wrap
msgid "Precision"
msgstr ""

#. type: kindex
#: ../../calc.texi:12104
#, no-wrap
msgid "m m"
msgstr ""

#. type: pindex
#: ../../calc.texi:12105
#, no-wrap
msgid "calc-save-modes"
msgstr ""

#. type: cindex
#: ../../calc.texi:12106
#, no-wrap
msgid "Continuous memory"
msgstr ""

#. type: cindex
#: ../../calc.texi:12107
#, no-wrap
msgid "Saving mode settings"
msgstr ""

#. type: cindex
#: ../../calc.texi:12108
#, no-wrap
msgid "Permanent mode settings"
msgstr ""

#. type: cindex
#: ../../calc.texi:12109
#, no-wrap
msgid "Calc init file, mode settings"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12122
msgid ""
"You can save all of the current mode settings in your Calc init file (the "
"file given by the variable @code{calc-settings-file}, typically "
"@file{~/.emacs.d/calc.el}) with the @kbd{m m} (@code{calc-save-modes})  "
"command.  This will cause Emacs to reestablish these modes each time it "
"starts up.  The modes saved in the file include everything controlled by the "
"@kbd{m} and @kbd{d} prefix keys, the current precision and binary word size, "
"whether or not the trail is displayed, the current height of the Calc "
"window, and more.  The current interface (used when you type @kbd{C-x * *}) "
"is also saved.  If there were already saved mode settings in the file, they "
"are replaced.  Otherwise, the new mode information is appended to the end of "
"the file."
msgstr ""

#. type: kindex
#: ../../calc.texi:12123
#, no-wrap
msgid "m R"
msgstr ""

#. type: pindex
#: ../../calc.texi:12124
#, no-wrap
msgid "calc-mode-record-mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12133
msgid ""
"The @kbd{m R} (@code{calc-mode-record-mode}) command tells Calc to record "
"all the mode settings (as if by pressing @kbd{m m}) every time a mode "
"setting changes.  If the modes are saved this way, then this ``automatic "
"mode recording'' mode is also saved.  Type @kbd{m R} again to disable this "
"method of recording the mode settings.  To turn it off permanently, the "
"@kbd{m m} command will also be necessary.  (If Embedded mode is enabled, "
"other options for recording the modes are available; @pxref{Mode Settings in "
"Embedded Mode}.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:12134
#, no-wrap
msgid "m F"
msgstr ""

#. type: pindex
#: ../../calc.texi:12135
#, no-wrap
msgid "calc-settings-file-name"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12146
msgid ""
"The @kbd{m F} (@code{calc-settings-file-name}) command allows you to choose "
"a different file than the current value of @code{calc-settings-file} for "
"@kbd{m m}, @kbd{Z P}, and similar commands to save permanent information.  "
"You are prompted for a file name.  All Calc modes are then reset to their "
"default values, then settings from the file you named are loaded if this "
"file exists, and this file becomes the one that Calc will use in the future "
"for commands like @kbd{m m}.  The default settings file name is "
"@file{~/.emacs.d/calc.el}.  You can see the current file name by giving a "
"blank response to the @kbd{m F} prompt.  See also the discussion of the "
"@code{calc-settings-file} variable; @pxref{Customizing Calc}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12157
msgid ""
"If the file name you give is your user init file (typically "
"@file{~/.emacs}), @kbd{m F} will not automatically load the new file.  This "
"is because your user init file may contain other things you don't want to "
"reread.  You can give a numeric prefix argument of 1 to @kbd{m F} to force "
"it to read the file no matter what.  Conversely, an argument of @mathit{-1} "
"tells @kbd{m F} @emph{not} to read the new file.  An argument of 2 or "
"@mathit{-2} tells @kbd{m F} not to reset the modes to their defaults "
"beforehand, which is useful if you intend your new file to have a variant of "
"the modes present in the file you were using before."
msgstr ""

#. type: kindex
#: ../../calc.texi:12158
#, no-wrap
msgid "m x"
msgstr ""

#. type: pindex
#: ../../calc.texi:12159
#, no-wrap
msgid "calc-always-load-extensions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12167
msgid ""
"The @kbd{m x} (@code{calc-always-load-extensions}) command enables a mode in "
"which the first use of Calc loads the entire program, including all "
"extensions modules.  Otherwise, the extensions modules will not be loaded "
"until the various advanced Calc features are used.  Since this mode only has "
"effect when Calc is first loaded, @kbd{m x} is usually followed by @kbd{m m} "
"to make the mode-setting permanent.  To load all of Calc just once, rather "
"than always in the future, you can press @kbd{C-x * L}."
msgstr ""

#. type: kindex
#: ../../calc.texi:12168
#, no-wrap
msgid "m S"
msgstr ""

#. type: pindex
#: ../../calc.texi:12169
#, no-wrap
msgid "calc-shift-prefix"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12181
msgid ""
"The @kbd{m S} (@code{calc-shift-prefix}) command enables a mode in which all "
"of Calc's letter prefix keys may be typed shifted as well as unshifted.  If "
"you are typing, say, @kbd{a S} (@code{calc-solve-for}) quite often you might "
"find it easier to turn this mode on so that you can type @kbd{A S} instead.  "
"When this mode is enabled, the commands that used to be on those single "
"shifted letters (e.g., @kbd{A} (@code{calc-abs})) can now be invoked by "
"pressing the shifted letter twice: @kbd{A A}.  Note that the @kbd{v} prefix "
"key always works both shifted and unshifted, and the @kbd{z} and @kbd{Z} "
"prefix keys are always distinct.  Also, the @kbd{h} prefix is not affected "
"by this mode.  Press @kbd{m S} again to disable shifted-prefix mode."
msgstr ""

#. type: node
#: ../../calc.texi:12182 ../../calc.texi:12239 ../../calc.texi:12282
#, no-wrap
msgid "Inverse and Hyperbolic"
msgstr ""

#. type: item
#: ../../calc.texi:12186 ../../calc.texi:13627 ../../calc.texi:24845
#, no-wrap
msgid "p"
msgstr ""

#. type: pindex
#: ../../calc.texi:12187
#, no-wrap
msgid "calc-precision"
msgstr ""

#. type: cindex
#: ../../calc.texi:12188
#, no-wrap
msgid "Precision of calculations"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12194
msgid ""
"The @kbd{p} (@code{calc-precision}) command controls the precision to which "
"floating-point calculations are carried.  The precision must be at least 3 "
"digits and may be arbitrarily high, within the limits of memory and time.  "
"This affects only floats: Integer and rational calculations are always "
"carried out with as many digits as necessary."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12197
msgid ""
"The @kbd{p} key prompts for the current precision.  If you wish you can "
"instead give the precision as a numeric prefix argument."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12207
msgid ""
"Many internal calculations are carried to one or two digits higher precision "
"than normal.  Results are rounded down afterward to the current precision.  "
"Unless a special display mode has been selected, floats are always displayed "
"with their full stored precision, i.e., what you see is what you get.  "
"Reducing the current precision does not round values already on the stack, "
"but those values will be rounded down before being used in any calculation.  "
"The @kbd{c 0} through @kbd{c 9} commands (@pxref{Conversions}) can be used "
"to round an existing value to a new precision."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12221
msgid ""
"It is important to distinguish the concepts of @dfn{precision} and "
"@dfn{accuracy}.  In the normal usage of these words, the number 123.4567 has "
"a precision of 7 digits but an accuracy of 4 digits.  The precision is the "
"total number of digits not counting leading or trailing zeros (regardless of "
"the position of the decimal point).  The accuracy is simply the number of "
"digits after the decimal point (again not counting trailing zeros).  In Calc "
"you control the precision, not the accuracy of computations.  If you were to "
"set the accuracy instead, then calculations like @samp{exp(100)} would "
"generate many more digits than you would typically need, while "
"@samp{exp(-100)} would probably round to zero! In Calc, both these "
"computations give you exactly 12 (or the requested number of) significant "
"digits."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12228
msgid ""
"The only Calc features that deal with accuracy instead of precision are "
"fixed-point display mode for floats (@kbd{d f}; @pxref{Float Formats}), and "
"the rounding functions like @code{floor} and @code{round} (@pxref{Integer "
"Truncation}).  Also, @kbd{c 0} through @kbd{c 9} deal with both precision "
"and accuracy depending on the magnitudes of the numbers involved."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12235
msgid ""
"If you need to work with a particular fixed accuracy (say, dollars and cents "
"with two digits after the decimal point), one solution is to work with "
"integers and an ``implied'' decimal point.  For example, $8.99 divided by 6 "
"would be entered @kbd{899 @key{RET} 6 /}, yielding 149.833 (actually "
"$1.49833 with our implied decimal point); pressing @kbd{R} would round this "
"to 150 cents, i.e., $1.50."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12238
msgid ""
"@xref{Floats}, for still more on floating-point precision and related "
"issues."
msgstr ""

#. type: node
#: ../../calc.texi:12239 ../../calc.texi:12282 ../../calc.texi:12283 ../../calc.texi:12302 ../../calc.texi:12333 ../../calc.texi:12350 ../../calc.texi:12376 ../../calc.texi:12416 ../../calc.texi:12449 ../../calc.texi:12521 ../../calc.texi:12545 ../../calc.texi:12572
#, no-wrap
msgid "Calculation Modes"
msgstr ""

#. type: section
#: ../../calc.texi:12240
#, no-wrap
msgid "Inverse and Hyperbolic Flags"
msgstr ""

#. type: pindex
#: ../../calc.texi:12244
#, no-wrap
msgid "calc-inverse"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12250
msgid ""
"There is no single-key equivalent to the @code{calc-arcsin} function.  "
"Instead, you must first press @kbd{I} (@code{calc-inverse}) to set the "
"@dfn{Inverse Flag}, then press @kbd{S} (@code{calc-sin}).  The @kbd{I} key "
"actually toggles the Inverse Flag.  When this flag is set, the word "
"@samp{Inv} appears in the mode line."
msgstr ""

#. type: item
#: ../../calc.texi:12251 ../../calc.texi:13621
#, no-wrap
msgid "H"
msgstr ""

#. type: pindex
#: ../../calc.texi:12252
#, no-wrap
msgid "calc-hyperbolic"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12259
msgid ""
"Likewise, the @kbd{H} key (@code{calc-hyperbolic}) sets or clears the "
"Hyperbolic Flag, which transforms @code{calc-sin} into @code{calc-sinh}.  If "
"both of these flags are set at once, the effect will be "
"@code{calc-arcsinh}.  (The Hyperbolic flag is also used by some "
"non-trigonometric commands; for example @kbd{H L} computes a base-10, "
"instead of base-@mathit{e}, logarithm.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12264
msgid ""
"Command names like @code{calc-arcsin} are provided for completeness, and may "
"be executed with @kbd{x} or @kbd{M-x}.  Their effect is simply to toggle the "
"Inverse and/or Hyperbolic flags and then execute the corresponding base "
"command (@code{calc-sin} in this case)."
msgstr ""

#. type: pindex
#: ../../calc.texi:12266
#, no-wrap
msgid "calc-option"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12270
msgid ""
"The @kbd{O} key (@code{calc-option}) sets another flag, the @dfn{Option "
"Flag}, which also can alter the subsequent Calc command in various ways."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12278
msgid ""
"The Inverse, Hyperbolic and Option flags apply only to the next Calculator "
"command, after which they are automatically cleared.  (They are also cleared "
"if the next keystroke is not a Calc command.)  Digits you type after "
"@kbd{I}, @kbd{H} or @kbd{O} (or @kbd{K}) are treated as prefix arguments for "
"the next command, not as numeric entries.  The same is true of @kbd{C-u}, "
"but not of the minus sign (@kbd{K -} means to subtract and keep arguments)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12281
msgid ""
"Another Calc prefix flag, @kbd{K} (keep-arguments), is discussed elsewhere.  "
"@xref{Keep Arguments}."
msgstr ""

#. type: node
#: ../../calc.texi:12282 ../../calc.texi:12572 ../../calc.texi:12573 ../../calc.texi:12653
#, no-wrap
msgid "Simplification Modes"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12290
msgid ""
"The commands in this section are two-key sequences beginning with the "
"@kbd{m} prefix.  (That's the letter @kbd{m}, not the @key{META} key.)  The "
"@samp{m a} (@code{calc-algebraic-mode}) command is described elsewhere "
"(@pxref{Algebraic Entry})."
msgstr ""

#. type: menuentry
#: ../../calc.texi:12300
msgid "Angular Modes::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:12300
msgid "Polar Mode::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:12300
msgid "Fraction Mode::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:12300
msgid "Infinite Mode::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:12300
msgid "Symbolic Mode::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:12300
msgid "Matrix Mode::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:12300
msgid "Automatic Recomputation::"
msgstr ""

#. type: node
#: ../../calc.texi:12300 ../../calc.texi:12521 ../../calc.texi:12545
#, no-wrap
msgid "Working Message"
msgstr ""

#. type: node
#: ../../calc.texi:12302 ../../calc.texi:12303 ../../calc.texi:12333
#, no-wrap
msgid "Angular Modes"
msgstr ""

#. type: node
#: ../../calc.texi:12302 ../../calc.texi:12333 ../../calc.texi:12334 ../../calc.texi:12350
#, no-wrap
msgid "Polar Mode"
msgstr ""

#. type: cindex
#: ../../calc.texi:12306
#, no-wrap
msgid "Angular mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12313
msgid ""
"The Calculator supports three notations for angles: radians, degrees, and "
"degrees-minutes-seconds.  When a number is presented to a function like "
"@code{sin} that requires an angle, the current angular mode is used to "
"interpret the number as either radians or degrees.  If an HMS form is "
"presented to @code{sin}, it is always interpreted as "
"degrees-minutes-seconds."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12321
msgid ""
"Functions that compute angles produce a number in radians, a number in "
"degrees, or an HMS form depending on the current angular mode.  If the "
"result is a complex number and the current mode is HMS, the number is "
"instead expressed in degrees.  (Complex-number calculations would normally "
"be done in Radians mode, though.  Complex numbers are converted to degrees "
"by calculating the complex result in radians and then multiplying by 180 "
"over @cpi{}.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:12322
#, no-wrap
msgid "m r"
msgstr ""

#. type: pindex
#: ../../calc.texi:12323
#, no-wrap
msgid "calc-radians-mode"
msgstr ""

#. type: kindex
#: ../../calc.texi:12324
#, no-wrap
msgid "m d"
msgstr ""

#. type: pindex
#: ../../calc.texi:12325
#, no-wrap
msgid "calc-degrees-mode"
msgstr ""

#. type: kindex
#: ../../calc.texi:12326
#, no-wrap
msgid "m h"
msgstr ""

#. type: pindex
#: ../../calc.texi:12327
#, no-wrap
msgid "calc-hms-mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12332
msgid ""
"The @kbd{m r} (@code{calc-radians-mode}), @kbd{m d} "
"(@code{calc-degrees-mode}), and @kbd{m h} (@code{calc-hms-mode}) commands "
"control the angular mode.  The current angular mode is displayed on the "
"Emacs mode line.  The default angular mode is Degrees."
msgstr ""

#. type: node
#: ../../calc.texi:12333 ../../calc.texi:12350 ../../calc.texi:12351 ../../calc.texi:12376
#, no-wrap
msgid "Fraction Mode"
msgstr ""

#. type: cindex
#: ../../calc.texi:12337
#, no-wrap
msgid "Polar mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12343
msgid ""
"The Calculator normally ``prefers'' rectangular complex numbers in the sense "
"that rectangular form is used when the proper form can not be decided from "
"the input.  This might happen by multiplying a rectangular number by a polar "
"one, by taking the square root of a negative real number, or by entering "
"@kbd{( 2 @key{SPC} 3 )}."
msgstr ""

#. type: kindex
#: ../../calc.texi:12344
#, no-wrap
msgid "m p"
msgstr ""

#. type: pindex
#: ../../calc.texi:12345
#, no-wrap
msgid "calc-polar-mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12349
msgid ""
"The @kbd{m p} (@code{calc-polar-mode}) command toggles complex-number "
"preference between rectangular and polar forms.  In Polar mode, all of the "
"above example situations would produce polar complex numbers."
msgstr ""

#. type: node
#: ../../calc.texi:12350 ../../calc.texi:12376 ../../calc.texi:12377 ../../calc.texi:12416
#, no-wrap
msgid "Infinite Mode"
msgstr ""

#. type: cindex
#: ../../calc.texi:12354
#, no-wrap
msgid "Fraction mode"
msgstr ""

#. type: cindex
#: ../../calc.texi:12355
#, no-wrap
msgid "Division of integers"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12363
msgid ""
"Division of two integers normally yields a floating-point number if the "
"result cannot be expressed as an integer.  In some cases you would rather "
"get an exact fractional answer.  One way to accomplish this is to use the "
"@kbd{:} (@code{calc-fdiv}) [@code{fdiv}] command, which divides the two "
"integers on the top of the stack to produce a fraction: @kbd{6 @key{RET} 4 "
":} produces @expr{3:2} even though @kbd{6 @key{RET} 4 /} produces "
"@expr{1.5}."
msgstr ""

#. type: kindex
#: ../../calc.texi:12364
#, no-wrap
msgid "m f"
msgstr ""

#. type: pindex
#: ../../calc.texi:12365
#, no-wrap
msgid "calc-frac-mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12371
msgid ""
"To set the Calculator to produce fractional results for normal integer "
"divisions, use the @kbd{m f} (@code{calc-frac-mode}) command.  For example, "
"@expr{8/4} produces @expr{2} in either mode, but @expr{6/4} produces "
"@expr{3:2} in Fraction mode, @expr{1.5} in Float mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12375
msgid ""
"At any time you can use @kbd{c f} (@code{calc-float}) to convert a fraction "
"to a float, or @kbd{c F} (@code{calc-fraction}) to convert a float to a "
"fraction.  @xref{Conversions}."
msgstr ""

#. type: node
#: ../../calc.texi:12376 ../../calc.texi:12416 ../../calc.texi:12417 ../../calc.texi:12449
#, no-wrap
msgid "Symbolic Mode"
msgstr ""

#. type: cindex
#: ../../calc.texi:12380
#, no-wrap
msgid "Infinite mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12385
msgid ""
"The Calculator normally treats results like @expr{1 / 0} as errors; formulas "
"like this are left in unsimplified form.  But Calc can be put into a mode "
"where such calculations instead produce ``infinite'' results."
msgstr ""

#. type: kindex
#: ../../calc.texi:12386
#, no-wrap
msgid "m i"
msgstr ""

#. type: pindex
#: ../../calc.texi:12387
#, no-wrap
msgid "calc-infinite-mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12394
msgid ""
"The @kbd{m i} (@code{calc-infinite-mode}) command turns this mode on and "
"off.  When the mode is off, infinities do not arise except in calculations "
"that already had infinities as inputs.  (One exception is that infinite open "
"intervals like @samp{[0 .. inf)} can be generated; however, intervals closed "
"at infinity (@samp{[0 .. inf]})  will not be generated when Infinite mode is "
"off.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12403
msgid ""
"With Infinite mode turned on, @samp{1 / 0} will generate @code{uinf}, an "
"undirected infinity.  @xref{Infinities}, for a discussion of the difference "
"between @code{inf} and @code{uinf}.  Also, @expr{0 / 0} evaluates to "
"@code{nan}, the ``indeterminate'' symbol.  Various other functions can also "
"return infinities in this mode; for example, @samp{ln(0) = -inf}, and "
"@samp{gamma(-7) = uinf}.  Once again, note that @samp{exp(inf) = inf} "
"regardless of Infinite mode because this calculation has infinity as an "
"input."
msgstr ""

#. type: cindex
#: ../../calc.texi:12404
#, no-wrap
msgid "Positive Infinite mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12415
msgid ""
"The @kbd{m i} command with a numeric prefix argument of zero, i.e., @kbd{C-u "
"0 m i}, turns on a Positive Infinite mode in which zero is treated as "
"positive instead of being directionless.  Thus, @samp{1 / 0 = inf} and "
"@samp{-1 / 0 = -inf} in this mode.  Note that zero never actually has a sign "
"in Calc; there are no separate representations for @mathit{+0} and "
"@mathit{-0}.  Positive Infinite mode merely changes the interpretation given "
"to the single symbol, @samp{0}.  One consequence of this is that, while you "
"might expect @samp{1 / -0 = -inf}, actually @samp{1 / -0} is equivalent to "
"@samp{1 / 0}, which is equal to positive @code{inf}."
msgstr ""

#. type: node
#: ../../calc.texi:12416 ../../calc.texi:12449 ../../calc.texi:12521
#, no-wrap
msgid "Matrix Mode"
msgstr ""

#. type: cindex
#: ../../calc.texi:12420
#, no-wrap
msgid "Symbolic mode"
msgstr ""

#. type: cindex
#: ../../calc.texi:12421
#, no-wrap
msgid "Inexact results"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12427
msgid ""
"Calculations are normally performed numerically wherever possible.  For "
"example, the @code{calc-sqrt} command, or @code{sqrt} function in an "
"algebraic expression, produces a numeric answer if the argument is a number "
"or a symbolic expression if the argument is an expression: @kbd{2 Q} pushes "
"1.4142 but @kbd{' x+1 @key{RET} Q} pushes @samp{sqrt(x+1)}."
msgstr ""

#. type: kindex
#: ../../calc.texi:12428
#, no-wrap
msgid "m s"
msgstr ""

#. type: pindex
#: ../../calc.texi:12429
#, no-wrap
msgid "calc-symbolic-mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12434
msgid ""
"In @dfn{Symbolic mode}, controlled by the @kbd{m s} "
"(@code{calc-symbolic-mode})  command, functions which would produce inexact, "
"irrational results are left in symbolic form.  Thus @kbd{16 Q} pushes 4, but "
"@kbd{2 Q} pushes @samp{sqrt(2)}."
msgstr ""

#. type: pindex
#: ../../calc.texi:12436
#, no-wrap
msgid "calc-eval-num"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12443
msgid ""
"The shift-@kbd{N} (@code{calc-eval-num}) command evaluates numerically the "
"expression at the top of the stack, by temporarily disabling "
"@code{calc-symbolic-mode} and executing @kbd{=} (@code{calc-evaluate}).  "
"Given a numeric prefix argument, it also sets the floating-point precision "
"to the specified value for the duration of the command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12448
msgid ""
"To evaluate a formula numerically without expanding the variables it "
"contains, you can use the key sequence @kbd{m s a v m s} (this uses "
"@code{calc-alg-evaluate}, which resimplifies but doesn't evaluate "
"variables.)"
msgstr ""

#. type: node
#: ../../calc.texi:12449 ../../calc.texi:12521 ../../calc.texi:12522 ../../calc.texi:12545
#, no-wrap
msgid "Automatic Recomputation"
msgstr ""

#. type: subsection
#: ../../calc.texi:12450
#, no-wrap
msgid "Matrix and Scalar Modes"
msgstr ""

#. type: cindex
#: ../../calc.texi:12453
#, no-wrap
msgid "Matrix mode"
msgstr ""

#. type: cindex
#: ../../calc.texi:12454
#, no-wrap
msgid "Scalar mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12459
msgid ""
"Calc sometimes makes assumptions during algebraic manipulation that are "
"awkward or incorrect when vectors and matrices are involved.  Calc has two "
"modes, @dfn{Matrix mode} and @dfn{Scalar mode}, which modify its behavior "
"around vectors in useful ways."
msgstr ""

#. type: kindex
#: ../../calc.texi:12460
#, no-wrap
msgid "m v"
msgstr ""

#. type: pindex
#: ../../calc.texi:12461
#, no-wrap
msgid "calc-matrix-mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12480
msgid ""
"Press @kbd{m v} (@code{calc-matrix-mode}) once to enter Matrix mode.  In "
"this mode, all objects are assumed to be matrices unless provably "
"otherwise.  One major effect is that Calc will no longer consider "
"multiplication to be commutative.  (Recall that in matrix arithmetic, "
"@samp{A*B} is not the same as @samp{B*A}.)  This assumption affects rewrite "
"rules and algebraic simplification.  Another effect of this mode is that "
"calculations that would normally produce constants like 0 and 1 (e.g., "
"@expr{a - a} and @expr{a / a}, respectively) will now produce function calls "
"that represent ``generic'' zero or identity matrices: @samp{idn(0)}, "
"@samp{idn(1)}.  The @code{idn} function @samp{idn(@var{a},@var{n})} returns "
"@var{a} times an @var{n}x@var{n} identity matrix; if @var{n} is omitted, it "
"doesn't know what dimension to use and so the @code{idn} call remains in "
"symbolic form.  However, if this generic identity matrix is later combined "
"with a matrix whose size is known, it will be converted into a true identity "
"matrix of the appropriate size.  On the other hand, if it is combined with a "
"scalar (as in @samp{idn(1) + 2}), Calc will assume it really was a scalar "
"after all and produce, e.g., 3."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12488
msgid ""
"Press @kbd{m v} a second time to get Scalar mode.  Here, objects are assumed "
"@emph{not} to be vectors or matrices unless provably so.  For example, "
"normally adding a variable to a vector, as in @samp{[x, y, z] + a}, will "
"leave the sum in symbolic form because as far as Calc knows, @samp{a} could "
"represent either a number or another 3-vector.  In Scalar mode, @samp{a} is "
"assumed to be a non-vector, and the addition is evaluated to @samp{[x+a, "
"y+a, z+a]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12490
msgid "Press @kbd{m v} a third time to return to the normal mode of operation."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12498
msgid ""
"If you press @kbd{m v} with a numeric prefix argument @var{n}, you get a "
"special ``dimensioned'' Matrix mode in which matrices of unknown size are "
"assumed to be @var{n}x@var{n} square matrices.  Then, the function call "
"@samp{idn(1)} will expand into an actual matrix rather than representing a "
"``generic'' matrix.  Simply typing @kbd{C-u m v} will get you a square "
"Matrix mode, in which matrices of unknown size are assumed to be square "
"matrices of unspecified size."
msgstr ""

#. type: cindex
#: ../../calc.texi:12499
#, no-wrap
msgid "Declaring scalar variables"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12505
msgid ""
"Of course these modes are approximations to the true state of affairs, which "
"is probably that some quantities will be matrices and others will be "
"scalars.  One solution is to ``declare'' certain variables or functions to "
"be scalar-valued.  @xref{Declarations}, to see how to make declarations in "
"Calc."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12513
msgid ""
"There is nothing stopping you from declaring a variable to be scalar and "
"then storing a matrix in it; however, if you do, the results you get from "
"Calc may not be valid.  Suppose you let Calc get the result @samp{[x+a, y+a, "
"z+a]} shown above, and then stored @samp{[1, 2, 3]} in @samp{a}.  The result "
"would not be the same as for @samp{[x, y, z] + [1, 2, 3]}, but that's "
"because you have broken your earlier promise to Calc that @samp{a} would be "
"scalar."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12520
msgid ""
"Another way to mix scalars and matrices is to use selections "
"(@pxref{Selecting Subformulas}).  Use Matrix mode when operating on your "
"formula normally; then, to apply Scalar mode to a certain part of the "
"formula without affecting the rest just select that part, change into Scalar "
"mode and press @kbd{=} to resimplify the part under this mode, then change "
"back to Matrix mode before deselecting."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12529
msgid ""
"The @dfn{evaluates-to} operator, @samp{=>}, has the special property that "
"any @samp{=>} formulas on the stack are recomputed whenever variable values "
"or mode settings that might affect them are changed.  @xref{Evaluates-To "
"Operator}."
msgstr ""

#. type: kindex
#: ../../calc.texi:12530 ../../calc.texi:29034
#, no-wrap
msgid "m C"
msgstr ""

#. type: pindex
#: ../../calc.texi:12531 ../../calc.texi:29035
#, no-wrap
msgid "calc-auto-recompute"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12540
msgid ""
"The @kbd{m C} (@code{calc-auto-recompute}) command turns this automatic "
"recomputation on and off.  If you turn it off, Calc will not update "
"@samp{=>} operators on the stack (nor those in the attached Embedded mode "
"buffer, if there is one).  They will not be updated unless you explicitly do "
"so by pressing @kbd{=} or until you press @kbd{m C} to turn recomputation "
"back on.  (While automatic recomputation is off, you can think of @kbd{m C m "
"C} as a command to update all @samp{=>} operators while leaving "
"recomputation off.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12544
msgid ""
"To update @samp{=>} operators in an Embedded buffer while automatic "
"recomputation is off, use @w{@kbd{C-x * u}}.  @xref{Embedded Mode}."
msgstr ""

#. type: subsection
#: ../../calc.texi:12546
#, no-wrap
msgid "Working Messages"
msgstr ""

#. type: cindex
#: ../../calc.texi:12549
#, no-wrap
msgid "Performance"
msgstr ""

#. type: cindex
#: ../../calc.texi:12550
#, no-wrap
msgid "Working messages"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12558
msgid ""
"Since the Calculator is written entirely in Emacs Lisp, which is not "
"designed for heavy numerical work, many operations are quite slow.  The "
"Calculator normally displays the message @samp{Working...} in the echo area "
"during any command that may be slow.  In addition, iterative operations such "
"as square roots and trigonometric functions display the intermediate result "
"at each step.  Both of these types of messages can be disabled if you find "
"them distracting."
msgstr ""

#. type: kindex
#: ../../calc.texi:12559
#, no-wrap
msgid "m w"
msgstr ""

#. type: pindex
#: ../../calc.texi:12560
#, no-wrap
msgid "calc-working"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12566
msgid ""
"Type @kbd{m w} (@code{calc-working}) with a numeric prefix of 0 to disable "
"all ``working'' messages.  Use a numeric prefix of 1 to enable only the "
"plain @samp{Working...} message.  Use a numeric prefix of 2 to see "
"intermediate results as well.  With no numeric prefix this displays the "
"current mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12571
msgid ""
"While it may seem that the ``working'' messages will slow Calc down "
"considerably, experiments have shown that their impact is actually quite "
"small.  But if your terminal is slow you may find that it helps to turn the "
"messages off."
msgstr ""

#. type: node
#: ../../calc.texi:12572 ../../calc.texi:12653 ../../calc.texi:12654 ../../calc.texi:12668 ../../calc.texi:12733 ../../calc.texi:12923 ../../calc.texi:13062
#, no-wrap
msgid "Declarations"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12582
msgid ""
"The current @dfn{simplification mode} controls how numbers and formulas are "
"``normalized'' when being taken from or pushed onto the stack.  Some "
"normalizations are unavoidable, such as rounding floating-point results to "
"the current precision, and reducing fractions to simplest form.  Others, "
"such as simplifying a formula like @expr{a+a} (or @expr{2+3}), are done "
"automatically but can be turned off when necessary."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12587
msgid ""
"When you press a key like @kbd{+} when @expr{2} and @expr{3} are on the "
"stack, Calc pops these numbers, normalizes them, creates the formula "
"@expr{2+3}, normalizes it, and pushes the result.  Of course the standard "
"rules for normalizing @expr{2+3} will produce the result @expr{5}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12590
msgid ""
"Simplification mode commands consist of the lower-case @kbd{m} prefix key "
"followed by a shifted letter."
msgstr ""

#. type: kindex
#: ../../calc.texi:12591
#, no-wrap
msgid "m O"
msgstr ""

#. type: pindex
#: ../../calc.texi:12592
#, no-wrap
msgid "calc-no-simplify-mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12600
msgid ""
"The @kbd{m O} (@code{calc-no-simplify-mode}) command turns off all optional "
"simplifications.  These would leave a formula like @expr{2+3} alone.  In "
"fact, nothing except simple numbers are ever affected by normalization in "
"this mode.  Explicit simplification commands, such as @kbd{=} or @kbd{a s}, "
"can still be given to simplify any formulas.  @xref{Algebraic Definitions}, "
"for a sample use of No-Simplification mode."
msgstr ""

#. type: kindex
#: ../../calc.texi:12601
#, no-wrap
msgid "m N"
msgstr ""

#. type: pindex
#: ../../calc.texi:12602
#, no-wrap
msgid "calc-num-simplify-mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12613
msgid ""
"The @kbd{m N} (@code{calc-num-simplify-mode}) command turns off "
"simplification of any formulas except those for which all arguments are "
"constants.  For example, @expr{1+2} is simplified to @expr{3}, and "
"@expr{a+(2-2)} is simplified to @expr{a+0} but no further, since one "
"argument of the sum is not a constant.  Unfortunately, @expr{(a+2)-2} is "
"@emph{not} simplified because the top-level @samp{-} operator's arguments "
"are not both constant numbers (one of them is the formula @expr{a+2}).  A "
"constant is a number or other numeric object (such as a constant error form "
"or modulo form), or a vector all of whose elements are constant."
msgstr ""

#. type: kindex
#: ../../calc.texi:12614
#, no-wrap
msgid "m I"
msgstr ""

#. type: pindex
#: ../../calc.texi:12615
#, no-wrap
msgid "calc-basic-simplify-mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12621
msgid ""
"The @kbd{m I} (@code{calc-basic-simplify-mode}) command does some basic "
"simplifications for all formulas.  This includes many easy and fast "
"algebraic simplifications such as @expr{a+0} to @expr{a}, and @expr{a + 2 a} "
"to @expr{3 a}, as well as evaluating functions like @expr{@tfn{deriv}(x^2, "
"x)} to @expr{2 x}."
msgstr ""

#. type: kindex
#: ../../calc.texi:12622
#, no-wrap
msgid "m B"
msgstr ""

#. type: pindex
#: ../../calc.texi:12623
#, no-wrap
msgid "calc-bin-simplify-mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12630
msgid ""
"The @kbd{m B} (@code{calc-bin-simplify-mode}) mode applies the basic "
"simplifications to a result and then, if the result is an integer, uses the "
"@kbd{b c} (@code{calc-clip}) command to clip the integer according to the "
"current binary word size.  @xref{Binary Functions}.  Real numbers are "
"rounded to the nearest integer and then clipped; other kinds of results "
"(after the basic simplifications) are left alone."
msgstr ""

#. type: kindex
#: ../../calc.texi:12631 ../../calc.texi:22809
#, no-wrap
msgid "m A"
msgstr ""

#. type: pindex
#: ../../calc.texi:12632
#, no-wrap
msgid "calc-alg-simplify-mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12635
msgid ""
"The @kbd{m A} (@code{calc-alg-simplify-mode}) mode does standard algebraic "
"simplifications.  @xref{Algebraic Simplifications}."
msgstr ""

#. type: kindex
#: ../../calc.texi:12636 ../../calc.texi:23043
#, no-wrap
msgid "m E"
msgstr ""

#. type: pindex
#: ../../calc.texi:12637
#, no-wrap
msgid "calc-ext-simplify-mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12640
msgid ""
"The @kbd{m E} (@code{calc-ext-simplify-mode}) mode does ``extended'', or "
"``unsafe'', algebraic simplification.  @xref{Unsafe Simplifications}."
msgstr ""

#. type: kindex
#: ../../calc.texi:12641
#, no-wrap
msgid "m U"
msgstr ""

#. type: pindex
#: ../../calc.texi:12642
#, no-wrap
msgid "calc-units-simplify-mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12648
msgid ""
"The @kbd{m U} (@code{calc-units-simplify-mode}) mode does units "
"simplification.  @xref{Simplification of Units}.  These include the "
"algebraic simplifications, plus variable names which are identifiable as "
"unit names (like @samp{mm} for ``millimeters'')  are simplified with their "
"unit definitions in mind."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12653
msgid ""
"A common technique is to set the simplification mode down to the lowest "
"amount of simplification you will allow to be applied automatically, then "
"use manual commands like @kbd{a s} and @kbd{c c} (@code{calc-clean}) to "
"perform higher types of simplifications on demand."
msgstr ""

#. type: node
#: ../../calc.texi:12653 ../../calc.texi:13062 ../../calc.texi:13063 ../../calc.texi:13107 ../../calc.texi:13192 ../../calc.texi:13230 ../../calc.texi:13296 ../../calc.texi:13327 ../../calc.texi:13364 ../../calc.texi:13391 ../../calc.texi:13800 ../../calc.texi:13835 ../../calc.texi:13896 ../../calc.texi:13927
#, no-wrap
msgid "Display Modes"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12661
msgid ""
"A @dfn{declaration} is a statement you make that promises you will use a "
"certain variable or function in a restricted way.  This may give Calc the "
"freedom to do things that it couldn't do if it had to take the fully general "
"situation into account."
msgstr ""

#. type: menuentry
#: ../../calc.texi:12666
msgid "Declaration Basics::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:12666
msgid "Kinds of Declarations::"
msgstr ""

#. type: subsection
#: ../../calc.texi:12666 ../../calc.texi:12733 ../../calc.texi:12923 ../../calc.texi:12924
#, no-wrap
msgid "Functions for Declarations"
msgstr ""

#. type: node
#: ../../calc.texi:12668 ../../calc.texi:12669 ../../calc.texi:12733
#, no-wrap
msgid "Declaration Basics"
msgstr ""

#. type: node
#: ../../calc.texi:12668 ../../calc.texi:12733 ../../calc.texi:12734 ../../calc.texi:12923
#, no-wrap
msgid "Kinds of Declarations"
msgstr ""

#. type: kindex
#: ../../calc.texi:12672
#, no-wrap
msgid "s d"
msgstr ""

#. type: pindex
#: ../../calc.texi:12673
#, no-wrap
msgid "calc-declare-variable"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12681
msgid ""
"The @kbd{s d} (@code{calc-declare-variable}) command is the easiest way to "
"make a declaration for a variable.  This command prompts for the variable "
"name, then prompts for the declaration.  The default at the declaration "
"prompt is the previous declaration, if any.  You can edit this declaration, "
"or press @kbd{C-k} to erase it and type a new declaration.  (Or, erase it "
"and press @key{RET} to clear the declaration, effectively ``undeclaring'' "
"the variable.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12690
msgid ""
"A declaration is in general a vector of @dfn{type symbols} and @dfn{range} "
"values.  If there is only one type symbol or range value, you can write it "
"directly rather than enclosing it in a vector.  For example, @kbd{s d foo "
"@key{RET} real @key{RET}} declares @code{foo} to be a real number, and "
"@kbd{s d bar @key{RET} [int, const, [1..6]] @key{RET}} declares @code{bar} "
"to be a constant integer between 1 and 6.  (Actually, you can omit the "
"outermost brackets and Calc will provide them for you: @kbd{s d bar "
"@key{RET} int, const, [1..6] @key{RET}}.)"
msgstr ""

#. type: cindex
#: ../../calc.texi:12691
#, no-wrap
msgid "@code{Decls} variable"
msgstr ""

#. type: vindex
#: ../../calc.texi:12692
#, no-wrap
msgid "Decls"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12702
msgid ""
"Declarations in Calc are kept in a special variable called @code{Decls}.  "
"This variable encodes the set of all outstanding declarations in the form of "
"a matrix.  Each row has two elements: A variable or vector of variables "
"declared by that row, and the declaration specifier as described above.  You "
"can use the @kbd{s D} command to edit this variable if you wish to see all "
"the declarations at once.  @xref{Operations on Variables}, for a description "
"of this command and the @kbd{s p} command that allows you to save your "
"declarations permanently if you wish."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12708
msgid ""
"Items being declared can also be function calls.  The arguments in the call "
"are ignored; the effect is to say that this function returns values of the "
"declared type for any valid arguments.  The @kbd{s d} command declares only "
"variables, so if you wish to make a function declaration you will have to "
"edit the @code{Decls} matrix yourself."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12710
msgid "For example, the declaration matrix"
msgstr ""

#. type: group
#: ../../calc.texi:12716
#, no-wrap
msgid ""
"[ [ foo,       real       ]\n"
"  [ [j, k, n], int        ]\n"
"  [ f(1,2,3),  [0 .. inf) ] ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12723
msgid ""
"declares that @code{foo} represents a real number, @code{j}, @code{k} and "
"@code{n} represent integers, and the function @code{f} always returns a real "
"number in the interval shown."
msgstr ""

#. type: vindex
#: ../../calc.texi:12724
#, no-wrap
msgid "All"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12732
msgid ""
"If there is a declaration for the variable @code{All}, then that declaration "
"applies to all variables that are not otherwise declared.  It does not apply "
"to function names.  For example, using the row @samp{[All, real]} says that "
"all your variables are real unless they are explicitly declared without "
"@code{real} in some other row.  The @kbd{s d} command declares @code{All} if "
"you give a blank response to the variable-name prompt."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12742
msgid ""
"The type-specifier part of a declaration (that is, the second prompt in the "
"@kbd{s d} command) can be a type symbol, an interval, or a vector consisting "
"of zero or more type symbols followed by zero or more intervals or numbers "
"that represent the set of possible values for the variable."
msgstr ""

#. type: group
#: ../../calc.texi:12748
#, no-wrap
msgid ""
"[ [ a, [1, 2, 3, 4, 5] ]\n"
"  [ b, [1 .. 5]        ]\n"
"  [ c, [int, 1 .. 5]   ] ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12756
msgid ""
"Here @code{a} is declared to contain one of the five integers shown; "
"@code{b} is any number in the interval from 1 to 5 (any real number since we "
"haven't specified), and @code{c} is any integer in that interval.  Thus the "
"declarations for @code{a} and @code{c} are nearly equivalent (see below)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12761
msgid ""
"The type-specifier can be the empty vector @samp{[]} to say that nothing is "
"known about a given variable's value.  This is the same as not declaring the "
"variable at all except that it overrides any @code{All} declaration which "
"would otherwise apply."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12768
msgid ""
"The initial value of @code{Decls} is the empty vector @samp{[]}.  If "
"@code{Decls} has no stored value or if the value stored in it is not valid, "
"it is ignored and there are no declarations as far as Calc is concerned.  "
"(The @kbd{s d} command will replace such a malformed value with a fresh "
"empty matrix, @samp{[]}, before recording the new declaration.)  "
"Unrecognized type symbols are ignored."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12771
msgid ""
"The following type symbols describe what sorts of numbers will be stored in "
"a variable:"
msgstr ""

#. type: item
#: ../../calc.texi:12773
#, no-wrap
msgid "int"
msgstr ""

#. type: table
#: ../../calc.texi:12775
msgid "Integers."
msgstr ""

#. type: item
#: ../../calc.texi:12775
#, no-wrap
msgid "numint"
msgstr ""

#. type: table
#: ../../calc.texi:12777
msgid "Numerical integers.  (Integers or integer-valued floats.)"
msgstr ""

#. type: item
#: ../../calc.texi:12777
#, no-wrap
msgid "frac"
msgstr ""

#. type: table
#: ../../calc.texi:12779
msgid "Fractions.  (Rational numbers which are not integers.)"
msgstr ""

#. type: item
#: ../../calc.texi:12779
#, no-wrap
msgid "rat"
msgstr ""

#. type: table
#: ../../calc.texi:12781
msgid "Rational numbers.  (Either integers or fractions.)"
msgstr ""

#. type: findex
#: ../../calc.texi:12781 ../../calc.texi:32647 ../../calc.texi:32648
#, no-wrap
msgid "float"
msgstr ""

#. type: table
#: ../../calc.texi:12783
msgid "Floating-point numbers."
msgstr ""

#. type: item
#: ../../calc.texi:12783
#, no-wrap
msgid "real"
msgstr ""

#. type: table
#: ../../calc.texi:12787
msgid ""
"Real numbers.  (Integers, fractions, or floats.  Actually, intervals and "
"error forms with real components also count as reals here.)"
msgstr ""

#. type: item
#: ../../calc.texi:12787
#, no-wrap
msgid "pos"
msgstr ""

#. type: table
#: ../../calc.texi:12789
msgid "Positive real numbers.  (Strictly greater than zero.)"
msgstr ""

#. type: item
#: ../../calc.texi:12789
#, no-wrap
msgid "nonneg"
msgstr ""

#. type: table
#: ../../calc.texi:12791
msgid "Nonnegative real numbers.  (Greater than or equal to zero.)"
msgstr ""

#. type: item
#: ../../calc.texi:12791
#, no-wrap
msgid "number"
msgstr ""

#. type: table
#: ../../calc.texi:12793
msgid "Numbers.  (Real or complex.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12804
msgid ""
"Calc uses this information to determine when certain simplifications of "
"formulas are safe.  For example, @samp{(x^y)^z} cannot be simplified to "
"@samp{x^(y z)} in general; for example, @samp{((-3)^2)^1:2} is 3, but "
"@samp{(-3)^(2*1:2) = (-3)^1} is @mathit{-3}.  However, this simplification "
"@emph{is} safe if @code{z} is known to be an integer, or if @code{x} is "
"known to be a nonnegative real number.  If you have given declarations that "
"allow Calc to deduce either of these facts, Calc will perform this "
"simplification of the formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12811
msgid ""
"Calc can apply a certain amount of logic when using declarations.  For "
"example, @samp{(x^y)^(2n+1)} will be simplified if @code{n} has been "
"declared @code{int}; Calc knows that an integer times an integer, plus an "
"integer, must always be an integer.  (In fact, Calc would simplify "
"@samp{(-x)^(2n+1)} to @samp{-(x^(2n+1))} since it is able to determine that "
"@samp{2n+1} must be an odd integer.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12817
msgid ""
"Similarly, @samp{(abs(x)^y)^z} will be simplified to @samp{abs(x)^(y z)} "
"because Calc knows that the @code{abs} function always returns a nonnegative "
"real.  If you had a @code{myabs} function that also had this property, you "
"could get Calc to recognize it by adding the row @samp{[myabs(), nonneg]} to "
"the @code{Decls} matrix."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12824
msgid ""
"One instance of this simplification is @samp{sqrt(x^2)} (since the "
"@code{sqrt} function is effectively a one-half power).  Normally Calc leaves "
"this formula alone.  After the command @kbd{s d x @key{RET} real @key{RET}}, "
"however, it can simplify the formula to @samp{abs(x)}.  And after @kbd{s d x "
"@key{RET} nonneg @key{RET}}, Calc can simplify this formula all the way to "
"@samp{x}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12835
msgid ""
"If there are any intervals or real numbers in the type specifier, they "
"comprise the set of possible values that the variable or function being "
"declared can have.  In particular, the type symbol @code{real} is "
"effectively the same as the range @samp{[-inf .. inf]} (note that infinity "
"is included in the range of possible values); @code{pos} is the same as "
"@samp{(0 .. inf]}, and @code{nonneg} is the same as @samp{[0 .. inf]}.  "
"Saying @samp{[real, [-5 .. 5]]} is redundant because the fact that the "
"variable is real can be deduced just from the interval, but @samp{[int, [-5 "
".. 5]]} and @samp{[rat, [-5 .. 5]]} are useful combinations."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12838
msgid ""
"Note that the vector of intervals or numbers is in the same format used by "
"Calc's set-manipulation commands.  @xref{Set Operations}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12846
msgid ""
"The type specifier @samp{[1, 2, 3]} is equivalent to @samp{[numint, 1, 2, "
"3]}, @emph{not} to @samp{[int, 1, 2, 3]}.  In other words, the range of "
"possible values means only that the variable's value must be numerically "
"equal to a number in that range, but not that it must be equal in type as "
"well.  Calc's set operations act the same way; @samp{in(2, [1., 2., 3.])} "
"and @samp{in(1.5, [1:2, 3:2, 5:2])} both report ``true.''"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12851
msgid ""
"If you use a conflicting combination of type specifiers, the results are "
"unpredictable.  An example is @samp{[pos, [0 .. 5]]}, where the interval "
"does not lie in the range described by the type symbol."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12857
msgid ""
"``Real'' declarations mostly affect simplifications involving powers like "
"the one described above.  Another case where they are used is in the @kbd{a "
"P} command which returns a list of all roots of a polynomial; if the "
"variable has been declared real, only the real roots (if any) will be "
"included in the list."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12861
msgid ""
"``Integer'' declarations are used for simplifications which are valid only "
"when certain values are integers (such as @samp{(x^y)^z} shown above)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12872
msgid ""
"Calc's algebraic simplifications also make use of declarations when "
"simplifying equations and inequalities.  They will cancel @code{x} from both "
"sides of @samp{a x = b x} only if it is sure @code{x} is non-zero, say, "
"because it has a @code{pos} declaration.  To declare specifically that "
"@code{x} is real and non-zero, use @samp{[[-inf .. 0), (0 .. inf]]}.  (There "
"is no way in the current notation to say that @code{x} is nonzero but not "
"necessarily real.)  The @kbd{a e} command does ``unsafe'' simplifications, "
"including canceling @samp{x} from the equation when @samp{x} is not known to "
"be nonzero."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12874
msgid "Another set of type symbols distinguish between scalars and vectors."
msgstr ""

#. type: item
#: ../../calc.texi:12876
#, no-wrap
msgid "scalar"
msgstr ""

#. type: table
#: ../../calc.texi:12878
msgid "The value is not a vector."
msgstr ""

#. type: item
#: ../../calc.texi:12878
#, no-wrap
msgid "vector"
msgstr ""

#. type: table
#: ../../calc.texi:12880
msgid "The value is a vector."
msgstr ""

#. type: item
#: ../../calc.texi:12880
#, no-wrap
msgid "matrix"
msgstr ""

#. type: table
#: ../../calc.texi:12882
msgid "The value is a matrix (a rectangular vector of vectors)."
msgstr ""

#. type: item
#: ../../calc.texi:12882
#, no-wrap
msgid "sqmatrix"
msgstr ""

#. type: table
#: ../../calc.texi:12884
msgid "The value is a square matrix."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12889
msgid ""
"These type symbols can be combined with the other type symbols described "
"above; @samp{[int, matrix]} describes an object which is a matrix of "
"integers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12899
msgid ""
"Scalar/vector declarations are used to determine whether certain algebraic "
"operations are safe.  For example, @samp{[a, b, c] + x} is normally not "
"simplified to @samp{[a + x, b + x, c + x]}, but it will be if @code{x} has "
"been declared @code{scalar}.  On the other hand, multiplication is usually "
"assumed to be commutative, but the terms in @samp{x y} will never be "
"exchanged if both @code{x} and @code{y} are known to be vectors or "
"matrices.  (Calc currently never distinguishes between @code{vector} and "
"@code{matrix} declarations.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12903
msgid ""
"@xref{Matrix Mode}, for a discussion of Matrix mode and Scalar mode, which "
"are similar to declaring @samp{[All, matrix]} or @samp{[All, scalar]} but "
"much more convenient."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12906
msgid ""
"One more type symbol that is recognized is used with the @kbd{H a d} command "
"for taking total derivatives of a formula.  @xref{Calculus}."
msgstr ""

#. type: item
#: ../../calc.texi:12908
#, no-wrap
msgid "const"
msgstr ""

#. type: table
#: ../../calc.texi:12910
msgid "The value is a constant with respect to other variables."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12922
msgid ""
"Calc does not check the declarations for a variable when you store a value "
"in it.  However, storing @mathit{-3.5} in a variable that has been declared "
"@code{pos}, @code{int}, or @code{matrix} may have unexpected effects; Calc "
"may evaluate @samp{sqrt(x^2)} to @expr{3.5} if it substitutes the value "
"first, or to @expr{-3.5} if @code{x} was declared @code{pos} and the formula "
"@samp{sqrt(x^2)} is simplified to @samp{x} before the value is substituted.  "
"Before using a variable for a new purpose, it is best to use @kbd{s d} or "
"@kbd{s D} to check to make sure you don't still have an old declaration for "
"the variable that will conflict with its new meaning."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12936
msgid ""
"Calc has a set of functions for accessing the current declarations in a "
"convenient manner.  These functions return 1 if the argument can be shown to "
"have the specified property, or 0 if the argument can be shown @emph{not} to "
"have that property; otherwise they are left unevaluated.  These functions "
"are suitable for use with rewrite rules (@pxref{Conditional Rewrite Rules}) "
"or programming constructs (@pxref{Conditionals in Macros}).  They can be "
"entered only using algebraic notation.  @xref{Logical Operations}, for "
"functions that perform other tests not related to declarations."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12942
msgid ""
"For example, @samp{dint(17)} returns 1 because 17 is an integer, as do "
"@samp{dint(n)} and @samp{dint(2 n - 3)} if @code{n} has been declared "
"@code{int}, but @samp{dint(2.5)} and @samp{dint(n + 0.5)} return 0.  Calc "
"consults knowledge of its own built-in functions as well as your own "
"declarations: @samp{dint(floor(x))} returns 1."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12947
msgid "@tindex dint"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12951
msgid "@tindex dnumint"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12963
msgid ""
"@tindex dnatnum The @code{dint} function checks if its argument is an "
"integer.  The @code{dnatnum} function checks if its argument is a natural "
"number, i.e., a nonnegative integer.  The @code{dnumint} function checks if "
"its argument is numerically an integer, i.e., either an integer or an "
"integer-valued float.  Note that these and the other data type functions "
"also accept vectors or matrices composed of suitable elements, and that real "
"infinities @samp{inf} and @samp{-inf} are considered to be integers for the "
"purposes of these functions."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12971
msgid ""
"@tindex drat The @code{drat} function checks if its argument is rational, "
"i.e., an integer or fraction.  Infinities count as rational, but intervals "
"and error forms do not."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12978
msgid ""
"@tindex dreal The @code{dreal} function checks if its argument is real.  "
"This includes integers, fractions, floats, real error forms, and intervals."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12985
msgid ""
"@tindex dimag The @code{dimag} function checks if its argument is imaginary, "
"i.e., is mathematically equal to a real number times @expr{i}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:12990
msgid "@tindex dpos"
msgstr ""

#. type: Plain text
#: ../../calc.texi:12994
msgid "@tindex dneg"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13006
msgid ""
"@tindex dnonneg The @code{dpos} function checks for positive (but nonzero) "
"reals.  The @code{dneg} function checks for negative reals.  The "
"@code{dnonneg} function checks for nonnegative reals, i.e., reals greater "
"than or equal to zero.  Note that Calc's algebraic simplifications, which "
"are effectively applied to all conditions in rewrite rules, can simplify an "
"expression like @expr{x > 0} to 1 or 0 using @code{dpos}.  So the actual "
"functions @code{dpos}, @code{dneg}, and @code{dnonneg} are rarely necessary."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13018
msgid ""
"@tindex dnonzero The @code{dnonzero} function checks that its argument is "
"nonzero.  This includes all nonzero real or complex numbers, all intervals "
"that do not include zero, all nonzero modulo forms, vectors all of whose "
"elements are nonzero, and variables or formulas whose values can be deduced "
"to be nonzero.  It does not include error forms, since they represent values "
"which could be anything including zero.  (This is also the set of objects "
"considered ``true'' in conditional contexts.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13023
msgid "@tindex deven"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13032
msgid ""
"@tindex dodd The @code{deven} function returns 1 if its argument is known to "
"be an even integer (or integer-valued float); it returns 0 if its argument "
"is known not to be even (because it is known to be odd or a non-integer).  "
"Calc's algebraic simplifications use this to simplify a test of the form "
"@samp{x % 2 = 0}.  There is also an analogous @code{dodd} function."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13046
msgid ""
"@tindex drange The @code{drange} function returns a set (an interval or a "
"vector of intervals and/or numbers; @pxref{Set Operations}) that describes "
"the set of possible values of its argument.  If the argument is a variable "
"or a function with a declaration, the range is copied from the declaration.  "
"Otherwise, the possible signs of the expression are determined using a "
"method similar to @code{dpos}, etc., and a suitable set like @samp{[0 "
".. inf]} is returned.  If the expression is not provably real, the "
"@code{drange} function remains unevaluated."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13061
msgid ""
"@tindex dscalar The @code{dscalar} function returns 1 if its argument is "
"provably scalar, or 0 if its argument is provably non-scalar.  It is left "
"unevaluated if this cannot be determined.  (If Matrix mode or Scalar mode is "
"in effect, this function returns 1 or 0, respectively, if it has no other "
"information.)  When Calc interprets a condition (say, in a rewrite rule) it "
"considers an unevaluated formula to be ``false.'' Thus, @samp{dscalar(a)} is "
"``true'' only if @code{a} is provably scalar, and @samp{!dscalar(a)} is "
"``true'' only if @code{a} is provably non-scalar; both are ``false'' if "
"there is insufficient information to tell."
msgstr ""

#. type: node
#: ../../calc.texi:13062 ../../calc.texi:13927 ../../calc.texi:13928 ../../calc.texi:13980 ../../calc.texi:14082 ../../calc.texi:14157 ../../calc.texi:14577 ../../calc.texi:14653 ../../calc.texi:14683 ../../calc.texi:14708 ../../calc.texi:14733 ../../calc.texi:14756 ../../calc.texi:14790 ../../calc.texi:15399 ../../calc.texi:15806
#, no-wrap
msgid "Language Modes"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13072
msgid ""
"The commands in this section are two-key sequences beginning with the "
"@kbd{d} prefix.  The @kbd{d l} (@code{calc-line-numbering}) and @kbd{d b} "
"(@code{calc-line-breaking}) commands are described elsewhere; @pxref{Stack "
"Basics} and @pxref{Normal Language Modes}, respectively.  Display formats "
"for vectors and matrices are also covered elsewhere; @pxref{Vector and "
"Matrix Formats}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13078
msgid ""
"One thing all display modes have in common is their treatment of the @kbd{H} "
"prefix.  This prefix causes any mode command that would normally refresh the "
"stack to leave the stack display alone.  The word ``Dirty'' will appear in "
"the mode line when Calc thinks the stack display may not reflect the latest "
"mode settings."
msgstr ""

#. type: kindex
#: ../../calc.texi:13079
#, no-wrap
msgid "d RET"
msgstr ""

#. type: pindex
#: ../../calc.texi:13080
#, no-wrap
msgid "calc-refresh-top"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13088
msgid ""
"The @kbd{d @key{RET}} (@code{calc-refresh-top}) command reformats the top "
"stack entry according to all the current modes.  Positive prefix arguments "
"reformat the top @var{n} entries; negative prefix arguments reformat the "
"specified entry, and a prefix of zero is equivalent to @kbd{d @key{SPC}} "
"(@code{calc-refresh}), which reformats the entire stack.  For example, "
"@kbd{H d s M-2 d @key{RET}} changes to scientific notation but reformats "
"only the top two stack entries in the new mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13093
msgid ""
"The @kbd{I} prefix has another effect on the display modes.  The mode is set "
"only temporarily; the top stack entry is reformatted according to that mode, "
"then the original mode setting is restored.  In other words, @kbd{I d s} is "
"equivalent to @kbd{H d s d @key{RET} H d (@var{old mode})}."
msgstr ""

#. type: menuentry
#: ../../calc.texi:13105
msgid "Radix Modes::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13105
msgid "Grouping Digits::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13105
msgid "Float Formats::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13105
msgid "Complex Formats::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13105
msgid "Fraction Formats::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13105
msgid "HMS Formats::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13105
msgid "Date Formats::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13105
msgid "Truncating the Stack::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13105
msgid "Justification::"
msgstr ""

#. type: subsection
#: ../../calc.texi:13105 ../../calc.texi:13835 ../../calc.texi:13896 ../../calc.texi:13897
#, no-wrap
msgid "Labels"
msgstr ""

#. type: node
#: ../../calc.texi:13107 ../../calc.texi:13108 ../../calc.texi:13192
#, no-wrap
msgid "Radix Modes"
msgstr ""

#. type: node
#: ../../calc.texi:13107 ../../calc.texi:13192 ../../calc.texi:13193 ../../calc.texi:13230
#, no-wrap
msgid "Grouping Digits"
msgstr ""

#. type: cindex
#: ../../calc.texi:13111
#, no-wrap
msgid "Radix display"
msgstr ""

#. type: cindex
#: ../../calc.texi:13112
#, no-wrap
msgid "Non-decimal numbers"
msgstr ""

#. type: cindex
#: ../../calc.texi:13113
#, no-wrap
msgid "Decimal and non-decimal numbers"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13119
msgid ""
"Calc normally displays numbers in decimal (@dfn{base-10} or @dfn{radix-10})  "
"notation.  Calc can actually display in any radix from two (binary) to 36.  "
"When the radix is above 10, the letters @code{A} to @code{Z} are used as "
"digits.  When entering such a number, letter keys are interpreted as "
"potential digits rather than terminating numeric entry mode."
msgstr ""

#. type: kindex
#: ../../calc.texi:13120
#, no-wrap
msgid "d 2"
msgstr ""

#. type: kindex
#: ../../calc.texi:13121
#, no-wrap
msgid "d 8"
msgstr ""

#. type: kindex
#: ../../calc.texi:13122
#, no-wrap
msgid "d 6"
msgstr ""

#. type: kindex
#: ../../calc.texi:13123
#, no-wrap
msgid "d 0"
msgstr ""

#. type: cindex
#: ../../calc.texi:13124
#, no-wrap
msgid "Hexadecimal integers"
msgstr ""

#. type: cindex
#: ../../calc.texi:13125
#, no-wrap
msgid "Octal integers"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13132
msgid ""
"The key sequences @kbd{d 2}, @kbd{d 8}, @kbd{d 6}, and @kbd{d 0} select "
"binary, octal, hexadecimal, and decimal as the current display radix, "
"respectively.  Numbers can always be entered in any radix, though the "
"current radix is used as a default if you press @kbd{#} without any initial "
"digits.  A number entered without a @kbd{#} is @emph{always} interpreted as "
"decimal."
msgstr ""

#. type: kindex
#: ../../calc.texi:13133
#, no-wrap
msgid "d r"
msgstr ""

#. type: pindex
#: ../../calc.texi:13134
#, no-wrap
msgid "calc-radix"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13138
msgid ""
"To set the radix generally, use @kbd{d r} (@code{calc-radix}) and enter an "
"integer from 2 to 36.  You can specify the radix as a numeric prefix "
"argument; otherwise you will be prompted for it."
msgstr ""

#. type: kindex
#: ../../calc.texi:13139
#, no-wrap
msgid "d z"
msgstr ""

#. type: pindex
#: ../../calc.texi:13140
#, no-wrap
msgid "calc-leading-zeros"
msgstr ""

#. type: cindex
#: ../../calc.texi:13141
#, no-wrap
msgid "Leading zeros"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13152
msgid ""
"Integers normally are displayed with however many digits are necessary to "
"represent the integer and no more.  The @kbd{d z} "
"(@code{calc-leading-zeros})  command causes integers to be padded out with "
"leading zeros according to the current binary word size.  (@xref{Binary "
"Functions}, for a discussion of word size.)  If the absolute value of the "
"word size is @expr{w}, all integers are displayed with at least enough "
"digits to represent @texline @math{2^w-1} @infoline @expr{(2^w)-1} in the "
"current radix.  (Larger integers will still be displayed in their entirety.)"
msgstr ""

#. type: cindex
#: ../../calc.texi:13153
#, no-wrap
msgid "Two's complements"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13191
msgid ""
"Calc can display @expr{w}-bit integers using two's complement notation, "
"although this is most useful with the binary, octal and hexadecimal display "
"modes.  This option is selected by using the @kbd{O} option prefix before "
"setting the display radix, and a negative word size might be appropriate "
"(@pxref{Binary Functions}). In two's complement notation, the integers in "
"the (nearly) symmetric interval from @texline @math{-2^{w-1}} @infoline "
"@expr{-2^(w-1)} to @texline @math{2^{w-1}-1} @infoline @expr{2^(w-1)-1} are "
"represented by the integers from @expr{0} to @expr{2^w-1}: the integers from "
"@expr{0} to @texline @math{2^{w-1}-1} @infoline @expr{2^(w-1)-1} are "
"represented by themselves and the integers from @texline @math{-2^{w-1}} "
"@infoline @expr{-2^(w-1)} to @expr{-1} are represented by the integers from "
"@texline @math{2^{w-1}} @infoline @expr{2^(w-1)} to @expr{2^w-1} (the "
"integer @expr{k} is represented by @expr{k+2^w}).  Calc will display a two's "
"complement integer by the radix (either @expr{2}, @expr{8} or @expr{16}), "
"two @kbd{#} symbols, and then its representation (including any leading "
"zeros necessary to include all @expr{w} bits).  In a two's complement "
"display mode, numbers that are not displayed in two's complement notation "
"(i.e., that aren't integers from @texline @math{-2^{w-1}} @infoline "
"@expr{-2^(w-1)} to @texline @math{2^{w-1}-1})  @infoline @expr{2^(w-1)-1})  "
"will be represented using Calc's usual notation (in the appropriate radix)."
msgstr ""

#. type: node
#: ../../calc.texi:13192 ../../calc.texi:13230 ../../calc.texi:13231 ../../calc.texi:13296
#, no-wrap
msgid "Float Formats"
msgstr ""

#. type: kindex
#: ../../calc.texi:13196
#, no-wrap
msgid "d g"
msgstr ""

#. type: pindex
#: ../../calc.texi:13197
#, no-wrap
msgid "calc-group-digits"
msgstr ""

#. type: cindex
#: ../../calc.texi:13198
#, no-wrap
msgid "Grouping digits"
msgstr ""

#. type: cindex
#: ../../calc.texi:13199
#, no-wrap
msgid "Digit grouping"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13205
msgid ""
"Long numbers can be hard to read if they have too many digits.  For example, "
"the factorial of 30 is 33 digits long! Press @kbd{d g} "
"(@code{calc-group-digits}) to enable @dfn{Grouping} mode, in which digits "
"are displayed in clumps of 3 or 4 (depending on the current radix)  "
"separated by commas."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13213
msgid ""
"The @kbd{d g} command toggles grouping on and off.  With a numeric prefix of "
"0, this command displays the current state of the grouping flag; with an "
"argument of minus one it disables grouping; with a positive argument "
"@expr{N} it enables grouping on every @expr{N} digits.  For floating-point "
"numbers, grouping normally occurs only before the decimal point.  A negative "
"prefix argument @expr{-N} enables grouping every @expr{N} digits both before "
"and after the decimal point."
msgstr ""

#. type: kindex
#: ../../calc.texi:13214
#, no-wrap
msgid "d ,"
msgstr ""

#. type: pindex
#: ../../calc.texi:13215
#, no-wrap
msgid "calc-group-char"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13223
msgid ""
"The @kbd{d ,} (@code{calc-group-char}) command allows you to choose any "
"character as the grouping separator.  The default is the comma character.  "
"If you find it difficult to read vectors of large integers grouped with "
"commas, you may wish to use spaces or some other character instead.  This "
"command takes the next character you type, whatever it is, and uses it as "
"the digit separator.  As a special case, @kbd{d , \\} selects @samp{\\,} "
"(@TeX{}'s thin-space symbol) as the digit separator."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13229
msgid ""
"Please note that grouped numbers will not generally be parsed correctly if "
"re-read in textual form, say by the use of @kbd{C-x * y} and @kbd{C-x * g}.  "
"(@xref{Kill and Yank}, for details on these commands.)  One exception is the "
"@samp{\\,} separator, which doesn't interfere with parsing because it is "
"ignored by @TeX{} language mode."
msgstr ""

#. type: node
#: ../../calc.texi:13230 ../../calc.texi:13296 ../../calc.texi:13297 ../../calc.texi:13327
#, no-wrap
msgid "Complex Formats"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13239
msgid ""
"Floating-point quantities are normally displayed in standard decimal form, "
"with scientific notation used if the exponent is especially high or low.  "
"All significant digits are normally displayed.  The commands in this section "
"allow you to choose among several alternative display formats for floats."
msgstr ""

#. type: kindex
#: ../../calc.texi:13240
#, no-wrap
msgid "d n"
msgstr ""

#. type: pindex
#: ../../calc.texi:13241
#, no-wrap
msgid "calc-normal-notation"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13249
msgid ""
"The @kbd{d n} (@code{calc-normal-notation}) command selects the normal "
"display format.  All significant figures in a number are displayed.  With a "
"positive numeric prefix, numbers are rounded if necessary to that number of "
"significant digits.  With a negative numerix prefix, the specified number of "
"significant digits less than the current precision is used.  (Thus @kbd{C-u "
"-2 d n} displays 10 digits if the current precision is 12.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:13250
#, no-wrap
msgid "d f"
msgstr ""

#. type: pindex
#: ../../calc.texi:13251
#, no-wrap
msgid "calc-fix-notation"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13259
msgid ""
"The @kbd{d f} (@code{calc-fix-notation}) command selects fixed-point "
"notation.  The numeric argument is the number of digits after the decimal "
"point, zero or more.  This format will relax into scientific notation if a "
"nonzero number would otherwise have been rounded all the way to zero.  "
"Specifying a negative number of digits is the same as for a positive number, "
"except that small nonzero numbers will be rounded to zero rather than "
"switching to scientific notation."
msgstr ""

#. type: kindex
#: ../../calc.texi:13260
#, no-wrap
msgid "d s"
msgstr ""

#. type: pindex
#: ../../calc.texi:13261
#, no-wrap
msgid "calc-sci-notation"
msgstr ""

#. type: cindex
#: ../../calc.texi:13262
#, no-wrap
msgid "Scientific notation, display of"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13268
msgid ""
"The @kbd{d s} (@code{calc-sci-notation}) command selects scientific "
"notation.  A positive argument sets the number of significant figures "
"displayed, of which one will be before and the rest after the decimal "
"point.  A negative argument works the same as for @kbd{d n} format.  The "
"default is to display all significant digits."
msgstr ""

#. type: kindex
#: ../../calc.texi:13269
#, no-wrap
msgid "d e"
msgstr ""

#. type: pindex
#: ../../calc.texi:13270
#, no-wrap
msgid "calc-eng-notation"
msgstr ""

#. type: cindex
#: ../../calc.texi:13271
#, no-wrap
msgid "Engineering notation, display of"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13277
msgid ""
"The @kbd{d e} (@code{calc-eng-notation}) command selects engineering "
"notation.  This is similar to scientific notation except that the exponent "
"is rounded down to a multiple of three, with from one to three digits before "
"the decimal point.  An optional numeric prefix sets the number of "
"significant digits to display, as for @kbd{d s}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13287
msgid ""
"It is important to distinguish between the current @emph{precision} and the "
"current @emph{display format}.  After the commands @kbd{C-u 10 p} and "
"@kbd{C-u 6 d n} the Calculator computes all results to ten significant "
"figures but displays only six.  (In fact, intermediate calculations are "
"often carried to one or two more significant figures, but values placed on "
"the stack will be rounded down to ten figures.)  Numbers are never actually "
"rounded to the display precision for storage, except by commands like "
"@kbd{C-k} and @kbd{C-x * y} which operate on the actual displayed text in "
"the Calculator buffer."
msgstr ""

#. type: kindex
#: ../../calc.texi:13288
#, no-wrap
msgid "d ."
msgstr ""

#. type: pindex
#: ../../calc.texi:13289
#, no-wrap
msgid "calc-point-char"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13295
msgid ""
"The @kbd{d .} (@code{calc-point-char}) command selects the character used as "
"a decimal point.  Normally this is a period; users in some countries may "
"wish to change this to a comma.  Note that this is only a display style; on "
"entry, periods must always be used to denote floating-point numbers, and "
"commas to separate elements in a list."
msgstr ""

#. type: node
#: ../../calc.texi:13296 ../../calc.texi:13327 ../../calc.texi:13328 ../../calc.texi:13364
#, no-wrap
msgid "Fraction Formats"
msgstr ""

#. type: kindex
#: ../../calc.texi:13300
#, no-wrap
msgid "d c"
msgstr ""

#. type: pindex
#: ../../calc.texi:13301
#, no-wrap
msgid "calc-complex-notation"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13306
msgid ""
"There are three supported notations for complex numbers in rectangular "
"form.  The default is as a pair of real numbers enclosed in parentheses and "
"separated by a comma: @samp{(a,b)}.  The @kbd{d c} "
"(@code{calc-complex-notation}) command selects this style."
msgstr ""

#. type: kindex
#: ../../calc.texi:13307
#, no-wrap
msgid "d i"
msgstr ""

#. type: pindex
#: ../../calc.texi:13308
#, no-wrap
msgid "calc-i-notation"
msgstr ""

#. type: kindex
#: ../../calc.texi:13309
#, no-wrap
msgid "d j"
msgstr ""

#. type: pindex
#: ../../calc.texi:13310
#, no-wrap
msgid "calc-j-notation"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13315
msgid ""
"The other notations are @kbd{d i} (@code{calc-i-notation}), in which numbers "
"are displayed in @samp{a+bi} form, and @kbd{d j} (@code{calc-j-notation}) "
"which displays the form @samp{a+bj} preferred in some disciplines."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13326
msgid ""
"Complex numbers are normally entered in @samp{(a,b)} format.  If you enter "
"@samp{2+3i} as an algebraic formula, it will be stored as the formula "
"@samp{2 + 3 * i}.  However, if you use @kbd{=} to evaluate this formula and "
"you have not changed the variable @samp{i}, the @samp{i} will be interpreted "
"as @samp{(0,1)} and the formula will be simplified to @samp{(2,3)}.  Other "
"commands (like @code{calc-sin}) will @emph{not} interpret the formula "
"@samp{2 + 3 * i} as a complex number.  @xref{Variables}, under ``special "
"constants.''"
msgstr ""

#. type: node
#: ../../calc.texi:13327 ../../calc.texi:13364 ../../calc.texi:13365 ../../calc.texi:13391
#, no-wrap
msgid "HMS Formats"
msgstr ""

#. type: kindex
#: ../../calc.texi:13331
#, no-wrap
msgid "d o"
msgstr ""

#. type: pindex
#: ../../calc.texi:13332
#, no-wrap
msgid "calc-over-notation"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13341
msgid ""
"Display of fractional numbers is controlled by the @kbd{d o} "
"(@code{calc-over-notation}) command.  By default, a number like eight thirds "
"is displayed in the form @samp{8:3}.  The @kbd{d o} command prompts for a "
"one- or two-character format.  If you give one character, that character is "
"used as the fraction separator.  Common separators are @samp{:} and "
"@samp{/}.  (During input of numbers, the @kbd{:} key must be used regardless "
"of the display format; in particular, the @kbd{/} is used for RPN-style "
"division, @emph{not} for entering fractions.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13347
msgid ""
"If you give two characters, fractions use ``integer-plus-fractional-part'' "
"notation.  For example, the format @samp{+/} would display eight thirds as "
"@samp{2+2/3}.  If two colons are present in a number being entered, the "
"number is interpreted in this form (so that the entries @kbd{2:2:3} and "
"@kbd{8:3} are equivalent)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13359
msgid ""
"It is also possible to follow the one- or two-character format with a "
"number.  For example: @samp{:10} or @samp{+/3}.  In this case, Calc adjusts "
"all fractions that are displayed to have the specified denominator, if "
"possible.  Otherwise it adjusts the denominator to be a multiple of the "
"specified value.  For example, in @samp{:6} mode the fraction @expr{1:6} "
"will be unaffected, but @expr{2:3} will be displayed as @expr{4:6}, "
"@expr{1:2} will be displayed as @expr{3:6}, and @expr{1:8} will be displayed "
"as @expr{3:24}.  Integers are also affected by this mode: 3 is displayed as "
"@expr{18:6}.  Note that the format @samp{:1} writes fractions the same as "
"@samp{:}, but it writes integers as @expr{n:1}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13363
msgid ""
"The fraction format does not affect the way fractions or integers are "
"stored, only the way they appear on the screen.  The fraction format never "
"affects floats."
msgstr ""

#. type: node
#: ../../calc.texi:13364 ../../calc.texi:13391 ../../calc.texi:13392 ../../calc.texi:13422 ../../calc.texi:13500 ../../calc.texi:13691 ../../calc.texi:13757 ../../calc.texi:13800
#, no-wrap
msgid "Date Formats"
msgstr ""

#. type: kindex
#: ../../calc.texi:13368
#, no-wrap
msgid "d h"
msgstr ""

#. type: pindex
#: ../../calc.texi:13369
#, no-wrap
msgid "calc-hms-notation"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13377
msgid ""
"The @kbd{d h} (@code{calc-hms-notation}) command controls the display of HMS "
"(hours-minutes-seconds) forms.  It prompts for a string which consists "
"basically of an ``hours'' marker, optional punctuation, a ``minutes'' "
"marker, more optional punctuation, and a ``seconds'' marker.  Punctuation is "
"zero or more spaces, commas, or semicolons.  The hours marker is one or more "
"non-punctuation characters.  The minutes and seconds markers must be single "
"non-punctuation characters."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13390
msgid ""
"The default HMS format is @samp{@@ ' \"}, producing HMS values of the form "
"@samp{23@@ 30' 15.75\"}.  The format @samp{deg, ms} would display this same "
"value as @samp{23deg, 30m15.75s}.  During numeric entry, the @kbd{h} or "
"@kbd{o} keys are recognized as synonyms for @kbd{@@} regardless of display "
"format.  The @kbd{m} and @kbd{s} keys are recognized as synonyms for @kbd{'} "
"and @kbd{\"}, respectively, but only if an @kbd{@@} (or @kbd{h} or @kbd{o}) "
"has already been typed; otherwise, they have their usual meanings (@kbd{m-} "
"prefix and @kbd{s-} prefix).  Thus, @kbd{5 \"}, @kbd{0 @@ 5 \"}, and @kbd{0 "
"h 5 s} are some of the ways to enter the quantity ``five seconds.'' The "
"@kbd{'} key is recognized as ``minutes'' only if @kbd{@@} (or @kbd{h} or "
"@kbd{o}) has already been pressed; otherwise it means to switch to algebraic "
"entry."
msgstr ""

#. type: node
#: ../../calc.texi:13391 ../../calc.texi:13800 ../../calc.texi:13801 ../../calc.texi:13835
#, no-wrap
msgid "Truncating the Stack"
msgstr ""

#. type: kindex
#: ../../calc.texi:13395
#, no-wrap
msgid "d d"
msgstr ""

#. type: pindex
#: ../../calc.texi:13396
#, no-wrap
msgid "calc-date-notation"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13405
msgid ""
"The @kbd{d d} (@code{calc-date-notation}) command controls the display of "
"date forms (@pxref{Date Forms}).  It prompts for a string which contains "
"letters that represent the various parts of a date and time.  To show which "
"parts should be omitted when the form represents a pure date with no time, "
"parts of the string can be enclosed in @samp{< >} marks.  If you don't "
"include @samp{< >} markers in the format, Calc guesses at which parts, if "
"any, should be omitted when formatting pure dates."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13410
msgid ""
"The default format is: @samp{<H:mm:SSpp >Www Mmm D, YYYY}.  An example "
"string in this format is @samp{3:32pm Wed Jan 9, 1991}.  If you enter a "
"blank format string, this default format is reestablished."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13414
msgid ""
"Calc uses @samp{< >} notation for nameless functions as well as for dates.  "
"@xref{Specifying Operators}.  To avoid confusion with nameless functions, "
"your date formats should avoid using the @samp{#} character."
msgstr ""

#. type: menuentry
#: ../../calc.texi:13420
msgid "ISO 8601::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13420
msgid "Date Formatting Codes::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13420
msgid "Free-Form Dates::"
msgstr ""

#. type: subsubsection
#: ../../calc.texi:13420 ../../calc.texi:13691 ../../calc.texi:13757 ../../calc.texi:13758
#, no-wrap
msgid "Standard Date Formats"
msgstr ""

#. type: node
#: ../../calc.texi:13422 ../../calc.texi:13423 ../../calc.texi:13426 ../../calc.texi:13500
#, no-wrap
msgid "ISO 8601"
msgstr ""

#. type: node
#: ../../calc.texi:13422 ../../calc.texi:13500 ../../calc.texi:13501 ../../calc.texi:13691
#, no-wrap
msgid "Date Formatting Codes"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13435
msgid ""
"The same date can be written down in different formats and Calc tries to "
"allow you to choose your preferred format.  Some common formats are "
"ambiguous, however; for example, 10/11/2012 means October 11, 2012 in the "
"United States but it means November 10, 2012 in Europe.  To help avoid such "
"ambiguities, the International Organization for Standardization (ISO) "
"provides the ISO 8601 standard, which provides three different but easily "
"distinguishable and unambiguous ways to represent a date."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13437
msgid "The ISO 8601 calendar date representation is"
msgstr ""

#. type: example
#: ../../calc.texi:13440
#, no-wrap
msgid "   @var{YYYY}-@var{MM}-@var{DD}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13452
msgid ""
"where @var{YYYY} is the four digit year, @var{MM} is the two-digit month "
"number (01 for January to 12 for December), and @var{DD} is the two-digit "
"day of the month (01 to 31).  (Note that @var{YYYY} does not correspond to "
"Calc's date formatting code, which will be introduced later.)  The year, "
"which should be padded with zeros to ensure it has at least four digits, is "
"the Gregorian year, except that the year before 0001 (1 AD) is the year 0000 "
"(1 BC).  The date October 11, 2012 is written 2012-10-11 in this "
"representation and November 10, 2012 is written 2012-11-10."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13454
msgid "The ISO 8601 ordinal date representation is"
msgstr ""

#. type: example
#: ../../calc.texi:13457
#, no-wrap
msgid "  @var{YYYY}-@var{DDD}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13463
msgid ""
"where @var{YYYY} is the year, as above, and @var{DDD} is the day of the "
"year.  The date December 31, 2011 is written 2011-365 in this representation "
"and January 1, 2012 is written 2012-001."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13465
msgid "The ISO 8601 week date representation is"
msgstr ""

#. type: example
#: ../../calc.texi:13468
#, no-wrap
msgid " @var{YYYY}-W@var{ww}-@var{D}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13485
msgid ""
"where @var{YYYY} is the ISO week-numbering year, @var{ww} is the two digit "
"week number (preceded by a literal ``W''), and @var{D} is the day of the "
"week (1 for Monday through 7 for Sunday).  The ISO week-numbering year is "
"based on the Gregorian year but can differ slightly.  The first week of an "
"ISO week-numbering year is the week with the Gregorian year's first Thursday "
"in it (equivalently, the week containing January 4); any day of that week "
"(Monday through Sunday) is part of the same ISO week-numbering year, any day "
"from the previous week is part of the previous year.  For example, January "
"4, 2013 is on a Friday, and so the first week for the ISO week-numbering "
"year 2013 starts on Monday, December 31, 2012.  The day December 31, 2012 is "
"then part of the Gregorian year 2012 but ISO week-numbering year 2013.  In "
"the week date representation, this week goes from 2013-W01-1 (December 31, "
"2012) to 2013-W01-7 (January 6, 2013)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13491
msgid ""
"All three ISO 8601 representations arrange the numbers from most significant "
"to least significant; as well as being unambiguous representations, they are "
"easy to sort since chronological order in this formats corresponds to "
"lexicographical order. The hyphens are sometimes omitted."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13499
msgid ""
"The ISO 8601 standard uses a 24 hour clock; a particular time is represented "
"by @var{hh}:@var{mm}:@var{ss} where @var{hh} is the two-digit hour (from 00 "
"to 24), @var{mm} is the two-digit minute (from 00 to 59) and @var{ss} is the "
"two-digit second.  The seconds or minutes and seconds can be omitted, and "
"decimals can be added.  If a date with a time is represented, they should be "
"separated by a literal ``T'', so noon on December 13, 2012 can be "
"represented as 2012-12-13T12:00."
msgstr ""

#. type: node
#: ../../calc.texi:13500 ../../calc.texi:13691 ../../calc.texi:13692 ../../calc.texi:13757
#, no-wrap
msgid "Free-Form Dates"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13510
msgid ""
"When displaying a date, the current date format is used.  All characters "
"except for letters and @samp{<} and @samp{>} are copied literally when dates "
"are formatted.  The portion between @samp{< >} markers is omitted for pure "
"dates, or included for date/time forms.  Letters are interpreted according "
"to the table below."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13519
msgid ""
"When dates are read in during algebraic entry, Calc first tries to match the "
"input string to the current format either with or without the time part.  "
"The punctuation characters (including spaces) must match exactly; letter "
"fields must correspond to suitable text in the input.  If this doesn't work, "
"Calc checks if the input is a simple number; if so, the number is "
"interpreted as a number of days since Dec 31, 1 BC@.  Otherwise, Calc tries "
"a much more relaxed and flexible algorithm which is described in the next "
"section."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13521
msgid "Weekday names are ignored during reading."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13527
msgid ""
"Two-digit year numbers are interpreted as lying in the range from 1941 to "
"2039.  Years outside that range are always entered and displayed in full.  "
"Year numbers with a leading @samp{+} sign are always interpreted exactly, "
"allowing the entry and display of the years 1 through 99 AD."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13529
msgid "Here is a complete list of the formatting codes for dates:"
msgstr ""

#. type: table
#: ../../calc.texi:13533
msgid "Year: ``91'' for 1991, ``7'' for 2007, ``+23'' for 23 AD."
msgstr ""

#. type: item
#: ../../calc.texi:13533
#, no-wrap
msgid "YY"
msgstr ""

#. type: table
#: ../../calc.texi:13535
msgid "Year: ``91'' for 1991, ``07'' for 2007, ``+23'' for 23 AD."
msgstr ""

#. type: item
#: ../../calc.texi:13535
#, no-wrap
msgid "BY"
msgstr ""

#. type: table
#: ../../calc.texi:13537
msgid "Year: ``91'' for 1991, `` 7'' for 2007, ``+23'' for 23 AD."
msgstr ""

#. type: item
#: ../../calc.texi:13537
#, no-wrap
msgid "YYY"
msgstr ""

#. type: table
#: ../../calc.texi:13539
msgid "Year: ``1991'' for 1991, ``23'' for 23 AD."
msgstr ""

#. type: item
#: ../../calc.texi:13539
#, no-wrap
msgid "YYYY"
msgstr ""

#. type: table
#: ../../calc.texi:13541
msgid "Year: ``1991'' for 1991, ``+23'' for 23 AD."
msgstr ""

#. type: item
#: ../../calc.texi:13541
#, no-wrap
msgid "ZYYY"
msgstr ""

#. type: table
#: ../../calc.texi:13543
msgid "Year: ``1991'' for 1991, ``0023'' for 23 AD, ``0000'' for 1 BC."
msgstr ""

#. type: item
#: ../../calc.texi:13543
#, no-wrap
msgid "IYYY"
msgstr ""

#. type: table
#: ../../calc.texi:13545
msgid "Year: ISO 8601 week-numbering year."
msgstr ""

#. type: item
#: ../../calc.texi:13545
#, no-wrap
msgid "aa"
msgstr ""

#. type: table
#: ../../calc.texi:13547
msgid "Year: ``ad'' or blank."
msgstr ""

#. type: item
#: ../../calc.texi:13547
#, no-wrap
msgid "AA"
msgstr ""

#. type: table
#: ../../calc.texi:13549
msgid "Year: ``AD'' or blank."
msgstr ""

#. type: item
#: ../../calc.texi:13549
#, no-wrap
msgid "aaa"
msgstr ""

#. type: table
#: ../../calc.texi:13551
msgid "Year: ``ad '' or blank.  (Note trailing space.)"
msgstr ""

#. type: item
#: ../../calc.texi:13551
#, no-wrap
msgid "AAA"
msgstr ""

#. type: table
#: ../../calc.texi:13553
msgid "Year: ``AD '' or blank."
msgstr ""

#. type: item
#: ../../calc.texi:13553
#, no-wrap
msgid "aaaa"
msgstr ""

#. type: table
#: ../../calc.texi:13555
msgid "Year: ``a.d.@:'' or blank."
msgstr ""

#. type: item
#: ../../calc.texi:13555
#, no-wrap
msgid "AAAA"
msgstr ""

#. type: table
#: ../../calc.texi:13557
msgid "Year: ``A.D.'' or blank."
msgstr ""

#. type: item
#: ../../calc.texi:13557
#, no-wrap
msgid "bb"
msgstr ""

#. type: table
#: ../../calc.texi:13559
msgid "Year: ``bc'' or blank."
msgstr ""

#. type: item
#: ../../calc.texi:13559
#, no-wrap
msgid "BB"
msgstr ""

#. type: table
#: ../../calc.texi:13561
msgid "Year: ``BC'' or blank."
msgstr ""

#. type: item
#: ../../calc.texi:13561
#, no-wrap
msgid "bbb"
msgstr ""

#. type: table
#: ../../calc.texi:13563
msgid "Year: `` bc'' or blank.  (Note leading space.)"
msgstr ""

#. type: item
#: ../../calc.texi:13563
#, no-wrap
msgid "BBB"
msgstr ""

#. type: table
#: ../../calc.texi:13565
msgid "Year: `` BC'' or blank."
msgstr ""

#. type: item
#: ../../calc.texi:13565
#, no-wrap
msgid "bbbb"
msgstr ""

#. type: table
#: ../../calc.texi:13567
msgid "Year: ``b.c.@:'' or blank."
msgstr ""

#. type: item
#: ../../calc.texi:13567
#, no-wrap
msgid "BBBB"
msgstr ""

#. type: table
#: ../../calc.texi:13569
msgid "Year: ``B.C.'' or blank."
msgstr ""

#. type: table
#: ../../calc.texi:13571
msgid "Month: ``8'' for August."
msgstr ""

#. type: item
#: ../../calc.texi:13571
#, no-wrap
msgid "MM"
msgstr ""

#. type: table
#: ../../calc.texi:13573
msgid "Month: ``08'' for August."
msgstr ""

#. type: item
#: ../../calc.texi:13573
#, no-wrap
msgid "BM"
msgstr ""

#. type: table
#: ../../calc.texi:13575
msgid "Month: `` 8'' for August."
msgstr ""

#. type: item
#: ../../calc.texi:13575
#, no-wrap
msgid "MMM"
msgstr ""

#. type: table
#: ../../calc.texi:13577
msgid "Month: ``AUG'' for August."
msgstr ""

#. type: item
#: ../../calc.texi:13577
#, no-wrap
msgid "Mmm"
msgstr ""

#. type: table
#: ../../calc.texi:13579
msgid "Month: ``Aug'' for August."
msgstr ""

#. type: item
#: ../../calc.texi:13579
#, no-wrap
msgid "mmm"
msgstr ""

#. type: table
#: ../../calc.texi:13581
msgid "Month: ``aug'' for August."
msgstr ""

#. type: item
#: ../../calc.texi:13581
#, no-wrap
msgid "MMMM"
msgstr ""

#. type: table
#: ../../calc.texi:13583
msgid "Month: ``AUGUST'' for August."
msgstr ""

#. type: item
#: ../../calc.texi:13583
#, no-wrap
msgid "Mmmm"
msgstr ""

#. type: table
#: ../../calc.texi:13585
msgid "Month: ``August'' for August."
msgstr ""

#. type: table
#: ../../calc.texi:13587
msgid "Day: ``7'' for 7th day of month."
msgstr ""

#. type: item
#: ../../calc.texi:13587
#, no-wrap
msgid "DD"
msgstr ""

#. type: table
#: ../../calc.texi:13589
msgid "Day: ``07'' for 7th day of month."
msgstr ""

#. type: item
#: ../../calc.texi:13589
#, no-wrap
msgid "BD"
msgstr ""

#. type: table
#: ../../calc.texi:13591
msgid "Day: `` 7'' for 7th day of month."
msgstr ""

#. type: table
#: ../../calc.texi:13593
msgid "Weekday: ``0'' for Sunday, ``6'' for Saturday."
msgstr ""

#. type: table
#: ../../calc.texi:13595
msgid "Weekday: ``1'' for Monday, ``7'' for Sunday."
msgstr ""

#. type: item
#: ../../calc.texi:13595
#, no-wrap
msgid "WWW"
msgstr ""

#. type: table
#: ../../calc.texi:13597
msgid "Weekday: ``SUN'' for Sunday."
msgstr ""

#. type: item
#: ../../calc.texi:13597
#, no-wrap
msgid "Www"
msgstr ""

#. type: table
#: ../../calc.texi:13599
msgid "Weekday: ``Sun'' for Sunday."
msgstr ""

#. type: item
#: ../../calc.texi:13599
#, no-wrap
msgid "www"
msgstr ""

#. type: table
#: ../../calc.texi:13601
msgid "Weekday: ``sun'' for Sunday."
msgstr ""

#. type: item
#: ../../calc.texi:13601
#, no-wrap
msgid "WWWW"
msgstr ""

#. type: table
#: ../../calc.texi:13603
msgid "Weekday: ``SUNDAY'' for Sunday."
msgstr ""

#. type: item
#: ../../calc.texi:13603
#, no-wrap
msgid "Wwww"
msgstr ""

#. type: table
#: ../../calc.texi:13605
msgid "Weekday: ``Sunday'' for Sunday."
msgstr ""

#. type: item
#: ../../calc.texi:13605
#, no-wrap
msgid "Iww"
msgstr ""

#. type: table
#: ../../calc.texi:13607
msgid "Week number: ISO 8601 week number, ``W01'' for week 1."
msgstr ""

#. type: item
#: ../../calc.texi:13607
#, no-wrap
msgid "d"
msgstr ""

#. type: table
#: ../../calc.texi:13609
msgid "Day of year: ``34'' for Feb.@: 3."
msgstr ""

#. type: item
#: ../../calc.texi:13609
#, no-wrap
msgid "ddd"
msgstr ""

#. type: table
#: ../../calc.texi:13611
msgid "Day of year: ``034'' for Feb.@: 3."
msgstr ""

#. type: item
#: ../../calc.texi:13611
#, no-wrap
msgid "bdd"
msgstr ""

#. type: table
#: ../../calc.texi:13613
msgid "Day of year: `` 34'' for Feb.@: 3."
msgstr ""

#. type: table
#: ../../calc.texi:13615
msgid "Letter: Literal ``T''."
msgstr ""

#. type: item
#: ../../calc.texi:13615
#, no-wrap
msgid "h"
msgstr ""

#. type: table
#: ../../calc.texi:13617
msgid "Hour: ``5'' for 5 AM; ``17'' for 5 PM."
msgstr ""

#. type: item
#: ../../calc.texi:13617
#, no-wrap
msgid "hh"
msgstr ""

#. type: table
#: ../../calc.texi:13619
msgid "Hour: ``05'' for 5 AM; ``17'' for 5 PM."
msgstr ""

#. type: item
#: ../../calc.texi:13619
#, no-wrap
msgid "bh"
msgstr ""

#. type: table
#: ../../calc.texi:13621
msgid "Hour: `` 5'' for 5 AM; ``17'' for 5 PM."
msgstr ""

#. type: table
#: ../../calc.texi:13623
msgid "Hour: ``5'' for 5 AM and 5 PM."
msgstr ""

#. type: item
#: ../../calc.texi:13623
#, no-wrap
msgid "HH"
msgstr ""

#. type: table
#: ../../calc.texi:13625
msgid "Hour: ``05'' for 5 AM and 5 PM."
msgstr ""

#. type: item
#: ../../calc.texi:13625
#, no-wrap
msgid "BH"
msgstr ""

#. type: table
#: ../../calc.texi:13627
msgid "Hour: `` 5'' for 5 AM and 5 PM."
msgstr ""

#. type: table
#: ../../calc.texi:13629
msgid "AM/PM: ``a'' or ``p''."
msgstr ""

#. type: table
#: ../../calc.texi:13631
msgid "AM/PM: ``A'' or ``P''."
msgstr ""

#. type: item
#: ../../calc.texi:13631
#, no-wrap
msgid "pp"
msgstr ""

#. type: table
#: ../../calc.texi:13633
msgid "AM/PM: ``am'' or ``pm''."
msgstr ""

#. type: item
#: ../../calc.texi:13633
#, no-wrap
msgid "PP"
msgstr ""

#. type: table
#: ../../calc.texi:13635
msgid "AM/PM: ``AM'' or ``PM''."
msgstr ""

#. type: item
#: ../../calc.texi:13635
#, no-wrap
msgid "pppp"
msgstr ""

#. type: table
#: ../../calc.texi:13637
msgid "AM/PM: ``a.m.@:'' or ``p.m.''."
msgstr ""

#. type: item
#: ../../calc.texi:13637
#, no-wrap
msgid "PPPP"
msgstr ""

#. type: table
#: ../../calc.texi:13639
msgid "AM/PM: ``A.M.'' or ``P.M.''."
msgstr ""

#. type: item
#: ../../calc.texi:13639
#, no-wrap
msgid "m"
msgstr ""

#. type: table
#: ../../calc.texi:13641
msgid "Minutes: ``7'' for 7."
msgstr ""

#. type: item
#: ../../calc.texi:13641
#, no-wrap
msgid "mm"
msgstr ""

#. type: table
#: ../../calc.texi:13643
msgid "Minutes: ``07'' for 7."
msgstr ""

#. type: item
#: ../../calc.texi:13643
#, no-wrap
msgid "bm"
msgstr ""

#. type: table
#: ../../calc.texi:13645
msgid "Minutes: `` 7'' for 7."
msgstr ""

#. type: item
#: ../../calc.texi:13645 ../../calc.texi:24853
#, no-wrap
msgid "s"
msgstr ""

#. type: table
#: ../../calc.texi:13647
msgid "Seconds: ``7'' for 7; ``7.23'' for 7.23."
msgstr ""

#. type: item
#: ../../calc.texi:13647
#, no-wrap
msgid "ss"
msgstr ""

#. type: table
#: ../../calc.texi:13649
msgid "Seconds: ``07'' for 7; ``07.23'' for 7.23."
msgstr ""

#. type: item
#: ../../calc.texi:13649
#, no-wrap
msgid "bs"
msgstr ""

#. type: table
#: ../../calc.texi:13651
msgid "Seconds: `` 7'' for 7; `` 7.23'' for 7.23."
msgstr ""

#. type: item
#: ../../calc.texi:13651
#, no-wrap
msgid "SS"
msgstr ""

#. type: table
#: ../../calc.texi:13653
msgid "Optional seconds: ``07'' for 7; blank for 0."
msgstr ""

#. type: item
#: ../../calc.texi:13653
#, no-wrap
msgid "BS"
msgstr ""

#. type: table
#: ../../calc.texi:13655
msgid "Optional seconds: `` 7'' for 7; blank for 0."
msgstr ""

#. type: table
#: ../../calc.texi:13657
msgid "Numeric date/time: ``726842.25'' for 6:00am Wed Jan 9, 1991."
msgstr ""

#. type: kindex
#: ../../calc.texi:13657 ../../calc.texi:16373
#, no-wrap
msgid "n"
msgstr ""

#. type: table
#: ../../calc.texi:13659
msgid "Numeric date: ``726842'' for any time on Wed Jan 9, 1991."
msgstr ""

#. type: table
#: ../../calc.texi:13661
msgid "Julian date/time: ``2448265.75'' for 6:00am Wed Jan 9, 1991."
msgstr ""

#. type: item
#: ../../calc.texi:13661
#, no-wrap
msgid "j"
msgstr ""

#. type: table
#: ../../calc.texi:13663
msgid "Julian date: ``2448266'' for any time on Wed Jan 9, 1991."
msgstr ""

#. type: table
#: ../../calc.texi:13665
msgid "Unix time: ``663400800'' for 6:00am Wed Jan 9, 1991."
msgstr ""

#. type: table
#: ../../calc.texi:13670
msgid ""
"Brackets suppression.  An ``X'' at the front of the format causes the "
"surrounding @w{@samp{< >}} delimiters to be omitted when formatting dates.  "
"Note that the brackets are still required for algebraic entry."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13674
msgid ""
"If ``SS'' or ``BS'' (optional seconds) is preceded by a colon, the colon is "
"also omitted if the seconds part is zero."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13680
msgid ""
"If ``bb,'' ``bbb'' or ``bbbb'' or their upper-case equivalents appear in the "
"format, then negative year numbers are displayed without a minus sign.  Note "
"that ``aa'' and ``bb'' are mutually exclusive.  Some typical usages would be "
"@samp{YYYY AABB}; @samp{AAAYYYYBBB}; @samp{YYYYBBB}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13686
msgid ""
"The formats ``YY,'' ``YYYY,'' ``MM,'' ``DD,'' ``ddd,'' ``hh,'' ``HH,'' "
"``mm,'' ``ss,'' and ``SS'' actually match any number of digits during "
"reading unless several of these codes are strung together with no "
"punctuation in between, in which case the input must have exactly as many "
"digits as there are letters in the format."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13690
msgid ""
"The ``j,'' ``J,'' and ``U'' formats do not make any time zone adjustment.  "
"They effectively use @samp{julian(x,0)} and @samp{unixtime(x,0)} to make the "
"conversion; @pxref{Date Arithmetic}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13700
msgid ""
"When reading a date form during algebraic entry, Calc falls back on the "
"algorithm described here if the input does not exactly match the current "
"date format.  This algorithm generally ``does the right thing'' and you "
"don't have to worry about it, but it is described here in full detail for "
"the curious."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13703
msgid ""
"Calc does not distinguish between upper- and lower-case letters while "
"interpreting dates."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13707
msgid ""
"First, the time portion, if present, is located somewhere in the text and "
"then removed.  The remaining text is then interpreted as the date."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13719
msgid ""
"A time is of the form @samp{hh:mm:ss}, possibly with the seconds part "
"omitted and possibly with an AM/PM indicator added to indicate 12-hour "
"time.  If the AM/PM is present, the minutes may also be omitted.  The AM/PM "
"part may be any of the words @samp{am}, @samp{pm}, @samp{noon}, or "
"@samp{midnight}; each of these may be abbreviated to one letter, and the "
"alternate forms @samp{a.m.}, @samp{p.m.}, and @samp{mid} are also "
"understood.  Obviously @samp{noon} and @samp{midnight} are allowed only on "
"12:00:00.  The words @samp{noon}, @samp{mid}, and @samp{midnight} are also "
"recognized with no number attached.  Midnight will represent the beginning "
"of a day."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13722
msgid "If there is no AM/PM indicator, the time is interpreted in 24-hour format."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13733
msgid ""
"When reading the date portion, Calc first checks to see if it is an ISO 8601 "
"week-numbering date; if the string contains an integer representing the "
"year, a ``W'' followed by two digits for the week number, and an integer "
"from 1 to 7 representing the weekday (in that order), then all other "
"characters are ignored and this information determines the date.  Otherwise, "
"all words and numbers are isolated from the string; other characters are "
"ignored.  All words must be either month names or day-of-week names (the "
"latter of which are ignored). Names can be written in full or as "
"three-letter abbreviations."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13741
msgid ""
"Large numbers, or numbers with @samp{+} or @samp{-} signs, are interpreted "
"as years.  If one of the other numbers is greater than 12, then that must be "
"the day and the remaining number in the input is therefore the month.  "
"Otherwise, Calc assumes the month, day and year are in the same order that "
"they appear in the current date format.  If the year is omitted, the current "
"year is taken from the system clock."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13744
msgid ""
"If there are too many or too few numbers, or any unrecognizable words, then "
"the input is rejected."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13749
msgid ""
"If there are any large numbers (of five digits or more) other than the year, "
"they are ignored on the assumption that they are something like Julian dates "
"that were included along with the traditional date components when the date "
"was formatted."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13753
msgid ""
"One of the words @samp{ad}, @samp{a.d.}, @samp{bc}, or @samp{b.c.} may "
"optionally be used; the latter two are equivalent to a minus sign on the "
"year value."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13756
msgid ""
"If you always enter a four-digit year, and use a name instead of a number "
"for the month, there is no danger of ambiguity."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13765
msgid ""
"There are actually ten standard date formats, numbered 0 through 9.  "
"Entering a blank line at the @kbd{d d} command's prompt gives you format "
"number 1, Calc's usual format.  You can enter any digit to select the other "
"formats."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13772
msgid ""
"To create your own standard date formats, give a numeric prefix argument "
"from 0 to 9 to the @w{@kbd{d d}} command.  The format you enter will be "
"recorded as the new standard format of that number, as well as becoming the "
"new current date format.  You can save your formats permanently with the "
"@w{@kbd{m m}} command (@pxref{Mode Settings})."
msgstr ""

#. type: table
#: ../../calc.texi:13776
msgid "@samp{N} (Numerical format)"
msgstr ""

#. type: item
#: ../../calc.texi:13776 ../../calc.texi:24827
#, no-wrap
msgid "1"
msgstr ""

#. type: table
#: ../../calc.texi:13778
msgid "@samp{<H:mm:SSpp >Www Mmm D, YYYY} (American format)"
msgstr ""

#. type: item
#: ../../calc.texi:13778
#, no-wrap
msgid "2"
msgstr ""

#. type: table
#: ../../calc.texi:13780
msgid "@samp{D Mmm YYYY<, h:mm:SS>} (European format)"
msgstr ""

#. type: item
#: ../../calc.texi:13780
#, no-wrap
msgid "3"
msgstr ""

#. type: table
#: ../../calc.texi:13782
msgid "@samp{Www Mmm BD< hh:mm:ss> YYYY} (Unix written date format)"
msgstr ""

#. type: item
#: ../../calc.texi:13782
#, no-wrap
msgid "4"
msgstr ""

#. type: table
#: ../../calc.texi:13784
msgid "@samp{M/D/Y< H:mm:SSpp>} (American slashed format)"
msgstr ""

#. type: item
#: ../../calc.texi:13784
#, no-wrap
msgid "5"
msgstr ""

#. type: table
#: ../../calc.texi:13786
msgid "@samp{D.M.Y< h:mm:SS>} (European dotted format)"
msgstr ""

#. type: item
#: ../../calc.texi:13786
#, no-wrap
msgid "6"
msgstr ""

#. type: table
#: ../../calc.texi:13788
msgid "@samp{M-D-Y< H:mm:SSpp>} (American dashed format)"
msgstr ""

#. type: item
#: ../../calc.texi:13788
#, no-wrap
msgid "7"
msgstr ""

#. type: table
#: ../../calc.texi:13790
msgid "@samp{D-M-Y< h:mm:SS>} (European dashed format)"
msgstr ""

#. type: item
#: ../../calc.texi:13790
#, no-wrap
msgid "8"
msgstr ""

#. type: table
#: ../../calc.texi:13792
msgid "@samp{j<, h:mm:ss>} (Julian day plus time)"
msgstr ""

#. type: item
#: ../../calc.texi:13792
#, no-wrap
msgid "9"
msgstr ""

#. type: table
#: ../../calc.texi:13794
msgid "@samp{YYddd< hh:mm:ss>} (Year-day format)"
msgstr ""

#. type: item
#: ../../calc.texi:13794
#, no-wrap
msgid "10"
msgstr ""

#. type: table
#: ../../calc.texi:13796
msgid "@samp{ZYYY-MM-DD Www< hh:mm>} (Org mode format)"
msgstr ""

#. type: item
#: ../../calc.texi:13796
#, no-wrap
msgid "11"
msgstr ""

#. type: table
#: ../../calc.texi:13798
msgid "@samp{IYYY-Iww-w<Thh:mm:ss>} (ISO 8601 week numbering format)"
msgstr ""

#. type: node
#: ../../calc.texi:13800 ../../calc.texi:13835 ../../calc.texi:13836 ../../calc.texi:13896
#, no-wrap
msgid "Justification"
msgstr ""

#. type: kindex
#: ../../calc.texi:13804
#, no-wrap
msgid "d t"
msgstr ""

#. type: pindex
#: ../../calc.texi:13805
#, no-wrap
msgid "calc-truncate-stack"
msgstr ""

#. type: cindex
#: ../../calc.texi:13806
#, no-wrap
msgid "Truncating the stack"
msgstr ""

#. type: cindex
#: ../../calc.texi:13807
#, no-wrap
msgid "Narrowing the stack"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13818
msgid ""
"The @kbd{d t} (@code{calc-truncate-stack}) command moves the @samp{.}@: line "
"that marks the top-of-stack up or down in the Calculator buffer.  The number "
"right above that line is considered to the be at the top of the stack.  Any "
"numbers below that line are ``hidden'' from all stack operations (although "
"still visible to the user).  This is similar to the Emacs ``narrowing'' "
"feature, except that the values below the @samp{.} are @emph{visible}, just "
"temporarily frozen.  This feature allows you to keep several independent "
"calculations running at once in different parts of the stack, or to apply a "
"certain command to an element buried deep in the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13826
msgid ""
"Pressing @kbd{d t} by itself moves the @samp{.} to the line the cursor is "
"on.  Thus, this line and all those below it become hidden.  To un-hide these "
"lines, move down to the end of the buffer and press @w{@kbd{d t}}.  With a "
"positive numeric prefix argument @expr{n}, @kbd{d t} hides the bottom "
"@expr{n} values in the buffer.  With a negative argument, it hides all but "
"the top @expr{n} values.  With an argument of zero, it hides zero values, "
"i.e., moves the @samp{.} all the way down to the bottom."
msgstr ""

#. type: kindex
#: ../../calc.texi:13827
#, no-wrap
msgid "d ["
msgstr ""

#. type: pindex
#: ../../calc.texi:13828
#, no-wrap
msgid "calc-truncate-up"
msgstr ""

#. type: kindex
#: ../../calc.texi:13829
#, no-wrap
msgid "d ]"
msgstr ""

#. type: pindex
#: ../../calc.texi:13830
#, no-wrap
msgid "calc-truncate-down"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13834
msgid ""
"The @kbd{d [} (@code{calc-truncate-up}) and @kbd{d ]} "
"(@code{calc-truncate-down}) commands move the @samp{.} up or down one line "
"at a time (or several lines with a prefix argument)."
msgstr ""

#. type: kindex
#: ../../calc.texi:13839
#, no-wrap
msgid "d <"
msgstr ""

#. type: pindex
#: ../../calc.texi:13840
#, no-wrap
msgid "calc-left-justify"
msgstr ""

#. type: kindex
#: ../../calc.texi:13841
#, no-wrap
msgid "d ="
msgstr ""

#. type: pindex
#: ../../calc.texi:13842
#, no-wrap
msgid "calc-center-justify"
msgstr ""

#. type: kindex
#: ../../calc.texi:13843
#, no-wrap
msgid "d >"
msgstr ""

#. type: pindex
#: ../../calc.texi:13844
#, no-wrap
msgid "calc-right-justify"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13851
msgid ""
"Values on the stack are normally left-justified in the window.  You can "
"control this arrangement by typing @kbd{d <} (@code{calc-left-justify}), "
"@kbd{d >} (@code{calc-right-justify}), or @kbd{d =} "
"(@code{calc-center-justify}).  For example, in Right-Justification mode, "
"stack entries are displayed flush-right against the right edge of the "
"window."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13855
msgid ""
"If you change the width of the Calculator window you may have to type @kbd{d "
"@key{SPC}} (@code{calc-refresh}) to re-align right-justified or centered "
"text."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13859
msgid ""
"Right-justification is especially useful together with fixed-point notation "
"(see @code{d f}; @code{calc-fix-notation}).  With these modes together, the "
"decimal points on numbers will always line up."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13868
msgid ""
"With a numeric prefix argument, the justification commands give you a little "
"extra control over the display.  The argument specifies the horizontal "
"``origin'' of a display line.  It is also possible to specify a maximum line "
"width using the @kbd{d b} command (@pxref{Normal Language Modes}).  For "
"reference, the precise rules for formatting and breaking lines are given "
"below.  Notice that the interaction between origin and line width is "
"slightly different in each justification mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13874
msgid ""
"In Left-Justified mode, the line is indented by a number of spaces given by "
"the origin (default zero).  If the result is longer than the maximum line "
"width, if given, or too wide to fit in the Calc window otherwise, then it is "
"broken into lines which will fit; each broken line is indented to the "
"origin."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13881
msgid ""
"In Right-Justified mode, lines are shifted right so that the rightmost "
"character is just before the origin, or just before the current window width "
"if no origin was specified.  If the line is too long for this, then it is "
"broken; the current line width is used, if specified, or else the origin is "
"used as a width if that is specified, or else the line is broken to fit in "
"the window."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13887
msgid ""
"In Centering mode, the origin is the column number of the center of each "
"stack entry.  If a line width is specified, lines will not be allowed to go "
"past that width; Calc will either indent less or break the lines if "
"necessary.  If no origin is specified, half the line width or Calc window "
"width is used."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13895
msgid ""
"Note that, in each case, if line numbering is enabled the display is "
"indented an additional four spaces to make room for the line number.  The "
"width of the line number is taken into account when positioning according to "
"the current Calc window width, but not when positioning by explicit origins "
"and widths.  In the latter case, the display is formatted as specified, and "
"then uniformly shifted over four spaces to fit the line numbers."
msgstr ""

#. type: kindex
#: ../../calc.texi:13900
#, no-wrap
msgid "d @{"
msgstr ""

#. type: pindex
#: ../../calc.texi:13901
#, no-wrap
msgid "calc-left-label"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13909
msgid ""
"The @kbd{d @{} (@code{calc-left-label}) command prompts for a string, then "
"displays that string to the left of every stack entry.  If the entries are "
"left-justified (@pxref{Justification}), then they will appear immediately "
"after the label (unless you specified an origin greater than the length of "
"the label).  If the entries are centered or right-justified, the label "
"appears on the far left and does not affect the horizontal position of the "
"stack entry."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13911
msgid "Give a blank string (with @kbd{d @{ @key{RET}}) to turn the label off."
msgstr ""

#. type: kindex
#: ../../calc.texi:13912
#, no-wrap
msgid "d @}"
msgstr ""

#. type: pindex
#: ../../calc.texi:13913
#, no-wrap
msgid "calc-right-label"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13920
msgid ""
"The @kbd{d @}} (@code{calc-right-label}) command similarly adds a label on "
"the righthand side.  It does not affect positioning of the stack entries "
"unless they are right-justified.  Also, if both a line width and an origin "
"are given in Right-Justified mode, the stack entry is justified to the "
"origin and the righthand label is justified to the line width."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13926
msgid ""
"One application of labels would be to add equation numbers to formulas you "
"are manipulating in Calc and then copying into a document (possibly using "
"Embedded mode).  The equations would typically be centered, and the equation "
"numbers would be on the left or right as you prefer."
msgstr ""

#. type: node
#: ../../calc.texi:13927 ../../calc.texi:15806 ../../calc.texi:15908
#, no-wrap
msgid "Modes Variable"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13937
msgid ""
"The commands in this section change Calc to use a different notation for "
"entry and display of formulas, corresponding to the conventions of some "
"other common language such as Pascal or @LaTeX{}.  Objects displayed on the "
"stack or yanked from the Calculator to an editing buffer will be formatted "
"in the current language; objects entered in algebraic entry or yanked from "
"another buffer will be interpreted according to the current language."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13942
msgid ""
"The current language has no effect on things written to or read from the "
"trail buffer, nor does it affect numeric entry.  Only algebraic entry is "
"affected.  You can make even algebraic entry ignore the current language and "
"use the standard notation by giving a numeric prefix, e.g., @kbd{C-u '}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13951
msgid ""
"For example, suppose the formula @samp{2*a[1] + atan(a[2])} occurs in a C "
"program; elsewhere in the program you need the derivatives of this formula "
"with respect to @samp{a[1]} and @samp{a[2]}.  First, type @kbd{d C} to "
"switch to C notation.  Now use @code{C-u C-x * g} to grab the formula into "
"the Calculator, @kbd{a d a[1] @key{RET}} to differentiate with respect to "
"the first variable, and @kbd{C-x * y} to yank the formula for the derivative "
"back into your C program.  Press @kbd{U} to undo the differentiation and "
"repeat with @kbd{a d a[2] @key{RET}} for the other derivative."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13957
msgid ""
"Without being switched into C mode first, Calc would have misinterpreted the "
"brackets in @samp{a[1]} and @samp{a[2]}, would not have known that "
"@code{atan} was equivalent to Calc's built-in @code{arctan} function, and "
"would have written the formula back with notations (like implicit "
"multiplication) which would not have been valid for a C program."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13962
msgid ""
"As another example, suppose you are maintaining a C program and a @LaTeX{} "
"document, each of which needs a copy of the same formula.  You can grab the "
"formula from the program in C mode, switch to @LaTeX{} mode, and yank the "
"formula into the document in @LaTeX{} math-mode format."
msgstr ""

#. type: Plain text
#: ../../calc.texi:13965
msgid ""
"Language modes are selected by typing the letter @kbd{d} followed by a "
"shifted letter key."
msgstr ""

#. type: menuentry
#: ../../calc.texi:13978
msgid "Normal Language Modes::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13978
msgid "C FORTRAN Pascal::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13978
msgid "TeX and LaTeX Language Modes::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13978
msgid "Eqn Language Mode::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13978
msgid "Yacas Language Mode::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13978
msgid "Maxima Language Mode::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13978
msgid "Giac Language Mode::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13978
msgid "Mathematica Language Mode::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13978
msgid "Maple Language Mode::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:13978
msgid "Compositions::"
msgstr ""

#. type: node
#: ../../calc.texi:13978 ../../calc.texi:14790 ../../calc.texi:15399 ../../calc.texi:15400 ../../calc.texi:15429 ../../calc.texi:15577 ../../calc.texi:15612 ../../calc.texi:15732
#, no-wrap
msgid "Syntax Tables"
msgstr ""

#. type: node
#: ../../calc.texi:13980 ../../calc.texi:13981 ../../calc.texi:14082
#, no-wrap
msgid "Normal Language Modes"
msgstr ""

#. type: node
#: ../../calc.texi:13980 ../../calc.texi:14082 ../../calc.texi:14157
#, no-wrap
msgid "C FORTRAN Pascal"
msgstr ""

#. type: kindex
#: ../../calc.texi:13984
#, no-wrap
msgid "d N"
msgstr ""

#. type: pindex
#: ../../calc.texi:13985
#, no-wrap
msgid "calc-normal-language"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13991
msgid ""
"The @kbd{d N} (@code{calc-normal-language}) command selects the usual "
"notation for Calc formulas, as described in the rest of this manual.  "
"Matrices are displayed in a multi-line tabular format, but all other objects "
"are written in linear form, as they would be typed from the keyboard."
msgstr ""

#. type: kindex
#: ../../calc.texi:13992
#, no-wrap
msgid "d O"
msgstr ""

#. type: pindex
#: ../../calc.texi:13993
#, no-wrap
msgid "calc-flat-language"
msgstr ""

#. type: cindex
#: ../../calc.texi:13994
#, no-wrap
msgid "Matrix display"
msgstr ""

#. type: Plain text
#: ../../calc.texi:13999
msgid ""
"The @kbd{d O} (@code{calc-flat-language}) command selects a language "
"identical with the normal one, except that matrices are written in one-line "
"form along with everything else.  In some applications this form may be more "
"suitable for yanking data into other buffers."
msgstr ""

#. type: kindex
#: ../../calc.texi:14000
#, no-wrap
msgid "d b"
msgstr ""

#. type: pindex
#: ../../calc.texi:14001
#, no-wrap
msgid "calc-line-breaking"
msgstr ""

#. type: cindex
#: ../../calc.texi:14002
#, no-wrap
msgid "Line breaking"
msgstr ""

#. type: cindex
#: ../../calc.texi:14003
#, no-wrap
msgid "Breaking up long lines"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14011
msgid ""
"Even in one-line mode, long formulas or vectors will still be split across "
"multiple lines if they exceed the width of the Calculator window.  The "
"@kbd{d b} (@code{calc-line-breaking}) command turns this line-breaking "
"feature on and off.  (It works independently of the current language.)  If "
"you give a numeric prefix argument of five or greater to the @kbd{d b} "
"command, that argument will specify the line width used when breaking long "
"lines."
msgstr ""

#. type: kindex
#: ../../calc.texi:14012
#, no-wrap
msgid "d B"
msgstr ""

#. type: pindex
#: ../../calc.texi:14013
#, no-wrap
msgid "calc-big-language"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14017
msgid ""
"The @kbd{d B} (@code{calc-big-language}) command selects a language which "
"uses textual approximations to various mathematical notations, such as "
"powers, quotients, and square roots:"
msgstr ""

#. type: example
#: ../../calc.texi:14023
#, no-wrap
msgid ""
"  ____________\n"
" | a + 1    2\n"
" | ----- + c\n"
"\\|   b\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14027
msgid "in place of @samp{sqrt((a+1)/b + c^2)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14033
msgid ""
"Subscripts like @samp{a_i} are displayed as actual subscripts in Big mode.  "
"Double subscripts, @samp{a_i_j} (@samp{subscr(subscr(a, i), j)})  are "
"displayed as @samp{a} with subscripts separated by commas: @samp{i, j}.  "
"They must still be entered in the usual underscore notation."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14035
msgid "One slight ambiguity of Big notation is that"
msgstr ""

#. type: example
#: ../../calc.texi:14040
#, no-wrap
msgid ""
"  3\n"
"- -\n"
"  4\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14048
msgid ""
"can represent either the negative rational number @expr{-3:4}, or the actual "
"expression @samp{-(3/4)}; but the latter formula would normally never be "
"displayed because it would immediately be evaluated to @expr{-3:4} or "
"@expr{-0.75}, so this ambiguity is not a problem in typical use."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14054
msgid ""
"Non-decimal numbers are displayed with subscripts.  Thus there is no way to "
"tell the difference between @samp{16#C2} and @samp{C2_16}, though generally "
"you will know which interpretation is correct.  Logarithms @samp{log(x,b)} "
"and @samp{log10(x)} also use subscripts in Big mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14060
msgid ""
"In Big mode, stack entries often take up several lines.  To aid readability, "
"stack entries are separated by a blank line in this mode.  You may find it "
"useful to expand the Calc window's height using @kbd{C-x ^} "
"(@code{enlarge-window}) or to make the Calc window the only one on the "
"screen with @kbd{C-x 1} (@code{delete-other-windows})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14065
msgid ""
"Long lines are currently not rearranged to fit the window width in Big mode, "
"so you may need to use the @kbd{<} and @kbd{>} keys to scroll across a wide "
"formula.  For really big formulas, you may even need to use @kbd{@{} and "
"@kbd{@}} to scroll up and down."
msgstr ""

#. type: kindex
#: ../../calc.texi:14066
#, no-wrap
msgid "d U"
msgstr ""

#. type: pindex
#: ../../calc.texi:14067
#, no-wrap
msgid "calc-unformatted-language"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14071
msgid ""
"The @kbd{d U} (@code{calc-unformatted-language}) command altogether disables "
"the use of operator notation in formulas.  In this mode, the formula shown "
"above would be displayed:"
msgstr ""

#. type: example
#: ../../calc.texi:14074
#, no-wrap
msgid "sqrt(add(div(add(a, 1), b), pow(c, 2)))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14081
msgid ""
"These four modes differ only in display format, not in the format expected "
"for algebraic entry.  The standard Calc operators work in all four modes, "
"and unformatted notation works in any language mode (except that Mathematica "
"mode expects square brackets instead of parentheses)."
msgstr ""

#. type: node
#: ../../calc.texi:14082 ../../calc.texi:14157 ../../calc.texi:14577
#, no-wrap
msgid "TeX and LaTeX Language Modes"
msgstr ""

#. type: subsection
#: ../../calc.texi:14083
#, no-wrap
msgid "C, FORTRAN, and Pascal Modes"
msgstr ""

#. type: kindex
#: ../../calc.texi:14086
#, no-wrap
msgid "d C"
msgstr ""

#. type: pindex
#: ../../calc.texi:14087
#, no-wrap
msgid "calc-c-language"
msgstr ""

#. type: cindex
#: ../../calc.texi:14088
#, no-wrap
msgid "C language"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14096
msgid ""
"The @kbd{d C} (@code{calc-c-language}) command selects the conventions of "
"the C language for display and entry of formulas.  This differs from the "
"normal language mode in a variety of (mostly minor) ways.  In particular, C "
"language operators and operator precedences are used in place of Calc's "
"usual ones.  For example, @samp{a^b} means @samp{xor(a,b)} in C mode; a "
"value raised to a power is written as a function call, @samp{pow(a,b)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14104
msgid ""
"In C mode, vectors and matrices use curly braces instead of brackets.  Octal "
"and hexadecimal values are written with leading @samp{0} or @samp{0x} rather "
"than using the @samp{#} symbol.  Array subscripting is translated into "
"@code{subscr} calls, so that @samp{a[i]} in C mode is the same as @samp{a_i} "
"in Normal mode.  Assignments turn into the @code{assign} function, which "
"Calc normally displays using the @samp{:=} symbol."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14113
msgid ""
"The variables @code{pi} and @code{e} would be displayed @samp{pi} and "
"@samp{e} in Normal mode, but in C mode they are displayed as @samp{M_PI} and "
"@samp{M_E}, corresponding to the names of constants typically provided in "
"the @file{<math.h>} header.  Functions whose names are different in C are "
"translated automatically for entry and display purposes.  For example, "
"entering @samp{asin(x)} will push the formula @samp{arcsin(x)} onto the "
"stack; this formula will be displayed as @samp{asin(x)} as long as C mode is "
"in effect."
msgstr ""

#. type: kindex
#: ../../calc.texi:14114
#, no-wrap
msgid "d P"
msgstr ""

#. type: pindex
#: ../../calc.texi:14115
#, no-wrap
msgid "calc-pascal-language"
msgstr ""

#. type: cindex
#: ../../calc.texi:14116
#, no-wrap
msgid "Pascal language"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14126
msgid ""
"The @kbd{d P} (@code{calc-pascal-language}) command selects Pascal "
"conventions.  Like C mode, Pascal mode interprets array brackets and uses a "
"different table of operators.  Hexadecimal numbers are entered and displayed "
"with a preceding dollar sign.  (Thus the regular meaning of @kbd{$2} during "
"algebraic entry does not work in Pascal mode, though @kbd{$} (and @kbd{$$}, "
"etc.)@: not followed by digits works the same as always.)  No special "
"provisions are made for other non-decimal numbers, vectors, and so on, since "
"there is no universally accepted standard way of handling these in Pascal."
msgstr ""

#. type: kindex
#: ../../calc.texi:14127
#, no-wrap
msgid "d F"
msgstr ""

#. type: pindex
#: ../../calc.texi:14128
#, no-wrap
msgid "calc-fortran-language"
msgstr ""

#. type: cindex
#: ../../calc.texi:14129
#, no-wrap
msgid "FORTRAN language"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14145
msgid ""
"The @kbd{d F} (@code{calc-fortran-language}) command selects FORTRAN "
"conventions.  Various function names are transformed into FORTRAN "
"equivalents.  Vectors are written as @samp{/1, 2, 3/}, and may be entered "
"this way or using square brackets.  Since FORTRAN uses round parentheses for "
"both function calls and array subscripts, Calc displays both in the same "
"way; @samp{a(i)} is interpreted as a function call upon reading, and "
"subscripts must be entered as @samp{subscr(a, i)}.  If the variable @code{a} "
"has been declared to have type @code{vector} or @code{matrix}, however, then "
"@samp{a(i)} will be parsed as a subscript.  (@xref{Declarations}.)  Usually "
"it doesn't matter, though; if you enter the subscript expression @samp{a(i)} "
"and Calc interprets it as a function call, you'll never know the difference "
"unless you switch to another language mode or replace @code{a} with an "
"actual vector (or unless @code{a} happens to be the name of a built-in "
"function!)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14149
msgid ""
"Underscores are allowed in variable and function names in all of these "
"language modes.  The underscore here is equivalent to the @samp{#} in Normal "
"mode, or to hyphens in the underlying Emacs Lisp variable names."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14156
msgid ""
"FORTRAN and Pascal modes normally do not adjust the case of letters in "
"formulas.  Most built-in Calc names use lower-case letters.  If you use a "
"positive numeric prefix argument with @kbd{d P} or @kbd{d F}, these modes "
"will use upper-case letters exclusively for display, and will convert to "
"lower-case on input.  With a negative prefix, these modes convert to "
"lower-case for display and input."
msgstr ""

#. type: node
#: ../../calc.texi:14157 ../../calc.texi:14577 ../../calc.texi:14578 ../../calc.texi:14653
#, no-wrap
msgid "Eqn Language Mode"
msgstr ""

#. type: subsection
#: ../../calc.texi:14158
#, no-wrap
msgid "@TeX{} and @LaTeX{} Language Modes"
msgstr ""

#. type: kindex
#: ../../calc.texi:14161
#, no-wrap
msgid "d T"
msgstr ""

#. type: pindex
#: ../../calc.texi:14162
#, no-wrap
msgid "calc-tex-language"
msgstr ""

#. type: cindex
#: ../../calc.texi:14163
#, no-wrap
msgid "TeX language"
msgstr ""

#. type: kindex
#: ../../calc.texi:14164
#, no-wrap
msgid "d L"
msgstr ""

#. type: pindex
#: ../../calc.texi:14165
#, no-wrap
msgid "calc-latex-language"
msgstr ""

#. type: cindex
#: ../../calc.texi:14166
#, no-wrap
msgid "LaTeX language"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14174
msgid ""
"The @kbd{d T} (@code{calc-tex-language}) command selects the conventions of "
"``math mode'' in Donald Knuth's @TeX{} typesetting language, and the @kbd{d "
"L} (@code{calc-latex-language}) command selects the conventions of ``math "
"mode'' in @LaTeX{}, a typesetting language that uses @TeX{} as its "
"formatting engine.  Calc's @LaTeX{} language mode can read any formula that "
"the @TeX{} language mode can, although @LaTeX{} mode may display it "
"differently."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14184
msgid ""
"Formulas are entered and displayed in the appropriate notation; @texline "
"@math{\\sin(a/b)} @infoline @expr{sin(a/b)} will appear as "
"@samp{\\sin\\left( @{a \\over b@} \\right)} in @TeX{} mode and "
"@samp{\\sin\\left(\\frac@{a@}@{b@}\\right)} in @LaTeX{} mode.  Math formulas "
"are often enclosed by @samp{$ $} signs in @TeX{} and @LaTeX{}; these should "
"be omitted when interfacing with Calc.  To Calc, the @samp{$} sign has the "
"same meaning it always does in algebraic formulas (a reference to an "
"existing entry on the stack)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14198
msgid ""
"Complex numbers are displayed as in @samp{3 + 4i}.  Fractions and quotients "
"are written using @code{\\over} in @TeX{} mode (as in @code{@{a \\over b@}}) "
"and @code{\\frac} in @LaTeX{} mode (as in @code{\\frac@{a@}@{b@}}); binomial "
"coefficients are written with @code{\\choose} in @TeX{} mode (as in "
"@code{@{a \\choose b@}}) and @code{\\binom} in @LaTeX{} mode (as in "
"@code{\\binom@{a@}@{b@}}).  Interval forms are written with @code{\\ldots}, "
"and error forms are written with @code{\\pm}. Absolute values are written as "
"in @samp{|x + 1|}, and the floor and ceiling functions are written with "
"@code{\\lfloor}, @code{\\rfloor}, etc. The words @code{\\left} and "
"@code{\\right} are ignored when reading formulas in @TeX{} and @LaTeX{} "
"modes.  Both @code{inf} and @code{uinf} are written as @code{\\infty}; when "
"read, @code{\\infty} always translates to @code{inf}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14211
msgid ""
"Function calls are written the usual way, with the function name followed by "
"the arguments in parentheses.  However, functions for which @TeX{} and "
"@LaTeX{} have special names (like @code{\\sin}) will use curly braces "
"instead of parentheses for very simple arguments.  During input, curly "
"braces and parentheses work equally well for grouping, but when the document "
"is formatted the curly braces will be invisible.  Thus the printed result is "
"@texline @math{\\sin{2 x}} @infoline @expr{sin 2x} but @texline "
"@math{\\sin(2 + x)}.  @infoline @expr{sin(2 + x)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14215
msgid ""
"The @TeX{} specific unit names (@pxref{Predefined Units}) will not use the "
"@samp{tex} prefix; the unit name for a @TeX{} point will be @samp{pt} "
"instead of @samp{texpt}, for example."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14231
msgid ""
"Function and variable names not treated specially by @TeX{} and @LaTeX{} are "
"simply written out as-is, which will cause them to come out in italic "
"letters in the printed document.  If you invoke @kbd{d T} or @kbd{d L} with "
"a positive numeric prefix argument, names of more than one character will "
"instead be enclosed in a protective commands that will prevent them from "
"being typeset in the math italics; they will be written "
"@samp{\\hbox@{@var{name}@}} in @TeX{} mode and @samp{\\text@{@var{name}@}} "
"in @LaTeX{} mode.  The @samp{\\hbox@{ @}} and @samp{\\text@{ @}} notations "
"are ignored during reading.  If you use a negative prefix argument, such "
"function names are written @samp{\\@var{name}}, and function names that "
"begin with @code{\\} during reading have the @code{\\} removed.  (Note that "
"in this mode, long variable names are still written with @code{\\hbox} or "
"@code{\\text}.  However, you can always make an actual variable name like "
"@code{\\bar} in any @TeX{} mode.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14248
msgid ""
"During reading, text of the form @samp{\\matrix@{ ...@: @}} is replaced by "
"@samp{[ ...@: ]}.  The same also applies to @code{\\pmatrix} and "
"@code{\\bmatrix}.  In @LaTeX{} mode this also applies to "
"@samp{\\begin@{matrix@} ... \\end@{matrix@}}, @samp{\\begin@{bmatrix@} "
"... \\end@{bmatrix@}}, @samp{\\begin@{pmatrix@} ... \\end@{pmatrix@}}, as "
"well as @samp{\\begin@{smallmatrix@} ... \\end@{smallmatrix@}}.  The symbol "
"@samp{&} is interpreted as a comma, and the symbols @samp{\\cr} and "
"@samp{\\\\} are interpreted as semicolons.  During output, matrices are "
"displayed in @samp{\\matrix@{ a & b \\\\ c & d@}} format in @TeX{} mode and "
"in @samp{\\begin@{pmatrix@} a & b \\\\ c & d \\end@{pmatrix@}} format in "
"@LaTeX{} mode; you may need to edit this afterwards to change to your "
"preferred matrix form.  If you invoke @kbd{d T} or @kbd{d L} with an "
"argument of 2 or @minus{}2, then matrices will be displayed in "
"two-dimensional form, such as"
msgstr ""

#. type: example
#: ../../calc.texi:14254
#, no-wrap
msgid ""
"\\begin@{pmatrix@}\n"
"a & b \\\\\n"
"c & d\n"
"\\end@{pmatrix@}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14259
msgid ""
"This may be convenient for isolated matrices, but could lead to expressions "
"being displayed like"
msgstr ""

#. type: example
#: ../../calc.texi:14265
#, no-wrap
msgid ""
"\\begin@{pmatrix@} \\times x\n"
"a & b \\\\\n"
"c & d\n"
"\\end@{pmatrix@}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14270
msgid ""
"While this wouldn't bother Calc, it is incorrect @LaTeX{}.  (Similarly for "
"@TeX{}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14277
msgid ""
"Accents like @code{\\tilde} and @code{\\bar} translate into function calls "
"internally (@samp{tilde(x)}, @samp{bar(x)}).  The @code{\\underline} "
"sequence is treated as an accent.  The @code{\\vec} accent corresponds to "
"the function name @code{Vec}, because @code{vec} is the name of a built-in "
"Calc function.  The following table shows the accents in Calc, @TeX{}, "
"@LaTeX{} and @dfn{eqn} (described in the next section):"
msgstr ""

#. type: iftex
#: ../../calc.texi:14283
#, no-wrap
msgid ""
"@begingroup\n"
"@let@calcindexershow=@calcindexernoshow  @c Suppress marginal notes\n"
"@let@calcindexersh=@calcindexernoshow\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14287
msgid "@tindex acute"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14291
msgid "@tindex Acute"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14295
msgid "@tindex bar"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14299
msgid "@tindex Bar"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14303
msgid "@tindex breve"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14307
msgid "@tindex Breve"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14311
msgid "@tindex check"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14315
msgid "@tindex Check"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14319
msgid "@tindex dddot"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14323
msgid "@tindex ddddot"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14327
msgid "@tindex dot"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14331
msgid "@tindex Dot"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14335
msgid "@tindex dotdot"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14339
msgid "@tindex DotDot"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14343
msgid "@tindex dyad"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14347
msgid "@tindex grave"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14351
msgid "@tindex Grave"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14355
msgid "@tindex hat"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14359
msgid "@tindex Hat"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14363
msgid "@tindex Prime"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14367
msgid "@tindex tilde"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14371
msgid "@tindex Tilde"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14375
msgid "@tindex under"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14379
msgid "@tindex Vec"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14383
msgid "@tindex VEC"
msgstr ""

#. type: iftex
#: ../../calc.texi:14386
#, no-wrap
msgid "@endgroup\n"
msgstr ""

#. type: example
#: ../../calc.texi:14416
#, no-wrap
msgid ""
"Calc      TeX           LaTeX         eqn\n"
"----      ---           -----         ---\n"
"acute     \\acute        \\acute\n"
"Acute                   \\Acute\n"
"bar       \\bar          \\bar          bar\n"
"Bar                     \\Bar\n"
"breve     \\breve        \\breve\n"
"Breve                   \\Breve\n"
"check     \\check        \\check\n"
"Check                   \\Check\n"
"dddot                   \\dddot\n"
"ddddot                  \\ddddot\n"
"dot       \\dot          \\dot          dot\n"
"Dot                     \\Dot\n"
"dotdot    \\ddot         \\ddot         dotdot\n"
"DotDot                  \\Ddot\n"
"dyad                                  dyad\n"
"grave     \\grave        \\grave\n"
"Grave                   \\Grave\n"
"hat       \\hat          \\hat          hat\n"
"Hat                     \\Hat\n"
"Prime                                 prime\n"
"tilde     \\tilde        \\tilde        tilde\n"
"Tilde                   \\Tilde\n"
"under     \\underline    \\underline    under\n"
"Vec       \\vec          \\vec          vec\n"
"VEC                     \\Vec\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14426
msgid ""
"The @samp{=>} (evaluates-to) operator appears as a @code{\\to} symbol: "
"@samp{@{@var{a} \\to @var{b}@}}.  @TeX{} defines @code{\\to} as an alias for "
"@code{\\rightarrow}.  However, if the @samp{=>} is the top-level expression "
"being formatted, a slightly different notation is used: @samp{\\evalto "
"@var{a} \\to @var{b}}.  The @code{\\evalto} word is ignored by Calc's input "
"routines, and is undefined in @TeX{}.  You will typically want to include "
"one of the following definitions at the top of a @TeX{} file that uses "
"@code{\\evalto}:"
msgstr ""

#. type: example
#: ../../calc.texi:14430
#, no-wrap
msgid ""
"\\def\\evalto@{@}\n"
"\\def\\evalto#1\\to@{@}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14438
msgid ""
"The first definition formats evaluates-to operators in the usual way.  The "
"second causes only the @var{b} part to appear in the printed document; the "
"@var{a} part and the arrow are hidden.  Another definition you may wish to "
"use is @samp{\\let\\to=\\Rightarrow} which causes @code{\\to} to appear more "
"like Calc's @samp{=>} symbol.  @xref{Evaluates-To Operator}, for a "
"discussion of @code{evalto}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14441
msgid ""
"The complete set of @TeX{} control sequences that are ignored during reading "
"is:"
msgstr ""

#. type: example
#: ../../calc.texi:14450
#, no-wrap
msgid ""
"\\hbox  \\mbox  \\text  \\left  \\right\n"
"\\,  \\>  \\:  \\;  \\!  \\quad  \\qquad  \\hfil  \\hfill\n"
"\\displaystyle  \\textstyle  \\dsize  \\tsize\n"
"\\scriptstyle  \\scriptscriptstyle  \\ssize  \\ssize\n"
"\\rm  \\bf  \\it  \\sl  \\roman  \\bold  \\italic  \\slanted\n"
"\\cal  \\mit  \\Cal  \\Bbb  \\frak  \\goth\n"
"\\evalto\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14455
msgid ""
"Note that, because these symbols are ignored, reading a @TeX{} or @LaTeX{} "
"formula into Calc and writing it back out may lose spacing and font "
"information."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14458
msgid ""
"Also, the ``discretionary multiplication sign'' @samp{\\*} is read the same "
"as @samp{*}."
msgstr ""

#. type: ifnottex
#: ../../calc.texi:14462
msgid ""
"The @TeX{} version of this manual includes some printed examples at the end "
"of this section."
msgstr ""

#. type: iftex
#: ../../calc.texi:14465
msgid "Here are some examples of how various Calc formulas are formatted in @TeX{}:"
msgstr ""

#. type: group
#: ../../calc.texi:14470
#, no-wrap
msgid ""
"sin(a^2 / b_i)\n"
"\\sin\\left( {a^2 \\over b_i} \\right)\n"
msgstr ""

#. type: tex
#: ../../calc.texi:14474
#, no-wrap
msgid "$$ \\sin\\left( a^2 \\over b_i \\right) $$\n"
msgstr ""

#. type: group
#: ../../calc.texi:14481
#, no-wrap
msgid ""
"[(3, 4), 3:4, 3 +/- 4, [3 .. inf)]\n"
"[3 + 4i, @{3 \\over 4@}, 3 \\pm 4, [3 \\ldots \\infty)]\n"
msgstr ""

#. type: tex
#: ../../calc.texi:14485
#, no-wrap
msgid "$$ [3 + 4i, {3 \\over 4}, 3 \\pm 4, [ 3 \\ldots \\infty)] $$\n"
msgstr ""

#. type: group
#: ../../calc.texi:14493
#, no-wrap
msgid ""
"[abs(a), abs(a / b), floor(a), ceil(a / b)]\n"
"[|a|, \\left| a \\over b \\right|,\n"
" \\lfloor a \\rfloor, \\left\\lceil a \\over b \\right\\rceil]\n"
msgstr ""

#. type: tex
#: ../../calc.texi:14498
#, no-wrap
msgid ""
"$$ [|a|, \\left| a \\over b \\right|,\n"
"    \\lfloor a \\rfloor, \\left\\lceil a \\over b \\right\\rceil] $$\n"
msgstr ""

#. type: group
#: ../../calc.texi:14506
#, no-wrap
msgid ""
"[sin(a), sin(2 a), sin(2 + a), sin(a / b)]\n"
"[\\sin@{a@}, \\sin@{2 a@}, \\sin(2 + a),\n"
" \\sin\\left( @{a \\over b@} \\right)]\n"
msgstr ""

#. type: tex
#: ../../calc.texi:14510
#, no-wrap
msgid ""
"$$ [\\sin{a}, \\sin{2 a}, \\sin(2 + a), \\sin\\left( {a \\over b} \\right)] "
"$$\n"
msgstr ""

#. type: iftex
#: ../../calc.texi:14516
msgid ""
"First with plain @kbd{d T}, then with @kbd{C-u d T}, then finally with "
"@kbd{C-u - d T} (using the example definition @samp{\\def\\foo#1@{\\tilde "
"F(#1)@}}:"
msgstr ""

#. type: group
#: ../../calc.texi:14523
#, no-wrap
msgid ""
"[f(a), foo(bar), sin(pi)]\n"
"[f(a), foo(bar), \\sin{\\pi}]\n"
"[f(a), \\hbox@{foo@}(\\hbox@{bar@}), \\sin@{\\pi@}]\n"
"[f(a), \\foo@{\\hbox@{bar@}@}, \\sin@{\\pi@}]\n"
msgstr ""

#. type: tex
#: ../../calc.texi:14529
#, no-wrap
msgid ""
"$$ [f(a), foo(bar), \\sin{\\pi}] $$\n"
"$$ [f(a), \\hbox{foo}(\\hbox{bar}), \\sin{\\pi}] $$\n"
"$$ [f(a), \\tilde F(\\hbox{bar}), \\sin{\\pi}] $$\n"
msgstr ""

#. type: iftex
#: ../../calc.texi:14533
msgid ""
"First with @samp{\\def\\evalto@{@}}, then with "
"@samp{\\def\\evalto#1\\to@{@}}:"
msgstr ""

#. type: group
#: ../../calc.texi:14538
#, no-wrap
msgid ""
"2 + 3 => 5\n"
"\\evalto 2 + 3 \\to 5\n"
msgstr ""

#. type: tex
#: ../../calc.texi:14543
#, no-wrap
msgid ""
"$$ 2 + 3 \\to 5 $$\n"
"$$ 5 $$\n"
msgstr ""

#. type: iftex
#: ../../calc.texi:14547
msgid "First with standard @code{\\to}, then with @samp{\\let\\to\\Rightarrow}:"
msgstr ""

#. type: group
#: ../../calc.texi:14552
#, no-wrap
msgid ""
"[2 + 3 => 5, a / 2 => (b + c) / 2]\n"
"[@{2 + 3 \\to 5@}, @{@{a \\over 2@} \\to @{b + c \\over 2@}@}]\n"
msgstr ""

#. type: tex
#: ../../calc.texi:14558
#, no-wrap
msgid ""
"$$ [{2 + 3 \\to 5}, {{a \\over 2} \\to {b + c \\over 2}}] $$\n"
"{\\let\\to\\Rightarrow\n"
"$$ [{2 + 3 \\to 5}, {{a \\over 2} \\to {b + c \\over 2}}] $$}\n"
msgstr ""

#. type: iftex
#: ../../calc.texi:14562
msgid "Matrices normally, then changing @code{\\matrix} to @code{\\pmatrix}:"
msgstr ""

#. type: group
#: ../../calc.texi:14568
#, no-wrap
msgid ""
"[ [ a / b, 0 ], [ 0, 2^(x + 1) ] ]\n"
"\\matrix@{ @{a \\over b@} & 0 \\\\ 0 & 2^@{(x + 1)@} @}\n"
"\\pmatrix@{ @{a \\over b@} & 0 \\\\ 0 & 2^@{(x + 1)@} @}\n"
msgstr ""

#. type: tex
#: ../../calc.texi:14573
#, no-wrap
msgid ""
"$$ \\matrix{ {a \\over b} & 0 \\cr 0 & 2^{(x + 1)} } $$\n"
"$$ \\pmatrix{ {a \\over b} & 0 \\cr 0 & 2^{(x + 1)} } $$\n"
msgstr ""

#. type: node
#: ../../calc.texi:14577 ../../calc.texi:14653 ../../calc.texi:14654 ../../calc.texi:14683
#, no-wrap
msgid "Yacas Language Mode"
msgstr ""

#. type: kindex
#: ../../calc.texi:14581
#, no-wrap
msgid "d E"
msgstr ""

#. type: pindex
#: ../../calc.texi:14582
#, no-wrap
msgid "calc-eqn-language"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14587
msgid ""
"@dfn{Eqn} is another popular formatter for math formulas.  It is designed "
"for use with the TROFF text formatter, and comes standard with many versions "
"of Unix.  The @kbd{d E} (@code{calc-eqn-language})  command selects "
"@dfn{eqn} notation."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14594
msgid ""
"The @dfn{eqn} language's main idiosyncrasy is that whitespace plays a "
"significant part in the parsing of the language.  For example, @samp{sqrt "
"x+1 + y} treats @samp{x+1} as the argument of the @code{sqrt} operator.  "
"@dfn{Eqn} also understands more conventional grouping using curly braces: "
"@samp{sqrt@{x+1@} + y}.  Braces are required only when the argument contains "
"spaces."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14602
msgid ""
"In Calc's @dfn{eqn} mode, however, curly braces are required to delimit "
"arguments of operators like @code{sqrt}.  The first of the above examples "
"would treat only the @samp{x} as the argument of @code{sqrt}, and in fact "
"@samp{sin x+1} would be interpreted as @samp{sin * x + 1}, because "
"@code{sin} is not a special operator in the @dfn{eqn} language.  If you "
"always surround the argument with curly braces, Calc will never "
"misunderstand."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14612
msgid ""
"Calc also understands parentheses as grouping characters.  Another "
"peculiarity of @dfn{eqn}'s syntax makes it advisable to separate words with "
"spaces from any surrounding characters that aren't curly braces, so Calc "
"writes @samp{sin ( x + y )} in @dfn{eqn} mode.  (The spaces around "
"@code{sin} are important to make @dfn{eqn} recognize that @code{sin} should "
"be typeset in a roman font, and the spaces around @code{x} and @code{y} are "
"a good idea just in case the @dfn{eqn} document has defined special meanings "
"for these names, too.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14618
msgid ""
"Powers and subscripts are written with the @code{sub} and @code{sup} "
"operators, respectively.  Note that the caret symbol @samp{^} is treated the "
"same as a space in @dfn{eqn} mode, as is the @samp{~} symbol (these are used "
"to introduce spaces of various widths into the typeset output of @dfn{eqn})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14623
msgid ""
"As in @LaTeX{} mode, Calc's formatter omits parentheses around the arguments "
"of functions like @code{ln} and @code{sin} if they are ``simple-looking''; "
"in this case Calc surrounds the argument with braces, separated by a "
"@samp{~} from the function name: @samp{sin~@{x@}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14631
msgid ""
"Font change codes (like @samp{roman @var{x}}) and positioning codes (like "
"@samp{~} and @samp{down @var{n} @var{x}}) are ignored by the @dfn{eqn} "
"reader.  Also ignored are the words @code{left}, @code{right}, @code{mark}, "
"and @code{lineup}.  Quotation marks in @dfn{eqn} mode input are treated the "
"same as curly braces: @samp{sqrt \"1+x\"} is equivalent to @samp{sqrt "
"@{1+x@}}; this is only an approximation to the true meaning of quotes in "
"@dfn{eqn}, but it is good enough for most uses."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14640
msgid ""
"Accent codes (@samp{@var{x} dot}) are handled by treating them as function "
"calls (@samp{dot(@var{x})}) internally.  @xref{TeX and LaTeX Language "
"Modes}, for a table of these accent functions.  The @code{prime} accent is "
"treated specially if it occurs on a variable or function name: @samp{f prime "
"prime @w{( x prime )}} is stored internally as @samp{f'@w{'}(x')}.  For "
"example, taking the derivative of @samp{f(2 x)} with @kbd{a d x} will "
"produce @samp{2 f'(2 x)}, which @dfn{eqn} mode will display as @samp{2 f "
"prime ( 2 x )}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14646
msgid ""
"Assignments are written with the @samp{<-} (left-arrow) symbol, and "
"@code{evalto} operators are written with @samp{->} or @samp{evalto ... ->} "
"(@pxref{TeX and LaTeX Language Modes}, for a discussion of this).  The "
"regular Calc symbols @samp{:=} and @samp{=>} are also recognized for these "
"operators during reading."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14652
msgid ""
"Vectors in @dfn{eqn} mode use regular Calc square brackets, but matrices are "
"formatted as @samp{matrix @{ ccol @{ a above b @} ... @}}.  The words "
"@code{lcol} and @code{rcol} are recognized as synonyms for @code{ccol} "
"during input, and are generated instead of @code{ccol} if the matrix "
"justification mode so specifies."
msgstr ""

#. type: node
#: ../../calc.texi:14653 ../../calc.texi:14683 ../../calc.texi:14684 ../../calc.texi:14708
#, no-wrap
msgid "Maxima Language Mode"
msgstr ""

#. type: kindex
#: ../../calc.texi:14657
#, no-wrap
msgid "d Y"
msgstr ""

#. type: pindex
#: ../../calc.texi:14658
#, no-wrap
msgid "calc-yacas-language"
msgstr ""

#. type: cindex
#: ../../calc.texi:14659
#, no-wrap
msgid "Yacas language"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14671
msgid ""
"The @kbd{d Y} (@code{calc-yacas-language}) command selects the conventions "
"of Yacas, a free computer algebra system.  While the operators and functions "
"in Yacas are similar to those of Calc, the names of built-in functions in "
"Yacas are capitalized.  The Calc formula @samp{sin(2 x)}, for example, is "
"entered and displayed @samp{Sin(2 x)} in Yacas mode, and @samp{arcsin(x^2)} "
"is @samp{ArcSin(x^2)} in Yacas mode.  Complex numbers are written are "
"written @samp{3 + 4 I}.  The standard special constants are written "
"@code{Pi}, @code{E}, @code{I}, @code{GoldenRatio} and @code{Gamma}.  "
"@code{Infinity} represents both @code{inf} and @code{uinf}, and "
"@code{Undefined} represents @code{nan}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14676
msgid ""
"Certain operators on functions, such as @code{D} for differentiation and "
"@code{Integrate} for integration, take a prefix form in Yacas.  For example, "
"the derivative of @w{@samp{e^x sin(x)}} can be computed with @w{@samp{D(x) "
"Exp(x)*Sin(x)}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14681
msgid ""
"Other notable differences between Yacas and standard Calc expressions are "
"that vectors and matrices use curly braces in Yacas, and subscripts use "
"square brackets.  If, for example, @samp{A} represents the list "
"@samp{@{a,2,c,4@}}, then @samp{A[3]} would equal @samp{c}."
msgstr ""

#. type: node
#: ../../calc.texi:14683 ../../calc.texi:14708 ../../calc.texi:14709 ../../calc.texi:14733
#, no-wrap
msgid "Giac Language Mode"
msgstr ""

#. type: kindex
#: ../../calc.texi:14687
#, no-wrap
msgid "d X"
msgstr ""

#. type: pindex
#: ../../calc.texi:14688
#, no-wrap
msgid "calc-maxima-language"
msgstr ""

#. type: cindex
#: ../../calc.texi:14689
#, no-wrap
msgid "Maxima language"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14698
msgid ""
"The @kbd{d X} (@code{calc-maxima-language}) command selects the conventions "
"of Maxima, another free computer algebra system.  The function names in "
"Maxima are similar, but not always identical, to Calc.  For example, instead "
"of @samp{arcsin(x)}, Maxima will use @samp{asin(x)}.  Complex numbers are "
"written @samp{3 + 4 %i}.  The standard special constants are written "
"@code{%pi}, @code{%e}, @code{%i}, @code{%phi} and @code{%gamma}.  In Maxima, "
"@code{inf} means the same as in Calc, but @code{infinity} represents Calc's "
"@code{uinf}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14703
msgid ""
"Underscores as well as percent signs are allowed in function and variable "
"names in Maxima mode.  The underscore again is equivalent to the @samp{#} in "
"Normal mode, and the percent sign is equivalent to @samp{o'o}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14707
msgid ""
"Maxima uses square brackets for lists and vectors, and matrices are written "
"as calls to the function @code{matrix}, given the row vectors of the matrix "
"as arguments.  Square brackets are also used as subscripts."
msgstr ""

#. type: node
#: ../../calc.texi:14708 ../../calc.texi:14733 ../../calc.texi:14734 ../../calc.texi:14756
#, no-wrap
msgid "Mathematica Language Mode"
msgstr ""

#. type: kindex
#: ../../calc.texi:14712
#, no-wrap
msgid "d A"
msgstr ""

#. type: pindex
#: ../../calc.texi:14713
#, no-wrap
msgid "calc-giac-language"
msgstr ""

#. type: cindex
#: ../../calc.texi:14714
#, no-wrap
msgid "Giac language"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14721
msgid ""
"The @kbd{d A} (@code{calc-giac-language}) command selects the conventions of "
"Giac, another free computer algebra system.  The function names in Giac are "
"similar to Maxima.  Complex numbers are written @samp{3 + 4 i}.  The "
"standard special constants in Giac are the same as in Calc, except that "
"@code{infinity} represents both Calc's @code{inf} and @code{uinf}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14727
msgid ""
"Underscores are allowed in function and variable names in Giac mode.  "
"Brackets are used for subscripts.  In Giac, indexing of lists begins at 0, "
"instead of 1 as in Calc.  So if @samp{A} represents the list "
"@samp{[a,2,c,4]}, then @samp{A[2]} would equal @samp{c}.  In general, "
"@samp{A[n]} in Giac mode corresponds to @samp{A_(n+1)} in Normal mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14732
msgid ""
"The Giac interval notation @samp{2 .. 3} has no surrounding brackets; Calc "
"reads @samp{2 .. 3} as the closed interval @samp{[2 .. 3]} and writes any "
"kind of interval as @samp{2 .. 3}.  This means you cannot see the difference "
"between an open and a closed interval while in Giac mode."
msgstr ""

#. type: node
#: ../../calc.texi:14733 ../../calc.texi:14756 ../../calc.texi:14757 ../../calc.texi:14790
#, no-wrap
msgid "Maple Language Mode"
msgstr ""

#. type: kindex
#: ../../calc.texi:14737
#, no-wrap
msgid "d M"
msgstr ""

#. type: pindex
#: ../../calc.texi:14738
#, no-wrap
msgid "calc-mathematica-language"
msgstr ""

#. type: cindex
#: ../../calc.texi:14739
#, no-wrap
msgid "Mathematica language"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14746
msgid ""
"The @kbd{d M} (@code{calc-mathematica-language}) command selects the "
"conventions of Mathematica.  Notable differences in Mathematica mode are "
"that the names of built-in functions are capitalized, and function calls use "
"square brackets instead of parentheses.  Thus the Calc formula @samp{sin(2 "
"x)} is entered and displayed @w{@samp{Sin[2 x]}} in Mathematica mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14755
msgid ""
"Vectors and matrices use curly braces in Mathematica.  Complex numbers are "
"written @samp{3 + 4 I}.  The standard special constants in Calc are written "
"@code{Pi}, @code{E}, @code{I}, @code{GoldenRatio}, @code{EulerGamma}, "
"@code{Infinity}, @code{ComplexInfinity}, and @code{Indeterminate} in "
"Mathematica mode.  Non-decimal numbers are written, e.g., @samp{16^^7fff}.  "
"Floating-point numbers in scientific notation are written "
"@samp{1.23*10.^3}.  Subscripts use double square brackets: @samp{a[[i]]}."
msgstr ""

#. type: node
#: ../../calc.texi:14756 ../../calc.texi:14790 ../../calc.texi:14791 ../../calc.texi:14794 ../../calc.texi:14826 ../../calc.texi:14967 ../../calc.texi:15011 ../../calc.texi:15132 ../../calc.texi:15226 ../../calc.texi:15268 ../../calc.texi:15399
#, no-wrap
msgid "Compositions"
msgstr ""

#. type: kindex
#: ../../calc.texi:14760
#, no-wrap
msgid "d W"
msgstr ""

#. type: pindex
#: ../../calc.texi:14761
#, no-wrap
msgid "calc-maple-language"
msgstr ""

#. type: cindex
#: ../../calc.texi:14762
#, no-wrap
msgid "Maple language"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14765
msgid ""
"The @kbd{d W} (@code{calc-maple-language}) command selects the conventions "
"of Maple."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14770
msgid ""
"Maple's language is much like C@.  Underscores are allowed in symbol names; "
"square brackets are used for subscripts; explicit @samp{*}s for "
"multiplications are required.  Use either @samp{^} or @samp{**} to denote "
"powers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14777
msgid ""
"Maple uses square brackets for lists and curly braces for sets.  Calc "
"interprets both notations as vectors, and displays vectors with square "
"brackets.  This means Maple sets will be converted to lists when they pass "
"through Calc.  As a special case, matrices are written as calls to the "
"function @code{matrix}, given a list of lists as the argument, and can be "
"read in this form or with all-capitals @code{MATRIX}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14780
msgid ""
"The Maple interval notation @samp{2 .. 3} is like Giac's interval notation, "
"and is handled the same by Calc."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14785
msgid ""
"Maple writes complex numbers as @samp{3 + 4*I}.  Its special constants are "
"@code{Pi}, @code{E}, @code{I}, and @code{infinity} (all three of @code{inf}, "
"@code{uinf}, and @code{nan} display as @code{infinity}).  Floating-point "
"numbers are written @samp{1.23*10.^3}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14789
msgid ""
"Among things not currently handled by Calc's Maple mode are the various "
"quote symbols, procedures and functional operators, and inert (@samp{&}) "
"operators."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14800
msgid ""
"There are several @dfn{composition functions} which allow you to get "
"displays in a variety of formats similar to those in Big language mode.  "
"Most of these functions do not evaluate to anything; they are placeholders "
"which are left in symbolic form by Calc's evaluator but are recognized by "
"Calc's display formatting routines."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14809
msgid ""
"Two of these, @code{string} and @code{bstring}, are described elsewhere.  "
"@xref{Strings}.  For example, @samp{string(\"ABC\")} is displayed as "
"@samp{ABC}.  When viewed on the stack it will be indistinguishable from the "
"variable @code{ABC}, but internally it will be stored as @samp{string([65, "
"66, 67])} and can still be manipulated this way; for example, the selection "
"and vector commands @kbd{j 1 v v j u} would select the vector portion of "
"this object and reverse the elements, then deselect to reveal a string whose "
"characters had been reversed."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14816
msgid ""
"The composition functions do the same thing in all language modes (although "
"their components will of course be formatted in the current language mode).  "
"The one exception is Unformatted mode (@kbd{d U}), which does not give the "
"composition functions any special treatment.  The functions are discussed "
"here because of their relationship to the language modes."
msgstr ""

#. type: menuentry
#: ../../calc.texi:14824
msgid "Composition Basics::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:14824
msgid "Horizontal Compositions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:14824
msgid "Vertical Compositions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:14824
msgid "Other Compositions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:14824
msgid "Information about Compositions::"
msgstr ""

#. type: subsubsection
#: ../../calc.texi:14824 ../../calc.texi:15226 ../../calc.texi:15268 ../../calc.texi:15269
#, no-wrap
msgid "User-Defined Compositions"
msgstr ""

#. type: node
#: ../../calc.texi:14826 ../../calc.texi:14827 ../../calc.texi:14967
#, no-wrap
msgid "Composition Basics"
msgstr ""

#. type: node
#: ../../calc.texi:14826 ../../calc.texi:14967 ../../calc.texi:14968 ../../calc.texi:15011
#, no-wrap
msgid "Horizontal Compositions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14837
msgid ""
"Compositions are generally formed by stacking formulas together horizontally "
"or vertically in various ways.  Those formulas are themselves compositions.  "
"@TeX{} users will find this analogous to @TeX{}'s ``boxes.'' Each multi-line "
"composition has a @dfn{baseline}; horizontal compositions use the baselines "
"to decide how formulas should be positioned relative to one another.  For "
"example, in the Big mode formula"
msgstr ""

#. type: group
#: ../../calc.texi:14844
#, no-wrap
msgid ""
"          2\n"
"     a + b\n"
"17 + ------\n"
"       c\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14851
msgid ""
"the second term of the sum is four lines tall and has line three as its "
"baseline.  Thus when the term is combined with 17, line three is placed on "
"the same level as the baseline of 17."
msgstr ""

#. type: tex
#: ../../calc.texi:14854 ../../calc.texi:14917 ../../calc.texi:22519 ../../calc.texi:22528 ../../calc.texi:22593 ../../calc.texi:22639 ../../calc.texi:22683 ../../calc.texi:22738 ../../calc.texi:22753 ../../calc.texi:22829 ../../calc.texi:22844 ../../calc.texi:22883 ../../calc.texi:22902 ../../calc.texi:22929 ../../calc.texi:22955 ../../calc.texi:23017 ../../calc.texi:23079 ../../calc.texi:24475 ../../calc.texi:24526 ../../calc.texi:24602 ../../calc.texi:24634 ../../calc.texi:24734 ../../calc.texi:24896 ../../calc.texi:24959 ../../calc.texi:24971 ../../calc.texi:25098 ../../calc.texi:25132 ../../calc.texi:25196 ../../calc.texi:25361 ../../calc.texi:27018 ../../calc.texi:27073 ../../calc.texi:30753 ../../calc.texi:30795 ../../calc.texi:30812 ../../calc.texi:30881
#, no-wrap
msgid "\\bigskip\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14861
msgid ""
"Another important composition concept is @dfn{precedence}.  This is an "
"integer that represents the binding strength of various operators.  For "
"example, @samp{*} has higher precedence (195) than @samp{+} (180), which "
"means that @samp{(a * b) + c} will be formatted without the parentheses, but "
"@samp{a * (b + c)} will keep the parentheses."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14864
msgid ""
"The operator table used by normal and Big language modes has the following "
"precedences:"
msgstr ""

#. type: example
#: ../../calc.texi:14889
#, no-wrap
msgid ""
"_     1200    @r{(subscripts)}\n"
"%     1100    @r{(as in n}%@r{)}\n"
"!     1000    @r{(as in }!@r{n)}\n"
"mod    400\n"
"+/-    300\n"
"!!     210    @r{(as in n}!!@r{)}\n"
"!      210    @r{(as in n}!@r{)}\n"
"^      200\n"
"-      197    @r{(as in }-@r{n)}\n"
"*      195    @r{(or implicit multiplication)}\n"
"/ % \\  190\n"
"+ -    180    @r{(as in a}+@r{b)}\n"
"|      170\n"
"< =    160    @r{(and other relations)}\n"
"&&     110\n"
"||     100\n"
"? :     90\n"
"!!!     85\n"
"&&&     80\n"
"|||     75\n"
":=      50\n"
"::      45\n"
"=>      40\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14897
msgid ""
"The general rule is that if an operator with precedence @expr{n} occurs as "
"an argument to an operator with precedence @expr{m}, then the argument is "
"enclosed in parentheses if @expr{n < m}.  Top-level expressions and "
"expressions which are function arguments, vector components, etc., are "
"formatted with precedence zero (so that they normally never get additional "
"parentheses)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14904
msgid ""
"For binary left-associative operators like @samp{+}, the righthand argument "
"is actually formatted with one-higher precedence than shown in the table.  "
"This makes sure @samp{(a + b) + c} omits the parentheses, but the unnatural "
"form @samp{a + (b + c)} keeps its parentheses.  Right-associative operators "
"like @samp{^} format the lefthand argument with one-higher precedence."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14914
msgid ""
"@tindex cprec The @code{cprec} function formats an expression with an "
"arbitrary precedence.  For example, @samp{cprec(abc, 185)} will combine into "
"sums and products as follows: @samp{7 + abc}, @samp{7 (abc)} (because this "
"@code{cprec} form has higher precedence than addition, but lower precedence "
"than multiplication)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14927
msgid ""
"A final composition issue is @dfn{line breaking}.  Calc uses two different "
"strategies for ``flat'' and ``non-flat'' compositions.  A non-flat "
"composition is anything that appears on multiple lines (not counting line "
"breaking).  Examples would be matrices and Big mode powers and quotients.  "
"Non-flat compositions are displayed exactly as specified.  If they come out "
"wider than the current window, you must use horizontal scrolling (@kbd{<} "
"and @kbd{>}) to view them."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14937
msgid ""
"Flat compositions, on the other hand, will be broken across several lines if "
"they are too wide to fit the window.  Certain points in a composition are "
"noted internally as @dfn{break points}.  Calc's general strategy is to fill "
"each line as much as possible, then to move down to the next line starting "
"at the first break point that didn't fit.  However, the line breaker "
"understands the hierarchical structure of formulas.  It will not break an "
"``inner'' formula if it can use an earlier break point from an ``outer'' "
"formula instead.  For example, a vector of sums might be formatted as:"
msgstr ""

#. type: group
#: ../../calc.texi:14942
#, no-wrap
msgid ""
"[ a + b + c, d + e + f,\n"
"  g + h + i, j + k + l, m ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14951
msgid ""
"If the @samp{m} can fit, then so, it seems, could the @samp{g}.  But Calc "
"prefers to break at the comma since the comma is part of a ``more outer'' "
"formula.  Calc would break at a plus sign only if it had to, say, if the "
"very first sum in the vector had itself been too large to fit."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14957
msgid ""
"Of the composition functions described below, only @code{choriz} generates "
"break points.  The @code{bstring} function (@pxref{Strings})  also generates "
"breakable items: A break point is added after every space (or group of "
"spaces) except for spaces at the very beginning or end of the string."
msgstr ""

#. type: Plain text
#: ../../calc.texi:14966
msgid ""
"Composition functions themselves count as levels in the formula hierarchy, "
"so a @code{choriz} that is a component of a larger @code{choriz} will be "
"less likely to be broken.  As a special case, if a @code{bstring} occurs as "
"a component of a @code{choriz} or @code{choriz}-like object (such as a "
"vector or a list of arguments in a function call), then the break points in "
"that @code{bstring} will be on the same level as the break points of the "
"surrounding object."
msgstr ""

#. type: node
#: ../../calc.texi:14967 ../../calc.texi:15011 ../../calc.texi:15012 ../../calc.texi:15132
#, no-wrap
msgid "Vertical Compositions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14978
msgid ""
"@tindex choriz The @code{choriz} function takes a vector of objects and "
"composes them horizontally.  For example, @samp{choriz([17, a b/c, d])} "
"formats as @w{@samp{17a b / cd}} in Normal language mode, or as"
msgstr ""

#. type: group
#: ../../calc.texi:14984
#, no-wrap
msgid ""
"  a b\n"
"17---d\n"
"   c\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:14994
msgid ""
"in Big language mode.  This is actually one case of the general function "
"@samp{choriz(@var{vec}, @var{sep}, @var{prec})}, where either or both of "
"@var{sep} and @var{prec} may be omitted.  @var{Prec} gives the "
"@dfn{precedence} to use when formatting each of the components of "
"@var{vec}.  The default precedence is the precedence from the surrounding "
"environment."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15001
msgid ""
"@var{Sep} is a string (i.e., a vector of character codes as might be entered "
"with @code{\" \"} notation) which should separate components of the "
"composition.  Also, if @var{sep} is given, the line breaker will allow lines "
"to be broken after each occurrence of @var{sep}.  If @var{sep} is omitted, "
"the composition will not be breakable (unless any of its component "
"compositions are breakable)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15007
msgid ""
"For example, @samp{2 choriz([a, b c, d = e], \" + \", 180)} is formatted as "
"@samp{2 a + b c + (d = e)}.  To get the @code{choriz} to have precedence 180 "
"``outwards'' as well as ``inwards,'' enclose it in a @code{cprec} form: "
"@samp{2 cprec(choriz(...), 180)} formats as @samp{2 (a + b c + (d = e))}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15010
msgid ""
"The baseline of a horizontal composition is the same as the baselines of the "
"component compositions, which are all aligned."
msgstr ""

#. type: node
#: ../../calc.texi:15011 ../../calc.texi:15132 ../../calc.texi:15133 ../../calc.texi:15226
#, no-wrap
msgid "Other Compositions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15024
msgid ""
"@tindex cvert The @code{cvert} function makes a vertical composition.  Each "
"component of the vector is centered in a column.  The baseline of the result "
"is by default the top line of the resulting composition.  For example, "
"@samp{f(cvert([a, bb, ccc]), cvert([a^2 + 1, b^2]))} formats in Big mode as"
msgstr ""

#. type: group
#: ../../calc.texi:15031
#, no-wrap
msgid ""
"f( a ,  2    )\n"
"  bb   a  + 1\n"
"  ccc     2\n"
"         b\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15044
msgid ""
"@tindex cbase There are several special composition functions that work only "
"as components of a vertical composition.  The @code{cbase} function controls "
"the baseline of the vertical composition; the baseline will be the same as "
"the baseline of whatever component is enclosed in @code{cbase}.  Thus "
"@samp{f(cvert([a, cbase(bb), ccc]), cvert([a^2 + 1, cbase(b^2)]))} displays "
"as"
msgstr ""

#. type: group
#: ../../calc.texi:15052
#, no-wrap
msgid ""
"        2\n"
"       a  + 1\n"
"   a      2\n"
"f(bb ,   b   )\n"
"  ccc\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15059
msgid "@tindex ctbase"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15068
msgid ""
"@tindex cbbase There are also @code{ctbase} and @code{cbbase} functions "
"which make the baseline of the vertical composition equal to the top or "
"bottom line (rather than the baseline) of that component.  Thus "
"@samp{cvert([cbase(a / b)]) + cvert([ctbase(a / b)]) + cvert([cbbase(a / "
"b)])} gives"
msgstr ""

#. type: group
#: ../../calc.texi:15076
#, no-wrap
msgid ""
"        a\n"
"a       -\n"
"- + a + b\n"
"b   -\n"
"    b\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15085
msgid ""
"There should be only one @code{cbase}, @code{ctbase}, or @code{cbbase} "
"function in a given vertical composition.  These functions can also be "
"written with no arguments: @samp{ctbase()} is a zero-height object which "
"means the baseline is the top line of the following item, and "
"@samp{cbbase()} means the baseline is the bottom line of the preceding item."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15097
msgid ""
"@tindex crule The @code{crule} function builds a ``rule,'' or horizontal "
"line, across a vertical composition.  By itself @samp{crule()} uses @samp{-} "
"characters to build the rule.  You can specify any other character, e.g., "
"@samp{crule(\"=\")}.  The argument must be a character code or vector of "
"exactly one character code.  It is repeated to match the width of the widest "
"item in the stack.  For example, a quotient with a thick line is "
"@samp{cvert([a + 1, cbase(crule(\"=\")), b^2])}:"
msgstr ""

#. type: group
#: ../../calc.texi:15104
#, no-wrap
msgid ""
"a + 1\n"
"=====\n"
"  2\n"
" b\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15111
msgid "@tindex clvert"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15119
msgid ""
"@tindex crvert Finally, the functions @code{clvert} and @code{crvert} act "
"exactly like @code{cvert} except that the items are left- or right-justified "
"in the stack.  Thus @samp{clvert([a, bb, ccc]) + crvert([a, bb, ccc])} "
"gives:"
msgstr ""

#. type: group
#: ../../calc.texi:15125
#, no-wrap
msgid ""
"a   +   a\n"
"bb     bb\n"
"ccc   ccc\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15131
msgid ""
"Like @code{choriz}, the vertical compositions accept a second argument which "
"gives the precedence to use when formatting the components.  Vertical "
"compositions do not support separator strings."
msgstr ""

#. type: node
#: ../../calc.texi:15132 ../../calc.texi:15226 ../../calc.texi:15227 ../../calc.texi:15268
#, no-wrap
msgid "Information about Compositions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15145
msgid ""
"@tindex csup The @code{csup} function builds a superscripted expression.  "
"For example, @samp{csup(a, b)} looks the same as @samp{a^b} does in Big "
"language mode.  This is essentially a horizontal composition of @samp{a} and "
"@samp{b}, where @samp{b} is shifted up so that its bottom line is one above "
"the baseline."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15155
msgid ""
"@tindex csub Likewise, the @code{csub} function builds a subscripted "
"expression.  This shifts @samp{b} down so that its top line is one below the "
"bottom line of @samp{a} (note that this is not quite analogous to "
"@code{csup}).  Other arrangements can be obtained by using @code{choriz} and "
"@code{cvert} directly."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15165
msgid ""
"@tindex cflat The @code{cflat} function formats its argument in ``flat'' "
"mode, as obtained by @samp{d O}, if the current language mode is normal or "
"Big.  It has no effect in other language modes.  For example, @samp{a^(b/c)} "
"is formatted by Big mode like @samp{csup(a, cflat(b/c))} to improve its "
"readability."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15177
msgid ""
"@tindex cspace The @code{cspace} function creates horizontal space.  For "
"example, @samp{cspace(4)} is effectively the same as @samp{string(\" \")}.  "
"A second string (i.e., vector of characters) argument is repeated instead of "
"the space character.  For example, @samp{cspace(4, \"ab\")} looks like "
"@samp{abababab}.  If the second argument is not a string, it is formatted in "
"the normal way and then several copies of that are composed together: "
"@samp{cspace(4, a^2)} yields"
msgstr ""

#. type: group
#: ../../calc.texi:15182
#, no-wrap
msgid ""
" 2 2 2 2\n"
"a a a a\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15187
msgid "If the number argument is zero, this is a zero-width object."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15197
msgid ""
"@tindex cvspace The @code{cvspace} function creates vertical space, or a "
"vertical stack of copies of a certain string or formatted object.  The "
"baseline is the center line of the resulting stack.  A numerical argument of "
"zero will produce an object which contributes zero height if used in a "
"vertical composition."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15202
msgid "@tindex ctspace"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15211
msgid ""
"@tindex cbspace There are also @code{ctspace} and @code{cbspace} functions "
"which create vertical space with the baseline the same as the baseline of "
"the top or bottom copy, respectively, of the second argument.  Thus "
"@samp{cvspace(2, a/b) + ctspace(2, a/b) + cbspace(2, a/b)} displays as:"
msgstr ""

#. type: group
#: ../../calc.texi:15223
#, no-wrap
msgid ""
"        a\n"
"        -\n"
"a       b\n"
"-   a   a\n"
"b + - + -\n"
"a   b   b\n"
"-   a\n"
"b   -\n"
"    b\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15233
msgid ""
"The functions in this section are actual functions; they compose their "
"arguments according to the current language and other display modes, then "
"return a certain measurement of the composition as an integer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15243
msgid ""
"@tindex cwidth The @code{cwidth} function measures the width, in characters, "
"of a composition.  For example, @samp{cwidth(a + b)} is 5, and "
"@samp{cwidth(a / b)} is 5 in Normal mode, 1 in Big mode, and 11 in @TeX{} "
"mode (for @samp{@{a \\over b@}}).  The argument may involve the composition "
"functions described in this section."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15250
msgid ""
"@tindex cheight The @code{cheight} function measures the height of a "
"composition.  This is the total number of lines in the argument's printed "
"form."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15255
msgid "@tindex cascent"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15267
msgid ""
"@tindex cdescent The functions @code{cascent} and @code{cdescent} measure "
"the amount of the height that is above (and including) the baseline, or "
"below the baseline, respectively.  Thus @samp{cascent(@var{x}) + "
"cdescent(@var{x})} always equals @samp{cheight(@var{x})}.  For a one-line "
"formula like @samp{a + b}, @code{cascent} returns 1 and @code{cdescent} "
"returns 0.  For @samp{a / b} in Big mode, @code{cascent} returns 2 and "
"@code{cdescent} returns 1.  The only formula for which @code{cascent} will "
"return zero is @samp{cvspace(0)} or equivalents."
msgstr ""

#. type: kindex
#: ../../calc.texi:15272
#, no-wrap
msgid "Z C"
msgstr ""

#. type: pindex
#: ../../calc.texi:15273
#, no-wrap
msgid "calc-user-define-composition"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15281
msgid ""
"The @kbd{Z C} (@code{calc-user-define-composition}) command lets you define "
"the display format for any algebraic function.  You provide a formula "
"containing a certain number of argument variables on the stack.  Any time "
"Calc formats a call to the specified function in the current language mode "
"and with that number of arguments, Calc effectively replaces the function "
"call with that formula with the arguments replaced."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15288
msgid ""
"Calc builds the default argument list by sorting all the variable names that "
"appear in the formula into alphabetical order.  You can edit this argument "
"list before pressing @key{RET} if you wish.  Any variables in the formula "
"that do not appear in the argument list will be displayed literally; any "
"arguments that do not appear in the formula will not affect the display at "
"all."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15299
msgid ""
"You can define formats for built-in functions, for functions you have "
"defined with @kbd{Z F} (@pxref{Algebraic Definitions}), or for functions "
"which have no definitions but are being used as purely syntactic objects.  "
"You can define different formats for each language mode, and for each number "
"of arguments, using a succession of @kbd{Z C} commands.  When Calc formats a "
"function call, it first searches for a format defined for the current "
"language mode (and number of arguments); if there is none, it uses the "
"format defined for the Normal language mode.  If neither format exists, Calc "
"uses its built-in standard format for that function (usually just "
"@samp{@var{func}(@var{args})})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15303
msgid ""
"If you execute @kbd{Z C} with the number 0 on the stack instead of a "
"formula, any defined formats for the function in the current language mode "
"will be removed.  The function will revert to its standard format."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15306
msgid ""
"For example, the default format for the binomial coefficient function "
"@samp{choose(n, m)} in the Big language mode is"
msgstr ""

#. type: group
#: ../../calc.texi:15312
#, no-wrap
msgid ""
" n\n"
"( )\n"
" m\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15317
msgid "You might prefer the notation,"
msgstr ""

#. type: group
#: ../../calc.texi:15322
#, no-wrap
msgid ""
" C\n"
"n m\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15328
msgid ""
"To define this notation, first make sure you are in Big mode, then put the "
"formula"
msgstr ""

#. type: smallexample
#: ../../calc.texi:15331
#, no-wrap
msgid "choriz([cvert([cvspace(1), n]), C, cvert([cvspace(1), m])])\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15340
msgid ""
"on the stack and type @kbd{Z C}.  Answer the first prompt with "
"@code{choose}.  The second prompt will be the default argument list of "
"@samp{(C m n)}.  Edit this list to be @samp{(n m)} and press @key{RET}.  "
"Now, try it out: For example, turn simplification off with @kbd{m O} and "
"enter @samp{choose(a,b) + choose(7,3)} as an algebraic entry."
msgstr ""

#. type: group
#: ../../calc.texi:15345
#, no-wrap
msgid ""
" C  +  C\n"
"a b   7 3\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15352
msgid ""
"As another example, let's define the usual notation for Stirling numbers of "
"the first kind, @samp{stir1(n, m)}.  This is just like the regular format "
"for binomial coefficients but with square brackets instead of parentheses."
msgstr ""

#. type: smallexample
#: ../../calc.texi:15355
#, no-wrap
msgid "choriz([string(\"[\"), cvert([n, cbase(cvspace(1)), m]), string(\"]\")])\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15359
msgid ""
"Now type @kbd{Z C stir1 @key{RET}}, edit the argument list to @samp{(n m)}, "
"and type @key{RET}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15372
msgid ""
"The formula provided to @kbd{Z C} usually will involve composition "
"functions, but it doesn't have to.  Putting the formula @samp{a + b + c} "
"onto the stack and typing @kbd{Z C foo @key{RET} @key{RET}} would define the "
"function @samp{foo(x,y,z)} to display like @samp{x + y + z}.  This ``sum'' "
"will act exactly like a real sum for all formatting purposes (it will be "
"parenthesized the same, and so on).  However it will be computationally "
"unrelated to a sum.  For example, the formula @samp{2 * foo(1, 2, 3)} will "
"display as @samp{2 (1 + 2 + 3)}.  Operator precedences have caused the "
"``sum'' to be written in parentheses, but the arguments have not actually "
"been summed.  (Generally a display format like this would be undesirable, "
"since it can easily be confused with a real sum.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15385
msgid ""
"The special function @code{eval} can be used inside a @kbd{Z C} composition "
"formula to cause all or part of the formula to be evaluated at display "
"time.  For example, if the formula is @samp{a + eval(b + c)}, then "
"@samp{foo(1, 2, 3)} will be displayed as @samp{1 + 5}.  Evaluation will use "
"the default simplifications, regardless of the current simplification mode.  "
"There are also @code{evalsimp} and @code{evalextsimp} which simplify as if "
"by @kbd{a s} and @kbd{a e} (respectively).  Note that these ``functions'' "
"operate only in the context of composition formulas (and also in rewrite "
"rules, where they serve a similar purpose; @pxref{Rewrite Rules}).  On the "
"stack, a call to @code{eval} will be left in symbolic form."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15395
msgid ""
"It is not a good idea to use @code{eval} except as a last resort.  It can "
"cause the display of formulas to be extremely slow.  For example, while "
"@samp{eval(a + b)} might seem quite fast and simple, there are several "
"situations where it could be slow.  For example, @samp{a} and/or @samp{b} "
"could be polar complex numbers, in which case doing the sum requires "
"trigonometry.  Or, @samp{a} could be the factorial @samp{fact(100)} which is "
"unevaluated because you have typed @kbd{m O}; @code{eval} will evaluate it "
"anyway to produce a large, unwieldy integer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15398
msgid ""
"You can save your display formats permanently using the @kbd{Z P} command "
"(@pxref{Creating User Keys})."
msgstr ""

#. type: cindex
#: ../../calc.texi:15403
#, no-wrap
msgid "Syntax tables"
msgstr ""

#. type: cindex
#: ../../calc.texi:15404
#, no-wrap
msgid "Parsing formulas, customized"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15408
msgid ""
"Syntax tables do for input what compositions do for output: They allow you "
"to teach custom notations to Calc's formula parser.  Calc keeps a separate "
"syntax table for each language mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15411
msgid ""
"(Note that the Calc ``syntax tables'' discussed here are completely "
"unrelated to the syntax tables described in the Emacs manual.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:15412
#, no-wrap
msgid "Z S"
msgstr ""

#. type: pindex
#: ../../calc.texi:15413
#, no-wrap
msgid "calc-edit-user-syntax"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15421
msgid ""
"The @kbd{Z S} (@code{calc-edit-user-syntax}) command edits the syntax table "
"for the current language mode.  If you want your syntax to work in any "
"language, define it in the Normal language mode.  Type @kbd{C-c C-c} to "
"finish editing the syntax table, or @kbd{C-x k} to cancel the edit.  The "
"@kbd{m m} command saves all the syntax tables along with the other mode "
"settings; @pxref{General Mode Commands}."
msgstr ""

#. type: menuentry
#: ../../calc.texi:15427
msgid "Syntax Table Basics::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:15427
msgid "Precedence in Syntax Tables::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:15427
msgid "Advanced Syntax Patterns::"
msgstr ""

#. type: subsubsection
#: ../../calc.texi:15427 ../../calc.texi:15612 ../../calc.texi:15732 ../../calc.texi:15733
#, no-wrap
msgid "Conditional Syntax Rules"
msgstr ""

#. type: node
#: ../../calc.texi:15429 ../../calc.texi:15430 ../../calc.texi:15577
#, no-wrap
msgid "Syntax Table Basics"
msgstr ""

#. type: node
#: ../../calc.texi:15429 ../../calc.texi:15577 ../../calc.texi:15612
#, no-wrap
msgid "Precedence in Syntax Tables"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15443
msgid ""
"@dfn{Parsing} is the process of converting a raw string of characters, such "
"as you would type in during algebraic entry, into a Calc formula.  Calc's "
"parser works in two stages.  First, the input is broken down into "
"@dfn{tokens}, such as words, numbers, and punctuation symbols like @samp{+}, "
"@samp{:=}, and @samp{+/-}.  Space between tokens is ignored (except when it "
"serves to separate adjacent words).  Next, the parser matches this string of "
"tokens against various built-in syntactic patterns, such as ``an expression "
"followed by @samp{+} followed by another expression'' or ``a name followed "
"by @samp{(}, zero or more expressions separated by commas, and @samp{)}.''"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15454
msgid ""
"A @dfn{syntax table} is a list of user-defined @dfn{syntax rules}, which "
"allow you to specify new patterns to define your own favorite input "
"notations.  Calc's parser always checks the syntax table for the current "
"language mode, then the table for the Normal language mode, before it uses "
"its built-in rules to parse an algebraic formula you have entered.  Each "
"syntax rule should go on its own line; it consists of a @dfn{pattern}, a "
"@samp{:=} symbol, and a Calc formula with an optional @dfn{condition}.  "
"(Syntax rules resemble algebraic rewrite rules, but the notation for "
"patterns is completely different.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15458
msgid ""
"A syntax pattern is a list of tokens, separated by spaces.  Except for a few "
"special symbols, tokens in syntax patterns are matched literally, from left "
"to right.  For example, the rule,"
msgstr ""

#. type: example
#: ../../calc.texi:15461
#, no-wrap
msgid "foo ( ) := 2+3\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15476
msgid ""
"would cause Calc to parse the formula @samp{4+foo()*5} as if it were "
"@samp{4+(2+3)*5}.  Notice that the parentheses were written as two separate "
"tokens in the rule.  As a result, the rule works for both @samp{foo()} and "
"@w{@samp{foo ( )}}.  If we had written the rule as @samp{foo () := 2+3}, "
"then Calc would treat @samp{()} as a single, indivisible token, so that "
"@w{@samp{foo( )}} would not be recognized by the rule.  (It would be parsed "
"as a regular zero-argument function call instead.)  In fact, this rule would "
"also make trouble for the rest of Calc's parser: An unrelated formula like "
"@samp{bar()} would now be tokenized into @samp{bar ()} instead of @samp{bar "
"( )}, so that the standard parser for function calls would no longer "
"recognize it!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15480
msgid ""
"While it is possible to make a token with a mixture of letters and "
"punctuation symbols, this is not recommended.  It is better to break it into "
"several tokens, as we did with @samp{foo()} above."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15487
msgid ""
"The symbol @samp{#} in a syntax pattern matches any Calc expression.  On the "
"righthand side, the things that matched the @samp{#}s can be referred to as "
"@samp{#1}, @samp{#2}, and so on (where @samp{#1} matches the leftmost "
"@samp{#} in the pattern).  For example, these rules match a user-defined "
"function, prefix operator, infix operator, and postfix operator, "
"respectively:"
msgstr ""

#. type: example
#: ../../calc.texi:15493
#, no-wrap
msgid ""
"foo ( # ) := myfunc(#1)\n"
"foo # := myprefix(#1)\n"
"# foo # := myinfix(#1,#2)\n"
"# foo := mypostfix(#1)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15497
msgid ""
"Thus @samp{foo(3)} will parse as @samp{myfunc(3)}, and @samp{2+3 foo} will "
"parse as @samp{mypostfix(2+3)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15510
msgid ""
"It is important to write the first two rules in the order shown, because "
"Calc tries rules in order from first to last.  If the pattern @samp{foo #} "
"came first, it would match anything that could match the @samp{foo ( # )} "
"rule, since an expression in parentheses is itself a valid expression.  Thus "
"the @w{@samp{foo ( # )}} rule would never get to match anything.  Likewise, "
"the last two rules must be written in the order shown or else @samp{3 foo 4} "
"will be parsed as @samp{mypostfix(3) * 4}.  (Of course, the best way to "
"avoid these ambiguities is not to use the same symbol in more than one way "
"at the same time! In case you're not convinced, try the following exercise: "
"How will the above rules parse the input @samp{foo(3,4)}, if at all? Work it "
"out for yourself, then try it in Calc and see.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15519
msgid ""
"Calc is quite flexible about what sorts of patterns are allowed.  The only "
"rule is that every pattern must begin with a literal token (like @samp{foo} "
"in the first two patterns above), or with a @samp{#} followed by a literal "
"token (as in the last two patterns).  After that, any mixture is allowed, "
"although putting two @samp{#}s in a row will not be very useful since two "
"expressions with nothing between them will be parsed as one expression that "
"uses implicit multiplication."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15524
msgid ""
"As a more practical example, Maple uses the notation @samp{sum(a(i), "
"i=1..10)} for sums, which Calc's Maple mode doesn't recognize at present.  "
"To handle this syntax, we simply add the rule,"
msgstr ""

#. type: example
#: ../../calc.texi:15527
#, no-wrap
msgid "sum ( # , # = # .. # ) := sum(#1,#2,#3,#4)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15533
msgid ""
"to the Maple mode syntax table.  As another example, C mode can't read "
"assignment operators like @samp{++} and @samp{*=}.  We can define these "
"operators quite easily:"
msgstr ""

#. type: example
#: ../../calc.texi:15538
#, no-wrap
msgid ""
"# *= # := muleq(#1,#2)\n"
"# ++ := postinc(#1)\n"
"++ # := preinc(#1)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15545
msgid ""
"To complete the job, we would use corresponding composition functions and "
"@kbd{Z C} to cause these functions to display in their respective Maple and "
"C notations.  (Note that the C example ignores issues of operator "
"precedence, which are discussed in the next section.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15548
msgid ""
"You can enclose any token in quotes to prevent its usual interpretation in "
"syntax patterns:"
msgstr ""

#. type: example
#: ../../calc.texi:15551
#, no-wrap
msgid "# \":=\" # := becomes(#1,#2)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15558
msgid ""
"Quotes also allow you to include spaces in a token, although once again it "
"is generally better to use two tokens than one token with an embedded "
"space.  To include an actual quotation mark in a quoted token, precede it "
"with a backslash.  (This also works to include backslashes in tokens.)"
msgstr ""

#. type: example
#: ../../calc.texi:15561
#, no-wrap
msgid "# \"bad token\" # \"/\\\"\\\\\" # := silly(#1,#2,#3)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15565
msgid "This will parse @samp{3 bad token 4 /\"\\ 5} to @samp{silly(3,4,5)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15573
msgid ""
"The token @kbd{#} has a predefined meaning in Calc's formula parser; it is "
"not valid to use @samp{\"#\"} in a syntax rule.  However, longer tokens that "
"include the @samp{#} character are allowed.  Also, while @samp{\"$\"} and "
"@samp{\"\\\"\"} are allowed as tokens, their presence in the syntax table "
"will prevent those characters from working in their usual ways (referring to "
"stack entries and quoting strings, respectively)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15576
msgid ""
"Finally, the notation @samp{%%} anywhere in a syntax table causes the rest "
"of the line to be ignored as a comment."
msgstr ""

#. type: node
#: ../../calc.texi:15577 ../../calc.texi:15612 ../../calc.texi:15613 ../../calc.texi:15732
#, no-wrap
msgid "Advanced Syntax Patterns"
msgstr ""

#. type: subsubsection
#: ../../calc.texi:15578
#, no-wrap
msgid "Precedence"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15583
msgid ""
"Different operators are generally assigned different @dfn{precedences}.  By "
"default, an operator defined by a rule like"
msgstr ""

#. type: example
#: ../../calc.texi:15586
#, no-wrap
msgid "# foo # := foo(#1,#2)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15595
msgid ""
"will have an extremely low precedence, so that @samp{2*3+4 foo 5 == 6} will "
"be parsed as @samp{(2*3+4) foo (5 == 6)}.  To change the precedence of an "
"operator, use the notation @samp{#/@var{p}} in place of @samp{#}, where "
"@var{p} is an integer precedence level.  For example, 185 lies between the "
"precedences for @samp{+} and @samp{*}, so if we change this rule to"
msgstr ""

#. type: example
#: ../../calc.texi:15598
#, no-wrap
msgid "#/185 foo #/186 := foo(#1,#2)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15607
msgid ""
"then @samp{2+3 foo 4*5} will be parsed as @samp{2+(3 foo (4*5))}.  Also, "
"because we've given the righthand expression slightly higher precedence, our "
"new operator will be left-associative: @samp{1 foo 2 foo 3} will be parsed "
"as @samp{(1 foo 2) foo 3}.  By raising the precedence of the lefthand "
"expression instead, we can create a right-associative operator."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15611
msgid ""
"@xref{Composition Basics}, for a table of precedences of the standard Calc "
"operators.  For the precedences of operators in other language modes, look "
"in the Calc source file @file{calc-lang.el}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15618
msgid "To match a function with a variable number of arguments, you could write"
msgstr ""

#. type: example
#: ../../calc.texi:15623
#, no-wrap
msgid ""
"foo ( # ) := myfunc(#1)\n"
"foo ( # , # ) := myfunc(#1,#2)\n"
"foo ( # , # , # ) := myfunc(#1,#2,#3)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15629
msgid ""
"but this isn't very elegant.  To match variable numbers of items, Calc uses "
"some notations inspired regular expressions and the ``extended BNF'' style "
"used by some language designers."
msgstr ""

#. type: example
#: ../../calc.texi:15632
#, no-wrap
msgid "foo ( @{ # @}*, ) := apply(myfunc,#1)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15642
msgid ""
"The token @samp{@{} introduces a repeated or optional portion.  One of the "
"three tokens @samp{@}*}, @samp{@}+}, or @samp{@}?} ends the portion.  These "
"will match zero or more, one or more, or zero or one copies of the enclosed "
"pattern, respectively.  In addition, @samp{@}*} and @samp{@}+} can be "
"followed by a separator token (with no space in between, as shown above).  "
"Thus @samp{@{ # @}*,} matches nothing, or one expression, or several "
"expressions separated by commas."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15649
msgid ""
"A complete @samp{@{ ... @}} item matches as a vector of the items that "
"matched inside it.  For example, the above rule will match @samp{foo(1,2,3)} "
"to get @samp{apply(myfunc,[1,2,3])}.  The Calc @code{apply} function takes a "
"function name and a vector of arguments and builds a call to the function "
"with those arguments, so the net result is the formula @samp{myfunc(1,2,3)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15655
msgid ""
"If the body of a @samp{@{ ... @}} contains several @samp{#}s (or nested "
"@samp{@{ ... @}} constructs), then the items will be strung together into "
"the resulting vector.  If the body does not contain anything but literal "
"tokens, the result will always be an empty vector."
msgstr ""

#. type: example
#: ../../calc.texi:15659
#, no-wrap
msgid ""
"foo ( @{ # , # @}+, ) := bar(#1)\n"
"foo ( @{ @{ # @}*, @}*; ) := matrix(#1)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15667
msgid ""
"will parse @samp{foo(1, 2, 3, 4)} as @samp{bar([1, 2, 3, 4])}, and "
"@samp{foo(1, 2; 3, 4)} as @samp{matrix([[1, 2], [3, 4]])}.  Also, after some "
"thought it's easy to see how this pair of rules will parse @samp{foo(1, 2, "
"3)} as @samp{matrix([[1, 2, 3]])}, since the first rule will only match an "
"even number of arguments.  The rule"
msgstr ""

#. type: example
#: ../../calc.texi:15670
#, no-wrap
msgid "foo ( # @{ , # , # @}? ) := bar(#1,#2)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15675
msgid ""
"will parse @samp{foo(2,3,4)} as @samp{bar(2,[3,4])}, and @samp{foo(2)} as "
"@samp{bar(2,[])}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15679
msgid ""
"The notation @samp{@{ ... @}?.} (note the trailing period) works just the "
"same as regular @samp{@{ ... @}?}, except that it does not count as an "
"argument; the following two rules are equivalent:"
msgstr ""

#. type: example
#: ../../calc.texi:15683
#, no-wrap
msgid ""
"foo ( # , @{ also @}? # ) := bar(#1,#3)\n"
"foo ( # , @{ also @}?. # ) := bar(#1,#2)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15689
msgid ""
"Note that in the first case the optional text counts as @samp{#2}, which "
"will always be an empty vector, but in the second case no empty vector is "
"produced."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15702
msgid ""
"Another variant is @samp{@{ ... @}?$}, which means the body is optional only "
"at the end of the input formula.  All built-in syntax rules in Calc use this "
"for closing delimiters, so that during algebraic entry you can type "
"@kbd{[sqrt(2), sqrt(3 @key{RET}}, omitting the closing parenthesis and "
"bracket.  Calc does this automatically for trailing @samp{)}, @samp{]}, and "
"@samp{>} tokens in syntax rules, but you can use @samp{@{ ... @}?$} "
"explicitly to get this effect with any token (such as @samp{\"@}\"} or "
"@samp{end}).  Like @samp{@{ ... @}?.}, this notation does not count as an "
"argument.  Conversely, you can use quotes, as in @samp{\")\"}, to prevent a "
"closing-delimiter token from being automatically treated as optional."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15705
msgid ""
"Calc's parser does not have full backtracking, which means some patterns "
"will not work as you might expect:"
msgstr ""

#. type: example
#: ../../calc.texi:15708
#, no-wrap
msgid "foo ( @{ # , @}? # , # ) := bar(#1,#2,#3)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15718
msgid ""
"Here we are trying to make the first argument optional, so that "
"@samp{foo(2,3)} parses as @samp{bar([],2,3)}.  Unfortunately, Calc first "
"tries to match @samp{2,} against the optional part of the pattern, finds a "
"match, and so goes ahead to match the rest of the pattern.  Later on it will "
"fail to match the second comma, but it doesn't know how to go back and try "
"the other alternative at that point.  One way to get around this would be to "
"use two rules:"
msgstr ""

#. type: example
#: ../../calc.texi:15722
#, no-wrap
msgid ""
"foo ( # , # , # ) := bar([#1],#2,#3)\n"
"foo ( # , # ) := bar([],#1,#2)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15731
msgid ""
"More precisely, when Calc wants to match an optional or repeated part of a "
"pattern, it scans forward attempting to match that part.  If it reaches the "
"end of the optional part without failing, it ``finalizes'' its choice and "
"proceeds.  If it fails, though, it backs up and tries the other "
"alternative.  Thus Calc has ``partial'' backtracking.  A fully backtracking "
"parser would go on to make sure the rest of the pattern matched before "
"finalizing the choice."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15738
msgid ""
"It is possible to attach a @dfn{condition} to a syntax rule.  For example, "
"the rules"
msgstr ""

#. type: example
#: ../../calc.texi:15742
#, no-wrap
msgid ""
"foo ( # ) := ifoo(#1) :: integer(#1)\n"
"foo ( # ) := gfoo(#1)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15751
msgid ""
"will parse @samp{foo(3)} as @samp{ifoo(3)}, but will parse @samp{foo(3.5)} "
"and @samp{foo(x)} as calls to @code{gfoo}.  Any number of conditions may be "
"attached; all must be true for the rule to succeed.  A condition is ``true'' "
"if it evaluates to a nonzero number.  @xref{Logical Operations}, for a list "
"of Calc functions like @code{integer} that perform logical tests."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15763
msgid ""
"The exact sequence of events is as follows: When Calc tries a rule, it first "
"matches the pattern as usual.  It then substitutes @samp{#1}, @samp{#2}, "
"etc., in the conditions, if any.  Next, the conditions are simplified and "
"evaluated in order from left to right, using the algebraic simplifications "
"(@pxref{Simplifying Formulas}).  Each result is true if it is a nonzero "
"number, or an expression that can be proven to be nonzero "
"(@pxref{Declarations}).  If the results of all conditions are true, the "
"expression (such as @samp{ifoo(#1)}) has its @samp{#}s substituted, and that "
"is the result of the parse.  If the result of any condition is false, Calc "
"goes on to try the next rule in the syntax table."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15770
msgid ""
"Syntax rules also support @code{let} conditions, which operate in exactly "
"the same way as they do in algebraic rewrite rules.  @xref{Other Features of "
"Rewrite Rules}, for details.  A @code{let} condition is always true, but as "
"a side effect it defines a variable which can be used in later conditions, "
"and also in the expression after the @samp{:=} sign:"
msgstr ""

#. type: example
#: ../../calc.texi:15773
#, no-wrap
msgid "foo ( # ) := hifoo(x) :: let(x := #1 + 0.5) :: dnumint(x)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15780
msgid ""
"The @code{dnumint} function tests if a value is numerically an integer, "
"i.e., either a true integer or an integer-valued float.  This rule will "
"parse @code{foo} with a half-integer argument, like @samp{foo(3.5)}, to a "
"call like @samp{hifoo(4.)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15784
msgid ""
"The lefthand side of a syntax rule @code{let} must be a simple variable, not "
"the arbitrary pattern that is allowed in rewrite rules."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15791
msgid ""
"The @code{matches} function is also treated specially in syntax rule "
"conditions (again, in the same way as in rewrite rules).  @xref{Matching "
"Commands}.  If the matching pattern contains meta-variables, then those "
"meta-variables may be used in later conditions and in the result "
"expression.  The arguments to @code{matches} are not evaluated in this "
"situation."
msgstr ""

#. type: example
#: ../../calc.texi:15794
#, no-wrap
msgid "sum ( # , # ) := sum(#1,a,b,c) :: matches(#2, a=[b..c])\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15805
msgid ""
"This is another way to implement the Maple mode @code{sum} notation.  In "
"this approach, we allow @samp{#2} to equal the whole expression "
"@samp{i=1..10}.  Then, we use @code{matches} to break it apart into its "
"components.  If the expression turns out not to match the pattern, the "
"syntax rule will fail.  Note that @kbd{Z S} always uses Calc's Normal "
"language mode for editing expressions in syntax rules, so we must use "
"regular Calc notation for the interval @samp{[b..c]} that will correspond to "
"the Maple mode interval @samp{1..10}."
msgstr ""

#. type: section
#: ../../calc.texi:15807
#, no-wrap
msgid "The @code{Modes} Variable"
msgstr ""

#. type: kindex
#: ../../calc.texi:15810
#, no-wrap
msgid "m g"
msgstr ""

#. type: pindex
#: ../../calc.texi:15811
#, no-wrap
msgid "calc-get-modes"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15818
msgid ""
"The @kbd{m g} (@code{calc-get-modes}) command pushes onto the stack a vector "
"of numbers that describes the various mode settings that are in effect.  "
"With a numeric prefix argument, it pushes only the @var{n}th mode, i.e., the "
"@var{n}th element of this vector.  Keyboard macros can use the @kbd{m g} "
"command to modify their behavior based on the current mode settings."
msgstr ""

#. type: cindex
#: ../../calc.texi:15819
#, no-wrap
msgid "@code{Modes} variable"
msgstr ""

#. type: vindex
#: ../../calc.texi:15820
#, no-wrap
msgid "Modes"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15826
msgid ""
"The modes vector is also available in the special variable @code{Modes}.  In "
"other words, @kbd{m g} is like @kbd{s r Modes @key{RET}}.  It will not work "
"to store into this variable; in fact, if you do, @code{Modes} will cease to "
"track the current modes.  (The @kbd{m g} command will continue to work, "
"however.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15831
msgid ""
"In general, each number in this vector is suitable as a numeric prefix "
"argument to the associated mode-setting command.  (Recall that the @kbd{~} "
"key takes a number from the stack and gives it as a numeric prefix to the "
"next command.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15833
msgid "The elements of the modes vector are as follows:"
msgstr ""

#. type: enumerate
#: ../../calc.texi:15837
msgid "Current precision.  Default is 12; associated command is @kbd{p}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:15840
msgid "Binary word size.  Default is 32; associated command is @kbd{b w}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:15844
msgid ""
"Stack size (not counting the value about to be pushed by @kbd{m g}).  This "
"is zero if @kbd{m g} is executed with an empty stack."
msgstr ""

#. type: enumerate
#: ../../calc.texi:15847
msgid "Number radix.  Default is 10; command is @kbd{d r}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:15859
msgid ""
"Floating-point format.  This is the number of digits, plus the constant 0 "
"for normal notation, 10000 for scientific notation, 20000 for engineering "
"notation, or 30000 for fixed-point notation.  These codes are acceptable as "
"prefix arguments to the @kbd{d n} command, but note that this may lose "
"information: For example, @kbd{d s} and @kbd{C-u 12 d s} have similar (but "
"not quite identical) effects if the current precision is 12, but they both "
"produce a code of 10012, which will be treated by @kbd{d n} as @kbd{C-u 12 d "
"s}.  If the precision then changes, the float format will still be frozen at "
"12 significant figures."
msgstr ""

#. type: enumerate
#: ../../calc.texi:15863
msgid ""
"Angular mode.  Default is 1 (degrees).  Other values are 2 (radians)  and 3 "
"(HMS).  The @kbd{m d} command accepts these prefixes."
msgstr ""

#. type: enumerate
#: ../../calc.texi:15866
msgid "Symbolic mode.  Value is 0 or 1; default is 0.  Command is @kbd{m s}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:15869
msgid "Fraction mode.  Value is 0 or 1; default is 0.  Command is @kbd{m f}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:15873
msgid ""
"Polar mode.  Value is 0 (rectangular) or 1 (polar); default is 0.  Command "
"is @kbd{m p}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:15881
msgid ""
"Matrix/Scalar mode.  Default value is @mathit{-1}.  Value is 0 for Scalar "
"mode, @mathit{-2} for Matrix mode, @mathit{-3} for square Matrix mode, or "
"@var{N} for @texline @math{N\\times N} @infoline @var{N}x@var{N} Matrix "
"mode.  Command is @kbd{m v}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:15886
msgid ""
"Simplification mode.  Default is 1.  Value is @mathit{-1} for off (@kbd{m "
"O}), 0 for @kbd{m N}, 2 for @kbd{m B}, 3 for @kbd{m A}, 4 for @kbd{m E}, or "
"5 for @w{@kbd{m U}}.  The @kbd{m D} command accepts these prefixes."
msgstr ""

#. type: enumerate
#: ../../calc.texi:15890
msgid ""
"Infinite mode.  Default is @mathit{-1} (off).  Value is 1 if the mode is on, "
"or 0 if the mode is on with positive zeros.  Command is @kbd{m i}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15897
msgid ""
"For example, the sequence @kbd{M-1 m g @key{RET} 2 + ~ p} increases the "
"precision by two, leaving a copy of the old precision on the stack.  Later, "
"@kbd{~ p} will restore the original precision using that stack value.  (This "
"sequence might be especially useful inside a keyboard macro.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15900
msgid ""
"As another example, @kbd{M-3 m g 1 - ~ @key{DEL}} deletes all but the oldest "
"(bottommost) stack entry."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15907
msgid ""
"Yet another example: The HP-48 ``round'' command rounds a number to the "
"current displayed precision.  You could roughly emulate this in Calc with "
"the sequence @kbd{M-5 m g 10000 % ~ c c}.  (This would not work for "
"fixed-point mode, but it wouldn't be hard to do a full emulation with the "
"help of the @kbd{Z [} and @kbd{Z ]} programming commands.  "
"@xref{Conditionals in Macros}.)"
msgstr ""

#. type: section
#: ../../calc.texi:15909
#, no-wrap
msgid "The Calc Mode Line"
msgstr ""

#. type: cindex
#: ../../calc.texi:15912
#, no-wrap
msgid "Mode line indicators"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15916
msgid ""
"This section is a summary of all symbols that can appear on the Calc mode "
"line, the highlighted bar that appears under the Calc stack window (or under "
"an editing window in Embedded mode)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15918
msgid "The basic mode line format is:"
msgstr ""

#. type: example
#: ../../calc.texi:15921
#, no-wrap
msgid "--%*-Calc: 12 Deg @var{other modes}       (Calculator)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:15926
msgid ""
"The @samp{%*} indicates that the buffer is ``read-only''; it shows that "
"regular Emacs commands are not allowed to edit the stack buffer as if it "
"were text."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15930
msgid ""
"The word @samp{Calc:} changes to @samp{CalcEmbed:} if Embedded mode is "
"enabled.  The words after this describe the various Calc modes that are in "
"effect."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15934
msgid ""
"The first mode is always the current precision, an integer.  The second mode "
"is always the angular mode, either @code{Deg}, @code{Rad}, or @code{Hms}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:15937
msgid ""
"Here is a complete list of the remaining symbols that can appear on the mode "
"line:"
msgstr ""

#. type: item
#: ../../calc.texi:15939
#, no-wrap
msgid "Alg"
msgstr ""

#. type: table
#: ../../calc.texi:15941
msgid "Algebraic mode (@kbd{m a}; @pxref{Algebraic Entry})."
msgstr ""

#. type: item
#: ../../calc.texi:15942
#, no-wrap
msgid "Alg[("
msgstr ""

#. type: table
#: ../../calc.texi:15944
msgid "Incomplete algebraic mode (@kbd{C-u m a})."
msgstr ""

#. type: item
#: ../../calc.texi:15945
#, no-wrap
msgid "Alg*"
msgstr ""

#. type: table
#: ../../calc.texi:15947
msgid "Total algebraic mode (@kbd{m t})."
msgstr ""

#. type: item
#: ../../calc.texi:15948
#, no-wrap
msgid "Symb"
msgstr ""

#. type: table
#: ../../calc.texi:15950
msgid "Symbolic mode (@kbd{m s}; @pxref{Symbolic Mode})."
msgstr ""

#. type: item
#: ../../calc.texi:15951
#, no-wrap
msgid "Matrix"
msgstr ""

#. type: table
#: ../../calc.texi:15953
msgid "Matrix mode (@kbd{m v}; @pxref{Matrix Mode})."
msgstr ""

#. type: item
#: ../../calc.texi:15954
#, no-wrap
msgid "Matrix@var{n}"
msgstr ""

#. type: table
#: ../../calc.texi:15956
msgid "Dimensioned Matrix mode (@kbd{C-u @var{n} m v}; @pxref{Matrix Mode})."
msgstr ""

#. type: item
#: ../../calc.texi:15957
#, no-wrap
msgid "SqMatrix"
msgstr ""

#. type: table
#: ../../calc.texi:15959
msgid "Square Matrix mode (@kbd{C-u m v}; @pxref{Matrix Mode})."
msgstr ""

#. type: item
#: ../../calc.texi:15960
#, no-wrap
msgid "Scalar"
msgstr ""

#. type: table
#: ../../calc.texi:15962
msgid "Scalar mode (@kbd{m v}; @pxref{Matrix Mode})."
msgstr ""

#. type: item
#: ../../calc.texi:15963
#, no-wrap
msgid "Polar"
msgstr ""

#. type: table
#: ../../calc.texi:15965
msgid "Polar complex mode (@kbd{m p}; @pxref{Polar Mode})."
msgstr ""

#. type: item
#: ../../calc.texi:15966
#, no-wrap
msgid "Frac"
msgstr ""

#. type: table
#: ../../calc.texi:15968
msgid "Fraction mode (@kbd{m f}; @pxref{Fraction Mode})."
msgstr ""

#. type: item
#: ../../calc.texi:15969
#, no-wrap
msgid "Inf"
msgstr ""

#. type: table
#: ../../calc.texi:15971
msgid "Infinite mode (@kbd{m i}; @pxref{Infinite Mode})."
msgstr ""

#. type: item
#: ../../calc.texi:15972
#, no-wrap
msgid "+Inf"
msgstr ""

#. type: table
#: ../../calc.texi:15974
msgid "Positive Infinite mode (@kbd{C-u 0 m i})."
msgstr ""

#. type: item
#: ../../calc.texi:15975
#, no-wrap
msgid "NoSimp"
msgstr ""

#. type: table
#: ../../calc.texi:15977
msgid "Default simplifications off (@kbd{m O}; @pxref{Simplification Modes})."
msgstr ""

#. type: item
#: ../../calc.texi:15978
#, no-wrap
msgid "NumSimp"
msgstr ""

#. type: table
#: ../../calc.texi:15980
msgid "Default simplifications for numeric arguments only (@kbd{m N})."
msgstr ""

#. type: item
#: ../../calc.texi:15981
#, no-wrap
msgid "BinSimp@var{w}"
msgstr ""

#. type: table
#: ../../calc.texi:15983
msgid ""
"Binary-integer simplification mode; word size @var{w} (@kbd{m B}, @kbd{b "
"w})."
msgstr ""

#. type: item
#: ../../calc.texi:15984
#, no-wrap
msgid "BasicSimp"
msgstr ""

#. type: table
#: ../../calc.texi:15986
msgid "Basic simplification mode (@kbd{m I})."
msgstr ""

#. type: item
#: ../../calc.texi:15987
#, no-wrap
msgid "ExtSimp"
msgstr ""

#. type: table
#: ../../calc.texi:15989
msgid "Extended algebraic simplification mode (@kbd{m E})."
msgstr ""

#. type: item
#: ../../calc.texi:15990
#, no-wrap
msgid "UnitSimp"
msgstr ""

#. type: table
#: ../../calc.texi:15992
msgid "Units simplification mode (@kbd{m U})."
msgstr ""

#. type: item
#: ../../calc.texi:15993
#, no-wrap
msgid "Bin"
msgstr ""

#. type: table
#: ../../calc.texi:15995
msgid "Current radix is 2 (@kbd{d 2}; @pxref{Radix Modes})."
msgstr ""

#. type: item
#: ../../calc.texi:15996
#, no-wrap
msgid "Oct"
msgstr ""

#. type: table
#: ../../calc.texi:15998
msgid "Current radix is 8 (@kbd{d 8})."
msgstr ""

#. type: item
#: ../../calc.texi:15999
#, no-wrap
msgid "Hex"
msgstr ""

#. type: table
#: ../../calc.texi:16001
msgid "Current radix is 16 (@kbd{d 6})."
msgstr ""

#. type: item
#: ../../calc.texi:16002
#, no-wrap
msgid "Radix@var{n}"
msgstr ""

#. type: table
#: ../../calc.texi:16004
msgid "Current radix is @var{n} (@kbd{d r})."
msgstr ""

#. type: item
#: ../../calc.texi:16005
#, no-wrap
msgid "Zero"
msgstr ""

#. type: table
#: ../../calc.texi:16007
msgid "Leading zeros (@kbd{d z}; @pxref{Radix Modes})."
msgstr ""

#. type: item
#: ../../calc.texi:16008
#, no-wrap
msgid "Big"
msgstr ""

#. type: table
#: ../../calc.texi:16010
msgid "Big language mode (@kbd{d B}; @pxref{Normal Language Modes})."
msgstr ""

#. type: item
#: ../../calc.texi:16011
#, no-wrap
msgid "Flat"
msgstr ""

#. type: table
#: ../../calc.texi:16013
msgid "One-line normal language mode (@kbd{d O})."
msgstr ""

#. type: item
#: ../../calc.texi:16014
#, no-wrap
msgid "Unform"
msgstr ""

#. type: table
#: ../../calc.texi:16016
msgid "Unformatted language mode (@kbd{d U})."
msgstr ""

#. type: table
#: ../../calc.texi:16019
msgid "C language mode (@kbd{d C}; @pxref{C FORTRAN Pascal})."
msgstr ""

#. type: item
#: ../../calc.texi:16020
#, no-wrap
msgid "Pascal"
msgstr ""

#. type: table
#: ../../calc.texi:16022
msgid "Pascal language mode (@kbd{d P})."
msgstr ""

#. type: item
#: ../../calc.texi:16023
#, no-wrap
msgid "Fortran"
msgstr ""

#. type: table
#: ../../calc.texi:16025
msgid "FORTRAN language mode (@kbd{d F})."
msgstr ""

#. type: item
#: ../../calc.texi:16026
#, no-wrap
msgid "TeX"
msgstr ""

#. type: table
#: ../../calc.texi:16028
msgid "@TeX{} language mode (@kbd{d T}; @pxref{TeX and LaTeX Language Modes})."
msgstr ""

#. type: item
#: ../../calc.texi:16029
#, no-wrap
msgid "LaTeX"
msgstr ""

#. type: table
#: ../../calc.texi:16031
msgid "@LaTeX{} language mode (@kbd{d L}; @pxref{TeX and LaTeX Language Modes})."
msgstr ""

#. type: item
#: ../../calc.texi:16032
#, no-wrap
msgid "Eqn"
msgstr ""

#. type: table
#: ../../calc.texi:16034
msgid "@dfn{Eqn} language mode (@kbd{d E}; @pxref{Eqn Language Mode})."
msgstr ""

#. type: item
#: ../../calc.texi:16035
#, no-wrap
msgid "Math"
msgstr ""

#. type: table
#: ../../calc.texi:16037
msgid "Mathematica language mode (@kbd{d M}; @pxref{Mathematica Language Mode})."
msgstr ""

#. type: item
#: ../../calc.texi:16038
#, no-wrap
msgid "Maple"
msgstr ""

#. type: table
#: ../../calc.texi:16040
msgid "Maple language mode (@kbd{d W}; @pxref{Maple Language Mode})."
msgstr ""

#. type: item
#: ../../calc.texi:16041
#, no-wrap
msgid "Norm@var{n}"
msgstr ""

#. type: table
#: ../../calc.texi:16043
msgid "Normal float mode with @var{n} digits (@kbd{d n}; @pxref{Float Formats})."
msgstr ""

#. type: item
#: ../../calc.texi:16044
#, no-wrap
msgid "Fix@var{n}"
msgstr ""

#. type: table
#: ../../calc.texi:16046
msgid "Fixed point mode with @var{n} digits after the point (@kbd{d f})."
msgstr ""

#. type: item
#: ../../calc.texi:16047
#, no-wrap
msgid "Sci"
msgstr ""

#. type: table
#: ../../calc.texi:16049
msgid "Scientific notation mode (@kbd{d s})."
msgstr ""

#. type: item
#: ../../calc.texi:16050
#, no-wrap
msgid "Sci@var{n}"
msgstr ""

#. type: table
#: ../../calc.texi:16052
msgid "Scientific notation with @var{n} digits (@kbd{d s})."
msgstr ""

#. type: item
#: ../../calc.texi:16053
#, no-wrap
msgid "Eng"
msgstr ""

#. type: table
#: ../../calc.texi:16055
msgid "Engineering notation mode (@kbd{d e})."
msgstr ""

#. type: item
#: ../../calc.texi:16056
#, no-wrap
msgid "Eng@var{n}"
msgstr ""

#. type: table
#: ../../calc.texi:16058
msgid "Engineering notation with @var{n} digits (@kbd{d e})."
msgstr ""

#. type: item
#: ../../calc.texi:16059
#, no-wrap
msgid "Left@var{n}"
msgstr ""

#. type: table
#: ../../calc.texi:16061
msgid ""
"Left-justified display indented by @var{n} (@kbd{d <}; "
"@pxref{Justification})."
msgstr ""

#. type: item
#: ../../calc.texi:16062
#, no-wrap
msgid "Right"
msgstr ""

#. type: table
#: ../../calc.texi:16064
msgid "Right-justified display (@kbd{d >})."
msgstr ""

#. type: item
#: ../../calc.texi:16065
#, no-wrap
msgid "Right@var{n}"
msgstr ""

#. type: table
#: ../../calc.texi:16067
msgid "Right-justified display with width @var{n} (@kbd{d >})."
msgstr ""

#. type: item
#: ../../calc.texi:16068
#, no-wrap
msgid "Center"
msgstr ""

#. type: table
#: ../../calc.texi:16070
msgid "Centered display (@kbd{d =})."
msgstr ""

#. type: item
#: ../../calc.texi:16071
#, no-wrap
msgid "Center@var{n}"
msgstr ""

#. type: table
#: ../../calc.texi:16073
msgid "Centered display with center column @var{n} (@kbd{d =})."
msgstr ""

#. type: item
#: ../../calc.texi:16074
#, no-wrap
msgid "Wid@var{n}"
msgstr ""

#. type: table
#: ../../calc.texi:16076
msgid "Line breaking with width @var{n} (@kbd{d b}; @pxref{Normal Language Modes})."
msgstr ""

#. type: item
#: ../../calc.texi:16077
#, no-wrap
msgid "Wide"
msgstr ""

#. type: table
#: ../../calc.texi:16079
msgid "No line breaking (@kbd{d b})."
msgstr ""

#. type: item
#: ../../calc.texi:16080
#, no-wrap
msgid "Break"
msgstr ""

#. type: table
#: ../../calc.texi:16082
msgid "Selections show deep structure (@kbd{j b}; @pxref{Making Selections})."
msgstr ""

#. type: item
#: ../../calc.texi:16083
#, no-wrap
msgid "Save"
msgstr ""

#. type: table
#: ../../calc.texi:16085
msgid ""
"Record modes in @file{~/.emacs.d/calc.el} (@kbd{m R}; @pxref{General Mode "
"Commands})."
msgstr ""

#. type: item
#: ../../calc.texi:16086
#, no-wrap
msgid "Local"
msgstr ""

#. type: table
#: ../../calc.texi:16088
msgid "Record modes in Embedded buffer (@kbd{m R})."
msgstr ""

#. type: item
#: ../../calc.texi:16089
#, no-wrap
msgid "LocEdit"
msgstr ""

#. type: table
#: ../../calc.texi:16091
msgid "Record modes as editing-only in Embedded buffer (@kbd{m R})."
msgstr ""

#. type: item
#: ../../calc.texi:16092
#, no-wrap
msgid "LocPerm"
msgstr ""

#. type: table
#: ../../calc.texi:16094
msgid "Record modes as permanent-only in Embedded buffer (@kbd{m R})."
msgstr ""

#. type: item
#: ../../calc.texi:16095
#, no-wrap
msgid "Global"
msgstr ""

#. type: table
#: ../../calc.texi:16097
msgid "Record modes as global in Embedded buffer (@kbd{m R})."
msgstr ""

#. type: item
#: ../../calc.texi:16098
#, no-wrap
msgid "Manual"
msgstr ""

#. type: table
#: ../../calc.texi:16101
msgid ""
"Automatic recomputation turned off (@kbd{m C}; @pxref{Automatic "
"Recomputation})."
msgstr ""

#. type: item
#: ../../calc.texi:16102
#, no-wrap
msgid "Graph"
msgstr ""

#. type: table
#: ../../calc.texi:16104
msgid "GNUPLOT process is alive in background (@pxref{Graphics})."
msgstr ""

#. type: item
#: ../../calc.texi:16105
#, no-wrap
msgid "Sel"
msgstr ""

#. type: table
#: ../../calc.texi:16107
msgid "Top-of-stack has a selection (Embedded only; @pxref{Making Selections})."
msgstr ""

#. type: item
#: ../../calc.texi:16108
#, no-wrap
msgid "Dirty"
msgstr ""

#. type: table
#: ../../calc.texi:16110
msgid "The stack display may not be up-to-date (@pxref{Display Modes})."
msgstr ""

#. type: item
#: ../../calc.texi:16111
#, no-wrap
msgid "Inv"
msgstr ""

#. type: table
#: ../../calc.texi:16113
msgid "``Inverse'' prefix was pressed (@kbd{I}; @pxref{Inverse and Hyperbolic})."
msgstr ""

#. type: item
#: ../../calc.texi:16114
#, no-wrap
msgid "Hyp"
msgstr ""

#. type: table
#: ../../calc.texi:16116
msgid "``Hyperbolic'' prefix was pressed (@kbd{H})."
msgstr ""

#. type: item
#: ../../calc.texi:16117
#, no-wrap
msgid "Keep"
msgstr ""

#. type: table
#: ../../calc.texi:16119
msgid "``Keep-arguments'' prefix was pressed (@kbd{K})."
msgstr ""

#. type: item
#: ../../calc.texi:16120
#, no-wrap
msgid "Narrow"
msgstr ""

#. type: table
#: ../../calc.texi:16122
msgid "Stack is truncated (@kbd{d t}; @pxref{Truncating the Stack})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16126
msgid ""
"In addition, the symbols @code{Active} and @code{~Active} can appear as "
"minor modes on an Embedded buffer's mode line.  @xref{Embedded Mode}."
msgstr ""

#. type: chapter
#: ../../calc.texi:16128
#, no-wrap
msgid "Arithmetic Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16138
msgid ""
"This chapter describes the Calc commands for doing simple calculations on "
"numbers, such as addition, absolute value, and square roots.  These commands "
"work by removing the top one or two values from the stack, performing the "
"desired operation, and pushing the result back onto the stack.  If the "
"operation cannot be performed, the result pushed is a formula instead of a "
"number, such as @samp{2/0} (because division by zero is invalid) or "
"@samp{sqrt(x)} (because the argument @samp{x} is a formula)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16142
msgid ""
"Most of the commands described here can be invoked by a single keystroke.  "
"Some of the more obscure ones are two-letter sequences beginning with the "
"@kbd{f} (``functions'') prefix key."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16146 ../../calc.texi:18301
msgid ""
"@xref{Prefix Arguments}, for a discussion of the effect of numeric prefix "
"arguments on commands in this chapter which do not otherwise interpret a "
"prefix argument."
msgstr ""

#. type: menuentry
#: ../../calc.texi:16155
msgid "Basic Arithmetic::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:16155
msgid "Integer Truncation::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:16155
msgid "Complex Number Functions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:16155
msgid "Conversions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:16155
msgid "Date Arithmetic::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:16155
msgid "Financial Functions::"
msgstr ""

#. type: node
#: ../../calc.texi:16155 ../../calc.texi:17513 ../../calc.texi:18064
#, no-wrap
msgid "Binary Functions"
msgstr ""

#. type: node
#: ../../calc.texi:16157 ../../calc.texi:16158 ../../calc.texi:16514
#, no-wrap
msgid "Basic Arithmetic"
msgstr ""

#. type: node
#: ../../calc.texi:16157 ../../calc.texi:16514 ../../calc.texi:16515 ../../calc.texi:16637
#, no-wrap
msgid "Integer Truncation"
msgstr ""

#. type: kindex
#: ../../calc.texi:16161
#, no-wrap
msgid "+"
msgstr ""

#. type: pindex
#: ../../calc.texi:16162
#, no-wrap
msgid "calc-plus"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16170
msgid ""
"@tindex + The @kbd{+} (@code{calc-plus}) command adds two numbers.  The "
"numbers may be any of the standard Calc data types.  The resulting sum is "
"pushed back onto the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16181
msgid ""
"If both arguments of @kbd{+} are vectors or matrices (of matching "
"dimensions), the result is a vector or matrix sum.  If one argument is a "
"vector and the other a scalar (i.e., a non-vector), the scalar is added to "
"each of the elements of the vector to form a new vector.  If the scalar is "
"not a number, the operation is left in symbolic form: Suppose you added "
"@samp{x} to the vector @samp{[1,2]}.  You may want the result "
"@samp{[1+x,2+x]}, or you may plan to substitute a 2-vector for @samp{x} in "
"the future.  Since the Calculator can't tell which interpretation you want, "
"it makes the safest assumption.  @xref{Reducing and Mapping}, for a way to "
"add @samp{x} to every element of a vector."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16187
msgid ""
"If either argument of @kbd{+} is a complex number, the result will in "
"general be complex.  If one argument is in rectangular form and the other "
"polar, the current Polar mode determines the form of the result.  If "
"Symbolic mode is enabled, the sum may be left as a formula if the necessary "
"conversions for polar addition are non-trivial."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16193
msgid ""
"If both arguments of @kbd{+} are HMS forms, the forms are added according to "
"the usual conventions of hours-minutes-seconds notation.  If one argument is "
"an HMS form and the other is a number, that number is converted from degrees "
"or radians (depending on the current Angular mode) to HMS format and then "
"the two HMS forms are added."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16202
msgid ""
"If one argument of @kbd{+} is a date form, the other can be either a real "
"number, which advances the date by a certain number of days, or an HMS form, "
"which advances the date by a certain amount of time.  Subtracting two date "
"forms yields the number of days between them.  Adding two date forms is "
"meaningless, but Calc interprets it as the subtraction of one date form and "
"the negative of the other.  (The negative of a date form can be understood "
"by remembering that dates are stored as the number of days before or after "
"Jan 1, 1 AD.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16211
msgid ""
"If both arguments of @kbd{+} are error forms, the result is an error form "
"with an appropriately computed standard deviation.  If one argument is an "
"error form and the other is a number, the number is taken to have zero "
"error.  Error forms may have symbolic formulas as their mean and/or error "
"parts; adding these will produce a symbolic error form result.  However, "
"adding an error form to a plain symbolic formula (as in @samp{(a +/- b) + "
"c}) will not work, for the same reasons just mentioned for vectors.  Instead "
"you must write @samp{(a +/- b) + (c +/- 0)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16216
msgid ""
"If both arguments of @kbd{+} are modulo forms with equal values of @expr{M}, "
"or if one argument is a modulo form and the other a plain number, the result "
"is a modulo form which represents the sum, modulo @expr{M}, of the two "
"values."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16221
msgid ""
"If both arguments of @kbd{+} are intervals, the result is an interval which "
"describes all possible sums of the possible input values.  If one argument "
"is a plain number, it is treated as the interval @w{@samp{[x ..@: x]}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16226
msgid ""
"If one argument of @kbd{+} is an infinity and the other is not, the result "
"is that same infinity.  If both arguments are infinite and in the same "
"direction, the result is the same infinity, but if they are infinite in "
"different directions the result is @code{nan}."
msgstr ""

#. type: kindex
#: ../../calc.texi:16227
#, no-wrap
msgid "-"
msgstr ""

#. type: pindex
#: ../../calc.texi:16228
#, no-wrap
msgid "calc-minus"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16237
msgid ""
"@tindex - The @kbd{-} (@code{calc-minus}) command subtracts two values.  The "
"top number on the stack is subtracted from the one behind it, so that the "
"computation @kbd{5 @key{RET} 2 -} produces 3, not @mathit{-3}.  All options "
"available for @kbd{+} are available for @kbd{-} as well."
msgstr ""

#. type: pindex
#: ../../calc.texi:16239
#, no-wrap
msgid "calc-times"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16253
msgid ""
"@tindex * The @kbd{*} (@code{calc-times}) command multiplies two numbers.  "
"If one argument is a vector and the other a scalar, the scalar is multiplied "
"by the elements of the vector to produce a new vector.  If both arguments "
"are vectors, the interpretation depends on the dimensions of the vectors: If "
"both arguments are matrices, a matrix multiplication is done.  If one "
"argument is a matrix and the other a plain vector, the vector is interpreted "
"as a row vector or column vector, whichever is dimensionally correct.  If "
"both arguments are plain vectors, the result is a single scalar number which "
"is the dot product of the two vectors."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16262
msgid ""
"If one argument of @kbd{*} is an HMS form and the other a number, the HMS "
"form is multiplied by that amount.  It is an error to multiply two HMS forms "
"together, or to attempt any multiplication involving date forms.  Error "
"forms, modulo forms, and intervals can be multiplied; see the comments for "
"addition of those forms.  When two error forms or intervals are multiplied "
"they are considered to be statistically independent; thus, @samp{[-2 ..@: 3] "
"* [-2 ..@: 3]} is @samp{[-6 ..@: 9]}, whereas @w{@samp{[-2 ..@: 3] ^ 2}} is "
"@samp{[0 ..@: 9]}."
msgstr ""

#. type: kindex
#: ../../calc.texi:16263
#, no-wrap
msgid "/"
msgstr ""

#. type: pindex
#: ../../calc.texi:16264
#, no-wrap
msgid "calc-divide"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16270
msgid "@tindex / The @kbd{/} (@code{calc-divide}) command divides two numbers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16284
msgid ""
"When combining multiplication and division in an algebraic formula, it is "
"good style to use parentheses to distinguish between possible "
"interpretations; the expression @samp{a/b*c} should be written "
"@samp{(a/b)*c} or @samp{a/(b*c)}, as appropriate.  Without the parentheses, "
"Calc will interpret @samp{a/b*c} as @samp{a/(b*c)}, since in algebraic entry "
"Calc gives division a lower precedence than multiplication. (This is not "
"standard across all computer languages, and Calc may change the precedence "
"depending on the language mode being used.  @xref{Language Modes}.)  This "
"default ordering can be changed by setting the customizable variable "
"@code{calc-multiplication-has-precedence} to @code{nil} (@pxref{Customizing "
"Calc}); this will give multiplication and division equal precedences.  Note "
"that Calc's default choice of precedence allows @samp{a b / c d} to be used "
"as a shortcut for"
msgstr ""

#. type: group
#: ../../calc.texi:16289
#, no-wrap
msgid ""
"a b\n"
"---.\n"
"c d\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16306
msgid ""
"When dividing a scalar @expr{B} by a square matrix @expr{A}, the computation "
"performed is @expr{B} times the inverse of @expr{A}.  This also occurs if "
"@expr{B} is itself a vector or matrix, in which case the effect is to solve "
"the set of linear equations represented by @expr{B}.  If @expr{B} is a "
"matrix with the same number of rows as @expr{A}, or a plain vector (which is "
"interpreted here as a column vector), then the equation @expr{A X = B} is "
"solved for the vector or matrix @expr{X}.  Otherwise, if @expr{B} is a "
"non-square matrix with the same number of @emph{columns} as @expr{A}, the "
"equation @expr{X A = B} is solved.  If you wish a vector @expr{B} to be "
"interpreted as a row vector to be solved as @expr{X A = B}, make it into a "
"one-row matrix with @kbd{C-u 1 v p} first.  To force a left-handed solution "
"with a square matrix @expr{B}, transpose @expr{A} and @expr{B} before "
"dividing, then transpose the result."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16313
msgid ""
"HMS forms can be divided by real numbers or by other HMS forms.  Error forms "
"can be divided in any combination of ways.  Modulo forms where both values "
"and the modulo are integers can be divided to get an integer modulo form "
"result.  Intervals can be divided; dividing by an interval that encompasses "
"zero or has zero as a limit will result in an infinite interval."
msgstr ""

#. type: item
#: ../../calc.texi:16314 ../../calc.texi:24843
#, no-wrap
msgid "^"
msgstr ""

#. type: pindex
#: ../../calc.texi:16315
#, no-wrap
msgid "calc-power"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16326
msgid ""
"@tindex ^ The @kbd{^} (@code{calc-power}) command raises a number to a "
"power.  If the power is an integer, an exact result is computed using "
"repeated multiplications.  For non-integer powers, Calc uses Newton's method "
"or logarithms and exponentials.  Square matrices can be raised to integer "
"powers.  If either argument is an error (or interval or modulo) form, the "
"result is also an error (or interval or modulo) form."
msgstr ""

#. type: kindex
#: ../../calc.texi:16327
#, no-wrap
msgid "I ^"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16332
msgid ""
"@tindex nroot If you press the @kbd{I} (inverse) key first, the @kbd{I ^} "
"command computes an Nth root: @kbd{125 @key{RET} 3 I ^} computes the number "
"5.  (This is entirely equivalent to @kbd{125 @key{RET} 1:3 ^}.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:16333
#, no-wrap
msgid "\\"
msgstr ""

#. type: pindex
#: ../../calc.texi:16334
#, no-wrap
msgid "calc-idiv"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16336
msgid "@tindex idiv"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16346
msgid ""
"@tindex \\ The @kbd{\\} (@code{calc-idiv}) command divides two numbers on "
"the stack to produce an integer result.  It is equivalent to dividing with "
"@kbd{/}, then rounding down with @kbd{F} (@code{calc-floor}), only a bit "
"more convenient and efficient.  Also, since it is an all-integer operation "
"when the arguments are integers, it avoids problems that @kbd{/ F} would "
"have with floating-point roundoff."
msgstr ""

#. type: kindex
#: ../../calc.texi:16347
#, no-wrap
msgid "%"
msgstr ""

#. type: pindex
#: ../../calc.texi:16348
#, no-wrap
msgid "calc-mod"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16360
msgid ""
"@tindex % The @kbd{%} (@code{calc-mod}) command performs a ``modulo'' (or "
"``remainder'')  operation.  Mathematically, @samp{a%b = a - (a\\b)*b}, and "
"is defined for all real numbers @expr{a} and @expr{b} (except @expr{b=0}).  "
"For positive @expr{b}, the result will always be between 0 (inclusive) and "
"@expr{b} (exclusive).  Modulo does not work for HMS forms and error forms.  "
"If @expr{a} is a modulo form, its modulo is changed to @expr{b}, which must "
"be positive real number."
msgstr ""

#. type: pindex
#: ../../calc.texi:16362
#, no-wrap
msgid "calc-fdiv"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16372
msgid ""
"@tindex fdiv The @kbd{:} (@code{calc-fdiv}) [@code{fdiv}] command divides "
"the two integers on the top of the stack to produce a fractional result.  "
"This is a convenient shorthand for enabling Fraction mode (with @kbd{m f}) "
"temporarily and using @samp{/}.  Note that during numeric entry the @kbd{:} "
"key is interpreted as a fraction separator, so to divide 8 by 6 you would "
"have to type @kbd{8 @key{RET} 6 @key{RET} :}.  (Of course, in this case, it "
"would be much easier simply to enter the fraction directly as @kbd{8:6 "
"@key{RET}}!)"
msgstr ""

#. type: pindex
#: ../../calc.texi:16374
#, no-wrap
msgid "calc-change-sign"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16378
msgid ""
"The @kbd{n} (@code{calc-change-sign}) command negates the number on the top "
"of the stack.  It works on numbers, vectors and matrices, HMS forms, date "
"forms, error forms, intervals, and modulo forms."
msgstr ""

#. type: pindex
#: ../../calc.texi:16380
#, no-wrap
msgid "calc-abs"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16391
msgid ""
"@tindex abs The @kbd{A} (@code{calc-abs}) [@code{abs}] command computes the "
"absolute value of a number.  The result of @code{abs} is always a "
"nonnegative real number: With a complex argument, it computes the complex "
"magnitude.  With a vector or matrix argument, it computes the Frobenius "
"norm, i.e., the square root of the sum of the squares of the absolute values "
"of the elements.  The absolute value of an error form is defined by "
"replacing the mean part with its absolute value and leaving the error part "
"the same.  The absolute value of a modulo form is undefined.  The absolute "
"value of an interval is defined in the obvious way."
msgstr ""

#. type: kindex
#: ../../calc.texi:16392
#, no-wrap
msgid "f A"
msgstr ""

#. type: pindex
#: ../../calc.texi:16393
#, no-wrap
msgid "calc-abssqr"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16397
msgid ""
"@tindex abssqr The @kbd{f A} (@code{calc-abssqr}) [@code{abssqr}] command "
"computes the absolute value squared of a number, vector or matrix, or error "
"form."
msgstr ""

#. type: kindex
#: ../../calc.texi:16398
#, no-wrap
msgid "f s"
msgstr ""

#. type: pindex
#: ../../calc.texi:16399
#, no-wrap
msgid "calc-sign"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16406
msgid ""
"@tindex sign The @kbd{f s} (@code{calc-sign}) [@code{sign}] command returns "
"1 if its argument is positive, @mathit{-1} if its argument is negative, or 0 "
"if its argument is zero.  In algebraic form, you can also write "
"@samp{sign(a,x)} which evaluates to @samp{x * sign(a)}, i.e., either "
"@samp{x}, @samp{-x}, or zero depending on the sign of @samp{a}."
msgstr ""

#. type: kindex
#: ../../calc.texi:16407
#, no-wrap
msgid "&"
msgstr ""

#. type: pindex
#: ../../calc.texi:16408
#, no-wrap
msgid "calc-inv"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16410
msgid "@tindex inv"
msgstr ""

#. type: cindex
#: ../../calc.texi:16410
#, no-wrap
msgid "Reciprocal"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16414
msgid ""
"The @kbd{&} (@code{calc-inv}) [@code{inv}] command computes the reciprocal "
"of a number, i.e., @expr{1 / x}.  Operating on a square matrix, it computes "
"the inverse of that matrix."
msgstr ""

#. type: pindex
#: ../../calc.texi:16416
#, no-wrap
msgid "calc-sqrt"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16421
msgid ""
"@tindex sqrt The @kbd{Q} (@code{calc-sqrt}) [@code{sqrt}] command computes "
"the square root of a number.  For a negative real argument, the result will "
"be a complex number whose form is determined by the current Polar mode."
msgstr ""

#. type: kindex
#: ../../calc.texi:16422
#, no-wrap
msgid "f h"
msgstr ""

#. type: pindex
#: ../../calc.texi:16423
#, no-wrap
msgid "calc-hypot"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16430
msgid ""
"@tindex hypot The @kbd{f h} (@code{calc-hypot}) [@code{hypot}] command "
"computes the square root of the sum of the squares of two numbers.  That is, "
"@samp{hypot(a,b)} is the length of the hypotenuse of a right triangle with "
"sides @expr{a} and @expr{b}.  If the arguments are complex numbers, their "
"squared magnitudes are used."
msgstr ""

#. type: kindex
#: ../../calc.texi:16431
#, no-wrap
msgid "f Q"
msgstr ""

#. type: pindex
#: ../../calc.texi:16432
#, no-wrap
msgid "calc-isqrt"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16441
msgid ""
"@tindex isqrt The @kbd{f Q} (@code{calc-isqrt}) [@code{isqrt}] command "
"computes the integer square root of an integer.  This is the true square "
"root of the number, rounded down to an integer.  For example, "
"@samp{isqrt(10)} produces 3.  Note that, like @kbd{\\} [@code{idiv}], this "
"uses exact integer arithmetic throughout to avoid roundoff problems.  If the "
"input is a floating-point number or other non-integer value, this is exactly "
"the same as @samp{floor(sqrt(x))}."
msgstr ""

#. type: kindex
#: ../../calc.texi:16442
#, no-wrap
msgid "f n"
msgstr ""

#. type: kindex
#: ../../calc.texi:16443
#, no-wrap
msgid "f x"
msgstr ""

#. type: pindex
#: ../../calc.texi:16444
#, no-wrap
msgid "calc-min"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16446
msgid "@tindex min"
msgstr ""

#. type: pindex
#: ../../calc.texi:16446
#, no-wrap
msgid "calc-max"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16454
msgid ""
"@tindex max The @kbd{f n} (@code{calc-min}) [@code{min}] and @kbd{f x} "
"(@code{calc-max})  [@code{max}] commands take the minimum or maximum of two "
"real numbers, respectively.  These commands also work on HMS forms, date "
"forms, intervals, and infinities.  (In algebraic expressions, these "
"functions take any number of arguments and return the maximum or minimum "
"among all the arguments.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:16455
#, no-wrap
msgid "f M"
msgstr ""

#. type: kindex
#: ../../calc.texi:16456
#, no-wrap
msgid "f X"
msgstr ""

#. type: pindex
#: ../../calc.texi:16457
#, no-wrap
msgid "calc-mant-part"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16459
msgid "@tindex mant"
msgstr ""

#. type: pindex
#: ../../calc.texi:16459
#, no-wrap
msgid "calc-xpon-part"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16474
msgid ""
"@tindex xpon The @kbd{f M} (@code{calc-mant-part}) [@code{mant}] function "
"extracts the ``mantissa'' part @expr{m} of its floating-point argument; "
"@kbd{f X} (@code{calc-xpon-part}) [@code{xpon}] extracts the ``exponent'' "
"part @expr{e}.  The original number is equal to @texline @math{m \\times "
"10^e}, @infoline @expr{m * 10^e}, where @expr{m} is in the interval "
"@samp{[1.0 ..@: 10.0)} except that @expr{m=e=0} if the original number is "
"zero.  For integers and fractions, @code{mant} returns the number unchanged "
"and @code{xpon} returns zero.  The @kbd{v u} (@code{calc-unpack}) command "
"can also be used to ``unpack'' a floating-point number; this produces an "
"integer mantissa and exponent, with the constraint that the mantissa is not "
"a multiple of ten (again except for the @expr{m=e=0} case)."
msgstr ""

#. type: kindex
#: ../../calc.texi:16475
#, no-wrap
msgid "f S"
msgstr ""

#. type: pindex
#: ../../calc.texi:16476
#, no-wrap
msgid "calc-scale-float"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16483
msgid ""
"@tindex scf The @kbd{f S} (@code{calc-scale-float}) [@code{scf}] function "
"scales a number by a given power of ten.  Thus, @samp{scf(mant(x), xpon(x)) "
"= x} for any real @samp{x}.  The second argument must be an integer, but the "
"first may actually be any numeric value.  For example, @samp{scf(5,-2) = "
"0.05} or @samp{1:20} depending on the current Fraction mode."
msgstr ""

#. type: kindex
#: ../../calc.texi:16484
#, no-wrap
msgid "f ["
msgstr ""

#. type: kindex
#: ../../calc.texi:16485
#, no-wrap
msgid "f ]"
msgstr ""

#. type: pindex
#: ../../calc.texi:16486
#, no-wrap
msgid "calc-decrement"
msgstr ""

#. type: pindex
#: ../../calc.texi:16487
#, no-wrap
msgid "calc-increment"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16503
msgid ""
"@tindex decr @tindex incr The @kbd{f [} (@code{calc-decrement}) "
"[@code{decr}] and @kbd{f ]} (@code{calc-increment}) [@code{incr}] functions "
"decrease or increase a number by one unit.  For integers, the effect is "
"obvious.  For floating-point numbers, the change is by one unit in the last "
"place.  For example, incrementing @samp{12.3456} when the current precision "
"is 6 digits yields @samp{12.3457}.  If the current precision had been 8 "
"digits, the result would have been @samp{12.345601}.  Incrementing "
"@samp{0.0} produces @texline @math{10^{-p}}, @infoline @expr{10^-p}, where "
"@expr{p} is the current precision.  These operations are defined only on "
"integers and floats.  With numeric prefix arguments, they change the number "
"by @expr{n} units."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16510
msgid ""
"Note that incrementing followed by decrementing, or vice-versa, will almost "
"but not quite always cancel out.  Suppose the precision is 6 digits and the "
"number @samp{9.99999} is on the stack.  Incrementing will produce "
"@samp{10.0000}; decrementing will produce @samp{9.9999}.  One digit has been "
"dropped.  This is an unavoidable consequence of the way floating-point "
"numbers work."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16513
msgid ""
"Incrementing a date/time form adjusts it by a certain number of seconds.  "
"Incrementing a pure date form adjusts it by a certain number of days."
msgstr ""

#. type: node
#: ../../calc.texi:16514 ../../calc.texi:16637 ../../calc.texi:16638 ../../calc.texi:16705
#, no-wrap
msgid "Complex Number Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16523
msgid ""
"There are four commands for truncating a real number to an integer, "
"differing mainly in their treatment of negative numbers.  All of these "
"commands have the property that if the argument is an integer, the result is "
"the same integer.  An integer-valued floating-point argument is converted to "
"integer form."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16526
msgid ""
"If you press @kbd{H} (@code{calc-hyperbolic}) first, the result will be "
"expressed as an integer-valued floating-point number."
msgstr ""

#. type: cindex
#: ../../calc.texi:16527
#, no-wrap
msgid "Integer part of a number"
msgstr ""

#. type: pindex
#: ../../calc.texi:16529
#, no-wrap
msgid "calc-floor"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16532
msgid "@tindex floor @tindex ffloor"
msgstr ""

#. type: kindex
#: ../../calc.texi:16535
#, no-wrap
msgid "H F"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16540
msgid ""
"The @kbd{F} (@code{calc-floor}) [@code{floor} or @code{ffloor}] command "
"truncates a real number to the next lower integer, i.e., toward minus "
"infinity.  Thus @kbd{3.6 F} produces 3, but @kbd{_3.6 F} produces "
"@mathit{-4}."
msgstr ""

#. type: kindex
#: ../../calc.texi:16541
#, no-wrap
msgid "I F"
msgstr ""

#. type: pindex
#: ../../calc.texi:16542
#, no-wrap
msgid "calc-ceiling"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16545
msgid "@tindex ceil @tindex fceil"
msgstr ""

#. type: kindex
#: ../../calc.texi:16548
#, no-wrap
msgid "H I F"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16552
msgid ""
"The @kbd{I F} (@code{calc-ceiling}) [@code{ceil} or @code{fceil}] command "
"truncates toward positive infinity.  Thus @kbd{3.6 I F} produces 4, and "
"@kbd{_3.6 I F} produces @mathit{-3}."
msgstr ""

#. type: pindex
#: ../../calc.texi:16554
#, no-wrap
msgid "calc-round"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16557
msgid "@tindex round @tindex fround"
msgstr ""

#. type: kindex
#: ../../calc.texi:16560
#, no-wrap
msgid "H R"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16566
msgid ""
"The @kbd{R} (@code{calc-round}) [@code{round} or @code{fround}] command "
"rounds to the nearest integer.  When the fractional part is .5 exactly, this "
"command rounds away from zero.  (All other rounding in the Calculator uses "
"this convention as well.)  Thus @kbd{3.5 R} produces 4 but @kbd{3.4 R} "
"produces 3; @kbd{_3.5 R} produces @mathit{-4}."
msgstr ""

#. type: kindex
#: ../../calc.texi:16567
#, no-wrap
msgid "I R"
msgstr ""

#. type: pindex
#: ../../calc.texi:16568
#, no-wrap
msgid "calc-trunc"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16571
msgid "@tindex trunc @tindex ftrunc"
msgstr ""

#. type: kindex
#: ../../calc.texi:16574
#, no-wrap
msgid "H I R"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16579
msgid ""
"The @kbd{I R} (@code{calc-trunc}) [@code{trunc} or @code{ftrunc}] command "
"truncates toward zero.  In other words, it ``chops off'' everything after "
"the decimal point.  Thus @kbd{3.6 I R} produces 3 and @kbd{_3.6 I R} "
"produces @mathit{-3}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16586
msgid ""
"These functions may not be applied meaningfully to error forms, but they do "
"work for intervals.  As a convenience, applying @code{floor} to a modulo "
"form floors the value part of the form.  Applied to a vector, these "
"functions operate on all elements of the vector one by one.  Applied to a "
"date form, they operate on the internal numerical representation of dates, "
"converting a date/time form into a pure date."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16591
msgid "@tindex rounde"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16595
msgid "@tindex roundu"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16599
msgid "@tindex frounde"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16618
msgid ""
"@tindex froundu There are two more rounding functions which can only be "
"entered in algebraic notation.  The @code{roundu} function is like "
"@code{round} except that it rounds up, toward plus infinity, when the "
"fractional part is .5.  This distinction matters only for negative "
"arguments.  Also, @code{rounde} rounds to an even number in the case of a "
"tie, rounding up or down as necessary.  For example, @samp{rounde(3.5)} and "
"@samp{rounde(4.5)} both return 4, but @samp{rounde(5.5)} returns 6.  The "
"advantage of round-to-even is that the net error due to rounding after a "
"long calculation tends to cancel out to zero.  An important subtle point "
"here is that the number being fed to @code{rounde} will already have been "
"rounded to the current precision before @code{rounde} begins.  For example, "
"@samp{rounde(2.500001)} with a current precision of 6 will incorrectly, or "
"at least surprisingly, yield 2 because the argument will first have been "
"rounded down to @expr{2.5} (which @code{rounde} sees as an exact tie between "
"2 and 3)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16626
msgid ""
"Each of these functions, when written in algebraic formulas, allows a second "
"argument which specifies the number of digits after the decimal point to "
"keep.  For example, @samp{round(123.4567, 2)} will produce the answer "
"123.46, and @samp{round(123.4567, -1)} will produce 120 (i.e., the cutoff is "
"one digit to the @emph{left} of the decimal point).  A second argument of "
"zero is equivalent to no second argument at all."
msgstr ""

#. type: cindex
#: ../../calc.texi:16627
#, no-wrap
msgid "Fractional part of a number"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16631
msgid ""
"To compute the fractional part of a number (i.e., the amount which, when "
"added to `@tfn{floor(}@var{n}@tfn{)}', will produce @var{n}) just take "
"@var{n} modulo 1 using the @code{%} command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16636
msgid ""
"Note also the @kbd{\\} (integer quotient), @kbd{f I} (integer logarithm), "
"and @kbd{f Q} (integer square root) commands, which are analogous to "
"@kbd{/}, @kbd{B}, and @kbd{Q}, respectively, except that they take integer "
"arguments and return the result rounded down to an integer."
msgstr ""

#. type: node
#: ../../calc.texi:16637 ../../calc.texi:16705 ../../calc.texi:16706 ../../calc.texi:16868
#, no-wrap
msgid "Conversions"
msgstr ""

#. type: pindex
#: ../../calc.texi:16642
#, no-wrap
msgid "calc-conj"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16649
msgid ""
"@tindex conj The @kbd{J} (@code{calc-conj}) [@code{conj}] command computes "
"the complex conjugate of a number.  For complex number @expr{a+bi}, the "
"complex conjugate is @expr{a-bi}.  If the argument is a real number, this "
"command leaves it the same.  If the argument is a vector or matrix, this "
"command replaces each element by its complex conjugate."
msgstr ""

#. type: pindex
#: ../../calc.texi:16651
#, no-wrap
msgid "calc-argument"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16661
msgid ""
"@tindex arg The @kbd{G} (@code{calc-argument}) [@code{arg}] command computes "
"the ``argument'' or polar angle of a complex number.  For a number in polar "
"notation, this is simply the second component of the pair @texline "
"`@tfn{(}@var{r}@tfn{;}@math{\\theta}@tfn{)}'.  @infoline "
"`@tfn{(}@var{r}@tfn{;}@var{theta}@tfn{)}'.  The result is expressed "
"according to the current angular mode and will be in the range @mathit{-180} "
"degrees (exclusive) to @mathit{+180} degrees (inclusive), or the equivalent "
"range in radians."
msgstr ""

#. type: pindex
#: ../../calc.texi:16662
#, no-wrap
msgid "calc-imaginary"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16667
msgid ""
"The @code{calc-imaginary} command multiplies the number on the top of the "
"stack by the imaginary number @expr{i = (0,1)}.  This command is not "
"normally bound to a key in Calc, but it is available on the @key{IMAG} "
"button in Keypad mode."
msgstr ""

#. type: kindex
#: ../../calc.texi:16668
#, no-wrap
msgid "f r"
msgstr ""

#. type: pindex
#: ../../calc.texi:16669
#, no-wrap
msgid "calc-re"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16675
msgid ""
"@tindex re The @kbd{f r} (@code{calc-re}) [@code{re}] command replaces a "
"complex number by its real part.  This command has no effect on real "
"numbers.  (As an added convenience, @code{re} applied to a modulo form "
"extracts the value part.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:16676
#, no-wrap
msgid "f i"
msgstr ""

#. type: pindex
#: ../../calc.texi:16677
#, no-wrap
msgid "calc-im"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16682
msgid ""
"@tindex im The @kbd{f i} (@code{calc-im}) [@code{im}] command replaces a "
"complex number by its imaginary part; real numbers are converted to zero.  "
"With a vector or matrix argument, these functions operate element-wise."
msgstr ""

#. type: kindex
#: ../../calc.texi:16686
#, no-wrap
msgid "v p @r{(complex)}"
msgstr ""

#. type: kindex
#: ../../calc.texi:16687
#, no-wrap
msgid "V p @r{(complex)}"
msgstr ""

#. type: pindex
#: ../../calc.texi:16688 ../../calc.texi:19498
#, no-wrap
msgid "calc-pack"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16694
msgid ""
"The @kbd{v p} (@code{calc-pack}) command can pack the top two numbers on the "
"stack into a composite object such as a complex number.  With a prefix "
"argument of @mathit{-1}, it produces a rectangular complex number; with an "
"argument of @mathit{-2}, it produces a polar complex number.  (Also, "
"@pxref{Building Vectors}.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:16698
#, no-wrap
msgid "v u @r{(complex)}"
msgstr ""

#. type: kindex
#: ../../calc.texi:16699
#, no-wrap
msgid "V u @r{(complex)}"
msgstr ""

#. type: pindex
#: ../../calc.texi:16700 ../../calc.texi:19631
#, no-wrap
msgid "calc-unpack"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16704
msgid ""
"The @kbd{v u} (@code{calc-unpack}) command takes the complex number (or "
"other composite object) on the top of the stack and unpacks it into its "
"separate components."
msgstr ""

#. type: node
#: ../../calc.texi:16705 ../../calc.texi:16868 ../../calc.texi:16869 ../../calc.texi:16896 ../../calc.texi:16984 ../../calc.texi:17148 ../../calc.texi:17291 ../../calc.texi:17513
#, no-wrap
msgid "Date Arithmetic"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16711
msgid ""
"The commands described in this section convert numbers from one form to "
"another; they are two-key sequences beginning with the letter @kbd{c}."
msgstr ""

#. type: kindex
#: ../../calc.texi:16712
#, no-wrap
msgid "c f"
msgstr ""

#. type: pindex
#: ../../calc.texi:16713
#, no-wrap
msgid "calc-float"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16724
msgid ""
"@tindex pfloat The @kbd{c f} (@code{calc-float}) [@code{pfloat}] command "
"converts the number on the top of the stack to floating-point form.  For "
"example, @expr{23} is converted to @expr{23.0}, @expr{3:2} is converted to "
"@expr{1.5}, and @expr{2.3} is left the same.  If the value is a composite "
"object such as a complex number or vector, each of the components is "
"converted to floating-point.  If the value is a formula, all numbers in the "
"formula are converted to floating-point.  Note that depending on the current "
"floating-point precision, conversion to floating-point format may lose "
"information."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16731
msgid ""
"As a special exception, integers which appear as powers or subscripts are "
"not floated by @kbd{c f}.  If you really want to float a power, you can use "
"a @kbd{j s} command to select the power followed by @kbd{c f}.  Because "
"@kbd{c f} cannot examine the formula outside of the selection, it does not "
"notice that the thing being floated is a power.  @xref{Selecting "
"Subformulas}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16736
msgid ""
"The normal @kbd{c f} command is ``pervasive'' in the sense that it applies "
"to all numbers throughout the formula.  The @code{pfloat} algebraic function "
"never stays around in a formula; @samp{pfloat(a + 1)} changes to @samp{a + "
"1.0} as soon as it is evaluated."
msgstr ""

#. type: kindex
#: ../../calc.texi:16737
#, no-wrap
msgid "H c f"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16743
msgid ""
"@tindex float With the Hyperbolic flag, @kbd{H c f} [@code{float}] operates "
"only on the number or vector of numbers at the top level of its argument.  "
"Thus, @samp{float(1)} is 1.0, but @samp{float(a + 1)} is left unevaluated "
"because its argument is not a number."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16748
msgid ""
"You should use @kbd{H c f} if you wish to guarantee that the final value, "
"once all the variables have been assigned, is a float; you would use @kbd{c "
"f} if you wish to do the conversion on the numbers that appear right now."
msgstr ""

#. type: kindex
#: ../../calc.texi:16749
#, no-wrap
msgid "c F"
msgstr ""

#. type: pindex
#: ../../calc.texi:16750
#, no-wrap
msgid "calc-fraction"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16763
msgid ""
"@tindex pfrac The @kbd{c F} (@code{calc-fraction}) [@code{pfrac}] command "
"converts a floating-point number into a fractional approximation.  By "
"default, it produces a fraction whose decimal representation is the same as "
"the input number, to within the current precision.  You can also give a "
"numeric prefix argument to specify a tolerance, either directly, or, if the "
"prefix argument is zero, by using the number on top of the stack as the "
"tolerance.  If the tolerance is a positive integer, the fraction is correct "
"to within that many significant figures.  If the tolerance is a non-positive "
"integer, it specifies how many digits fewer than the current precision to "
"use.  If the tolerance is a floating-point number, the fraction is correct "
"to within that absolute amount."
msgstr ""

#. type: kindex
#: ../../calc.texi:16764
#, no-wrap
msgid "H c F"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16769
msgid ""
"@tindex frac The @code{pfrac} function is pervasive, like @code{pfloat}.  "
"There is also a non-pervasive version, @kbd{H c F} [@code{frac}], which is "
"analogous to @kbd{H c f} discussed above."
msgstr ""

#. type: kindex
#: ../../calc.texi:16770
#, no-wrap
msgid "c d"
msgstr ""

#. type: pindex
#: ../../calc.texi:16771
#, no-wrap
msgid "calc-to-degrees"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16777
msgid ""
"@tindex deg The @kbd{c d} (@code{calc-to-degrees}) [@code{deg}] command "
"converts a number into degrees form.  The value on the top of the stack may "
"be an HMS form (interpreted as degrees-minutes-seconds), or a real number "
"which will be interpreted in radians regardless of the current angular mode."
msgstr ""

#. type: kindex
#: ../../calc.texi:16778
#, no-wrap
msgid "c r"
msgstr ""

#. type: pindex
#: ../../calc.texi:16779
#, no-wrap
msgid "calc-to-radians"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16783
msgid ""
"@tindex rad The @kbd{c r} (@code{calc-to-radians}) [@code{rad}] command "
"converts an HMS form or angle in degrees into an angle in radians."
msgstr ""

#. type: kindex
#: ../../calc.texi:16784
#, no-wrap
msgid "c h"
msgstr ""

#. type: pindex
#: ../../calc.texi:16785
#, no-wrap
msgid "calc-to-hms"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16792
msgid ""
"@tindex hms The @kbd{c h} (@code{calc-to-hms}) [@code{hms}] command converts "
"a real number, interpreted according to the current angular mode, to an HMS "
"form describing the same angle.  In algebraic notation, the @code{hms} "
"function also accepts three arguments: @samp{hms(@var{h}, @var{m}, "
"@var{s})}.  (The three-argument version is independent of the current "
"angular mode.)"
msgstr ""

#. type: pindex
#: ../../calc.texi:16793
#, no-wrap
msgid "calc-from-hms"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16796
msgid ""
"The @code{calc-from-hms} command converts the HMS form on the top of the "
"stack into a real number according to the current angular mode."
msgstr ""

#. type: kindex
#: ../../calc.texi:16797
#, no-wrap
msgid "c p"
msgstr ""

#. type: kindex
#: ../../calc.texi:16798
#, no-wrap
msgid "I c p"
msgstr ""

#. type: pindex
#: ../../calc.texi:16799
#, no-wrap
msgid "calc-polar"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16810
msgid ""
"@tindex polar @tindex rect The @kbd{c p} (@code{calc-polar}) command "
"converts the complex number on the top of the stack from polar to "
"rectangular form, or from rectangular to polar form, whichever is "
"appropriate.  Real numbers are left the same.  This command is equivalent to "
"the @code{rect} or @code{polar} functions in algebraic formulas, depending "
"on the direction of conversion.  (It uses @code{polar}, except that if the "
"argument is already a polar complex number, it uses @code{rect} instead.  "
"The @kbd{I c p} command always uses @code{rect}.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:16811
#, no-wrap
msgid "c c"
msgstr ""

#. type: pindex
#: ../../calc.texi:16812
#, no-wrap
msgid "calc-clean"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16823
msgid ""
"@tindex pclean The @kbd{c c} (@code{calc-clean}) [@code{pclean}] command "
"``cleans'' the number on the top of the stack.  Floating point numbers are "
"re-rounded according to the current precision.  Polar numbers whose angular "
"components have strayed from the @mathit{-180} to @mathit{+180} degree range "
"are normalized.  (Note that results will be undesirable if the current "
"angular mode is different from the one under which the number was produced!)  "
"Integers and fractions are generally unaffected by this operation.  Vectors "
"and formulas are cleaned by cleaning each component number (i.e., "
"pervasively)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16828
msgid ""
"If the simplification mode is set below basic simplification, it is raised "
"for the purposes of this command.  Thus, @kbd{c c} applies the basic "
"simplifications even if their automatic application is disabled.  "
"@xref{Simplification Modes}."
msgstr ""

#. type: cindex
#: ../../calc.texi:16829
#, no-wrap
msgid "Roundoff errors, correcting"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16834
msgid ""
"A numeric prefix argument to @kbd{c c} sets the floating-point precision to "
"that value for the duration of the command.  A positive prefix (of at least "
"3) sets the precision to the specified value; a negative or zero prefix "
"decreases the precision by the specified amount."
msgstr ""

#. type: kindex
#: ../../calc.texi:16835
#, no-wrap
msgid "c 0-9"
msgstr ""

#. type: pindex
#: ../../calc.texi:16836
#, no-wrap
msgid "calc-clean-num"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16841
msgid ""
"The keystroke sequences @kbd{c 0} through @kbd{c 9} are equivalent to @kbd{c "
"c} with the corresponding negative prefix argument.  If roundoff errors have "
"changed 2.0 into 1.999999, typing @kbd{c 1} to clip off one decimal place "
"often conveniently does the trick."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16849
msgid ""
"The @kbd{c c} command with a numeric prefix argument, and the @kbd{c 0} "
"through @kbd{c 9} commands, also ``clip'' very small floating-point numbers "
"to zero.  If the exponent is less than or equal to the negative of the "
"specified precision, the number is changed to 0.0.  For example, if the "
"current precision is 12, then @kbd{c 2} changes the vector @samp{[1e-8, "
"1e-9, 1e-10, 1e-11]} to @samp{[1e-8, 1e-9, 0, 0]}.  Numbers this small "
"generally arise from roundoff noise."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16854
msgid ""
"If the numbers you are using really are legitimately this small, you should "
"avoid using the @kbd{c 0} through @kbd{c 9} commands.  (The plain @kbd{c c} "
"command rounds to the current precision but does not clip small numbers.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16861
msgid ""
"One more property of @kbd{c 0} through @kbd{c 9}, and of @kbd{c c} with a "
"prefix argument, is that integer-valued floats are converted to plain "
"integers, so that @kbd{c 1} on @samp{[1., 1.5, 2., 2.5, 3.]} produces "
"@samp{[1, 1.5, 2, 2.5, 3]}.  This is not done for huge numbers (@samp{1e100} "
"is technically an integer-valued float, but you wouldn't want it "
"automatically converted to a 100-digit integer)."
msgstr ""

#. type: kindex
#: ../../calc.texi:16862
#, no-wrap
msgid "H c 0-9"
msgstr ""

#. type: kindex
#: ../../calc.texi:16863
#, no-wrap
msgid "H c c"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16867
msgid ""
"@tindex clean With the Hyperbolic flag, @kbd{H c c} and @kbd{H c 0} through "
"@kbd{H c 9} operate non-pervasively [@code{clean}]."
msgstr ""

#. type: node
#: ../../calc.texi:16868 ../../calc.texi:17513 ../../calc.texi:17514 ../../calc.texi:17540 ../../calc.texi:17605 ../../calc.texi:17667 ../../calc.texi:17751 ../../calc.texi:17839 ../../calc.texi:17910 ../../calc.texi:18064
#, no-wrap
msgid "Financial Functions"
msgstr ""

#. type: cindex
#: ../../calc.texi:16872
#, no-wrap
msgid "Date arithmetic, additional functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16877
msgid ""
"The commands described in this section perform various conversions and "
"calculations involving date forms (@pxref{Date Forms}).  They use the "
"@kbd{t} (for time/date) prefix key followed by shifted letters."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16884
msgid ""
"The simplest date arithmetic is done using the regular @kbd{+} and @kbd{-} "
"commands.  In particular, adding a number to a date form advances the date "
"form by a certain number of days; adding an HMS form to a date form advances "
"the date by a certain amount of time; and subtracting two date forms "
"produces a difference measured in days.  The commands described here provide "
"additional, more specialized operations on dates."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16888
msgid ""
"Many of these commands accept a numeric prefix argument; if you give plain "
"@kbd{C-u} as the prefix, these commands will instead take the additional "
"argument from the top of the stack."
msgstr ""

#. type: menuentry
#: ../../calc.texi:16894
msgid "Date Conversions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:16894
msgid "Date Functions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:16894
msgid "Time Zones::"
msgstr ""

#. type: node
#: ../../calc.texi:16894 ../../calc.texi:16984 ../../calc.texi:17148 ../../calc.texi:17149 ../../calc.texi:17291
#, no-wrap
msgid "Business Days"
msgstr ""

#. type: node
#: ../../calc.texi:16896 ../../calc.texi:16897 ../../calc.texi:16984
#, no-wrap
msgid "Date Conversions"
msgstr ""

#. type: node
#: ../../calc.texi:16896 ../../calc.texi:16984 ../../calc.texi:16985 ../../calc.texi:17148
#, no-wrap
msgid "Date Functions"
msgstr ""

#. type: kindex
#: ../../calc.texi:16900
#, no-wrap
msgid "t D"
msgstr ""

#. type: pindex
#: ../../calc.texi:16901
#, no-wrap
msgid "calc-date"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16908
msgid ""
"@tindex date The @kbd{t D} (@code{calc-date}) [@code{date}] command converts "
"a date form into a number, measured in days since Jan 1, 1 AD@.  The result "
"will be an integer if @var{date} is a pure date form, or a fraction or float "
"if @var{date} is a date/time form.  Or, if its argument is a number, it "
"converts this number into a date form."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16912
msgid ""
"With a numeric prefix argument, @kbd{t D} takes that many objects (up to "
"six) from the top of the stack and interprets them in one of the following "
"ways:"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16921
msgid ""
"The @samp{date(@var{year}, @var{month}, @var{day})} function builds a pure "
"date form out of the specified year, month, and day, which must all be "
"integers.  @var{Year} is a year number, such as 1991 (@emph{not} the same as "
"91!).  @var{Month} must be an integer in the range 1 to 12; @var{day} must "
"be in the range 1 to 31.  If the specified month has fewer than 31 days and "
"@var{day} is too large, the equivalent day in the following month will be "
"used."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16925
msgid ""
"The @samp{date(@var{month}, @var{day})} function builds a pure date form "
"using the current year, as determined by the real-time clock."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16928
msgid ""
"The @samp{date(@var{year}, @var{month}, @var{day}, @var{hms})} function "
"builds a date/time form using an @var{hms} form."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16935
msgid ""
"The @samp{date(@var{year}, @var{month}, @var{day}, @var{hour}, @var{minute}, "
"@var{second})} function builds a date/time form.  @var{hour} should be an "
"integer in the range 0 to 23; @var{minute} should be an integer in the range "
"0 to 59; @var{second} should be any real number in the range @samp{[0 "
".. 60)}.  The last two arguments default to zero if omitted."
msgstr ""

#. type: kindex
#: ../../calc.texi:16936
#, no-wrap
msgid "t J"
msgstr ""

#. type: pindex
#: ../../calc.texi:16937
#, no-wrap
msgid "calc-julian"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16939
msgid "@tindex julian"
msgstr ""

#. type: cindex
#: ../../calc.texi:16939
#, no-wrap
msgid "Julian day counts, conversions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16950
msgid ""
"The @kbd{t J} (@code{calc-julian}) [@code{julian}] command converts a date "
"form into a Julian day count, which is the number of days since noon (GMT) "
"on Jan 1, 4713 BC@.  A pure date is converted to an integer Julian count "
"representing noon of that day.  A date/time form is converted to an exact "
"floating-point Julian count, adjusted to interpret the date form in the "
"current time zone but the Julian day count in Greenwich Mean Time.  A "
"numeric prefix argument allows you to specify the time zone; @pxref{Time "
"Zones}.  Use a prefix of zero to suppress the time zone adjustment.  Note "
"that pure date forms are never time-zone adjusted."
msgstr ""

#. type: Plain text
#: ../../calc.texi:16955
msgid ""
"This command can also do the opposite conversion, from a Julian day count "
"(either an integer day, or a floating-point day and time in the GMT zone), "
"into a pure date form or a date/time form in the current or specified time "
"zone."
msgstr ""

#. type: kindex
#: ../../calc.texi:16956
#, no-wrap
msgid "t U"
msgstr ""

#. type: pindex
#: ../../calc.texi:16957
#, no-wrap
msgid "calc-unix-time"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16959
msgid "@tindex unixtime"
msgstr ""

#. type: cindex
#: ../../calc.texi:16959
#, no-wrap
msgid "Unix time format, conversions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16970
msgid ""
"The @kbd{t U} (@code{calc-unix-time}) [@code{unixtime}] command converts a "
"date form into a Unix time value, which is the number of seconds since "
"midnight on Jan 1, 1970, or vice-versa.  The numeric result will be an "
"integer if the current precision is 12 or less; for higher precision, the "
"result may be a float with (@var{precision}@minus{}12)  digits after the "
"decimal.  Just as for @kbd{t J}, the numeric time is interpreted in the GMT "
"time zone and the date form is interpreted in the current or specified "
"zone.  Some systems use Unix-like numbering but with the local time zone; "
"give a prefix of zero to suppress the adjustment if so."
msgstr ""

#. type: kindex
#: ../../calc.texi:16971
#, no-wrap
msgid "t C"
msgstr ""

#. type: pindex
#: ../../calc.texi:16972
#, no-wrap
msgid "calc-convert-time-zones"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16974
msgid "@tindex tzconv"
msgstr ""

#. type: cindex
#: ../../calc.texi:16974
#, no-wrap
msgid "Time Zones, converting between"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16983
msgid ""
"The @kbd{t C} (@code{calc-convert-time-zones}) [@code{tzconv}] command "
"converts a date form from one time zone to another.  You are prompted for "
"each time zone name in turn; you can answer with any suitable Calc time zone "
"expression (@pxref{Time Zones}).  If you answer either prompt with a blank "
"line, the local time zone is used for that prompt.  You can also answer the "
"first prompt with @kbd{$} to take the two time zone names from the stack "
"(and the date to be converted from the third stack level)."
msgstr ""

#. type: kindex
#: ../../calc.texi:16988
#, no-wrap
msgid "t N"
msgstr ""

#. type: pindex
#: ../../calc.texi:16989
#, no-wrap
msgid "calc-now"
msgstr ""

#. type: Plain text
#: ../../calc.texi:16995
msgid ""
"@tindex now The @kbd{t N} (@code{calc-now}) [@code{now}] command pushes the "
"current date and time on the stack as a date form.  The time is reported in "
"terms of the specified time zone; with no numeric prefix argument, @kbd{t N} "
"reports for the current time zone."
msgstr ""

#. type: kindex
#: ../../calc.texi:16996
#, no-wrap
msgid "t P"
msgstr ""

#. type: pindex
#: ../../calc.texi:16997
#, no-wrap
msgid "calc-date-part"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17002
msgid ""
"The @kbd{t P} (@code{calc-date-part}) command extracts one part of a date "
"form.  The prefix argument specifies the part; with no argument, this "
"command prompts for a part code from 1 to 9.  The various part codes are "
"described in the following paragraphs."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17010
msgid ""
"@tindex year The @kbd{M-1 t P} [@code{year}] function extracts the year "
"number from a date form as an integer, e.g., 1991.  This and the following "
"functions will also accept a real number for an argument, which is "
"interpreted as a standard Calc day number.  Note that this function will "
"never return zero, since the year 1 BC immediately precedes the year 1 AD."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17014
msgid ""
"@tindex month The @kbd{M-2 t P} [@code{month}] function extracts the month "
"number from a date form as an integer in the range 1 to 12."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17018
msgid ""
"@tindex day The @kbd{M-3 t P} [@code{day}] function extracts the day number "
"from a date form as an integer in the range 1 to 31."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17025
msgid ""
"@tindex hour The @kbd{M-4 t P} [@code{hour}] function extracts the hour from "
"a date form as an integer in the range 0 (midnight) to 23.  Note that "
"24-hour time is always used.  This returns zero for a pure date form.  This "
"function (and the following two) also accept HMS forms as input."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17029
msgid ""
"@tindex minute The @kbd{M-5 t P} [@code{minute}] function extracts the "
"minute from a date form as an integer in the range 0 to 59."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17035
msgid ""
"@tindex second The @kbd{M-6 t P} [@code{second}] function extracts the "
"second from a date form.  If the current precision is 12 or less, the result "
"is an integer in the range 0 to 59.  For higher precision, the result may "
"instead be a floating-point number."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17040
msgid ""
"@tindex weekday The @kbd{M-7 t P} [@code{weekday}] function extracts the "
"weekday number from a date form as an integer in the range 0 (Sunday)  to 6 "
"(Saturday)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17045
msgid ""
"@tindex yearday The @kbd{M-8 t P} [@code{yearday}] function extracts the "
"day-of-year number from a date form as an integer in the range 1 (January 1)  "
"to 366 (December 31 of a leap year)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17050
msgid ""
"@tindex time The @kbd{M-9 t P} [@code{time}] function extracts the time "
"portion of a date form as an HMS form.  This returns @samp{0@@ 0' 0\"} for a "
"pure date form."
msgstr ""

#. type: kindex
#: ../../calc.texi:17051
#, no-wrap
msgid "t M"
msgstr ""

#. type: pindex
#: ../../calc.texi:17052
#, no-wrap
msgid "calc-new-month"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17062
msgid ""
"@tindex newmonth The @kbd{t M} (@code{calc-new-month}) [@code{newmonth}] "
"command computes a new date form that represents the first day of the month "
"specified by the input date.  The result is always a pure date form; only "
"the year and month numbers of the input are retained.  With a numeric prefix "
"argument @var{n} in the range from 1 to 31, @kbd{t M} computes the @var{n}th "
"day of the month.  (If @var{n} is greater than the actual number of days in "
"the month, or if @var{n} is zero, the last day of the month is used.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:17063
#, no-wrap
msgid "t Y"
msgstr ""

#. type: pindex
#: ../../calc.texi:17064
#, no-wrap
msgid "calc-new-year"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17075
msgid ""
"@tindex newyear The @kbd{t Y} (@code{calc-new-year}) [@code{newyear}] "
"command computes a new pure date form that represents the first day of the "
"year specified by the input.  The month, day, and time of the input date "
"form are lost.  With a numeric prefix argument @var{n} in the range from 1 "
"to 366, @kbd{t Y} computes the @var{n}th day of the year (366 is treated as "
"365 in non-leap years).  A prefix argument of 0 computes the last day of the "
"year (December 31).  A negative prefix argument from @mathit{-1} to "
"@mathit{-12} computes the first day of the @var{n}th month of the year."
msgstr ""

#. type: kindex
#: ../../calc.texi:17076
#, no-wrap
msgid "t W"
msgstr ""

#. type: pindex
#: ../../calc.texi:17077
#, no-wrap
msgid "calc-new-week"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17085
msgid ""
"@tindex newweek The @kbd{t W} (@code{calc-new-week}) [@code{newweek}] "
"command computes a new pure date form that represents the Sunday on or "
"before the input date.  With a numeric prefix argument, it can be made to "
"use any day of the week as the starting day; the argument must be in the "
"range from 0 (Sunday) to 6 (Saturday).  This function always subtracts "
"between 0 and 6 days from the input date."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17097
msgid ""
"Here's an example use of @code{newweek}: Find the date of the next Wednesday "
"after a given date.  Using @kbd{M-3 t W} or @samp{newweek(d, 3)} will give "
"you the @emph{preceding} Wednesday, so @samp{newweek(d+7, 3)} will give you "
"the following Wednesday.  A further look at the definition of @code{newweek} "
"shows that if the input date is itself a Wednesday, this formula will return "
"the Wednesday one week in the future.  An exercise for the reader is to "
"modify this formula to yield the same day if the input is already a "
"Wednesday.  Another interesting exercise is to preserve the time-of-day "
"portion of the input (@code{newweek} resets the time to midnight; hint: how "
"can @code{newweek} be defined in terms of the @code{weekday} function?)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17113
msgid ""
"@tindex pwday The @samp{pwday(@var{date})} function (not on any key) "
"computes the day-of-month number of the Sunday on or before @var{date}.  "
"With two arguments, @samp{pwday(@var{date}, @var{day})} computes the day "
"number of the Sunday on or before day number @var{day} of the month "
"specified by @var{date}.  The @var{day} must be in the range from 7 to 31; "
"if the day number is greater than the actual number of days in the month, "
"the true number of days is used instead.  Thus @samp{pwday(@var{date}, 7)} "
"finds the first Sunday of the month, and @samp{pwday(@var{date}, 31)} finds "
"the last Sunday of the month.  With a third @var{weekday} argument, "
"@code{pwday} can be made to look for any day of the week instead of Sunday."
msgstr ""

#. type: kindex
#: ../../calc.texi:17114
#, no-wrap
msgid "t I"
msgstr ""

#. type: pindex
#: ../../calc.texi:17115
#, no-wrap
msgid "calc-inc-month"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17127
msgid ""
"@tindex incmonth The @kbd{t I} (@code{calc-inc-month}) [@code{incmonth}] "
"command increases a date form by one month, or by an arbitrary number of "
"months specified by a numeric prefix argument.  The time portion, if any, of "
"the date form stays the same.  The day also stays the same, except that if "
"the new month has fewer days the day number may be reduced to lie in the "
"valid range.  For example, @samp{incmonth(<Jan 31, 1991>)} produces "
"@samp{<Feb 28, 1991>}.  Because of this, @kbd{t I t I} and @kbd{M-2 t I} do "
"not always give the same results (@samp{<Mar 28, 1991>} versus @samp{<Mar "
"31, 1991>} in this case)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17140
msgid ""
"@tindex incyear The @samp{incyear(@var{date}, @var{step})} function "
"increases a date form by the specified number of years, which may be any "
"positive or negative integer.  Note that @samp{incyear(d, n)} is equivalent "
"to @w{@samp{incmonth(d, 12*n)}}, but these do not have simple equivalents in "
"terms of day arithmetic because months and years have varying lengths.  If "
"the @var{step} argument is omitted, 1 year is assumed.  There is no keyboard "
"command for this function; use @kbd{C-u 12 t I} instead."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17144
msgid ""
"There is no @code{newday} function at all because @kbd{F} [@code{floor}] "
"serves this purpose.  Similarly, instead of @code{incday} and @code{incweek} "
"simply use @expr{d + n} or @expr{d + 7 n}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17147
msgid ""
"@xref{Basic Arithmetic}, for the @kbd{f ]} [@code{incr}] command which can "
"adjust a date/time form by a certain number of seconds."
msgstr ""

#. type: subsection
#: ../../calc.texi:17148 ../../calc.texi:17291 ../../calc.texi:17292
#, no-wrap
msgid "Time Zones"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17158
msgid ""
"Often time is measured in ``business days'' or ``working days,'' where "
"weekends and holidays are skipped.  Calc's normal date arithmetic functions "
"use calendar days, so that subtracting two consecutive Mondays will yield a "
"difference of 7 days.  By contrast, subtracting two consecutive Mondays "
"would yield 5 business days (assuming two-day weekends and the absence of "
"holidays)."
msgstr ""

#. type: kindex
#: ../../calc.texi:17159
#, no-wrap
msgid "t +"
msgstr ""

#. type: kindex
#: ../../calc.texi:17160
#, no-wrap
msgid "t -"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17163
msgid "@tindex badd @tindex bsub"
msgstr ""

#. type: pindex
#: ../../calc.texi:17163
#, no-wrap
msgid "calc-business-days-plus"
msgstr ""

#. type: pindex
#: ../../calc.texi:17164
#, no-wrap
msgid "calc-business-days-minus"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17178
msgid ""
"The @kbd{t +} (@code{calc-business-days-plus}) [@code{badd}] and @kbd{t -} "
"(@code{calc-business-days-minus}) [@code{bsub}] commands perform arithmetic "
"using business days.  For @kbd{t +}, one argument must be a date form and "
"the other must be a real number (positive or negative).  If the number is "
"not an integer, then a certain amount of time is added as well as a number "
"of days; for example, adding 0.5 business days to a time in Friday evening "
"will produce a time in Monday morning.  It is also possible to add an HMS "
"form; adding @samp{12@@ 0' 0\"} also adds half a business day.  For @kbd{t "
"-}, the arguments are either a date form and a number or HMS form, or two "
"date forms, in which case the result is the number of business days between "
"the two dates."
msgstr ""

#. type: cindex
#: ../../calc.texi:17179
#, no-wrap
msgid "@code{Holidays} variable"
msgstr ""

#. type: vindex
#: ../../calc.texi:17180
#, no-wrap
msgid "Holidays"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17188
msgid ""
"By default, Calc considers any day that is not a Saturday or Sunday to be a "
"business day.  You can define any number of additional holidays by editing "
"the variable @code{Holidays}.  (There is an @w{@kbd{s H}} convenience "
"command for editing this variable.)  Initially, @code{Holidays} contains the "
"vector @samp{[sat, sun]}.  Entries in the @code{Holidays} vector may be any "
"of the following kinds of objects:"
msgstr ""

#. type: itemize
#: ../../calc.texi:17193
msgid ""
"Date forms (pure dates, not date/time forms).  These specify particular days "
"which are to be treated as holidays."
msgstr ""

#. type: itemize
#: ../../calc.texi:17197
msgid ""
"Intervals of date forms.  These specify a range of days, all of which are "
"holidays (e.g., Christmas week).  @xref{Interval Forms}."
msgstr ""

#. type: itemize
#: ../../calc.texi:17201
msgid ""
"Nested vectors of date forms.  Each date form in the vector is considered to "
"be a holiday."
msgstr ""

#. type: itemize
#: ../../calc.texi:17212
msgid ""
"Any Calc formula which evaluates to one of the above three things.  If the "
"formula involves the variable @expr{y}, it stands for a yearly repeating "
"holiday; @expr{y} will take on various year numbers like 1992.  For example, "
"@samp{date(y, 12, 25)} specifies Christmas day, and @samp{newweek(date(y, "
"11, 7), 4) + 21} specifies Thanksgiving (which is held on the fourth "
"Thursday of November).  If the formula involves the variable @expr{m}, that "
"variable takes on month numbers from 1 to 12: @samp{date(y, m, 15)} is a "
"holiday that takes place on the 15th of every month."
msgstr ""

#. type: itemize
#: ../../calc.texi:17216
msgid ""
"A weekday name, such as @code{sat} or @code{sun}.  This is really a variable "
"whose name is a three-letter, lower-case day name."
msgstr ""

#. type: itemize
#: ../../calc.texi:17228
msgid ""
"An interval of year numbers (integers).  This specifies the span of years "
"over which this holiday list is to be considered valid.  Any business-day "
"arithmetic that goes outside this range will result in an error message.  "
"Use this if you are including an explicit list of holidays, rather than a "
"formula to generate them, and you want to make sure you don't accidentally "
"go beyond the last point where the holidays you entered are complete.  If "
"there is no limiting interval in the @code{Holidays} vector, the default "
"@samp{[1 .. 2737]} is used.  (This is the absolute range of years for which "
"Calc's business-day algorithms will operate.)"
msgstr ""

#. type: itemize
#: ../../calc.texi:17244
msgid ""
"An interval of HMS forms.  This specifies the span of hours that are to be "
"considered one business day.  For example, if this range is @samp{[9@@ 0' "
"0\" .. 17@@ 0' 0\"]} (i.e., 9am to 5pm), then the business day is only eight "
"hours long, so that @kbd{1.5 t +} on @samp{<4:00pm Fri Dec 13, 1991>} will "
"add one business day and four business hours to produce @samp{<12:00pm Tue "
"Dec 17, 1991>}.  Likewise, @kbd{t -} will now express differences in time as "
"fractions of an eight-hour day.  Times before 9am will be treated as 9am by "
"business date arithmetic, and times at or after 5pm will be treated as "
"4:59:59pm.  If there is no HMS interval in @code{Holidays}, the full 24-hour "
"day @samp{[0@ 0' 0\" .. 24@ 0' 0\"]} is assumed.  (Regardless of the type of "
"bounds you specify, the interval is treated as inclusive on the low end and "
"exclusive on the high end, so that the work day goes from 9am up to, but not "
"including, 5pm.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17249
msgid ""
"If the @code{Holidays} vector is empty, then @kbd{t +} and @kbd{t -} will "
"act just like @kbd{+} and @kbd{-} because there will then be no difference "
"between business days and calendar days."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17256
msgid ""
"Calc expands the intervals and formulas you give into a complete list of "
"holidays for internal use.  This is done mainly to make sure it can detect "
"multiple holidays.  (For example, @samp{<Jan 1, 1989>} is both New Year's "
"Day and a Sunday, but Calc's algorithms take care to count it only once when "
"figuring the number of holidays between two dates.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17265
msgid ""
"Since the complete list of holidays for all the years from 1 to 2737 would "
"be huge, Calc actually computes only the part of the list between the "
"smallest and largest years that have been involved in business-day "
"calculations so far.  Normally, you won't have to worry about this.  Keep in "
"mind, however, that if you do one calculation for 1992, and another for "
"1792, even if both involve only a small range of years, Calc will still work "
"out all the holidays that fall in that 200-year span."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17281
msgid ""
"If you add a (positive) number of days to a date form that falls on a "
"weekend or holiday, the date form is treated as if it were the most recent "
"business day.  (Thus adding one business day to a Friday, Saturday, or "
"Sunday will all yield the following Monday.)  If you subtract a number of "
"days from a weekend or holiday, the date is effectively on the following "
"business day.  (So subtracting one business day from Saturday, Sunday, or "
"Monday yields the preceding Friday.)  The difference between two dates one "
"or both of which fall on holidays equals the number of actual business days "
"between them.  These conventions are consistent in the sense that, if you "
"add @var{n} business days to any date, the difference between the result and "
"the original date will come out to @var{n} business days.  (It can't be "
"completely consistent though; a subtraction followed by an addition might "
"come out a bit differently, since @kbd{t +} is incapable of producing a date "
"that falls on a weekend or holiday.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17290
msgid ""
"@tindex holiday There is a @code{holiday} function, not on any keys, that "
"takes any date form and returns 1 if that date falls on a weekend or "
"holiday, as defined in @code{Holidays}, or 0 if the date is a business day."
msgstr ""

#. type: cindex
#: ../../calc.texi:17295
#, no-wrap
msgid "Time zones"
msgstr ""

#. type: cindex
#: ../../calc.texi:17296
#, no-wrap
msgid "Daylight saving time"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17304
msgid ""
"Time zones and daylight saving time are a complicated business.  The "
"conversions to and from Julian and Unix-style dates automatically compute "
"the correct time zone and daylight saving adjustment to use, provided they "
"can figure out this information.  This section describes Calc's time zone "
"adjustment algorithm in detail, in case you want to do conversions in "
"different time zones or in case Calc's algorithms can't determine the right "
"correction to use."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17317
msgid ""
"Adjustments for time zones and daylight saving time are done by @kbd{t U}, "
"@kbd{t J}, @kbd{t N}, and @kbd{t C}, but not by any other commands.  In "
"particular, @samp{<may 1 1991> - <apr 1 1991>} evaluates to exactly 30 days "
"even though there is a daylight-saving transition in between.  This is also "
"true for Julian pure dates: @samp{julian(<may 1 1991>) - julian(<apr 1 "
"1991>)}.  But Julian and Unix date/times will adjust for daylight saving "
"time: using Calc's default daylight saving time rule (see the explanation "
"below), @samp{julian(<12am may 1 1991>) - julian(<12am apr 1 1991>)} "
"evaluates to @samp{29.95833} (that's 29 days and 23 hours)  because one hour "
"was lost when daylight saving commenced on April 7, 1991."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17322
msgid ""
"In brief, the idiom @samp{julian(@var{date1}) - julian(@var{date2})} "
"computes the actual number of 24-hour periods between two dates, whereas "
"@samp{@var{date1} - @var{date2}} computes the number of calendar days "
"between two dates without taking daylight saving into account."
msgstr ""

#. type: pindex
#: ../../calc.texi:17323
#, no-wrap
msgid "calc-time-zone"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17335
msgid ""
"@tindex tzone The @code{calc-time-zone} [@code{tzone}] command converts the "
"time zone specified by its numeric prefix argument into a number of seconds "
"difference from Greenwich mean time (GMT).  If the argument is a number, the "
"result is simply that value multiplied by 3600.  Typical arguments for North "
"America are 5 (Eastern) or 8 (Pacific).  If Daylight Saving time is in "
"effect, one hour should be subtracted from the normal difference."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17345
msgid ""
"If you give a prefix of plain @kbd{C-u}, @code{calc-time-zone} (like other "
"date arithmetic commands that include a time zone argument) takes the zone "
"argument from the top of the stack.  (In the case of @kbd{t J} and @kbd{t "
"U}, the normal argument is then taken from the second-to-top stack "
"position.)  This allows you to give a non-integer time zone adjustment.  The "
"time-zone argument can also be an HMS form, or it can be a variable which is "
"a time zone name in upper- or lower-case.  For example @samp{tzone(PST) = "
"tzone(8)} and @samp{tzone(pdt) = tzone(7)} (for Pacific standard and "
"daylight saving times, respectively)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17350
msgid ""
"North American and European time zone names are defined as follows; note "
"that for each time zone there is one name for standard time, another for "
"daylight saving time, and a third for ``generalized'' time in which the "
"daylight saving adjustment is computed from context."
msgstr ""

#. type: group
#: ../../calc.texi:17355
#, no-wrap
msgid ""
"YST  PST  MST  CST  EST  AST    NST    GMT   WET     MET    MEZ\n"
" 9    8    7    6    5    4     3.5     0     -1      -2     -2\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:17358
#, no-wrap
msgid ""
"YDT  PDT  MDT  CDT  EDT  ADT    NDT    BST  WETDST  METDST  MESZ\n"
" 8    7    6    5    4    3     2.5     -1    -2      -3     -3\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:17361
#, no-wrap
msgid ""
"YGT  PGT  MGT  CGT  EGT  AGT    NGT    BGT   WEGT    MEGT   MEGZ\n"
"9/8  8/7  7/6  6/5  5/4  4/3  3.5/2.5  0/-1 -1/-2   -2/-3  -2/-3\n"
msgstr ""

#. type: vindex
#: ../../calc.texi:17364
#, no-wrap
msgid "math-tzone-names"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17370
msgid ""
"To define time zone names that do not appear in the above table, you must "
"modify the Lisp variable @code{math-tzone-names}.  This is a list of lists "
"describing the different time zone names; its structure is best explained by "
"an example.  The three entries for Pacific Time look like this:"
msgstr ""

#. type: group
#: ../../calc.texi:17376
#, no-wrap
msgid ""
"( ( \"PST\" 8 0 )    ; Name as an upper-case string, then standard\n"
"  ( \"PDT\" 8 -1 )   ; adjustment, then daylight saving adjustment.\n"
"  ( \"PGT\" 8 \"PST\" \"PDT\" ) )   ; Generalized time zone.\n"
msgstr ""

#. type: cindex
#: ../../calc.texi:17379
#, no-wrap
msgid "@code{TimeZone} variable"
msgstr ""

#. type: vindex
#: ../../calc.texi:17380
#, no-wrap
msgid "TimeZone"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17399
msgid ""
"With no arguments, @code{calc-time-zone} or @samp{tzone()} will by default "
"get the time zone and daylight saving information from the calendar "
"(@pxref{Daylight Saving,Calendar/Diary,The Calendar and the Diary, emacs,The "
"GNU Emacs Manual}).  To use a different time zone, or if the calendar does "
"not give the desired result, you can set the Calc variable @code{TimeZone} "
"(which is by default @code{nil}) to an appropriate time zone name.  (The "
"easiest way to do this is to edit the @code{TimeZone} variable using Calc's "
"@kbd{s T} command, then use the @kbd{s p} (@code{calc-permanent-variable}) "
"command to save the value of @code{TimeZone} permanently.)  If the time zone "
"given by @code{TimeZone} is a generalized time zone, e.g., @code{EGT}, Calc "
"examines the date being converted to tell whether to use standard or "
"daylight saving time.  But if the current time zone is explicit, e.g., "
"@code{EST} or @code{EDT}, then that adjustment is used exactly and Calc's "
"daylight saving algorithm is not consulted.  The special time zone name "
"@code{local} is equivalent to no argument; i.e., it uses the information "
"obtained from the calendar."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17404
msgid ""
"The @kbd{t J} and @code{t U} commands with no numeric prefix arguments do "
"the same thing as @samp{tzone()}; namely, use the information from the "
"calendar if @code{TimeZone} is @code{nil}, otherwise use the time zone given "
"by @code{TimeZone}."
msgstr ""

#. type: vindex
#: ../../calc.texi:17405
#, no-wrap
msgid "math-daylight-savings-hook"
msgstr ""

#. type: findex
#: ../../calc.texi:17406
#, no-wrap
msgid "math-std-daylight-savings"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17420
msgid ""
"When Calc computes the daylight saving information itself (i.e., when the "
"@code{TimeZone} variable is set), it will by default consider daylight "
"saving time to begin at 2 a.m.@: on the second Sunday of March (for years "
"from 2007 on) or on the last Sunday in April (for years before 2007), and to "
"end at 2 a.m.@: on the first Sunday of November. (for years from 2007 on) or "
"the last Sunday in October (for years before 2007).  These are the rules "
"that have been in effect in much of North America since 1966 and take into "
"account the rule change that began in 2007.  If you are in a country that "
"uses different rules for computing daylight saving time, you have two "
"choices: Write your own daylight saving hook, or control time zones "
"explicitly by setting the @code{TimeZone} variable and/or always giving a "
"time-zone argument for the conversion functions."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17426
msgid ""
"The Lisp variable @code{math-daylight-savings-hook} holds the name of a "
"function that is used to compute the daylight saving adjustment for a given "
"date.  The default is @code{math-std-daylight-savings}, which computes an "
"adjustment (either 0 or @mathit{-1}) using the North American rules given "
"above."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17434
msgid ""
"The daylight saving hook function is called with four arguments: The date, "
"as a floating-point number in standard Calc format; a six-element list of "
"the date decomposed into year, month, day, hour, minute, and second, "
"respectively; a string which contains the generalized time zone name in "
"upper-case, e.g., @code{\"WEGT\"}; and a special adjustment to be applied to "
"the hour value when converting into a generalized time zone (see below)."
msgstr ""

#. type: findex
#: ../../calc.texi:17435
#, no-wrap
msgid "math-prev-weekday-in-month"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17442
msgid ""
"The Lisp function @code{math-prev-weekday-in-month} is useful for daylight "
"saving computations.  This is an internal version of the user-level "
"@code{pwday} function described in the previous section. It takes four "
"arguments: The floating-point date value, the corresponding six-element date "
"list, the day-of-month number, and the weekday number (0--6)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17449
msgid ""
"The default daylight saving hook ignores the time zone name, but a more "
"sophisticated hook could use different algorithms for different time zones.  "
"It would also be possible to use different algorithms depending on the year "
"number, but the default hook always uses the algorithm for 1987 and later.  "
"Here is a listing of the default daylight saving hook:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:17468
#, no-wrap
msgid ""
"(defun math-std-daylight-savings (date dt zone bump)\n"
"  (cond ((< (nth 1 dt) 4) 0)\n"
"        ((= (nth 1 dt) 4)\n"
"         (let ((sunday (math-prev-weekday-in-month date dt 7 0)))\n"
"           (cond ((< (nth 2 dt) sunday) 0)\n"
"                 ((= (nth 2 dt) sunday)\n"
"                  (if (>= (nth 3 dt) (+ 3 bump)) -1 0))\n"
"                 (t -1))))\n"
"        ((< (nth 1 dt) 10) -1)\n"
"        ((= (nth 1 dt) 10)\n"
"         (let ((sunday (math-prev-weekday-in-month date dt 31 0)))\n"
"           (cond ((< (nth 2 dt) sunday) -1)\n"
"                 ((= (nth 2 dt) sunday)\n"
"                  (if (>= (nth 3 dt) (+ 2 bump)) 0 -1))\n"
"                 (t 0))))\n"
"        (t 0))\n"
")\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17476
msgid ""
"The @code{bump} parameter is equal to zero when Calc is converting from a "
"date form in a generalized time zone into a GMT date value.  It is "
"@mathit{-1} when Calc is converting in the other direction.  The adjustments "
"shown above ensure that the conversion behaves correctly and reasonably "
"around the 2 a.m.@: transition in each direction."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17485
msgid ""
"There is a ``missing'' hour between 2 a.m.@: and 3 a.m.@: at the beginning "
"of daylight saving time; converting a date/time form that falls in this hour "
"results in a time value for the following hour, from 3 a.m.@: to 4 a.m.  At "
"the end of daylight saving time, the hour from 1 a.m.@: to 2 a.m.@: repeats "
"itself; converting a date/time form that falls in this hour results in a "
"time value for the first manifestation of that time (@emph{not} the one that "
"occurs one hour later)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17488
msgid ""
"If @code{math-daylight-savings-hook} is @code{nil}, then the daylight saving "
"adjustment is always taken to be zero."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17500
msgid ""
"In algebraic formulas, @samp{tzone(@var{zone}, @var{date})} computes the "
"time zone adjustment for a given zone name at a given date.  The @var{date} "
"is ignored unless @var{zone} is a generalized time zone.  If @var{date} is a "
"date form, the daylight saving computation is applied to it as it appears.  "
"If @var{date} is a numeric date value, it is adjusted for the "
"daylight-saving version of @var{zone} before being given to the daylight "
"saving hook.  This odd-sounding rule ensures that the daylight-saving "
"computation is always done in local time, not in the GMT time that a numeric "
"@var{date} is typically represented in."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17512
msgid ""
"@tindex dsadj The @samp{dsadj(@var{date}, @var{zone})} function computes the "
"daylight saving adjustment that is appropriate for @var{date} in time zone "
"@var{zone}.  If @var{zone} is explicitly in or not in daylight saving time "
"(e.g., @code{PDT} or @code{PST}) the @var{date} is ignored.  If @var{zone} "
"is a generalized time zone, the algorithms described above are used.  If "
"@var{zone} is omitted, the computation is done for the current time zone."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17520
msgid ""
"Calc's financial or business functions use the @kbd{b} prefix key followed "
"by a shifted letter.  (The @kbd{b} prefix followed by a lower-case letter is "
"used for operations on binary numbers.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17525
msgid ""
"Note that the rate and the number of intervals given to these functions must "
"be on the same time scale, e.g., both months or both years.  Mixing an "
"annual interest rate with a time expressed in months will give you very "
"wrong answers!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17530
msgid ""
"It is wise to compute these functions to a higher precision than you really "
"need, just to make sure your answer is correct to the last penny; also, you "
"may wish to check the definitions at the end of this section to make sure "
"the functions have the meaning you expect."
msgstr ""

#. type: menuentry
#: ../../calc.texi:17538
msgid "Percentages::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:17538
msgid "Future Value::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:17538
msgid "Present Value::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:17538
msgid "Related Financial Functions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:17538
msgid "Depreciation Functions::"
msgstr ""

#. type: node
#: ../../calc.texi:17538 ../../calc.texi:17839 ../../calc.texi:17910
#, no-wrap
msgid "Definitions of Financial Functions"
msgstr ""

#. type: node
#: ../../calc.texi:17540 ../../calc.texi:17541 ../../calc.texi:17605
#, no-wrap
msgid "Percentages"
msgstr ""

#. type: node
#: ../../calc.texi:17540 ../../calc.texi:17605 ../../calc.texi:17606 ../../calc.texi:17667
#, no-wrap
msgid "Future Value"
msgstr ""

#. type: kindex
#: ../../calc.texi:17543
#, no-wrap
msgid "M-%"
msgstr ""

#. type: pindex
#: ../../calc.texi:17544
#, no-wrap
msgid "calc-percent"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17551
msgid ""
"@tindex % @tindex percent The @kbd{M-%} (@code{calc-percent}) command takes "
"a percentage value, say 5.4, and converts it to an equivalent actual "
"number.  For example, @kbd{5.4 M-%} enters 0.054 on the stack.  (That's the "
"@key{META} or @key{ESC} key combined with @kbd{%}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17560
msgid ""
"Actually, @kbd{M-%} creates a formula of the form @samp{5.4%}.  You can "
"enter @samp{5.4%} yourself during algebraic entry.  The @samp{%} operator "
"simply means, ``the preceding value divided by 100.'' The @samp{%} operator "
"has very high precedence, so that @samp{1+8%} is interpreted as "
"@samp{1+(8%)}, not as @samp{(1+8)%}.  (The @samp{%} operator is just a "
"postfix notation for the @code{percent} function, just like @samp{20!} is "
"the notation for @samp{fact(20)}, or twenty-factorial.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17567
msgid ""
"The formula @samp{5.4%} would normally evaluate immediately to 0.054, but "
"the @kbd{M-%} command suppresses evaluation as it puts the formula onto the "
"stack.  However, the next Calc command that uses the formula @samp{5.4%} "
"will evaluate it as its first step.  The net effect is that you get to look "
"at @samp{5.4%} on the stack, but Calc commands see it as @samp{0.054}, which "
"is what they expect."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17572
msgid ""
"In particular, @samp{5.4%} and @samp{0.054} are suitable values for the "
"@var{rate} arguments of the various financial functions, but the number "
"@samp{5.4} is probably @emph{not} suitable---it represents a rate of 540 "
"percent!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17576
msgid ""
"The key sequence @kbd{M-% *} effectively means ``percent-of.'' For example, "
"@kbd{68 @key{RET} 25 M-% *} computes 17, which is 25% of 68 (and also 68% of "
"25, which comes out to the same thing)."
msgstr ""

#. type: kindex
#: ../../calc.texi:17577
#, no-wrap
msgid "c %"
msgstr ""

#. type: pindex
#: ../../calc.texi:17578
#, no-wrap
msgid "calc-convert-percent"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17586
msgid ""
"The @kbd{c %} (@code{calc-convert-percent}) command converts the value on "
"the top of the stack from numeric to percentage form.  For example, if 0.08 "
"is on the stack, @kbd{c %} converts it to @samp{8%}.  The quantity is the "
"same, it's just represented differently.  (Contrast this with @kbd{M-%}, "
"which would convert this number to @samp{0.08%}.)  The @kbd{=} key is a "
"convenient way to convert a formula like @samp{8%} back to numeric form, "
"0.08."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17590
msgid ""
"To compute what percentage one quantity is of another quantity, use @kbd{/ c "
"%}.  For example, @w{@kbd{17 @key{RET} 68 / c %}} displays @samp{25%}."
msgstr ""

#. type: kindex
#: ../../calc.texi:17591
#, no-wrap
msgid "b %"
msgstr ""

#. type: pindex
#: ../../calc.texi:17592
#, no-wrap
msgid "calc-percent-change"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17604
msgid ""
"@tindex relch The @kbd{b %} (@code{calc-percent-change}) [@code{relch}] "
"command calculates the percentage change from one number to another.  For "
"example, @kbd{40 @key{RET} 50 b %} produces the answer @samp{25%}, since 50 "
"is 25% larger than 40.  A negative result represents a decrease: @kbd{50 "
"@key{RET} 40 b %} produces @samp{-20%}, since 40 is 20% smaller than 50.  "
"(The answers are different in magnitude because, in the first case, we're "
"increasing by 25% of 40, but in the second case, we're decreasing by 20% of "
"50.)  The effect of @kbd{40 @key{RET} 50 b %} is to compute "
"@expr{(50-40)/40}, converting the answer to percentage form as if by @kbd{c "
"%}."
msgstr ""

#. type: node
#: ../../calc.texi:17605 ../../calc.texi:17667 ../../calc.texi:17668 ../../calc.texi:17751
#, no-wrap
msgid "Present Value"
msgstr ""

#. type: kindex
#: ../../calc.texi:17609
#, no-wrap
msgid "b F"
msgstr ""

#. type: pindex
#: ../../calc.texi:17610
#, no-wrap
msgid "calc-fin-fv"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17622
msgid ""
"@tindex fv The @kbd{b F} (@code{calc-fin-fv}) [@code{fv}] command computes "
"the future value of an investment.  It takes three arguments from the stack: "
"@samp{fv(@var{rate}, @var{n}, @var{payment})}.  If you give payments of "
"@var{payment} every year for @var{n} years, and the money you have paid "
"earns interest at @var{rate} per year, then this function tells you what "
"your investment would be worth at the end of the period.  (The actual "
"interval doesn't have to be years, as long as @var{n} and @var{rate} are "
"expressed in terms of the same intervals.)  This function assumes payments "
"occur at the @emph{end} of each interval."
msgstr ""

#. type: kindex
#: ../../calc.texi:17623
#, no-wrap
msgid "I b F"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17634
msgid ""
"@tindex fvb The @kbd{I b F} [@code{fvb}] command does the same computation, "
"but assuming your payments are at the beginning of each interval.  Suppose "
"you plan to deposit $1000 per year in a savings account earning 5.4% "
"interest, starting right now.  How much will be in the account after five "
"years? @code{fvb(5.4%, 5, 1000) = 5870.73}.  Thus you will have earned $870 "
"worth of interest over the years.  Using the stack, this calculation would "
"have been @kbd{5.4 M-% 5 @key{RET} 1000 I b F}.  Note that the rate is "
"expressed as a number between 0 and 1, @emph{not} as a percentage."
msgstr ""

#. type: kindex
#: ../../calc.texi:17635
#, no-wrap
msgid "H b F"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17641
msgid ""
"@tindex fvl The @kbd{H b F} [@code{fvl}] command computes the future value "
"of an initial lump sum investment.  Suppose you could deposit those five "
"thousand dollars in the bank right now; how much would they be worth in five "
"years? @code{fvl(5.4%, 5, 5000) = 6503.89}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17647
msgid ""
"The algebraic functions @code{fv} and @code{fvb} accept an optional fourth "
"argument, which is used as an initial lump sum in the sense of @code{fvl}.  "
"In other words, @code{fv(@var{rate}, @var{n}, @var{payment}, @var{initial}) "
"= fv(@var{rate}, @var{n}, @var{payment})  + fvl(@var{rate}, @var{n}, "
"@var{initial})}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17658
msgid ""
"To illustrate the relationships between these functions, we could do the "
"@code{fvb} calculation ``by hand'' using @code{fvl}.  The final balance will "
"be the sum of the contributions of our five deposits at various times.  The "
"first deposit earns interest for five years: @code{fvl(5.4%, 5, 1000) = "
"1300.78}.  The second deposit only earns interest for four years: "
"@code{fvl(5.4%, 4, 1000) = 1234.13}.  And so on down to the last deposit, "
"which earns one year's interest: @code{fvl(5.4%, 1, 1000) = 1054.00}.  The "
"sum of these five values is, sure enough, $5870.73, just as was computed by "
"@code{fvb} directly."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17666
msgid ""
"What does @code{fv(5.4%, 5, 1000) = 5569.96} mean? The payments are now at "
"the ends of the periods.  The end of one year is the same as the beginning "
"of the next, so what this really means is that we've lost the payment at "
"year zero (which contributed $1300.78), but we're now counting the payment "
"at year five (which, since it didn't have a chance to earn interest, counts "
"as $1000).  Indeed, @expr{5569.96 = 5870.73 - 1300.78 + 1000} (give or take "
"a bit of roundoff error)."
msgstr ""

#. type: node
#: ../../calc.texi:17667 ../../calc.texi:17751 ../../calc.texi:17752 ../../calc.texi:17839
#, no-wrap
msgid "Related Financial Functions"
msgstr ""

#. type: kindex
#: ../../calc.texi:17671
#, no-wrap
msgid "b P"
msgstr ""

#. type: pindex
#: ../../calc.texi:17672
#, no-wrap
msgid "calc-fin-pv"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17687
msgid ""
"@tindex pv The @kbd{b P} (@code{calc-fin-pv}) [@code{pv}] command computes "
"the present value of an investment.  Like @code{fv}, it takes three "
"arguments: @code{pv(@var{rate}, @var{n}, @var{payment})}.  It computes the "
"present value of a series of regular payments.  Suppose you have the chance "
"to make an investment that will pay $2000 per year over the next four years; "
"as you receive these payments you can put them in the bank at 9% interest.  "
"You want to know whether it is better to make the investment, or to keep the "
"money in the bank where it earns 9% interest right from the start.  The "
"calculation @code{pv(9%, 4, 2000)} gives the result 6479.44.  If your "
"initial investment must be less than this, say, $6000, then the investment "
"is worthwhile.  But if you had to put up $7000, then it would be better just "
"to leave it in the bank."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17697
msgid ""
"Here is the interpretation of the result of @code{pv}: You are trying to "
"compare the return from the investment you are considering, which is "
"@code{fv(9%, 4, 2000) = 9146.26}, with the return from leaving the money in "
"the bank, which is @code{fvl(9%, 4, @var{x})} where @var{x} is the amount of "
"money you would have to put up in advance.  The @code{pv} function finds the "
"break-even point, @expr{x = 6479.44}, at which @code{fvl(9%, 4, 6479.44)} is "
"also equal to 9146.26.  This is the largest amount you should be willing to "
"invest."
msgstr ""

#. type: kindex
#: ../../calc.texi:17698
#, no-wrap
msgid "I b P"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17706
msgid ""
"@tindex pvb The @kbd{I b P} [@code{pvb}] command solves the same problem, "
"but with payments occurring at the beginning of each interval.  It has the "
"same relationship to @code{fvb} as @code{pv} has to @code{fv}.  For example "
"@code{pvb(9%, 4, 2000) = 7062.59}, a larger number than @code{pv} produced "
"because we get to start earning interest on the return from our investment "
"sooner."
msgstr ""

#. type: kindex
#: ../../calc.texi:17707
#, no-wrap
msgid "H b P"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17716
msgid ""
"@tindex pvl The @kbd{H b P} [@code{pvl}] command computes the present value "
"of an investment that will pay off in one lump sum at the end of the "
"period.  For example, if we get our $8000 all at the end of the four years, "
"@code{pvl(9%, 4, 8000) = 5667.40}.  This is much less than @code{pv} "
"reported, because we don't earn any interest on the return from this "
"investment.  Note that @code{pvl} and @code{fvl} are simple inverses: "
"@code{fvl(9%, 4, 5667.40) = 8000}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17720
msgid ""
"You can give an optional fourth lump-sum argument to @code{pv} and "
"@code{pvb}; this is handled in exactly the same way as the fourth argument "
"for @code{fv} and @code{fvb}."
msgstr ""

#. type: kindex
#: ../../calc.texi:17721
#, no-wrap
msgid "b N"
msgstr ""

#. type: pindex
#: ../../calc.texi:17722
#, no-wrap
msgid "calc-fin-npv"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17731
msgid ""
"@tindex npv The @kbd{b N} (@code{calc-fin-npv}) [@code{npv}] command "
"computes the net present value of a series of irregular investments.  The "
"first argument is the interest rate.  The second argument is a vector which "
"represents the expected return from the investment at the end of each "
"interval.  For example, if the rate represents a yearly interest rate, then "
"the vector elements are the return from the first year, second year, and so "
"on."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17735
msgid ""
"Thus, @code{npv(9%, [2000,2000,2000,2000]) = pv(9%, 4, 2000) = 6479.44}.  "
"Obviously this function is more interesting when the payments are not all "
"the same!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17744
msgid ""
"The @code{npv} function can actually have two or more arguments.  Multiple "
"arguments are interpreted in the same way as for the vector statistical "
"functions like @code{vsum}.  @xref{Single-Variable Statistics}.  Basically, "
"if there are several payment arguments, each either a vector or a plain "
"number, all these values are collected left-to-right into the complete list "
"of payments.  A numeric prefix argument on the @kbd{b N} command says how "
"many payment values or vectors to take from the stack."
msgstr ""

#. type: kindex
#: ../../calc.texi:17745
#, no-wrap
msgid "I b N"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17750
msgid ""
"@tindex npvb The @kbd{I b N} [@code{npvb}] command computes the net present "
"value where payments occur at the beginning of each interval rather than at "
"the end."
msgstr ""

#. type: node
#: ../../calc.texi:17751 ../../calc.texi:17839 ../../calc.texi:17840 ../../calc.texi:17910
#, no-wrap
msgid "Depreciation Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17757
msgid ""
"The functions in this section are basically inverses of the present value "
"functions with respect to the various arguments."
msgstr ""

#. type: kindex
#: ../../calc.texi:17758
#, no-wrap
msgid "b M"
msgstr ""

#. type: pindex
#: ../../calc.texi:17759
#, no-wrap
msgid "calc-fin-pmt"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17766
msgid ""
"@tindex pmt The @kbd{b M} (@code{calc-fin-pmt}) [@code{pmt}] command "
"computes the amount of periodic payment necessary to amortize a loan.  Thus "
"@code{pmt(@var{rate}, @var{n}, @var{amount})} equals the value of "
"@var{payment} such that @code{pv(@var{rate}, @var{n}, @var{payment}) = "
"@var{amount}}."
msgstr ""

#. type: kindex
#: ../../calc.texi:17767
#, no-wrap
msgid "I b M"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17773
msgid ""
"@tindex pmtb The @kbd{I b M} [@code{pmtb}] command does the same computation "
"but using @code{pvb} instead of @code{pv}.  Like @code{pv} and @code{pvb}, "
"these functions can also take a fourth argument which represents an initial "
"lump-sum investment."
msgstr ""

#. type: kindex
#: ../../calc.texi:17774
#, no-wrap
msgid "H b M"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17777
msgid ""
"The @kbd{H b M} key just invokes the @code{fvl} function, which is the "
"inverse of @code{pvl}.  There is no explicit @code{pmtl} function."
msgstr ""

#. type: kindex
#: ../../calc.texi:17778
#, no-wrap
msgid "b #"
msgstr ""

#. type: pindex
#: ../../calc.texi:17779
#, no-wrap
msgid "calc-fin-nper"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17788
msgid ""
"@tindex nper The @kbd{b #} (@code{calc-fin-nper}) [@code{nper}] command "
"computes the number of regular payments necessary to amortize a loan.  Thus "
"@code{nper(@var{rate}, @var{payment}, @var{amount})} equals the value of "
"@var{n} such that @code{pv(@var{rate}, @var{n}, @var{payment}) = "
"@var{amount}}.  If @var{payment} is too small ever to amortize a loan for "
"@var{amount} at interest rate @var{rate}, the @code{nper} function is left "
"in symbolic form."
msgstr ""

#. type: kindex
#: ../../calc.texi:17789
#, no-wrap
msgid "I b #"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17795
msgid ""
"@tindex nperb The @kbd{I b #} [@code{nperb}] command does the same "
"computation but using @code{pvb} instead of @code{pv}.  You can give a "
"fourth lump-sum argument to these functions, but the computation will be "
"rather slow in the four-argument case."
msgstr ""

#. type: kindex
#: ../../calc.texi:17796
#, no-wrap
msgid "H b #"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17803
msgid ""
"@tindex nperl The @kbd{H b #} [@code{nperl}] command does the same "
"computation using @code{pvl}.  By exchanging @var{payment} and @var{amount} "
"you can also get the solution for @code{fvl}.  For example, @code{nperl(8%, "
"2000, 1000) = 9.006}, so if you place $1000 in a bank account earning 8%, it "
"will take nine years to grow to $2000."
msgstr ""

#. type: kindex
#: ../../calc.texi:17804
#, no-wrap
msgid "b T"
msgstr ""

#. type: pindex
#: ../../calc.texi:17805
#, no-wrap
msgid "calc-fin-rate"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17812
msgid ""
"@tindex rate The @kbd{b T} (@code{calc-fin-rate}) [@code{rate}] command "
"computes the rate of return on an investment.  This is also an inverse of "
"@code{pv}: @code{rate(@var{n}, @var{payment}, @var{amount})} computes the "
"value of @var{rate} such that @code{pv(@var{rate}, @var{n}, @var{payment}) = "
"@var{amount}}.  The result is expressed as a formula like @samp{6.3%}."
msgstr ""

#. type: kindex
#: ../../calc.texi:17813
#, no-wrap
msgid "I b T"
msgstr ""

#. type: kindex
#: ../../calc.texi:17814
#, no-wrap
msgid "H b T"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17824
msgid ""
"@tindex rateb @tindex ratel The @kbd{I b T} [@code{rateb}] and @kbd{H b T} "
"[@code{ratel}] commands solve the analogous equations with @code{pvb} or "
"@code{pvl} in place of @code{pv}.  Also, @code{rate} and @code{rateb} can "
"accept an optional fourth argument just like @code{pv} and @code{pvb}.  To "
"redo the above example from a different perspective, @code{ratel(9, 2000, "
"1000) = 8.00597%}, which says you will need an interest rate of 8% in order "
"to double your account in nine years."
msgstr ""

#. type: kindex
#: ../../calc.texi:17825
#, no-wrap
msgid "b I"
msgstr ""

#. type: pindex
#: ../../calc.texi:17826
#, no-wrap
msgid "calc-fin-irr"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17833
msgid ""
"@tindex irr The @kbd{b I} (@code{calc-fin-irr}) [@code{irr}] command is the "
"analogous function to @code{rate} but for net present value.  Its argument "
"is a vector of payments.  Thus @code{irr(@var{payments})} computes the "
"@var{rate} such that @code{npv(@var{rate}, @var{payments}) = 0}; this rate "
"is known as the @dfn{internal rate of return}."
msgstr ""

#. type: kindex
#: ../../calc.texi:17834
#, no-wrap
msgid "I b I"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17838
msgid ""
"@tindex irrb The @kbd{I b I} [@code{irrb}] command computes the internal "
"rate of return assuming payments occur at the beginning of each period."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17849
msgid ""
"The functions in this section calculate @dfn{depreciation}, which is the "
"amount of value that a possession loses over time.  These functions are "
"characterized by three parameters: @var{cost}, the original cost of the "
"asset; @var{salvage}, the value the asset will have at the end of its "
"expected ``useful life''; and @var{life}, the number of years (or other "
"periods) of the expected useful life."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17852
msgid ""
"There are several methods for calculating depreciation that differ in the "
"way they spread the depreciation over the lifetime of the asset."
msgstr ""

#. type: kindex
#: ../../calc.texi:17853
#, no-wrap
msgid "b S"
msgstr ""

#. type: pindex
#: ../../calc.texi:17854
#, no-wrap
msgid "calc-fin-sln"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17862
msgid ""
"@tindex sln The @kbd{b S} (@code{calc-fin-sln}) [@code{sln}] command "
"computes the ``straight-line'' depreciation.  In this method, the asset "
"depreciates by the same amount every year (or period).  For example, "
"@samp{sln(12000, 2000, 5)} returns 2000.  The asset costs $12000 initially "
"and will be worth $2000 after five years; it loses $2000 per year."
msgstr ""

#. type: kindex
#: ../../calc.texi:17863
#, no-wrap
msgid "b Y"
msgstr ""

#. type: pindex
#: ../../calc.texi:17864
#, no-wrap
msgid "calc-fin-syd"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17873
msgid ""
"@tindex syd The @kbd{b Y} (@code{calc-fin-syd}) [@code{syd}] command "
"computes the accelerated ``sum-of-years'-digits'' depreciation.  Here the "
"depreciation is higher during the early years of the asset's life.  Since "
"the depreciation is different each year, @kbd{b Y} takes a fourth "
"@var{period} parameter which specifies which year is requested, from 1 to "
"@var{life}.  If @var{period} is outside this range, the @code{syd} function "
"will return zero."
msgstr ""

#. type: kindex
#: ../../calc.texi:17874
#, no-wrap
msgid "b D"
msgstr ""

#. type: pindex
#: ../../calc.texi:17875
#, no-wrap
msgid "calc-fin-ddb"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17880
msgid ""
"@tindex ddb The @kbd{b D} (@code{calc-fin-ddb}) [@code{ddb}] command "
"computes an accelerated depreciation using the double-declining balance "
"method.  It also takes a fourth @var{period} parameter."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17884
msgid ""
"For symmetry, the @code{sln} function will accept a @var{period} parameter "
"as well, although it will ignore its value except that the return value will "
"as usual be zero if @var{period} is out of range."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17889
msgid ""
"For example, pushing the vector @expr{[1,2,3,4,5]} (perhaps with @kbd{v x "
"5})  and then mapping @kbd{V M ' [sln(12000,2000,5,$), syd(12000,2000,5,$), "
"ddb(12000,2000,5,$)] @key{RET}} produces a matrix that allows us to compare "
"the three depreciation methods:"
msgstr ""

#. type: group
#: ../../calc.texi:17897
#, no-wrap
msgid ""
"[ [ 2000, 3333, 4800 ]\n"
"  [ 2000, 2667, 2880 ]\n"
"  [ 2000, 2000, 1728 ]\n"
"  [ 2000, 1333,  592 ]\n"
"  [ 2000,  667,   0  ] ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17905
msgid ""
"(Values have been rounded to nearest integers in this figure.)  We see that "
"@code{sln} depreciates by the same amount each year, @kbd{syd} depreciates "
"more at the beginning and less at the end, and @kbd{ddb} weights the "
"depreciation even more toward the beginning."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17909
msgid ""
"Summing columns with @kbd{V R : +} yields @expr{[10000, 10000, 10000]}; the "
"total depreciation in any method is (by definition) the difference between "
"the cost and the salvage value."
msgstr ""

#. type: subsection
#: ../../calc.texi:17911
#, no-wrap
msgid "Definitions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:17916
msgid ""
"For your reference, here are the actual formulas used to compute Calc's "
"financial functions."
msgstr ""

#. type: Plain text
#: ../../calc.texi:17923
msgid ""
"Calc will not evaluate a financial function unless the @var{rate} or @var{n} "
"argument is known.  However, @var{payment} or @var{amount} can be a "
"variable.  Calc expands these functions according to the formulas below for "
"symbolic arguments only when you use the @kbd{a \"} "
"(@code{calc-expand-formula}) command, or when taking derivatives or "
"integrals or solving equations involving the functions."
msgstr ""

#. type: ifnottex
#: ../../calc.texi:17928
msgid ""
"These formulas are shown using the conventions of Big display mode (@kbd{d "
"B}); for example, the formula for @code{fv} written linearly is @samp{pmt * "
"((1 + rate)^n) - 1) / rate}."
msgstr ""

#. type: example
#: ../../calc.texi:17934
#, no-wrap
msgid ""
"                                        n\n"
"                              (1 + rate)  - 1\n"
"fv(rate, n, pmt) =      pmt * ---------------\n"
"                                   rate\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:17939
#, no-wrap
msgid ""
"                                         n\n"
"                              ((1 + rate)  - 1) (1 + rate)\n"
"fvb(rate, n, pmt) =     pmt * ----------------------------\n"
"                                         rate\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:17942
#, no-wrap
msgid ""
"                                        n\n"
"fvl(rate, n, pmt) =     pmt * (1 + rate)\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:17947
#, no-wrap
msgid ""
"                                            -n\n"
"                              1 - (1 + rate)\n"
"pv(rate, n, pmt) =      pmt * ----------------\n"
"                                    rate\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:17952
#, no-wrap
msgid ""
"                                             -n\n"
"                              (1 - (1 + rate)  ) (1 + rate)\n"
"pvb(rate, n, pmt) =     pmt * -----------------------------\n"
"                                         rate\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:17955
#, no-wrap
msgid ""
"                                        -n\n"
"pvl(rate, n, pmt) =     pmt * (1 + rate)\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:17958
#, no-wrap
msgid ""
"                                    -1               -2               -3\n"
"npv(rate, [a, b, c]) =  a*(1 + rate)   + b*(1 + rate)   + c*(1 + rate)\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:17961
#, no-wrap
msgid ""
"                                        -1               -2\n"
"npvb(rate, [a, b, c]) = a + b*(1 + rate)   + c*(1 + rate)\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:17967
#, no-wrap
msgid ""
"                                             -n\n"
"                        (amt - x * (1 + rate)  ) * rate\n"
"pmt(rate, n, amt, x) =  -------------------------------\n"
"                                             -n\n"
"                               1 - (1 + rate)\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:17973
#, no-wrap
msgid ""
"                                             -n\n"
"                        (amt - x * (1 + rate)  ) * rate\n"
"pmtb(rate, n, amt, x) = -------------------------------\n"
"                                        -n\n"
"                         (1 - (1 + rate)  ) (1 + rate)\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:17977
#, no-wrap
msgid ""
"                                   amt * rate\n"
"nper(rate, pmt, amt) =  - log(1 - ------------, 1 + rate)\n"
"                                      pmt\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:17981
#, no-wrap
msgid ""
"                                    amt * rate\n"
"nperb(rate, pmt, amt) = - log(1 - ---------------, 1 + rate)\n"
"                                  pmt * (1 + rate)\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:17985
#, no-wrap
msgid ""
"                              amt\n"
"nperl(rate, pmt, amt) = - log(---, 1 + rate)\n"
"                              pmt\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:17991
#, no-wrap
msgid ""
"                           1/n\n"
"                        pmt\n"
"ratel(n, pmt, amt) =    ------ - 1\n"
"                           1/n\n"
"                        amt\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:17995
#, no-wrap
msgid ""
"                        cost - salv\n"
"sln(cost, salv, life) = -----------\n"
"                           life\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:17999
#, no-wrap
msgid ""
"                             (cost - salv) * (life - per + 1)\n"
"syd(cost, salv, life, per) = --------------------------------\n"
"                                  life * (life + 1) / 2\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:18003
#, no-wrap
msgid ""
"                             book * 2\n"
"ddb(cost, salv, life, per) = --------,  book = cost - depreciation so far\n"
"                               life\n"
msgstr ""

#. type: tex
#: ../../calc.texi:18024
#, no-wrap
msgid ""
"$$ \\code{fv}(r, n, p) = p { (1 + r)^n - 1 \\over r } $$\n"
"$$ \\code{fvb}(r, n, p) = p { ((1 + r)^n - 1) (1 + r) \\over r } $$\n"
"$$ \\code{fvl}(r, n, p) = p (1 + r)^n $$\n"
"$$ \\code{pv}(r, n, p) = p { 1 - (1 + r)^{-n} \\over r } $$\n"
"$$ \\code{pvb}(r, n, p) = p { (1 - (1 + r)^{-n}) (1 + r) \\over r } $$\n"
"$$ \\code{pvl}(r, n, p) = p (1 + r)^{-n} $$\n"
"$$ \\code{npv}(r, [a,b,c]) = a (1 + r)^{-1} + b (1 + r)^{-2} + c (1 + "
"r)^{-3} $$\n"
"$$ \\code{npvb}(r, [a,b,c]) = a + b (1 + r)^{-1} + c (1 + r)^{-2} $$\n"
"$$ \\code{pmt}(r, n, a, x) = { (a - x (1 + r)^{-n}) r \\over 1 - (1 + "
"r)^{-n} }$$\n"
"$$ \\code{pmtb}(r, n, a, x) = { (a - x (1 + r)^{-n}) r \\over\n"
"                               (1 - (1 + r)^{-n}) (1 + r) } $$\n"
"$$ \\code{nper}(r, p, a) = -\\code{log}(1 - { a r \\over p }, 1 + r) $$\n"
"$$ \\code{nperb}(r, p, a) = -\\code{log}(1 - { a r \\over p (1 + r) }, 1 + "
"r) $$\n"
"$$ \\code{nperl}(r, p, a) = -\\code{log}({a \\over p}, 1 + r) $$\n"
"$$ \\code{ratel}(n, p, a) = { p^{1/n} \\over a^{1/n} } - 1 $$\n"
"$$ \\code{sln}(c, s, l) = { c - s \\over l } $$\n"
"$$ \\code{syd}(c, s, l, p) = { (c - s) (l - p + 1) \\over l (l+1) / 2 } $$\n"
"$$ \\code{ddb}(c, s, l, p) = { 2 (c - \\hbox{depreciation so far}) \\over l "
"} $$\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18028
msgid "In @code{pmt} and @code{pmtb}, @expr{x=0} if omitted."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18033
msgid ""
"These functions accept any numeric objects, including error forms, "
"intervals, and even (though not very usefully) complex numbers.  The above "
"formulas specify exactly the behavior of these functions with all sorts of "
"inputs."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18037
msgid ""
"Note that if the first argument to the @code{log} in @code{nper} is "
"negative, @code{nper} leaves itself in symbolic form rather than returning a "
"(financially meaningless) complex number."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18044
msgid ""
"@samp{rate(num, pmt, amt)} solves the equation @samp{pv(rate, num, pmt) = "
"amt} for @samp{rate} using @kbd{H a R} (@code{calc-find-root}), with the "
"interval @samp{[.01% .. 100%]} for an initial guess.  The @code{rateb} "
"function is the same except that it uses @code{pvb}.  Note that @code{ratel} "
"can be solved directly; its formula is shown in the above list."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18047
msgid ""
"Similarly, @samp{irr(pmts)} solves the equation @samp{npv(rate, pmts) = 0} "
"for @samp{rate}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18051
msgid ""
"If you give a fourth argument to @code{nper} or @code{nperb}, Calc will also "
"use @kbd{H a R} to solve the equation using an initial guess interval of "
"@samp{[0 .. 100]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18055
msgid ""
"A fourth argument to @code{fv} simply sums the two components calculated "
"from the above formulas for @code{fv} and @code{fvl}.  The same is true of "
"@code{fvb}, @code{pv}, and @code{pvb}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18063
msgid ""
"The @kbd{ddb} function is computed iteratively; the ``book'' value starts "
"out equal to @var{cost}, and decreases according to the above formula for "
"the specified number of periods.  If the book value would decrease below "
"@var{salvage}, it only decreases to @var{salvage} and the depreciation is "
"zero for all subsequent periods.  The @code{ddb} function returns the amount "
"the book value decreased in the specified period."
msgstr ""

#. type: section
#: ../../calc.texi:18065
#, no-wrap
msgid "Binary Number Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18070
msgid ""
"The commands in this chapter all use two-letter sequences beginning with the "
"@kbd{b} prefix."
msgstr ""

#. type: cindex
#: ../../calc.texi:18071
#, no-wrap
msgid "Binary numbers"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18077
msgid ""
"The ``binary'' operations actually work regardless of the currently "
"displayed radix, although their results make the most sense in a radix like "
"2, 8, or 16 (as obtained by the @kbd{d 2}, @kbd{d 8}, or @w{@kbd{d 6}} "
"commands, respectively).  You may also wish to enable display of leading "
"zeros with @kbd{d z}.  @xref{Radix Modes}."
msgstr ""

#. type: cindex
#: ../../calc.texi:18078
#, no-wrap
msgid "Word size for binary operations"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18084
msgid ""
"The Calculator maintains a current @dfn{word size} @expr{w}, an arbitrary "
"positive or negative integer.  For a positive word size, all of the binary "
"operations described here operate modulo @expr{2^w}.  In particular, "
"negative arguments are converted to positive integers modulo @expr{2^w} by "
"all binary functions."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18094
msgid ""
"If the word size is negative, binary operations produce twos-complement "
"integers from @texline @math{-2^{-w-1}} @infoline @expr{-(2^(-w-1))} to "
"@texline @math{2^{-w-1}-1} @infoline @expr{2^(-w-1)-1} inclusive.  Either "
"mode accepts inputs in any range; the sign of @expr{w} affects only the "
"results produced."
msgstr ""

#. type: kindex
#: ../../calc.texi:18095
#, no-wrap
msgid "b c"
msgstr ""

#. type: pindex
#: ../../calc.texi:18096
#, no-wrap
msgid "calc-clip"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18107
msgid ""
"@tindex clip The @kbd{b c} (@code{calc-clip})  [@code{clip}] command can be "
"used to clip a number by reducing it modulo @expr{2^w}.  The commands "
"described in this chapter automatically clip their results to the current "
"word size.  Note that other operations like addition do not use the current "
"word size, since integer addition generally is not ``binary.'' (However, "
"@pxref{Simplification Modes}, @code{calc-bin-simplify-mode}.)  For example, "
"with a word size of 8 bits @kbd{b c} converts a number to the range 0 to "
"255; with a word size of @mathit{-8} @kbd{b c} converts to the range "
"@mathit{-128} to 127."
msgstr ""

#. type: kindex
#: ../../calc.texi:18108
#, no-wrap
msgid "b w"
msgstr ""

#. type: pindex
#: ../../calc.texi:18109
#, no-wrap
msgid "calc-word-size"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18117
msgid ""
"The default word size is 32 bits.  All operations except the shifts and "
"rotates allow you to specify a different word size for that one operation by "
"giving a numeric prefix argument: @kbd{C-u 8 b c} clips the top of stack to "
"the range 0 to 255 regardless of the current word size.  To set the word "
"size permanently, use @kbd{b w} (@code{calc-word-size}).  This command "
"displays a prompt with the current word size; press @key{RET} immediately to "
"keep this word size, or type a new word size at the prompt."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18125
msgid ""
"When the binary operations are written in symbolic form, they take an "
"optional second (or third) word-size parameter.  When a formula like "
"@samp{and(a,b)} is finally evaluated, the word size current at that time "
"will be used, but when @samp{and(a,b,-8)} is evaluated, a word size of "
"@mathit{-8} will always be used.  A symbolic binary function will be left in "
"symbolic form unless the all of its argument(s) are integers or "
"integer-valued floats."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18130
msgid ""
"If either or both arguments are modulo forms for which @expr{M} is a power "
"of two, that power of two is taken as the word size unless a numeric prefix "
"argument overrides it.  The current word size is never consulted when "
"modulo-power-of-two forms are involved."
msgstr ""

#. type: kindex
#: ../../calc.texi:18131
#, no-wrap
msgid "b a"
msgstr ""

#. type: pindex
#: ../../calc.texi:18132
#, no-wrap
msgid "calc-and"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18139
msgid ""
"@tindex and The @kbd{b a} (@code{calc-and}) [@code{and}] command computes "
"the bitwise AND of the two numbers on the top of the stack.  In other words, "
"for each of the @expr{w} binary digits of the two numbers (pairwise), the "
"corresponding bit of the result is 1 if and only if both input bits are 1: "
"@samp{and(2#1100, 2#1010) = 2#1000}."
msgstr ""

#. type: kindex
#: ../../calc.texi:18140
#, no-wrap
msgid "b o"
msgstr ""

#. type: pindex
#: ../../calc.texi:18141
#, no-wrap
msgid "calc-or"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18146
msgid ""
"@tindex or The @kbd{b o} (@code{calc-or}) [@code{or}] command computes the "
"bitwise inclusive OR of two numbers.  A bit is 1 if either of the input "
"bits, or both, are 1: @samp{or(2#1100, 2#1010) = 2#1110}."
msgstr ""

#. type: kindex
#: ../../calc.texi:18147
#, no-wrap
msgid "b x"
msgstr ""

#. type: pindex
#: ../../calc.texi:18148
#, no-wrap
msgid "calc-xor"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18153
msgid ""
"@tindex xor The @kbd{b x} (@code{calc-xor}) [@code{xor}] command computes "
"the bitwise exclusive OR of two numbers.  A bit is 1 if exactly one of the "
"input bits is 1: @samp{xor(2#1100, 2#1010) = 2#0110}."
msgstr ""

#. type: kindex
#: ../../calc.texi:18154
#, no-wrap
msgid "b d"
msgstr ""

#. type: pindex
#: ../../calc.texi:18155
#, no-wrap
msgid "calc-diff"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18160
msgid ""
"@tindex diff The @kbd{b d} (@code{calc-diff}) [@code{diff}] command computes "
"the bitwise difference of two numbers; this is defined by @samp{diff(a,b) = "
"and(a,not(b))}, so that @samp{diff(2#1100, 2#1010) = 2#0100}."
msgstr ""

#. type: kindex
#: ../../calc.texi:18161
#, no-wrap
msgid "b n"
msgstr ""

#. type: pindex
#: ../../calc.texi:18162
#, no-wrap
msgid "calc-not"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18166
msgid ""
"@tindex not The @kbd{b n} (@code{calc-not}) [@code{not}] command computes "
"the bitwise NOT of a number.  A bit is 1 if the input bit is 0 and "
"vice-versa."
msgstr ""

#. type: kindex
#: ../../calc.texi:18167
#, no-wrap
msgid "b l"
msgstr ""

#. type: pindex
#: ../../calc.texi:18168
#, no-wrap
msgid "calc-lshift-binary"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18176
msgid ""
"@tindex lsh The @kbd{b l} (@code{calc-lshift-binary}) [@code{lsh}] command "
"shifts a number left by one bit, or by the number of bits specified in the "
"numeric prefix argument.  A negative prefix argument performs a logical "
"right shift, in which zeros are shifted in on the left.  In symbolic form, "
"@samp{lsh(a)} is short for @samp{lsh(a,1)}, which in turn is short for "
"@samp{lsh(a,n,w)}.  Bits shifted ``off the end,'' according to the current "
"word size, are lost."
msgstr ""

#. type: kindex
#: ../../calc.texi:18177
#, no-wrap
msgid "H b l"
msgstr ""

#. type: kindex
#: ../../calc.texi:18178
#, no-wrap
msgid "H b r"
msgstr ""

#. type: kindex
#: ../../calc.texi:18182
#, no-wrap
msgid "H b L"
msgstr ""

#. type: kindex
#: ../../calc.texi:18186
#, no-wrap
msgid "H b R"
msgstr ""

#. type: kindex
#: ../../calc.texi:18190
#, no-wrap
msgid "H b t"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18196
msgid ""
"The @kbd{H b l} command also does a left shift, but it takes two arguments "
"from the stack (the value to shift, and, at top-of-stack, the number of bits "
"to shift).  This version interprets the prefix argument just like the "
"regular binary operations, i.e., as a word size.  The Hyperbolic flag has a "
"similar effect on the rest of the binary shift and rotate commands."
msgstr ""

#. type: kindex
#: ../../calc.texi:18197
#, no-wrap
msgid "b r"
msgstr ""

#. type: pindex
#: ../../calc.texi:18198
#, no-wrap
msgid "calc-rshift-binary"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18203
msgid ""
"@tindex rsh The @kbd{b r} (@code{calc-rshift-binary}) [@code{rsh}] command "
"shifts a number right by one bit, or by the number of bits specified in the "
"numeric prefix argument: @samp{rsh(a,n) = lsh(a,-n)}."
msgstr ""

#. type: kindex
#: ../../calc.texi:18204
#, no-wrap
msgid "b L"
msgstr ""

#. type: pindex
#: ../../calc.texi:18205
#, no-wrap
msgid "calc-lshift-arith"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18211
msgid ""
"@tindex ash The @kbd{b L} (@code{calc-lshift-arith}) [@code{ash}] command "
"shifts a number left.  It is analogous to @code{lsh}, except that if the "
"shift is rightward (the prefix argument is negative), an arithmetic shift is "
"performed as described below."
msgstr ""

#. type: kindex
#: ../../calc.texi:18212
#, no-wrap
msgid "b R"
msgstr ""

#. type: pindex
#: ../../calc.texi:18213
#, no-wrap
msgid "calc-rshift-arith"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18223
msgid ""
"@tindex rash The @kbd{b R} (@code{calc-rshift-arith}) [@code{rash}] command "
"performs an ``arithmetic'' shift to the right, in which the leftmost bit "
"(according to the current word size) is duplicated rather than shifting in "
"zeros.  This corresponds to dividing by a power of two where the input is "
"interpreted as a signed, twos-complement number.  (The distinction between "
"the @samp{rsh} and @samp{rash} operations is totally independent from "
"whether the word size is positive or negative.)  With a negative prefix "
"argument, this performs a standard left shift."
msgstr ""

#. type: kindex
#: ../../calc.texi:18224
#, no-wrap
msgid "b t"
msgstr ""

#. type: pindex
#: ../../calc.texi:18225
#, no-wrap
msgid "calc-rotate-binary"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18232
msgid ""
"@tindex rot The @kbd{b t} (@code{calc-rotate-binary}) [@code{rot}] command "
"rotates a number one bit to the left.  The leftmost bit (according to the "
"current word size) is dropped off the left and shifted in on the right.  "
"With a numeric prefix argument, the number is rotated that many bits to the "
"left or right."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18238
msgid ""
"@xref{Set Operations}, for the @kbd{b p} and @kbd{b u} commands that pack "
"and unpack binary integers into sets.  (For example, @kbd{b u} unpacks the "
"number @samp{2#11001} to the set of bit-numbers @samp{[0, 3, 4]}.)  Type "
"@kbd{b u V #} to count the number of ``1'' bits in a binary integer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18244
msgid ""
"Another interesting use of the set representation of binary integers is to "
"reverse the bits in, say, a 32-bit integer.  Type @kbd{b u} to unpack; type "
"@kbd{31 @key{TAB} -} to replace each bit-number in the set with 31 minus "
"that bit-number; type @kbd{b p} to pack the set back into a binary integer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18253
msgid ""
"The functions described here perform trigonometric and other transcendental "
"calculations.  They generally produce floating-point answers correct to the "
"full current precision.  The @kbd{H} (Hyperbolic) and @kbd{I} (Inverse)  "
"flag keys must be used to get some of these functions from the keyboard."
msgstr ""

#. type: pindex
#: ../../calc.texi:18255
#, no-wrap
msgid "calc-pi"
msgstr ""

#. type: kindex
#: ../../calc.texi:18258
#, no-wrap
msgid "H P"
msgstr ""

#. type: kindex
#: ../../calc.texi:18261
#, no-wrap
msgid "I P"
msgstr ""

#. type: kindex
#: ../../calc.texi:18266
#, no-wrap
msgid "H I P"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18285
msgid ""
"One miscellaneous command is shift-@kbd{P} (@code{calc-pi}), which pushes "
"the value of @cpi{} (at the current precision) onto the stack.  With the "
"Hyperbolic flag, it pushes the value @expr{e}, the base of natural "
"logarithms.  With the Inverse flag, it pushes Euler's constant @texline "
"@math{\\gamma} @infoline @expr{gamma} (about 0.5772).  With both Inverse and "
"Hyperbolic, it pushes the ``golden ratio'' @texline @math{\\phi} @infoline "
"@expr{phi} (about 1.618).  (At present, Euler's constant is not available to "
"unlimited precision; Calc knows only the first 100 digits.)  In Symbolic "
"mode, these commands push the actual variables @samp{pi}, @samp{e}, "
"@samp{gamma}, and @samp{phi}, respectively, instead of their values; "
"@pxref{Symbolic Mode}."
msgstr ""

#. type: kindex
#: ../../calc.texi:18292
#, no-wrap
msgid "I Q"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18297
msgid ""
"@tindex sqr The @kbd{Q} (@code{calc-sqrt}) [@code{sqrt}] function is "
"described elsewhere; @pxref{Basic Arithmetic}.  With the Inverse flag "
"[@code{sqr}], this command computes the square of the argument."
msgstr ""

#. type: menuentry
#: ../../calc.texi:18310
msgid "Logarithmic Functions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:18310
msgid "Trigonometric and Hyperbolic Functions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:18310
msgid "Advanced Math Functions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:18310
msgid "Branch Cuts::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:18310
msgid "Random Numbers::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:18310
msgid "Combinatorial Functions::"
msgstr ""

#. type: section
#: ../../calc.texi:18310 ../../calc.texi:19092 ../../calc.texi:19308 ../../calc.texi:19309
#, no-wrap
msgid "Probability Distribution Functions"
msgstr ""

#. type: node
#: ../../calc.texi:18312 ../../calc.texi:18313 ../../calc.texi:18406
#, no-wrap
msgid "Logarithmic Functions"
msgstr ""

#. type: node
#: ../../calc.texi:18312 ../../calc.texi:18406 ../../calc.texi:18583
#, no-wrap
msgid "Trigonometric and Hyperbolic Functions"
msgstr ""

#. type: pindex
#: ../../calc.texi:18317
#, no-wrap
msgid "calc-ln"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18319
msgid "@tindex ln"
msgstr ""

#. type: kindex
#: ../../calc.texi:18322
#, no-wrap
msgid "I E"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18327
msgid ""
"The shift-@kbd{L} (@code{calc-ln}) [@code{ln}] command computes the natural "
"logarithm of the real or complex number on the top of the stack.  With the "
"Inverse flag it computes the exponential function instead, although this is "
"redundant with the @kbd{E} command."
msgstr ""

#. type: pindex
#: ../../calc.texi:18329
#, no-wrap
msgid "calc-exp"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18331
msgid "@tindex exp"
msgstr ""

#. type: kindex
#: ../../calc.texi:18334
#, no-wrap
msgid "I L"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18339
msgid ""
"The shift-@kbd{E} (@code{calc-exp}) [@code{exp}] command computes the "
"exponential, i.e., @expr{e} raised to the power of the number on the stack.  "
"The meanings of the Inverse and Hyperbolic flags follow from those for the "
"@code{calc-ln} command."
msgstr ""

#. type: kindex
#: ../../calc.texi:18340
#, no-wrap
msgid "H L"
msgstr ""

#. type: kindex
#: ../../calc.texi:18341
#, no-wrap
msgid "H E"
msgstr ""

#. type: pindex
#: ../../calc.texi:18342
#, no-wrap
msgid "calc-log10"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18345
msgid "@tindex log10 @tindex exp10"
msgstr ""

#. type: kindex
#: ../../calc.texi:18348
#, no-wrap
msgid "H I L"
msgstr ""

#. type: kindex
#: ../../calc.texi:18352
#, no-wrap
msgid "H I E"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18360
msgid ""
"The @kbd{H L} (@code{calc-log10}) [@code{log10}] command computes the common "
"(base-10) logarithm of a number.  (With the Inverse flag [@code{exp10}], it "
"raises ten to a given power.)  Note that the common logarithm of a complex "
"number is computed by taking the natural logarithm and dividing by @texline "
"@math{\\ln10}.  @infoline @expr{ln(10)}."
msgstr ""

#. type: kindex
#: ../../calc.texi:18362
#, no-wrap
msgid "I B"
msgstr ""

#. type: pindex
#: ../../calc.texi:18363
#, no-wrap
msgid "calc-log"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18374
msgid ""
"@tindex log @tindex alog The @kbd{B} (@code{calc-log}) [@code{log}] command "
"computes a logarithm to any base.  For example, @kbd{1024 @key{RET} 2 B} "
"produces 10, since @texline @math{2^{10} = 1024}.  @infoline @expr{2^10 = "
"1024}.  In certain cases like @samp{log(3,9)}, the result will be either "
"@expr{1:2} or @expr{0.5} depending on the current Fraction mode setting.  "
"With the Inverse flag [@code{alog}], this command is similar to @kbd{^} "
"except that the order of the arguments is reversed."
msgstr ""

#. type: kindex
#: ../../calc.texi:18375
#, no-wrap
msgid "f I"
msgstr ""

#. type: pindex
#: ../../calc.texi:18376
#, no-wrap
msgid "calc-ilog"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18385
msgid ""
"@tindex ilog The @kbd{f I} (@code{calc-ilog}) [@code{ilog}] command computes "
"the integer logarithm of a number to any base.  The number and the base must "
"themselves be positive integers.  This is the true logarithm, rounded down "
"to an integer.  Thus @kbd{ilog(x,10)} is 3 for all @expr{x} in the range "
"from 1000 to 9999.  If both arguments are positive integers, exact integer "
"arithmetic is used; otherwise, this is equivalent to @samp{floor(log(x,b))}."
msgstr ""

#. type: kindex
#: ../../calc.texi:18386
#, no-wrap
msgid "f E"
msgstr ""

#. type: pindex
#: ../../calc.texi:18387
#, no-wrap
msgid "calc-expm1"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18397
msgid ""
"@tindex expm1 The @kbd{f E} (@code{calc-expm1}) [@code{expm1}] command "
"computes @texline @math{e^x - 1}, @infoline @expr{exp(x)-1}, but using an "
"algorithm that produces a more accurate answer when the result is close to "
"zero, i.e., when @texline @math{e^x} @infoline @expr{exp(x)} is close to "
"one."
msgstr ""

#. type: kindex
#: ../../calc.texi:18398
#, no-wrap
msgid "f L"
msgstr ""

#. type: pindex
#: ../../calc.texi:18399
#, no-wrap
msgid "calc-lnp1"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18405
msgid ""
"@tindex lnp1 The @kbd{f L} (@code{calc-lnp1}) [@code{lnp1}] command computes "
"@texline @math{\\ln(x+1)}, @infoline @expr{ln(x+1)}, producing a more "
"accurate answer when @expr{x} is close to zero."
msgstr ""

#. type: node
#: ../../calc.texi:18406 ../../calc.texi:18583 ../../calc.texi:18720
#, no-wrap
msgid "Advanced Math Functions"
msgstr ""

#. type: section
#: ../../calc.texi:18407
#, no-wrap
msgid "Trigonometric/Hyperbolic Functions"
msgstr ""

#. type: pindex
#: ../../calc.texi:18411
#, no-wrap
msgid "calc-sin"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18418
msgid ""
"@tindex sin The shift-@kbd{S} (@code{calc-sin}) [@code{sin}] command "
"computes the sine of an angle or complex number.  If the input is an HMS "
"form, it is interpreted as degrees-minutes-seconds; otherwise, the input is "
"interpreted according to the current angular mode.  It is best to use "
"Radians mode when operating on complex numbers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18424
msgid ""
"Calc's ``units'' mechanism includes angular units like @code{deg}, "
"@code{rad}, and @code{grad}.  While @samp{sin(45 deg)} is not evaluated all "
"the time, the @kbd{u s} (@code{calc-simplify-units}) command will simplify "
"@samp{sin(45 deg)} by taking the sine of 45 degrees, regardless of the "
"current angular mode.  @xref{Basic Operations on Units}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18435
msgid ""
"Also, the symbolic variable @code{pi} is not ordinarily recognized in "
"arguments to trigonometric functions, as in @samp{sin(3 pi / 4)}, but the "
"default algebraic simplifications recognize many such formulas when the "
"current angular mode is Radians @emph{and} Symbolic mode is enabled; this "
"example would be replaced by @samp{sqrt(2) / 2}.  @xref{Symbolic Mode}.  "
"Beware, this simplification occurs even if you have stored a different value "
"in the variable @samp{pi}; this is one reason why changing built-in "
"variables is a bad idea.  Arguments of the form @expr{x} plus a multiple of "
"@cpiover{2} are also simplified.  Calc includes similar formulas for "
"@code{cos} and @code{tan}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18440
msgid ""
"Calc's algebraic simplifications know all angles which are integer multiples "
"of @cpiover{12}, @cpiover{10}, or @cpiover{8} radians.  In Degrees mode, "
"analogous simplifications occur for integer multiples of 15 or 18 degrees, "
"and for arguments plus multiples of 90 degrees."
msgstr ""

#. type: kindex
#: ../../calc.texi:18441
#, no-wrap
msgid "I S"
msgstr ""

#. type: pindex
#: ../../calc.texi:18442
#, no-wrap
msgid "calc-arcsin"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18448
msgid ""
"@tindex arcsin With the Inverse flag, @code{calc-sin} computes an arcsine.  "
"This is also available as the @code{calc-arcsin} command or @code{arcsin} "
"algebraic function.  The returned argument is converted to degrees, radians, "
"or HMS notation depending on the current angular mode."
msgstr ""

#. type: kindex
#: ../../calc.texi:18449
#, no-wrap
msgid "H S"
msgstr ""

#. type: pindex
#: ../../calc.texi:18450
#, no-wrap
msgid "calc-sinh"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18452
msgid "@tindex sinh"
msgstr ""

#. type: kindex
#: ../../calc.texi:18452
#, no-wrap
msgid "H I S"
msgstr ""

#. type: pindex
#: ../../calc.texi:18453
#, no-wrap
msgid "calc-arcsinh"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18459
msgid ""
"@tindex arcsinh With the Hyperbolic flag, @code{calc-sin} computes the "
"hyperbolic sine, also available as @code{calc-sinh} [@code{sinh}].  With the "
"Hyperbolic and Inverse flags, it computes the hyperbolic arcsine "
"(@code{calc-arcsinh}) [@code{arcsinh}]."
msgstr ""

#. type: pindex
#: ../../calc.texi:18461
#, no-wrap
msgid "calc-cos"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18463
msgid "@tindex cos"
msgstr ""

#. type: kindex
#: ../../calc.texi:18466
#, no-wrap
msgid "I C"
msgstr ""

#. type: pindex
#: ../../calc.texi:18467
#, no-wrap
msgid "calc-arccos"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18472
msgid "@tindex arccos"
msgstr ""

#. type: kindex
#: ../../calc.texi:18475
#, no-wrap
msgid "H C"
msgstr ""

#. type: pindex
#: ../../calc.texi:18476
#, no-wrap
msgid "calc-cosh"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18481
msgid "@tindex cosh"
msgstr ""

#. type: kindex
#: ../../calc.texi:18484
#, no-wrap
msgid "H I C"
msgstr ""

#. type: pindex
#: ../../calc.texi:18485
#, no-wrap
msgid "calc-arccosh"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18490
msgid "@tindex arccosh"
msgstr ""

#. type: pindex
#: ../../calc.texi:18494
#, no-wrap
msgid "calc-tan"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18499
msgid "@tindex tan"
msgstr ""

#. type: kindex
#: ../../calc.texi:18502
#, no-wrap
msgid "I T"
msgstr ""

#. type: pindex
#: ../../calc.texi:18503
#, no-wrap
msgid "calc-arctan"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18508
msgid "@tindex arctan"
msgstr ""

#. type: kindex
#: ../../calc.texi:18511
#, no-wrap
msgid "H T"
msgstr ""

#. type: pindex
#: ../../calc.texi:18512
#, no-wrap
msgid "calc-tanh"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18517
msgid "@tindex tanh"
msgstr ""

#. type: kindex
#: ../../calc.texi:18520
#, no-wrap
msgid "H I T"
msgstr ""

#. type: pindex
#: ../../calc.texi:18521
#, no-wrap
msgid "calc-arctanh"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18530
msgid ""
"@tindex arctanh The shift-@kbd{C} (@code{calc-cos}) [@code{cos}] command "
"computes the cosine of an angle or complex number, and shift-@kbd{T} "
"(@code{calc-tan}) [@code{tan}] computes the tangent, along with all the "
"various inverse and hyperbolic variants of these functions."
msgstr ""

#. type: kindex
#: ../../calc.texi:18531
#, no-wrap
msgid "f T"
msgstr ""

#. type: pindex
#: ../../calc.texi:18532
#, no-wrap
msgid "calc-arctan2"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18544
msgid ""
"@tindex arctan2 The @kbd{f T} (@code{calc-arctan2}) [@code{arctan2}] command "
"takes two numbers from the stack and computes the arc tangent of their "
"ratio.  The result is in the full range from @mathit{-180} (exclusive) to "
"@mathit{+180} (inclusive) degrees, or the analogous range in radians.  A "
"similar result would be obtained with @kbd{/} followed by @kbd{I T}, but the "
"value would only be in the range from @mathit{-90} to @mathit{+90} degrees "
"since the division loses information about the signs of the two components, "
"and an error might result from an explicit division by zero which "
"@code{arctan2} would avoid.  By (arbitrary) definition, "
"@samp{arctan2(0,0)=0}."
msgstr ""

#. type: pindex
#: ../../calc.texi:18545
#, no-wrap
msgid "calc-sincos"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18550
msgid "@tindex sincos"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18563
msgid ""
"@tindex arcsincos The @code{calc-sincos} [@code{sincos}] command computes "
"the sine and cosine of a number, returning them as a vector of the form "
"@samp{[@var{cos}, @var{sin}]}.  With the Inverse flag [@code{arcsincos}], "
"this command takes a two-element vector as an argument and computes "
"@code{arctan2} of the elements.  (This command does not accept the "
"Hyperbolic flag.)"
msgstr ""

#. type: pindex
#: ../../calc.texi:18564
#, no-wrap
msgid "calc-sec"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18566
msgid "@tindex sec"
msgstr ""

#. type: pindex
#: ../../calc.texi:18566
#, no-wrap
msgid "calc-csc"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18568
msgid "@tindex csc"
msgstr ""

#. type: pindex
#: ../../calc.texi:18568
#, no-wrap
msgid "calc-cot"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18570
msgid "@tindex cot"
msgstr ""

#. type: pindex
#: ../../calc.texi:18570
#, no-wrap
msgid "calc-sech"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18572
msgid "@tindex sech"
msgstr ""

#. type: pindex
#: ../../calc.texi:18572
#, no-wrap
msgid "calc-csch"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18574
msgid "@tindex csch"
msgstr ""

#. type: pindex
#: ../../calc.texi:18574
#, no-wrap
msgid "calc-coth"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18582
msgid ""
"@tindex coth The remaining trigonometric functions, @code{calc-sec} "
"[@code{sec}], @code{calc-csc} [@code{csc}] and @code{calc-cot} [@code{cot}], "
"are also available.  With the Hyperbolic flag, these compute their "
"hyperbolic counterparts, which are also available separately as "
"@code{calc-sech} [@code{sech}], @code{calc-csch} [@code{csch}] and "
"@code{calc-coth} [@code{coth}].  (These commands do not accept the Inverse "
"flag.)"
msgstr ""

#. type: node
#: ../../calc.texi:18583 ../../calc.texi:18720 ../../calc.texi:18864
#, no-wrap
msgid "Branch Cuts"
msgstr ""

#. type: section
#: ../../calc.texi:18584
#, no-wrap
msgid "Advanced Mathematical Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18592
msgid ""
"Calc can compute a variety of less common functions that arise in various "
"branches of mathematics.  All of the functions described in this section "
"allow arbitrary complex arguments and, except as noted, will work to "
"arbitrarily large precision.  They can not at present handle error forms or "
"intervals as arguments."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18598
msgid ""
"NOTE: These functions are still experimental.  In particular, their accuracy "
"is not guaranteed in all domains.  It is advisable to set the current "
"precision comfortably higher than you actually need when using these "
"functions.  Also, these functions may be impractically slow for some values "
"of the arguments."
msgstr ""

#. type: kindex
#: ../../calc.texi:18599
#, no-wrap
msgid "f g"
msgstr ""

#. type: pindex
#: ../../calc.texi:18600
#, no-wrap
msgid "calc-gamma"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18610
msgid ""
"@tindex gamma The @kbd{f g} (@code{calc-gamma}) [@code{gamma}] command "
"computes the Euler gamma function.  For positive integer arguments, this is "
"related to the factorial function: @samp{gamma(n+1) = fact(n)}.  For general "
"complex arguments the gamma function can be defined by the following "
"definite integral: @texline @math{\\Gamma(a) = \\int_0^\\infty t^{a-1} e^t "
"dt}.  @infoline @expr{gamma(a) = integ(t^(a-1) exp(t), t, 0, inf)}.  (The "
"actual implementation uses far more efficient computational methods.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:18611
#, no-wrap
msgid "f G"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18613
msgid "@tindex gammaP"
msgstr ""

#. type: kindex
#: ../../calc.texi:18616
#, no-wrap
msgid "I f G"
msgstr ""

#. type: kindex
#: ../../calc.texi:18620
#, no-wrap
msgid "H f G"
msgstr ""

#. type: kindex
#: ../../calc.texi:18624
#, no-wrap
msgid "H I f G"
msgstr ""

#. type: pindex
#: ../../calc.texi:18625
#, no-wrap
msgid "calc-inc-gamma"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18630
msgid "@tindex gammaQ"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18634
msgid "@tindex gammag"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18645
msgid ""
"@tindex gammaG The @kbd{f G} (@code{calc-inc-gamma}) [@code{gammaP}] command "
"computes the incomplete gamma function, denoted @samp{P(a,x)}.  This is "
"defined by the integral, @texline @math{P(a,x) = \\left( \\int_0^x t^{a-1} "
"e^t dt \\right) / \\Gamma(a)}.  @infoline @expr{gammaP(a,x) = integ(t^(a-1) "
"exp(t), t, 0, x) / gamma(a)}.  This implies that @samp{gammaP(a,inf) = 1} "
"for any @expr{a} (see the definition of the normal gamma function)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18651
msgid ""
"Several other varieties of incomplete gamma function are defined.  The "
"complement of @expr{P(a,x)}, called @expr{Q(a,x) = 1-P(a,x)} by some "
"authors, is computed by the @kbd{I f G} [@code{gammaQ}] command.  You can "
"think of this as taking the other half of the integral, from @expr{x} to "
"infinity."
msgstr ""

#. type: ifnottex
#: ../../calc.texi:18659
msgid ""
"The functions corresponding to the integrals that define @expr{P(a,x)} and "
"@expr{Q(a,x)} but without the normalizing @expr{1/gamma(a)} factor are "
"called @expr{g(a,x)} and @expr{G(a,x)}, respectively (where @expr{g} and "
"@expr{G} represent the lower- and upper-case Greek letter gamma).  You can "
"obtain these using the @kbd{H f G} [@code{gammag}] and @kbd{H I f G} "
"[@code{gammaG}] commands."
msgstr ""

#. type: tex
#: ../../calc.texi:18666
#, no-wrap
msgid ""
"The functions corresponding to the integrals that define $P(a,x)$\n"
"and $Q(a,x)$ but without the normalizing $1/\\Gamma(a)$\n"
"factor are called $\\gamma(a,x)$ and $\\Gamma(a,x)$, respectively.\n"
"You can obtain these using the \\kbd{H f G} [\\code{gammag}] and\n"
"\\kbd{I H f G} [\\code{gammaG}] commands.\n"
msgstr ""

#. type: kindex
#: ../../calc.texi:18668
#, no-wrap
msgid "f b"
msgstr ""

#. type: pindex
#: ../../calc.texi:18669
#, no-wrap
msgid "calc-beta"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18678
msgid ""
"@tindex beta The @kbd{f b} (@code{calc-beta}) [@code{beta}] command computes "
"the Euler beta function, which is defined in terms of the gamma function as "
"@texline @math{B(a,b) = \\Gamma(a) \\Gamma(b) / \\Gamma(a+b)}, @infoline "
"@expr{beta(a,b) = gamma(a) gamma(b) / gamma(a+b)}, or by @texline "
"@math{B(a,b) = \\int_0^1 t^{a-1} (1-t)^{b-1} dt}.  @infoline @expr{beta(a,b) "
"= integ(t^(a-1) (1-t)^(b-1), t, 0, 1)}."
msgstr ""

#. type: kindex
#: ../../calc.texi:18679
#, no-wrap
msgid "f B"
msgstr ""

#. type: kindex
#: ../../calc.texi:18680
#, no-wrap
msgid "H f B"
msgstr ""

#. type: pindex
#: ../../calc.texi:18681
#, no-wrap
msgid "calc-inc-beta"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18690
msgid ""
"@tindex betaI @tindex betaB The @kbd{f B} (@code{calc-inc-beta}) "
"[@code{betaI}] command computes the incomplete beta function "
"@expr{I(x,a,b)}.  It is defined by @texline @math{I(x,a,b) = \\left( "
"\\int_0^x t^{a-1} (1-t)^{b-1} dt \\right) / B(a,b)}.  @infoline "
"@expr{betaI(x,a,b) = integ(t^(a-1) (1-t)^(b-1), t, 0, x) / beta(a,b)}.  Once "
"again, the @kbd{H} (hyperbolic) prefix gives the corresponding un-normalized "
"version [@code{betaB}]."
msgstr ""

#. type: kindex
#: ../../calc.texi:18691
#, no-wrap
msgid "f e"
msgstr ""

#. type: kindex
#: ../../calc.texi:18692
#, no-wrap
msgid "I f e"
msgstr ""

#. type: pindex
#: ../../calc.texi:18693
#, no-wrap
msgid "calc-erf"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18704
msgid ""
"@tindex erf @tindex erfc The @kbd{f e} (@code{calc-erf}) [@code{erf}] "
"command computes the error function @texline @math{\\hbox{erf}(x) = {2 "
"\\over \\sqrt{\\pi}} \\int_0^x e^{-t^2} dt}.  @infoline @expr{erf(x) = 2 "
"integ(exp(-(t^2)), t, 0, x) / sqrt(pi)}.  The complementary error function "
"@kbd{I f e} (@code{calc-erfc}) [@code{erfc}] is the corresponding integral "
"from @samp{x} to infinity; the sum @texline @math{\\hbox{erf}(x) + "
"\\hbox{erfc}(x) = 1}.  @infoline @expr{erf(x) + erfc(x) = 1}."
msgstr ""

#. type: kindex
#: ../../calc.texi:18705
#, no-wrap
msgid "f j"
msgstr ""

#. type: kindex
#: ../../calc.texi:18706
#, no-wrap
msgid "f y"
msgstr ""

#. type: pindex
#: ../../calc.texi:18707
#, no-wrap
msgid "calc-bessel-J"
msgstr ""

#. type: pindex
#: ../../calc.texi:18708
#, no-wrap
msgid "calc-bessel-Y"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18719
msgid ""
"@tindex besJ @tindex besY The @kbd{f j} (@code{calc-bessel-J}) [@code{besJ}] "
"and @kbd{f y} (@code{calc-bessel-Y}) [@code{besY}] commands compute the "
"Bessel functions of the first and second kinds, respectively.  In "
"@samp{besJ(n,x)} and @samp{besY(n,x)} the ``order'' parameter @expr{n} is "
"often an integer, but is not required to be one.  Calc's implementation of "
"the Bessel functions currently limits the precision to 8 digits, and may not "
"be exact even to that precision.  Use with care!"
msgstr ""

#. type: node
#: ../../calc.texi:18720 ../../calc.texi:18864 ../../calc.texi:18865 ../../calc.texi:18994 ../../calc.texi:19092
#, no-wrap
msgid "Random Numbers"
msgstr ""

#. type: section
#: ../../calc.texi:18721
#, no-wrap
msgid "Branch Cuts and Principal Values"
msgstr ""

#. type: cindex
#: ../../calc.texi:18724
#, no-wrap
msgid "Branch cuts"
msgstr ""

#. type: cindex
#: ../../calc.texi:18725
#, no-wrap
msgid "Principal values"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18734
msgid ""
"All of the logarithmic, trigonometric, and other scientific functions are "
"defined for complex numbers as well as for reals.  This section describes "
"the values returned in cases where the general result is a family of "
"possible values.  Calc follows section 12.5.3 of Steele's @dfn{Common Lisp, "
"the Language}, second edition, in these matters.  This section will describe "
"each function briefly; for a more detailed discussion (including some nifty "
"diagrams), consult Steele's book."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18738
msgid ""
"Note that the branch cuts for @code{arctan} and @code{arctanh} were changed "
"between the first and second editions of Steele.  Recent versions of Calc "
"follow the second edition."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18745
msgid ""
"The new branch cuts exactly match those of the HP-28/48 calculators.  They "
"also match those of Mathematica 1.2, except that Mathematica's @code{arctan} "
"cut is always in the right half of the complex plane, and its @code{arctanh} "
"cut is always in the top half of the plane.  Calc's cuts are continuous with "
"quadrants I and III for @code{arctan}, or II and IV for @code{arctanh}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18750
msgid ""
"Note: The current implementations of these functions with complex arguments "
"are designed with proper behavior around the branch cuts in mind, @emph{not} "
"efficiency or accuracy.  You may need to increase the floating precision and "
"wait a while to get suitable answers from them."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18755
msgid ""
"For @samp{sqrt(a+bi)}: When @expr{a<0} and @expr{b} is small but positive or "
"zero, the result is close to the @expr{+i} axis.  For @expr{b} small and "
"negative, the result is close to the @expr{-i} axis.  The result always lies "
"in the right half of the complex plane."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18760
msgid ""
"For @samp{ln(a+bi)}: The real part is defined as @samp{ln(abs(a+bi))}.  The "
"imaginary part is defined as @samp{arg(a+bi) = arctan2(b,a)}.  Thus the "
"branch cuts for @code{sqrt} and @code{ln} both lie on the negative real "
"axis."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18766
msgid ""
"The following table describes these branch cuts in another way.  If the real "
"and imaginary parts of @expr{z} are as shown, then the real and imaginary "
"parts of @expr{f(z)} will be as shown.  Here @code{eps} stands for a small "
"positive value; each occurrence of @code{eps} may stand for a different "
"small value."
msgstr ""

#. type: smallexample
#: ../../calc.texi:18774
#, no-wrap
msgid ""
"     z           sqrt(z)       ln(z)\n"
"----------------------------------------\n"
"   +,   0         +,  0       any, 0\n"
"   -,   0         0,  +       any, pi\n"
"   -, +eps      +eps, +      +eps, +\n"
"   -, -eps      +eps, -      +eps, -\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18782
msgid ""
"For @samp{z1^z2}: This is defined by @samp{exp(ln(z1)*z2)}.  One interesting "
"consequence of this is that @samp{(-8)^1:3} does not evaluate to @mathit{-2} "
"as you might expect, but to the complex number @expr{(1., 1.732)}.  Both of "
"these are valid cube roots of @mathit{-8} (as is @expr{(1., -1.732)}); Calc "
"chooses a perhaps less-obvious root for the sake of mathematical "
"consistency."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18785
msgid ""
"For @samp{arcsin(z)}: This is defined by @samp{-i*ln(i*z + sqrt(1-z^2))}.  "
"The branch cuts are on the real axis, less than @mathit{-1} and greater than "
"1."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18789
msgid ""
"For @samp{arccos(z)}: This is defined by @samp{-i*ln(z + i*sqrt(1-z^2))}, or "
"equivalently by @samp{pi/2 - arcsin(z)}.  The branch cuts are on the real "
"axis, less than @mathit{-1} and greater than 1."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18793
msgid ""
"For @samp{arctan(z)}: This is defined by @samp{(ln(1+i*z) - ln(1-i*z)) / "
"(2*i)}.  The branch cuts are on the imaginary axis, below @expr{-i} and "
"above @expr{i}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18797
msgid ""
"For @samp{arcsinh(z)}: This is defined by @samp{ln(z + sqrt(1+z^2))}.  The "
"branch cuts are on the imaginary axis, below @expr{-i} and above @expr{i}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18801
msgid ""
"For @samp{arccosh(z)}: This is defined by @samp{ln(z + "
"(z+1)*sqrt((z-1)/(z+1)))}.  The branch cut is on the real axis less than 1."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18804
msgid ""
"For @samp{arctanh(z)}: This is defined by @samp{(ln(1+z) - ln(1-z)) / 2}.  "
"The branch cuts are on the real axis, less than @mathit{-1} and greater than "
"1."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18808
msgid ""
"The following tables for @code{arcsin}, @code{arccos}, and @code{arctan} "
"assume the current angular mode is Radians.  The hyperbolic functions "
"operate independently of the angular mode."
msgstr ""

#. type: smallexample
#: ../../calc.texi:18821
#, no-wrap
msgid ""
"       z             arcsin(z)            arccos(z)\n"
"-------------------------------------------------------\n"
" (-1..1),  0      (-pi/2..pi/2), 0       (0..pi), 0\n"
" (-1..1), +eps    (-pi/2..pi/2), +eps    (0..pi), -eps\n"
" (-1..1), -eps    (-pi/2..pi/2), -eps    (0..pi), +eps\n"
"   <-1,    0          -pi/2,     +         pi,    -\n"
"   <-1,  +eps      -pi/2 + eps,  +      pi - eps, -\n"
"   <-1,  -eps      -pi/2 + eps,  -      pi - eps, +\n"
"    >1,    0           pi/2,     -          0,    +\n"
"    >1,  +eps       pi/2 - eps,  +        +eps,   -\n"
"    >1,  -eps       pi/2 - eps,  -        +eps,   +\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:18835
#, no-wrap
msgid ""
"       z            arccosh(z)         arctanh(z)\n"
"-----------------------------------------------------\n"
" (-1..1),  0        0,  (0..pi)       any,     0\n"
" (-1..1), +eps    +eps, (0..pi)       any,    +eps\n"
" (-1..1), -eps    +eps, (-pi..0)      any,    -eps\n"
"   <-1,    0        +,    pi           -,     pi/2\n"
"   <-1,  +eps       +,  pi - eps       -,  pi/2 - eps\n"
"   <-1,  -eps       +, -pi + eps       -, -pi/2 + eps\n"
"    >1,    0        +,     0           +,    -pi/2\n"
"    >1,  +eps       +,   +eps          +,  pi/2 - eps\n"
"    >1,  -eps       +,   -eps          +, -pi/2 + eps\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:18847
#, no-wrap
msgid ""
"       z           arcsinh(z)           arctan(z)\n"
"-----------------------------------------------------\n"
"   0, (-1..1)    0, (-pi/2..pi/2)         0,     any\n"
"   0,   <-1      -,    -pi/2            -pi/2,    -\n"
" +eps,  <-1      +, -pi/2 + eps       pi/2 - eps, -\n"
" -eps,  <-1      -, -pi/2 + eps      -pi/2 + eps, -\n"
"   0,    >1      +,     pi/2             pi/2,    +\n"
" +eps,   >1      +,  pi/2 - eps       pi/2 - eps, +\n"
" -eps,   >1      -,  pi/2 - eps      -pi/2 + eps, +\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18852
msgid ""
"Finally, the following identities help to illustrate the relationship "
"between the complex trigonometric and hyperbolic functions.  They are valid "
"everywhere, including on the branch cuts."
msgstr ""

#. type: smallexample
#: ../../calc.texi:18858
#, no-wrap
msgid ""
"sin(i*z)  = i*sinh(z)       arcsin(i*z)  = i*arcsinh(z)\n"
"cos(i*z)  =   cosh(z)       arcsinh(i*z) = i*arcsin(z)\n"
"tan(i*z)  = i*tanh(z)       arctan(i*z)  = i*arctanh(z)\n"
"sinh(i*z) = i*sin(z)        cosh(i*z)    =   cos(z)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18863
msgid ""
"The ``advanced math'' functions (gamma, Bessel, etc.@:) are also defined for "
"general complex arguments, but their branch cuts and principal values are "
"not rigorously specified at present."
msgstr ""

#. type: node
#: ../../calc.texi:18864 ../../calc.texi:19092 ../../calc.texi:19093 ../../calc.texi:19308
#, no-wrap
msgid "Combinatorial Functions"
msgstr ""

#. type: kindex
#: ../../calc.texi:18868
#, no-wrap
msgid "k r"
msgstr ""

#. type: pindex
#: ../../calc.texi:18869
#, no-wrap
msgid "calc-random"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18873
msgid ""
"@tindex random The @kbd{k r} (@code{calc-random}) [@code{random}] command "
"produces random numbers of various sorts."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18879
msgid ""
"Given a positive numeric prefix argument @expr{M}, it produces a random "
"integer @expr{N} in the range @texline @math{0 \\le N < M}.  @infoline "
"@expr{0 <= N < M}.  Each possible value @expr{N} appears with equal "
"probability."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18888
msgid ""
"With no numeric prefix argument, the @kbd{k r} command takes its argument "
"from the stack instead.  Once again, if this is a positive integer @expr{M} "
"the result is a random integer less than @expr{M}.  However, note that while "
"numeric prefix arguments are limited to six digits or so, an @expr{M} taken "
"from the stack can be arbitrarily large.  If @expr{M} is negative, the "
"result is a random integer in the range @texline @math{M < N \\le 0}.  "
"@infoline @expr{M < N <= 0}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18897
msgid ""
"If the value on the stack is a floating-point number @expr{M}, the result is "
"a random floating-point number @expr{N} in the range @texline @math{0 \\le N "
"< M} @infoline @expr{0 <= N < M} or @texline @math{M < N \\le 0}, @infoline "
"@expr{M < N <= 0}, according to the sign of @expr{M}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18902
msgid ""
"If @expr{M} is zero, the result is a Gaussian-distributed random real "
"number; the distribution has a mean of zero and a standard deviation of "
"one.  The algorithm used generates random numbers in pairs; thus, every "
"other call to this function will be especially fast."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18913
msgid ""
"If @expr{M} is an error form @texline @math{m} @code{+/-} @math{\\sigma} "
"@infoline @samp{m +/- s} where @var{m} and @texline @math{\\sigma} @infoline "
"@var{s} are both real numbers, the result uses a Gaussian distribution with "
"mean @var{m} and standard deviation @texline @math{\\sigma}.  @infoline "
"@var{s}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18925
msgid ""
"If @expr{M} is an interval form, the lower and upper bounds specify the "
"acceptable limits of the random numbers.  If both bounds are integers, the "
"result is a random integer in the specified range.  If either bound is "
"floating-point, the result is a random real number in the specified range.  "
"If the interval is open at either end, the result will be sure not to equal "
"that end value.  (This makes a big difference for integer intervals, but for "
"floating-point intervals it's relatively minor: with a precision of 6, "
"@samp{random([1.0..2.0))} will return any of one million numbers from "
"1.00000 to 1.99999; @samp{random([1.0..2.0])} may additionally return "
"2.00000, but the probability of this happening is extremely small.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18928
msgid ""
"If @expr{M} is a vector, the result is one element taken at random from the "
"vector.  All elements of the vector are given equal probabilities."
msgstr ""

#. type: vindex
#: ../../calc.texi:18929
#, no-wrap
msgid "RandSeed"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18941
msgid ""
"The sequence of numbers produced by @kbd{k r} is completely random by "
"default, i.e., the sequence is seeded each time you start Calc using the "
"current time and other information.  You can get a reproducible sequence by "
"storing a particular ``seed value'' in the Calc variable @code{RandSeed}.  "
"Any integer will do for a seed; integers of from 1 to 12 digits are good.  "
"If you later store a different integer into @code{RandSeed}, Calc will "
"switch to a different pseudo-random sequence.  If you ``unstore'' "
"@code{RandSeed}, Calc will re-seed itself from the current time.  If you "
"store the same integer that you used before back into @code{RandSeed}, you "
"will get the exact same sequence of random numbers as before."
msgstr ""

#. type: pindex
#: ../../calc.texi:18942
#, no-wrap
msgid "calc-rrandom"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18945
msgid ""
"The @code{calc-rrandom} command (not on any key) produces a random real "
"number between zero and one.  It is equivalent to @samp{random(1.0)}."
msgstr ""

#. type: kindex
#: ../../calc.texi:18946
#, no-wrap
msgid "k a"
msgstr ""

#. type: pindex
#: ../../calc.texi:18947
#, no-wrap
msgid "calc-random-again"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18952
msgid ""
"The @kbd{k a} (@code{calc-random-again}) command produces another random "
"number, re-using the most recent value of @expr{M}.  With a numeric prefix "
"argument @var{n}, it produces @var{n} more random numbers using that value "
"of @expr{M}."
msgstr ""

#. type: kindex
#: ../../calc.texi:18953
#, no-wrap
msgid "k h"
msgstr ""

#. type: pindex
#: ../../calc.texi:18954
#, no-wrap
msgid "calc-shuffle"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18963
msgid ""
"@tindex shuffle The @kbd{k h} (@code{calc-shuffle}) command produces a "
"vector of several random values with no duplicates.  The value on the top of "
"the stack specifies the set from which the random values are drawn, and may "
"be any of the @expr{M} formats described above.  The numeric prefix argument "
"gives the length of the desired list.  (If you do not provide a numeric "
"prefix argument, the length of the list is taken from the top of the stack, "
"and @expr{M} from second-to-top.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18975
msgid ""
"If @expr{M} is a floating-point number, zero, or an error form (so that the "
"random values are being drawn from the set of real numbers)  there is little "
"practical difference between using @kbd{k h} and using @kbd{k r} several "
"times.  But if the set of possible values consists of just a few integers, "
"or the elements of a vector, then there is a very real chance that multiple "
"@kbd{k r}'s will produce the same number more than once.  The @kbd{k h} "
"command produces a vector whose elements are always distinct.  (Actually, "
"there is a slight exception: If @expr{M} is a vector, no given vector "
"element will be drawn more than once, but if several elements of @expr{M} "
"are equal, they may each make it into the result vector.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:18983
msgid ""
"One use of @kbd{k h} is to rearrange a list at random.  This happens if the "
"prefix argument is equal to the number of values in the list: @kbd{[1, 1.5, "
"2, 2.5, 3] 5 k h} might produce the permuted list @samp{[2.5, 1, 1.5, 3, "
"2]}.  As a convenient feature, if the argument @var{n} is negative it is "
"replaced by the size of the set represented by @expr{M}.  Naturally, this is "
"allowed only when @expr{M} specifies a small discrete set of possibilities."
msgstr ""

#. type: Plain text
#: ../../calc.texi:18989
msgid ""
"To do the equivalent of @kbd{k h} but with duplications allowed, given "
"@expr{M} on the stack and with @var{n} just entered as a numeric prefix, use "
"@kbd{v b} to build a vector of copies of @expr{M}, then use @kbd{V M k r} to "
"``map'' the normal @kbd{k r} function over the elements of this vector.  "
"@xref{Matrix Functions}."
msgstr ""

#. type: subsection
#: ../../calc.texi:18992 ../../calc.texi:18994 ../../calc.texi:18995
#, no-wrap
msgid "Random Number Generator"
msgstr ""

#. type: menuentry
#: ../../calc.texi:18992
msgid "(Complete description of Calc's algorithm)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19002
msgid ""
"Calc's random number generator uses several methods to ensure that the "
"numbers it produces are highly random.  Knuth's @emph{Art of Computer "
"Programming}, Volume II, contains a thorough description of the theory of "
"random number generators and their measurement and characterization."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19007
msgid ""
"If @code{RandSeed} has no stored value, Calc calls Emacs's built-in "
"@code{random} function to get a stream of random numbers, which it then "
"treats in various ways to avoid problems inherent in the simple random "
"number generators that many systems use to implement @code{random}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19011
msgid ""
"When Calc's random number generator is first invoked, it ``seeds'' the "
"low-level random sequence using the time of day, so that the random number "
"sequence will be different every time you use Calc."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19020
msgid ""
"Since Emacs Lisp doesn't specify the range of values that will be returned "
"by its @code{random} function, Calc exercises the function several times to "
"estimate the range.  When Calc subsequently uses the @code{random} function, "
"it takes only 10 bits of the result near the most-significant end.  (It "
"avoids at least the bottom four bits, preferably more, and also tries to "
"avoid the top two bits.)  This strategy works well with the linear "
"congruential generators that are typically used to implement @code{random}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19038
msgid ""
"If @code{RandSeed} contains an integer, Calc uses this integer to seed an "
"``additive congruential'' method (Knuth's algorithm 3.2.2A, computing "
"@texline @math{X_{n-55} - X_{n-24}}.  @infoline @expr{X_n-55 - X_n-24}).  "
"This method expands the seed value into a large table which is maintained "
"internally; the variable @code{RandSeed} is changed from, e.g., 42 to the "
"vector @expr{[42]} to indicate that the seed has been absorbed into this "
"table.  When @code{RandSeed} contains a vector, @kbd{k r} and related "
"commands continue to use the same internal table as last time.  There is no "
"way to extract the complete state of the random number generator so that you "
"can restart it from any point; you can only restart it from the same initial "
"seed value.  A simple way to restart from the same seed is to type @kbd{s r "
"RandSeed} to get the seed vector, @kbd{v u} to unpack it back into a number, "
"then @kbd{s t RandSeed} to reseed the generator with that number."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19050
msgid ""
"Calc uses a ``shuffling'' method as described in algorithm 3.2.2B of Knuth.  "
"It fills a table with 13 random 10-bit numbers.  Then, to generate a new "
"random number, it uses the previous number to index into the table, picks "
"the value it finds there as the new random number, then replaces that table "
"entry with a new value obtained from a call to the base random number "
"generator (either the additive congruential generator or the @code{random} "
"function supplied by the system).  If there are any flaws in the base "
"generator, shuffling will tend to even them out.  But if the system provides "
"an excellent @code{random} function, shuffling will not damage its "
"randomness."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19057
msgid ""
"To create a random integer of a certain number of digits, Calc builds the "
"integer three decimal digits at a time.  For each group of three digits, "
"Calc calls its 10-bit shuffling random number generator (which returns a "
"value from 0 to 1023); if the random value is 1000 or more, Calc throws it "
"out and tries again until it gets a suitable value."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19075
msgid ""
"To create a random floating-point number with precision @var{p}, Calc simply "
"creates a random @var{p}-digit integer and multiplies by @texline "
"@math{10^{-p}}.  @infoline @expr{10^-p}.  The resulting random numbers "
"should be very clean, but note that relatively small numbers will have few "
"significant random digits.  In other words, with a precision of 12, you will "
"occasionally get numbers on the order of @texline @math{10^{-9}} @infoline "
"@expr{10^-9} or @texline @math{10^{-10}}, @infoline @expr{10^-10}, but those "
"numbers will only have two or three random digits since they correspond to "
"small integers times @texline @math{10^{-12}}.  @infoline @expr{10^-12}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19086
msgid ""
"To create a random integer in the interval @samp{[0 .. @var{m})}, Calc "
"counts the digits in @var{m}, creates a random integer with three additional "
"digits, then reduces modulo @var{m}.  Unless @var{m} is a power of ten the "
"resulting values will be very slightly biased toward the lower numbers, but "
"this bias will be less than 0.1%.  (For example, if @var{m} is 42, Calc will "
"reduce a random integer less than 100000 modulo 42 to get a result less than "
"42.  It is easy to show that the numbers 40 and 41 will be only 2380/2381 as "
"likely to result from this modulo operation as numbers 39 and below.)  If "
"@var{m} is a power of ten, however, the numbers should be completely "
"unbiased."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19091
msgid ""
"The Gaussian random numbers generated by @samp{random(0.0)} use the "
"``polar'' method described in Knuth section 3.4.1C@.  This method generates "
"a pair of Gaussian random numbers at a time, so only every other call to "
"@samp{random(0.0)} will require significant calculations."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19098
msgid ""
"Commands relating to combinatorics and number theory begin with the @kbd{k} "
"key prefix."
msgstr ""

#. type: kindex
#: ../../calc.texi:19099
#, no-wrap
msgid "k g"
msgstr ""

#. type: pindex
#: ../../calc.texi:19100
#, no-wrap
msgid "calc-gcd"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19109
msgid ""
"@tindex gcd The @kbd{k g} (@code{calc-gcd}) [@code{gcd}] command computes "
"the Greatest Common Divisor of two integers.  It also accepts fractions; the "
"GCD of two fractions is defined by taking the GCD of the numerators, and the "
"LCM of the denominators.  This definition is consistent with the idea that "
"@samp{a / gcd(a,x)} should yield an integer for any @samp{a} and @samp{x}.  "
"For other types of arguments, the operation is left in symbolic form."
msgstr ""

#. type: kindex
#: ../../calc.texi:19110
#, no-wrap
msgid "k l"
msgstr ""

#. type: pindex
#: ../../calc.texi:19111
#, no-wrap
msgid "calc-lcm"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19117
msgid ""
"@tindex lcm The @kbd{k l} (@code{calc-lcm}) [@code{lcm}] command computes "
"the Least Common Multiple of two integers or fractions.  The product of the "
"LCM and GCD of two numbers is equal to the absolute value of the product of "
"the numbers."
msgstr ""

#. type: kindex
#: ../../calc.texi:19118
#, no-wrap
msgid "k E"
msgstr ""

#. type: pindex
#: ../../calc.texi:19119
#, no-wrap
msgid "calc-extended-gcd"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19126
msgid ""
"@tindex egcd The @kbd{k E} (@code{calc-extended-gcd}) [@code{egcd}] command "
"computes the GCD of two integers @expr{x} and @expr{y} and returns a vector "
"@expr{[g, a, b]} where @texline @math{g = \\gcd(x,y) = a x + b y}.  "
"@infoline @expr{g = gcd(x,y) = a x + b y}."
msgstr ""

#. type: kindex
#: ../../calc.texi:19127
#, no-wrap
msgid "!"
msgstr ""

#. type: pindex
#: ../../calc.texi:19128
#, no-wrap
msgid "calc-factorial"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19130
msgid "@tindex fact"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19143
msgid ""
"@tindex ! The @kbd{!} (@code{calc-factorial}) [@code{fact}] command computes "
"the factorial of the number at the top of the stack.  If the number is an "
"integer, the result is an exact integer.  If the number is an integer-valued "
"float, the result is a floating-point approximation.  If the number is a "
"non-integral real number, the generalized factorial is used, as defined by "
"the Euler Gamma function.  Please note that computation of large factorials "
"can be slow; using floating-point format will help since fewer digits must "
"be maintained.  The same is true of many of the commands in this section."
msgstr ""

#. type: kindex
#: ../../calc.texi:19144
#, no-wrap
msgid "k d"
msgstr ""

#. type: pindex
#: ../../calc.texi:19145
#, no-wrap
msgid "calc-double-factorial"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19147
msgid "@tindex dfact"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19158
msgid ""
"@tindex !! The @kbd{k d} (@code{calc-double-factorial}) [@code{dfact}] "
"command computes the ``double factorial'' of an integer.  For an even "
"integer, this is the product of even integers from 2 to @expr{N}.  For an "
"odd integer, this is the product of odd integers from 3 to @expr{N}.  If the "
"argument is an integer-valued float, the result is a floating-point "
"approximation.  This function is undefined for negative even integers.  The "
"notation @expr{N!!} is also recognized for double factorials."
msgstr ""

#. type: kindex
#: ../../calc.texi:19159
#, no-wrap
msgid "k c"
msgstr ""

#. type: pindex
#: ../../calc.texi:19160
#, no-wrap
msgid "calc-choose"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19170
msgid ""
"@tindex choose The @kbd{k c} (@code{calc-choose}) [@code{choose}] command "
"computes the binomial coefficient @expr{N}-choose-@expr{M}, where @expr{M} "
"is the number on the top of the stack and @expr{N} is second-to-top.  If "
"both arguments are integers, the result is an exact integer.  Otherwise, the "
"result is a floating-point approximation.  The binomial coefficient is "
"defined for all real numbers by @texline @math{N! \\over M! (N-M)!\\,}.  "
"@infoline @expr{N! / M! (N-M)!}."
msgstr ""

#. type: kindex
#: ../../calc.texi:19171
#, no-wrap
msgid "H k c"
msgstr ""

#. type: pindex
#: ../../calc.texi:19172
#, no-wrap
msgid "calc-perm"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19174
msgid "@tindex perm"
msgstr ""

#. type: ifnottex
#: ../../calc.texi:19177
msgid ""
"The @kbd{H k c} (@code{calc-perm}) [@code{perm}] command computes the "
"number-of-permutations function @expr{N! / (N-M)!}."
msgstr ""

#. type: tex
#: ../../calc.texi:19181
#, no-wrap
msgid ""
"The \\kbd{H k c} (\\code{calc-perm}) [\\code{perm}] command computes the\n"
"number-of-perm\\-utations function $N! \\over (N-M)!\\,$.\n"
msgstr ""

#. type: kindex
#: ../../calc.texi:19183
#, no-wrap
msgid "k b"
msgstr ""

#. type: kindex
#: ../../calc.texi:19184
#, no-wrap
msgid "H k b"
msgstr ""

#. type: pindex
#: ../../calc.texi:19185
#, no-wrap
msgid "calc-bernoulli-number"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19194
msgid ""
"@tindex bern The @kbd{k b} (@code{calc-bernoulli-number}) [@code{bern}] "
"command computes a given Bernoulli number.  The value at the top of the "
"stack is a nonnegative integer @expr{n} that specifies which Bernoulli "
"number is desired.  The @kbd{H k b} command computes a Bernoulli polynomial, "
"taking @expr{n} from the second-to-top position and @expr{x} from the top of "
"the stack.  If @expr{x} is a variable or formula the result is a polynomial "
"in @expr{x}; if @expr{x} is a number the result is a number."
msgstr ""

#. type: kindex
#: ../../calc.texi:19195
#, no-wrap
msgid "k e"
msgstr ""

#. type: kindex
#: ../../calc.texi:19196
#, no-wrap
msgid "H k e"
msgstr ""

#. type: pindex
#: ../../calc.texi:19197
#, no-wrap
msgid "calc-euler-number"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19203
msgid ""
"@tindex euler The @kbd{k e} (@code{calc-euler-number}) [@code{euler}] "
"command similarly computes an Euler number, and @w{@kbd{H k e}} computes an "
"Euler polynomial.  Bernoulli and Euler numbers occur in the Taylor "
"expansions of several functions."
msgstr ""

#. type: kindex
#: ../../calc.texi:19204
#, no-wrap
msgid "k s"
msgstr ""

#. type: kindex
#: ../../calc.texi:19205
#, no-wrap
msgid "H k s"
msgstr ""

#. type: pindex
#: ../../calc.texi:19206
#, no-wrap
msgid "calc-stirling-number"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19220
msgid ""
"@tindex stir1 @tindex stir2 The @kbd{k s} (@code{calc-stirling-number}) "
"[@code{stir1}] command computes a Stirling number of the first @texline "
"kind@tie{}@math{n \\brack m}, @infoline kind, given two integers @expr{n} "
"and @expr{m} on the stack.  The @kbd{H k s} [@code{stir2}] command computes "
"a Stirling number of the second @texline kind@tie{}@math{n \\brace m}.  "
"@infoline kind.  These are the number of @expr{m}-cycle permutations of "
"@expr{n} objects, and the number of ways to partition @expr{n} objects into "
"@expr{m} non-empty sets, respectively."
msgstr ""

#. type: kindex
#: ../../calc.texi:19221
#, no-wrap
msgid "k p"
msgstr ""

#. type: pindex
#: ../../calc.texi:19222
#, no-wrap
msgid "calc-prime-test"
msgstr ""

#. type: cindex
#: ../../calc.texi:19223
#, no-wrap
msgid "Primes"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19237
msgid ""
"The @kbd{k p} (@code{calc-prime-test}) command checks if the integer on the "
"top of the stack is prime.  For integers less than eight million, the answer "
"is always exact and reasonably fast.  For larger integers, a probabilistic "
"method is used (see Knuth vol.@: II, section 4.5.4, algorithm P).  The "
"number is first checked against small prime factors (up to 13).  Then, any "
"number of iterations of the algorithm are performed.  Each step either "
"discovers that the number is non-prime, or substantially increases the "
"certainty that the number is prime.  After a few steps, the chance that a "
"number was mistakenly described as prime will be less than one percent.  "
"(Indeed, this is a worst-case estimate of the probability; in practice even "
"a single iteration is quite reliable.)  After the @kbd{k p} command, the "
"number will be reported as definitely prime or non-prime if possible, or "
"otherwise ``probably'' prime with a certain probability of error."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19248
msgid ""
"@tindex prime The normal @kbd{k p} command performs one iteration of the "
"primality test.  Pressing @kbd{k p} repeatedly for the same integer will "
"perform additional iterations.  Also, @kbd{k p} with a numeric prefix "
"performs the specified number of iterations.  There is also an algebraic "
"function @samp{prime(n)} or @samp{prime(n,iters)} which returns 1 if "
"@expr{n} is (probably) prime and 0 if not."
msgstr ""

#. type: kindex
#: ../../calc.texi:19249
#, no-wrap
msgid "k f"
msgstr ""

#. type: pindex
#: ../../calc.texi:19250
#, no-wrap
msgid "calc-prime-factors"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19261
msgid ""
"@tindex prfac The @kbd{k f} (@code{calc-prime-factors}) [@code{prfac}] "
"command attempts to decompose an integer into its prime factors.  For "
"numbers up to 25 million, the answer is exact although it may take some "
"time.  The result is a vector of the prime factors in increasing order.  For "
"larger inputs, prime factors above 5000 may not be found, in which case the "
"last number in the vector will be an unfactored integer greater than 25 "
"million (with a warning message).  For negative integers, the first element "
"of the list will be @mathit{-1}.  For inputs @mathit{-1}, @mathit{0}, and "
"@mathit{1}, the result is a list of the same number."
msgstr ""

#. type: kindex
#: ../../calc.texi:19262
#, no-wrap
msgid "k n"
msgstr ""

#. type: pindex
#: ../../calc.texi:19263
#, no-wrap
msgid "calc-next-prime"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19279
msgid ""
"@tindex nextprime The @kbd{k n} (@code{calc-next-prime}) [@code{nextprime}] "
"command finds the next prime above a given number.  Essentially, it searches "
"by calling @code{calc-prime-test} on successive integers until it finds one "
"that passes the test.  This is quite fast for integers less than eight "
"million, but once the probabilistic test comes into play the search may be "
"rather slow.  Ordinarily this command stops for any prime that passes one "
"iteration of the primality test.  With a numeric prefix argument, a number "
"must pass the specified number of iterations before the search stops.  (This "
"only matters when searching above eight million.)  You can always use "
"additional @kbd{k p} commands to increase your certainty that the number is "
"indeed prime."
msgstr ""

#. type: kindex
#: ../../calc.texi:19280
#, no-wrap
msgid "I k n"
msgstr ""

#. type: pindex
#: ../../calc.texi:19281
#, no-wrap
msgid "calc-prev-prime"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19288
msgid ""
"@tindex prevprime The @kbd{I k n} (@code{calc-prev-prime}) "
"[@code{prevprime}] command analogously finds the next prime less than a "
"given number."
msgstr ""

#. type: kindex
#: ../../calc.texi:19289
#, no-wrap
msgid "k t"
msgstr ""

#. type: pindex
#: ../../calc.texi:19290
#, no-wrap
msgid "calc-totient"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19298
msgid ""
"@tindex totient The @kbd{k t} (@code{calc-totient}) [@code{totient}] command "
"computes the Euler ``totient'' @texline function@tie{}@math{\\phi(n)}, "
"@infoline function, the number of integers less than @expr{n} which are "
"relatively prime to @expr{n}."
msgstr ""

#. type: kindex
#: ../../calc.texi:19299
#, no-wrap
msgid "k m"
msgstr ""

#. type: pindex
#: ../../calc.texi:19300
#, no-wrap
msgid "calc-moebius"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19307
msgid ""
"@tindex moebius The @kbd{k m} (@code{calc-moebius}) [@code{moebius}] command "
"computes the Möbius μ function.  If the input number is a product of "
"@expr{k} distinct factors, this is @expr{(-1)^k}.  If the input number has "
"any duplicate factors (i.e., can be divided by the same prime more than "
"once), the result is zero."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19320
msgid ""
"The functions in this section compute various probability distributions.  "
"For continuous distributions, this is the integral of the probability "
"density function from @expr{x} to infinity.  (These are the ``upper tail'' "
"distribution functions; there are also corresponding ``lower tail'' "
"functions which integrate from minus infinity to @expr{x}.)  For discrete "
"distributions, the upper tail function gives the sum from @expr{x} to "
"infinity; the lower tail function gives the sum from minus infinity up to, "
"but not including,@w{ }@expr{x}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19327
msgid ""
"To integrate from @expr{x} to @expr{y}, just use the distribution function "
"twice and subtract.  For example, the probability that a Gaussian random "
"variable with mean 2 and standard deviation 1 will lie in the range from 2.5 "
"to 2.8 is @samp{utpn(2.5,2,1) - utpn(2.8,2,1)} (``the probability that it is "
"greater than 2.5, but not greater than 2.8''), or equivalently "
"@samp{ltpn(2.8,2,1) - ltpn(2.5,2,1)}."
msgstr ""

#. type: kindex
#: ../../calc.texi:19328
#, no-wrap
msgid "k B"
msgstr ""

#. type: kindex
#: ../../calc.texi:19329
#, no-wrap
msgid "I k B"
msgstr ""

#. type: pindex
#: ../../calc.texi:19330
#, no-wrap
msgid "calc-utpb"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19340
msgid ""
"@tindex utpb @tindex ltpb The @kbd{k B} (@code{calc-utpb}) [@code{utpb}] "
"function uses the binomial distribution.  Push the parameters @var{n}, "
"@var{p}, and then @var{x} onto the stack; the result (@samp{utpb(x,n,p)}) is "
"the probability that an event will occur @var{x} or more times out of "
"@var{n} trials, if its probability of occurring in any given trial is "
"@var{p}.  The @kbd{I k B} [@code{ltpb}] function is the probability that the "
"event will occur fewer than @var{x} times."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19352
msgid ""
"The other probability distribution functions similarly take the form @kbd{k "
"@var{X}} (@code{calc-utp@var{x}}) [@code{utp@var{x}}] and @kbd{I k @var{X}} "
"[@code{ltp@var{x}}], for various letters @var{x}.  The arguments to the "
"algebraic functions are the value of the random variable first, then "
"whatever other parameters define the distribution.  Note these are among the "
"few Calc functions where the order of the arguments in algebraic form "
"differs from the order of arguments as found on the stack.  (The random "
"variable comes last on the stack, so that you can type, e.g., @kbd{2 "
"@key{RET} 1 @key{RET} 2.5 k N M-@key{RET} @key{DEL} 2.8 k N -}, using "
"@kbd{M-@key{RET} @key{DEL}} to recover the original arguments but substitute "
"a new value for @expr{x}.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:19353
#, no-wrap
msgid "k C"
msgstr ""

#. type: pindex
#: ../../calc.texi:19354
#, no-wrap
msgid "calc-utpc"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19356
msgid "@tindex utpc"
msgstr ""

#. type: kindex
#: ../../calc.texi:19359
#, no-wrap
msgid "I k C"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19369
msgid ""
"@tindex ltpc The @samp{utpc(x,v)} function uses the chi-square distribution "
"with @texline @math{\\nu} @infoline @expr{v} degrees of freedom.  It is the "
"probability that a model is correct if its chi-square statistic is @expr{x}."
msgstr ""

#. type: kindex
#: ../../calc.texi:19370
#, no-wrap
msgid "k F"
msgstr ""

#. type: pindex
#: ../../calc.texi:19371
#, no-wrap
msgid "calc-utpf"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19373
msgid "@tindex utpf"
msgstr ""

#. type: kindex
#: ../../calc.texi:19376
#, no-wrap
msgid "I k F"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19390
msgid ""
"@tindex ltpf The @samp{utpf(F,v1,v2)} function uses the F distribution, used "
"in various statistical tests.  The parameters @texline @math{\\nu_1} "
"@infoline @expr{v1} and @texline @math{\\nu_2} @infoline @expr{v2} are the "
"degrees of freedom in the numerator and denominator, respectively, used in "
"computing the statistic @expr{F}."
msgstr ""

#. type: kindex
#: ../../calc.texi:19391
#, no-wrap
msgid "k N"
msgstr ""

#. type: pindex
#: ../../calc.texi:19392
#, no-wrap
msgid "calc-utpn"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19394
msgid "@tindex utpn"
msgstr ""

#. type: kindex
#: ../../calc.texi:19397
#, no-wrap
msgid "I k N"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19408
msgid ""
"@tindex ltpn The @samp{utpn(x,m,s)} function uses a normal (Gaussian) "
"distribution with mean @expr{m} and standard deviation @texline "
"@math{\\sigma}.  @infoline @expr{s}.  It is the probability that such a "
"normal-distributed random variable would exceed @expr{x}."
msgstr ""

#. type: kindex
#: ../../calc.texi:19409
#, no-wrap
msgid "k P"
msgstr ""

#. type: pindex
#: ../../calc.texi:19410
#, no-wrap
msgid "calc-utpp"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19412
msgid "@tindex utpp"
msgstr ""

#. type: kindex
#: ../../calc.texi:19415
#, no-wrap
msgid "I k P"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19423
msgid ""
"@tindex ltpp The @samp{utpp(n,x)} function uses a Poisson distribution with "
"mean @expr{x}.  It is the probability that @expr{n} or more such Poisson "
"random events will occur."
msgstr ""

#. type: kindex
#: ../../calc.texi:19424
#, no-wrap
msgid "k T"
msgstr ""

#. type: pindex
#: ../../calc.texi:19425
#, no-wrap
msgid "calc-ltpt"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19427
msgid "@tindex utpt"
msgstr ""

#. type: kindex
#: ../../calc.texi:19430
#, no-wrap
msgid "I k T"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19452
msgid ""
"@tindex ltpt The @samp{utpt(t,v)} function uses the Student's ``t'' "
"distribution with @texline @math{\\nu} @infoline @expr{v} degrees of "
"freedom.  It is the probability that a t-distributed random variable will be "
"greater than @expr{t}.  (Note: This computes the distribution function "
"@texline @math{A(t|\\nu)} @infoline @expr{A(t|v)} where @texline "
"@math{A(0|\\nu) = 1} @infoline @expr{A(0|v) = 1} and @texline "
"@math{A(\\infty|\\nu) \\to 0}.  @infoline @expr{A(inf|v) -> 0}.  The "
"@code{UTPT} operation on the HP-48 uses a different definition which returns "
"half of Calc's value: @samp{UTPT(t,v) = .5*utpt(t,v)}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19458
msgid ""
"While Calc does not provide inverses of the probability distribution "
"functions, the @kbd{a R} command can be used to solve for the inverse.  "
"Since the distribution functions are monotonic, @kbd{a R} is guaranteed to "
"be able to find a solution given any initial guess.  @xref{Numerical "
"Solutions}."
msgstr ""

#. type: chapter
#: ../../calc.texi:19460
#, no-wrap
msgid "Vector/Matrix Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19468
msgid ""
"Many of the commands described here begin with the @kbd{v} prefix.  (For "
"convenience, the shift-@kbd{V} prefix is equivalent to @kbd{v}.)  The "
"commands usually apply to both plain vectors and matrices; some apply only "
"to matrices or only to square matrices.  If the argument has the wrong "
"dimensions the operation is left in symbolic form."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19474
msgid ""
"Vectors are entered and displayed using @samp{[a,b,c]} notation.  Matrices "
"are vectors of which all elements are vectors of equal length.  (Though none "
"of the standard Calc commands use this concept, a three-dimensional matrix "
"or rank-3 tensor could be defined as a vector of matrices, and so on.)"
msgstr ""

#. type: menuentry
#: ../../calc.texi:19485
msgid "Packing and Unpacking::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:19485
msgid "Building Vectors::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:19485
msgid "Extracting Elements::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:19485
msgid "Manipulating Vectors::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:19485
msgid "Vector and Matrix Arithmetic::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:19485
msgid "Set Operations::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:19485
msgid "Statistical Operations::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:19485
msgid "Reducing and Mapping::"
msgstr ""

#. type: node
#: ../../calc.texi:19485 ../../calc.texi:20884 ../../calc.texi:21360
#, no-wrap
msgid "Vector and Matrix Formats"
msgstr ""

#. type: node
#: ../../calc.texi:19487 ../../calc.texi:19488 ../../calc.texi:19707
#, no-wrap
msgid "Packing and Unpacking"
msgstr ""

#. type: node
#: ../../calc.texi:19487 ../../calc.texi:19707 ../../calc.texi:19708 ../../calc.texi:19875
#, no-wrap
msgid "Building Vectors"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19495
msgid ""
"Calc's ``pack'' and ``unpack'' commands collect stack entries to build "
"composite objects such as vectors and complex numbers.  They are described "
"in this chapter because they are most often used to build vectors."
msgstr ""

#. type: kindex
#: ../../calc.texi:19496
#, no-wrap
msgid "v p"
msgstr ""

#. type: kindex
#: ../../calc.texi:19497
#, no-wrap
msgid "V p"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19507
msgid ""
"The @kbd{v p} (@code{calc-pack}) [@code{pack}] command collects several "
"elements from the stack into a matrix, complex number, HMS form, error form, "
"etc.  It uses a numeric prefix argument to specify the kind of object to be "
"built; this argument is referred to as the ``packing mode.'' If the packing "
"mode is a nonnegative integer, a vector of that length is created.  For "
"example, @kbd{C-u 5 v p} will pop the top five stack elements and push back "
"a single vector of those five elements.  (@kbd{C-u 0 v p} simply creates an "
"empty vector.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19512
msgid ""
"The same effect can be had by pressing @kbd{[} to push an incomplete vector "
"on the stack, using @key{TAB} (@code{calc-roll-down}) to sneak the "
"incomplete object up past a certain number of elements, and then pressing "
"@kbd{]} to complete the vector."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19514
msgid "Negative packing modes create other kinds of composite objects:"
msgstr ""

#. type: item
#: ../../calc.texi:19516
#, no-wrap
msgid "-1"
msgstr ""

#. type: table
#: ../../calc.texi:19525
msgid ""
"Two values are collected to build a complex number.  For example, @kbd{5 "
"@key{RET} 7 C-u -1 v p} creates the complex number @expr{(5, 7)}.  The "
"result is always a rectangular complex number.  The two input values must "
"both be real numbers, i.e., integers, fractions, or floats.  If they are "
"not, Calc will instead build a formula like @samp{a + (0, 1) b}.  (The other "
"packing modes also create a symbolic answer if the components are not "
"suitable.)"
msgstr ""

#. type: item
#: ../../calc.texi:19526
#, no-wrap
msgid "-2"
msgstr ""

#. type: table
#: ../../calc.texi:19531
msgid ""
"Two values are collected to build a polar complex number.  The first is the "
"magnitude; the second is the phase expressed in either degrees or radians "
"according to the current angular mode."
msgstr ""

#. type: item
#: ../../calc.texi:19532
#, no-wrap
msgid "-3"
msgstr ""

#. type: table
#: ../../calc.texi:19537
msgid ""
"Three values are collected into an HMS form.  The first two values (hours "
"and minutes) must be integers or integer-valued floats.  The third value may "
"be any real number."
msgstr ""

#. type: item
#: ../../calc.texi:19538
#, no-wrap
msgid "-4"
msgstr ""

#. type: table
#: ../../calc.texi:19541
msgid ""
"Two values are collected into an error form.  The inputs may be real numbers "
"or formulas."
msgstr ""

#. type: item
#: ../../calc.texi:19542
#, no-wrap
msgid "-5"
msgstr ""

#. type: table
#: ../../calc.texi:19545
msgid ""
"Two values are collected into a modulo form.  The inputs must be real "
"numbers."
msgstr ""

#. type: item
#: ../../calc.texi:19546
#, no-wrap
msgid "-6"
msgstr ""

#. type: table
#: ../../calc.texi:19549
msgid ""
"Two values are collected into the interval @samp{[a .. b]}.  The inputs may "
"be real numbers, HMS or date forms, or formulas."
msgstr ""

#. type: item
#: ../../calc.texi:19550
#, no-wrap
msgid "-7"
msgstr ""

#. type: table
#: ../../calc.texi:19552
msgid "Two values are collected into the interval @samp{[a .. b)}."
msgstr ""

#. type: item
#: ../../calc.texi:19553
#, no-wrap
msgid "-8"
msgstr ""

#. type: table
#: ../../calc.texi:19555
msgid "Two values are collected into the interval @samp{(a .. b]}."
msgstr ""

#. type: item
#: ../../calc.texi:19556
#, no-wrap
msgid "-9"
msgstr ""

#. type: table
#: ../../calc.texi:19558
msgid "Two values are collected into the interval @samp{(a .. b)}."
msgstr ""

#. type: item
#: ../../calc.texi:19559
#, no-wrap
msgid "-10"
msgstr ""

#. type: table
#: ../../calc.texi:19561
msgid "Two integer values are collected into a fraction."
msgstr ""

#. type: item
#: ../../calc.texi:19562
#, no-wrap
msgid "-11"
msgstr ""

#. type: table
#: ../../calc.texi:19567
msgid ""
"Two values are collected into a floating-point number.  The first is the "
"mantissa; the second, which must be an integer, is the exponent.  The result "
"is the mantissa times ten to the power of the exponent."
msgstr ""

#. type: item
#: ../../calc.texi:19568
#, no-wrap
msgid "-12"
msgstr ""

#. type: table
#: ../../calc.texi:19572
msgid ""
"This is treated the same as @mathit{-11} by the @kbd{v p} command.  When "
"unpacking, @mathit{-12} specifies that a floating-point mantissa is desired."
msgstr ""

#. type: item
#: ../../calc.texi:19573
#, no-wrap
msgid "-13"
msgstr ""

#. type: table
#: ../../calc.texi:19575
msgid "A real number is converted into a date form."
msgstr ""

#. type: item
#: ../../calc.texi:19576
#, no-wrap
msgid "-14"
msgstr ""

#. type: table
#: ../../calc.texi:19578
msgid "Three numbers (year, month, day) are packed into a pure date form."
msgstr ""

#. type: item
#: ../../calc.texi:19579
#, no-wrap
msgid "-15"
msgstr ""

#. type: table
#: ../../calc.texi:19581
msgid "Six numbers are packed into a date/time form."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19593
msgid ""
"With any of the two-input negative packing modes, either or both of the "
"inputs may be vectors.  If both are vectors of the same length, the result "
"is another vector made by packing corresponding elements of the input "
"vectors.  If one input is a vector and the other is a plain number, the "
"number is packed along with each vector element to produce a new vector.  "
"For example, @kbd{C-u -4 v p} could be used to convert a vector of numbers "
"and a vector of errors into a single vector of error forms; @kbd{C-u -5 v p} "
"could convert a vector of numbers and a single number @var{M} into a vector "
"of numbers modulo @var{M}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19599
msgid ""
"If you don't give a prefix argument to @kbd{v p}, it takes the packing mode "
"from the top of the stack.  The elements to be packed then begin at stack "
"level 2.  Thus @kbd{1 @key{RET} 2 @key{RET} 4 n v p} is another way to enter "
"the error form @samp{1 +/- 2}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19605
msgid ""
"If the packing mode taken from the stack is a vector, the result is a matrix "
"with the dimensions specified by the elements of the vector, which must each "
"be integers.  For example, if the packing mode is @samp{[2, 3]}, then six "
"numbers will be taken from the stack and returned in the form @samp{[@w{[a, "
"b, c]}, [d, e, f]]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19614
msgid ""
"If any elements of the vector are negative, other kinds of packing are done "
"at that level as described above.  For example, @samp{[2, 3, -4]} takes 12 "
"objects and creates a @texline @math{2\\times3} @infoline 2x3 matrix of "
"error forms: @samp{[[a +/- b, c +/- d ... ]]}.  Also, @samp{[-4, -10]} will "
"convert four integers into an error form consisting of two fractions: "
"@samp{a:b +/- c:d}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19628
msgid ""
"@tindex pack There is an equivalent algebraic function, "
"@samp{pack(@var{mode}, @var{items})} where @var{mode} is a packing mode (an "
"integer or a vector of integers) and @var{items} is a vector of objects to "
"be packed (re-packed, really) according to that mode.  For example, "
"@samp{pack([3, -4], [a,b,c,d,e,f])} yields @samp{[a +/- b, @w{c +/- d}, e "
"+/- f]}.  The function is left in symbolic form if the packing mode is "
"invalid, or if the number of data items does not match the number of items "
"required by the mode."
msgstr ""

#. type: kindex
#: ../../calc.texi:19629
#, no-wrap
msgid "v u"
msgstr ""

#. type: kindex
#: ../../calc.texi:19630
#, no-wrap
msgid "V u"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19638
msgid ""
"The @kbd{v u} (@code{calc-unpack}) command takes the vector, complex number, "
"HMS form, or other composite object on the top of the stack and ``unpacks'' "
"it, pushing each of its elements onto the stack as separate objects.  Thus, "
"it is the ``inverse'' of @kbd{v p}.  If the value at the top of the stack is "
"a formula, @kbd{v u} unpacks it by pushing each of the arguments of the "
"top-level operator onto the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19646
msgid ""
"You can optionally give a numeric prefix argument to @kbd{v u} to specify an "
"explicit (un)packing mode.  If the packing mode is negative and the input is "
"actually a vector or matrix, the result will be two or more similar vectors "
"or matrices of the elements.  For example, given the vector @samp{[@w{a +/- "
"b}, c^2, d +/- 7]}, the result of @kbd{C-u -4 v u} will be the two vectors "
"@samp{[a, c^2, d]} and @w{@samp{[b, 0, 7]}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19655
msgid ""
"Note that the prefix argument can have an effect even when the input is not "
"a vector.  For example, if the input is the number @mathit{-5}, then "
"@kbd{c-u -1 v u} yields @mathit{-5} and 0 (the components of @mathit{-5} "
"when viewed as a rectangular complex number); @kbd{C-u -2 v u} yields 5 and "
"180 (assuming Degrees mode); and @kbd{C-u -10 v u} yields @mathit{-5} and 1 "
"(the numerator and denominator of @mathit{-5}, viewed as a rational "
"number).  Plain @kbd{v u} with this input would complain that the input is "
"not a composite object."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19664
msgid ""
"Unpacking mode @mathit{-11} converts a float into an integer mantissa and an "
"integer exponent, where the mantissa is not divisible by 10 (except that 0.0 "
"is represented by a mantissa and exponent of 0).  Unpacking mode "
"@mathit{-12} converts a float into a floating-point mantissa and integer "
"exponent, where the mantissa (for non-zero numbers)  is guaranteed to lie in "
"the range [1 .. 10).  In both cases, the mantissa is shifted left or right "
"(and the exponent adjusted to compensate) in order to satisfy these "
"constraints."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19671
msgid ""
"Positive unpacking modes are treated differently than for @kbd{v p}.  A mode "
"of 1 is much like plain @kbd{v u} with no prefix argument, except that in "
"addition to the components of the input object, a suitable packing mode to "
"re-pack the object is also pushed.  Thus, @kbd{C-u 1 v u} followed by @kbd{v "
"p} will re-build the original object."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19676
msgid ""
"A mode of 2 unpacks two levels of the object; the resulting re-packing mode "
"will be a vector of length 2.  This might be used to unpack a matrix, say, "
"or a vector of error forms.  Higher unpacking modes unpack the input even "
"more deeply."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19687
msgid ""
"@tindex unpack There are two algebraic functions analogous to @kbd{v u}.  "
"The @samp{unpack(@var{mode}, @var{item})} function unpacks the @var{item} "
"using the given @var{mode}, returning the result as a vector of components.  "
"Here the @var{mode} must be an integer, not a vector.  For example, "
"@samp{unpack(-4, a +/- b)} returns @samp{[a, b]}, as does @samp{unpack(1, a "
"+/- b)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19701
msgid ""
"@tindex unpackt The @code{unpackt} function is like @code{unpack} but "
"instead of returning a simple vector of items, it returns a vector of two "
"things: The mode, and the vector of items.  For example, @samp{unpackt(1, "
"2:3 +/- 1:4)} returns @samp{[-4, [2:3, 1:4]]}, and @samp{unpackt(2, 2:3 +/- "
"1:4)} returns @samp{[[-4, -10], [2, 3, 1, 4]]}.  The identity for "
"re-building the original object is @samp{apply(pack, unpackt(@var{n}, "
"@var{x})) = @var{x}}.  (The @code{apply} function builds a function call "
"given the function name and a vector of arguments.)"
msgstr ""

#. type: cindex
#: ../../calc.texi:19702
#, no-wrap
msgid "Numerator of a fraction, extracting"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19706
msgid ""
"Subscript notation is a useful way to extract a particular part of an "
"object.  For example, to get the numerator of a rational number, you can use "
"@samp{unpack(-10, @var{x})_1}."
msgstr ""

#. type: node
#: ../../calc.texi:19707 ../../calc.texi:19875 ../../calc.texi:19981
#, no-wrap
msgid "Extracting Elements"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19713
msgid ""
"Vectors and matrices can be added, subtracted, multiplied, and divided; "
"@pxref{Basic Arithmetic}."
msgstr ""

#. type: kindex
#: ../../calc.texi:19714
#, no-wrap
msgid "|"
msgstr ""

#. type: pindex
#: ../../calc.texi:19715
#, no-wrap
msgid "calc-concat"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19726
msgid ""
"@tindex | The @kbd{|} (@code{calc-concat}) [@code{vconcat}] command "
"``concatenates'' two vectors into one.  For example, after @kbd{@w{[ 1 , 2 "
"]} [ 3 , 4 ] |}, the stack will contain the single vector @samp{[1, 2, 3, "
"4]}.  If the arguments are matrices, the rows of the first matrix are "
"concatenated with the rows of the second.  (In other words, two matrices are "
"just two vectors of row-vectors as far as @kbd{|} is concerned.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19732
msgid ""
"If either argument to @kbd{|} is a scalar (a non-vector), it is treated like "
"a one-element vector for purposes of concatenation: @kbd{1 [ 2 , 3 ] |} "
"produces the vector @samp{[1, 2, 3]}.  Likewise, if one argument is a matrix "
"and the other is a plain vector, the vector is treated as a one-row matrix."
msgstr ""

#. type: kindex
#: ../../calc.texi:19733
#, no-wrap
msgid "H |"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19740
msgid ""
"@tindex append The @kbd{H |} (@code{calc-append}) [@code{append}] command "
"concatenates two vectors without any special cases.  Both inputs must be "
"vectors.  Whether or not they are matrices is not taken into account.  If "
"either argument is a scalar, the @code{append} function is left in symbolic "
"form.  See also @code{cons} and @code{rcons} below."
msgstr ""

#. type: kindex
#: ../../calc.texi:19741
#, no-wrap
msgid "I |"
msgstr ""

#. type: kindex
#: ../../calc.texi:19742
#, no-wrap
msgid "H I |"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19746
msgid ""
"The @kbd{I |} and @kbd{H I |} commands are similar, but they use their two "
"stack arguments in the opposite order.  Thus @kbd{I |} is equivalent to "
"@kbd{@key{TAB} |}, but possibly more convenient and also a bit faster."
msgstr ""

#. type: kindex
#: ../../calc.texi:19747
#, no-wrap
msgid "v d"
msgstr ""

#. type: kindex
#: ../../calc.texi:19748
#, no-wrap
msgid "V d"
msgstr ""

#. type: pindex
#: ../../calc.texi:19749
#, no-wrap
msgid "calc-diag"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19758
msgid ""
"@tindex diag The @kbd{v d} (@code{calc-diag}) [@code{diag}] function builds "
"a diagonal square matrix.  The optional numeric prefix gives the number of "
"rows and columns in the matrix.  If the value at the top of the stack is a "
"vector, the elements of the vector are used as the diagonal elements; the "
"prefix, if specified, must match the size of the vector.  If the value on "
"the stack is a scalar, it is used for each element on the diagonal, and the "
"prefix argument is required."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19765
msgid ""
"To build a constant square matrix, e.g., a @texline @math{3\\times3} "
"@infoline 3x3 matrix filled with ones, use @kbd{0 M-3 v d 1 +}, i.e., build "
"a zero matrix first and then add a constant value to that matrix.  (Another "
"alternative would be to use @kbd{v b} and @kbd{v a}; see below.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:19766
#, no-wrap
msgid "v i"
msgstr ""

#. type: kindex
#: ../../calc.texi:19767
#, no-wrap
msgid "V i"
msgstr ""

#. type: pindex
#: ../../calc.texi:19768
#, no-wrap
msgid "calc-ident"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19774
msgid ""
"@tindex idn The @kbd{v i} (@code{calc-ident}) [@code{idn}] function builds "
"an identity matrix of the specified size.  It is a convenient form of @kbd{v "
"d} where the diagonal element is always one.  If no prefix argument is "
"given, this command prompts for one."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19786
msgid ""
"In algebraic notation, @samp{idn(a,n)} acts much like @samp{diag(a,n)}, "
"except that @expr{a} is required to be a scalar (non-vector) quantity.  If "
"@expr{n} is omitted, @samp{idn(a)} represents @expr{a} times an identity "
"matrix of unknown size.  Calc can operate algebraically on such generic "
"identity matrices, and if one is combined with a matrix whose size is known, "
"it is converted automatically to an identity matrix of a suitable matching "
"size.  The @kbd{v i} command with an argument of zero creates a generic "
"identity matrix, @samp{idn(1)}.  Note that in dimensioned Matrix mode "
"(@pxref{Matrix Mode}), generic identity matrices are immediately expanded to "
"the current default dimensions."
msgstr ""

#. type: kindex
#: ../../calc.texi:19787
#, no-wrap
msgid "v x"
msgstr ""

#. type: kindex
#: ../../calc.texi:19788
#, no-wrap
msgid "V x"
msgstr ""

#. type: pindex
#: ../../calc.texi:19789
#, no-wrap
msgid "calc-index"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19796
msgid ""
"@tindex index The @kbd{v x} (@code{calc-index}) [@code{index}] function "
"builds a vector of consecutive integers from 1 to @var{n}, where @var{n} is "
"the numeric prefix argument.  If you do not provide a prefix argument, you "
"will be prompted to enter a suitable number.  If @var{n} is negative, the "
"result is a vector of negative integers from @var{n} to @mathit{-1}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19804
msgid ""
"With a prefix argument of just @kbd{C-u}, the @kbd{v x} command takes three "
"values from the stack: @var{n}, @var{start}, and @var{incr} (with @var{incr} "
"at top-of-stack).  Counting starts at @var{start} and increases by "
"@var{incr} for successive vector elements.  If @var{start} or @var{n} is in "
"floating-point format, the resulting vector elements will also be floats.  "
"Note that @var{start} and @var{incr} may in fact be any kind of numbers or "
"formulas."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19811
msgid ""
"When @var{start} and @var{incr} are specified, a negative @var{n} has a "
"different interpretation: It causes a geometric instead of arithmetic "
"sequence to be generated.  For example, @samp{index(-3, a, b)} produces "
"@samp{[a, a b, a b^2]}.  If you omit @var{incr} in the algebraic form, "
"@samp{index(@var{n}, @var{start})}, the default value for @var{incr} is one "
"for positive @var{n} or two for negative @var{n}."
msgstr ""

#. type: kindex
#: ../../calc.texi:19812
#, no-wrap
msgid "v b"
msgstr ""

#. type: kindex
#: ../../calc.texi:19813
#, no-wrap
msgid "V b"
msgstr ""

#. type: pindex
#: ../../calc.texi:19814
#, no-wrap
msgid "calc-build-vector"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19822
msgid ""
"@tindex cvec The @kbd{v b} (@code{calc-build-vector}) [@code{cvec}] function "
"builds a vector of @var{n} copies of the value on the top of the stack, "
"where @var{n} is the numeric prefix argument.  In algebraic formulas, "
"@samp{cvec(x,n,m)} can also be used to build an @var{n}-by-@var{m} matrix of "
"copies of @var{x}.  (Interactively, just use @kbd{v b} twice: once to build "
"a row, then again to build a matrix of copies of that row.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:19823
#, no-wrap
msgid "v h"
msgstr ""

#. type: kindex
#: ../../calc.texi:19824
#, no-wrap
msgid "V h"
msgstr ""

#. type: kindex
#: ../../calc.texi:19825
#, no-wrap
msgid "I v h"
msgstr ""

#. type: kindex
#: ../../calc.texi:19826
#, no-wrap
msgid "I V h"
msgstr ""

#. type: pindex
#: ../../calc.texi:19827
#, no-wrap
msgid "calc-head"
msgstr ""

#. type: pindex
#: ../../calc.texi:19828
#, no-wrap
msgid "calc-tail"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19835
msgid ""
"@tindex head @tindex tail The @kbd{v h} (@code{calc-head}) [@code{head}] "
"function returns the first element of a vector.  The @kbd{I v h} "
"(@code{calc-tail}) [@code{tail}] function returns the vector with its first "
"element removed.  In both cases, the argument must be a non-empty vector."
msgstr ""

#. type: kindex
#: ../../calc.texi:19836
#, no-wrap
msgid "v k"
msgstr ""

#. type: kindex
#: ../../calc.texi:19837
#, no-wrap
msgid "V k"
msgstr ""

#. type: pindex
#: ../../calc.texi:19838
#, no-wrap
msgid "calc-cons"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19845
msgid ""
"@tindex cons The @kbd{v k} (@code{calc-cons}) [@code{cons}] function takes a "
"value @var{h} and a vector @var{t} from the stack, and produces the vector "
"whose head is @var{h} and whose tail is @var{t}.  This is similar to "
"@kbd{|}, except if @var{h} is itself a vector, @kbd{|} will concatenate the "
"two vectors whereas @code{cons} will insert @var{h} at the front of the "
"vector @var{t}."
msgstr ""

#. type: kindex
#: ../../calc.texi:19846
#, no-wrap
msgid "H v h"
msgstr ""

#. type: kindex
#: ../../calc.texi:19847
#, no-wrap
msgid "H V h"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19849
msgid "@tindex rhead"
msgstr ""

#. type: kindex
#: ../../calc.texi:19852
#, no-wrap
msgid "H I v h"
msgstr ""

#. type: kindex
#: ../../calc.texi:19853
#, no-wrap
msgid "H I V h"
msgstr ""

#. type: kindex
#: ../../calc.texi:19857
#, no-wrap
msgid "H v k"
msgstr ""

#. type: kindex
#: ../../calc.texi:19858
#, no-wrap
msgid "H V k"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19863
msgid "@tindex rtail"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19874
msgid ""
"@tindex rcons Each of these three functions also accepts the Hyperbolic flag "
"[@code{rhead}, @code{rtail}, @code{rcons}] in which case @var{t} instead "
"represents the @emph{last} single element of the vector, with @var{h} "
"representing the remainder of the vector.  Thus the vector @samp{[a, b, c, "
"d] = cons(a, [b, c, d]) = rcons([a, b, c], d)}.  Also, @samp{head([a, b, c, "
"d]) = a}, @samp{tail([a, b, c, d]) = [b, c, d]}, @samp{rhead([a, b, c, d]) = "
"[a, b, c]}, and @samp{rtail([a, b, c, d]) = d}."
msgstr ""

#. type: node
#: ../../calc.texi:19875 ../../calc.texi:19981 ../../calc.texi:19982 ../../calc.texi:20213
#, no-wrap
msgid "Manipulating Vectors"
msgstr ""

#. type: section
#: ../../calc.texi:19876
#, no-wrap
msgid "Extracting Vector Elements"
msgstr ""

#. type: kindex
#: ../../calc.texi:19879
#, no-wrap
msgid "v r"
msgstr ""

#. type: kindex
#: ../../calc.texi:19880
#, no-wrap
msgid "V r"
msgstr ""

#. type: pindex
#: ../../calc.texi:19881
#, no-wrap
msgid "calc-mrow"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19889
msgid ""
"@tindex mrow The @kbd{v r} (@code{calc-mrow}) [@code{mrow}] command extracts "
"one row of the matrix on the top of the stack, or one element of the plain "
"vector on the top of the stack.  The row or element is specified by the "
"numeric prefix argument; the default is to prompt for the row or element "
"number.  The matrix or vector is replaced by the specified row or element in "
"the form of a vector or scalar, respectively."
msgstr ""

#. type: cindex
#: ../../calc.texi:19890
#, no-wrap
msgid "Permutations, applying"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19897
msgid ""
"With a prefix argument of @kbd{C-u} only, @kbd{v r} takes the index of the "
"element or row from the top of the stack, and the vector or matrix from the "
"second-to-top position.  If the index is itself a vector of integers, the "
"result is a vector of the corresponding elements of the input vector, or a "
"matrix of the corresponding rows of the input matrix.  This command can be "
"used to obtain any permutation of a vector."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19901
msgid ""
"With @kbd{C-u}, if the index is an interval form with integer components, it "
"is interpreted as a range of indices and the corresponding subvector or "
"submatrix is returned."
msgstr ""

#. type: cindex
#: ../../calc.texi:19902
#, no-wrap
msgid "Subscript notation"
msgstr ""

#. type: kindex
#: ../../calc.texi:19903
#, no-wrap
msgid "a _"
msgstr ""

#. type: pindex
#: ../../calc.texi:19904
#, no-wrap
msgid "calc-subscript"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19917
msgid ""
"@tindex subscr @tindex _ Subscript notation in algebraic formulas "
"(@samp{a_b}) stands for the Calc function @code{subscr}, which is synonymous "
"with @code{mrow}.  Thus, @samp{[x, y, z]_k} produces @expr{x}, @expr{y}, or "
"@expr{z} if @expr{k} is one, two, or three, respectively.  A double "
"subscript (@samp{M_i_j}, equivalent to @samp{subscr(subscr(M, i), j)}) will "
"access the element at row @expr{i}, column @expr{j} of a matrix.  The @kbd{a "
"_} (@code{calc-subscript}) command creates a subscript formula @samp{a_b} "
"out of two stack entries.  (It is on the @kbd{a} ``algebra'' prefix because "
"subscripted variables are often used purely as an algebraic notation.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19924
msgid ""
"@tindex mrrow Given a negative prefix argument, @kbd{v r} instead deletes "
"one row or element from the matrix or vector on the top of the stack.  Thus "
"@kbd{C-u 2 v r} replaces a matrix with its second row, but @kbd{C-u -2 v r} "
"replaces the matrix with the same matrix with its second row removed.  In "
"algebraic form this function is called @code{mrrow}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19929
msgid ""
"@tindex getdiag Given a prefix argument of zero, @kbd{v r} extracts the "
"diagonal elements of a square matrix in the form of a vector.  In algebraic "
"form this function is called @code{getdiag}."
msgstr ""

#. type: kindex
#: ../../calc.texi:19930
#, no-wrap
msgid "v c"
msgstr ""

#. type: kindex
#: ../../calc.texi:19931
#, no-wrap
msgid "V c"
msgstr ""

#. type: pindex
#: ../../calc.texi:19932
#, no-wrap
msgid "calc-mcol"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19941
msgid ""
"@tindex mcol @tindex mrcol The @kbd{v c} (@code{calc-mcol}) [@code{mcol} or "
"@code{mrcol}] command is the analogous operation on columns of a matrix.  "
"Given a plain vector it extracts (or removes) one element, just like @kbd{v "
"r}.  If the index in @kbd{C-u v c} is an interval or vector and the argument "
"is a matrix, the result is a submatrix with only the specified columns "
"retained (and possibly permuted in the case of a vector index)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19947
msgid ""
"To extract a matrix element at a given row and column, use @kbd{v r} to "
"extract the row as a vector, then @kbd{v c} to extract the column element "
"from that vector.  In algebraic formulas, it is often more convenient to use "
"subscript notation: @samp{m_i_j} gives row @expr{i}, column @expr{j} of "
"matrix @expr{m}."
msgstr ""

#. type: kindex
#: ../../calc.texi:19948
#, no-wrap
msgid "v s"
msgstr ""

#. type: kindex
#: ../../calc.texi:19949
#, no-wrap
msgid "V s"
msgstr ""

#. type: pindex
#: ../../calc.texi:19950
#, no-wrap
msgid "calc-subvector"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19960
msgid ""
"@tindex subvec The @kbd{v s} (@code{calc-subvector}) [@code{subvec}] command "
"extracts a subvector of a vector.  The arguments are the vector, the "
"starting index, and the ending index, with the ending index in the "
"top-of-stack position.  The starting index indicates the first element of "
"the vector to take.  The ending index indicates the first element "
"@emph{past} the range to be taken.  Thus, @samp{subvec([a, b, c, d, e], 2, "
"4)} produces the subvector @samp{[b, c]}.  You could get the same result "
"using @samp{mrow([a, b, c, d, e], @w{[2 .. 4)})}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19968
msgid ""
"If either the start or the end index is zero or negative, it is interpreted "
"as relative to the end of the vector.  Thus @samp{subvec([a, b, c, d, e], 2, "
"-2)} also produces @samp{[b, c]}.  In the algebraic form, the end index can "
"be omitted in which case it is taken as zero, i.e., elements from the "
"starting element to the end of the vector are used.  The infinity symbol, "
"@code{inf}, also has this effect when used as the ending index."
msgstr ""

#. type: kindex
#: ../../calc.texi:19969
#, no-wrap
msgid "I v s"
msgstr ""

#. type: kindex
#: ../../calc.texi:19970
#, no-wrap
msgid "I V s"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19977
msgid ""
"@tindex rsubvec With the Inverse flag, @kbd{I v s} [@code{rsubvec}] removes "
"a subvector from a vector.  The arguments are interpreted the same as for "
"the normal @kbd{v s} command.  Thus, @samp{rsubvec([a, b, c, d, e], 2, 4)} "
"produces @samp{[a, d, e]}.  It is always true that @code{subvec} and "
"@code{rsubvec} return complementary parts of the input vector."
msgstr ""

#. type: Plain text
#: ../../calc.texi:19980
msgid ""
"@xref{Selecting Subformulas}, for an alternative way to operate on vectors "
"one element at a time."
msgstr ""

#. type: node
#: ../../calc.texi:19981 ../../calc.texi:20213 ../../calc.texi:20214 ../../calc.texi:20335
#, no-wrap
msgid "Vector and Matrix Arithmetic"
msgstr ""

#. type: kindex
#: ../../calc.texi:19985
#, no-wrap
msgid "v l"
msgstr ""

#. type: kindex
#: ../../calc.texi:19986
#, no-wrap
msgid "V l"
msgstr ""

#. type: pindex
#: ../../calc.texi:19987
#, no-wrap
msgid "calc-vlength"
msgstr ""

#. type: Plain text
#: ../../calc.texi:19993
msgid ""
"@tindex vlen The @kbd{v l} (@code{calc-vlength}) [@code{vlen}] command "
"computes the length of a vector.  The length of a non-vector is considered "
"to be zero.  Note that matrices are just vectors of vectors for the purposes "
"of this command."
msgstr ""

#. type: kindex
#: ../../calc.texi:19994
#, no-wrap
msgid "H v l"
msgstr ""

#. type: kindex
#: ../../calc.texi:19995
#, no-wrap
msgid "H V l"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20004
msgid ""
"@tindex mdims With the Hyperbolic flag, @kbd{H v l} [@code{mdims}] computes "
"a vector of the dimensions of a vector, matrix, or higher-order object.  For "
"example, @samp{mdims([[a,b,c],[d,e,f]])} returns @samp{[2, 3]} since its "
"argument is a @texline @math{2\\times3} @infoline 2x3 matrix."
msgstr ""

#. type: kindex
#: ../../calc.texi:20005
#, no-wrap
msgid "v f"
msgstr ""

#. type: kindex
#: ../../calc.texi:20006
#, no-wrap
msgid "V f"
msgstr ""

#. type: pindex
#: ../../calc.texi:20007
#, no-wrap
msgid "calc-vector-find"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20015
msgid ""
"@tindex find The @kbd{v f} (@code{calc-vector-find}) [@code{find}] command "
"searches along a vector for the first element equal to a given target.  The "
"target is on the top of the stack; the vector is in the second-to-top "
"position.  If a match is found, the result is the index of the matching "
"element.  Otherwise, the result is zero.  The numeric prefix argument, if "
"given, allows you to select any starting index for the search."
msgstr ""

#. type: kindex
#: ../../calc.texi:20016
#, no-wrap
msgid "v a"
msgstr ""

#. type: kindex
#: ../../calc.texi:20017
#, no-wrap
msgid "V a"
msgstr ""

#. type: pindex
#: ../../calc.texi:20018
#, no-wrap
msgid "calc-arrange-vector"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20020
msgid "@tindex arrange"
msgstr ""

#. type: cindex
#: ../../calc.texi:20020
#, no-wrap
msgid "Arranging a matrix"
msgstr ""

#. type: cindex
#: ../../calc.texi:20021
#, no-wrap
msgid "Reshaping a matrix"
msgstr ""

#. type: cindex
#: ../../calc.texi:20022
#, no-wrap
msgid "Flattening a matrix"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20046
msgid ""
"The @kbd{v a} (@code{calc-arrange-vector}) [@code{arrange}] command "
"rearranges a vector to have a certain number of columns and rows.  The "
"numeric prefix argument specifies the number of columns; if you do not "
"provide an argument, you will be prompted for the number of columns.  The "
"vector or matrix on the top of the stack is @dfn{flattened} into a plain "
"vector.  If the number of columns is nonzero, this vector is then formed "
"into a matrix by taking successive groups of @var{n} elements.  If the "
"number of columns does not evenly divide the number of elements in the "
"vector, the last row will be short and the result will not be suitable for "
"use as a matrix.  For example, with the matrix @samp{[[1, 2], @w{[3, 4]}]} "
"on the stack, @kbd{v a 4} produces @samp{[[1, 2, 3, 4]]} (a @texline "
"@math{1\\times4} @infoline 1x4 matrix), @kbd{v a 1} produces @samp{[[1], "
"[2], [3], [4]]} (a @texline @math{4\\times1} @infoline 4x1 matrix), @kbd{v a "
"2} produces @samp{[[1, 2], [3, 4]]} (the original @texline @math{2\\times2} "
"@infoline 2x2 matrix), @w{@kbd{v a 3}} produces @samp{[[1, 2, 3], [4]]} (not "
"a matrix), and @kbd{v a 0} produces the flattened list @samp{[1, 2, @w{3, "
"4}]}."
msgstr ""

#. type: cindex
#: ../../calc.texi:20047
#, no-wrap
msgid "Sorting data"
msgstr ""

#. type: kindex
#: ../../calc.texi:20048
#, no-wrap
msgid "v S"
msgstr ""

#. type: kindex
#: ../../calc.texi:20049
#, no-wrap
msgid "V S"
msgstr ""

#. type: kindex
#: ../../calc.texi:20050
#, no-wrap
msgid "I v S"
msgstr ""

#. type: kindex
#: ../../calc.texi:20051
#, no-wrap
msgid "I V S"
msgstr ""

#. type: pindex
#: ../../calc.texi:20052
#, no-wrap
msgid "calc-sort"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20066
msgid ""
"@tindex sort @tindex rsort The @kbd{V S} (@code{calc-sort}) [@code{sort}] "
"command sorts the elements of a vector into increasing order.  Real numbers, "
"real infinities, and constant interval forms come first in this ordering; "
"next come other kinds of numbers, then variables (in alphabetical order), "
"then finally come formulas and other kinds of objects; these are sorted "
"according to a kind of lexicographic ordering with the useful property that "
"one vector is less or greater than another if the first corresponding "
"unequal elements are less or greater, respectively.  Since quoted strings "
"are stored by Calc internally as vectors of ASCII character codes "
"(@pxref{Strings}), this means vectors of strings are also sorted into "
"alphabetical order by this command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20068
msgid "The @kbd{I V S} [@code{rsort}] command sorts a vector into decreasing order."
msgstr ""

#. type: cindex
#: ../../calc.texi:20069
#, no-wrap
msgid "Permutation, inverse of"
msgstr ""

#. type: cindex
#: ../../calc.texi:20070
#, no-wrap
msgid "Inverse of permutation"
msgstr ""

#. type: cindex
#: ../../calc.texi:20071
#, no-wrap
msgid "Index tables"
msgstr ""

#. type: cindex
#: ../../calc.texi:20072
#, no-wrap
msgid "Rank tables"
msgstr ""

#. type: kindex
#: ../../calc.texi:20073
#, no-wrap
msgid "v G"
msgstr ""

#. type: kindex
#: ../../calc.texi:20074
#, no-wrap
msgid "V G"
msgstr ""

#. type: kindex
#: ../../calc.texi:20075
#, no-wrap
msgid "I v G"
msgstr ""

#. type: kindex
#: ../../calc.texi:20076
#, no-wrap
msgid "I V G"
msgstr ""

#. type: pindex
#: ../../calc.texi:20077
#, no-wrap
msgid "calc-grade"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20093
msgid ""
"@tindex grade @tindex rgrade The @kbd{V G} (@code{calc-grade}) "
"[@code{grade}, @code{rgrade}] command produces an index table or permutation "
"vector which, if applied to the input vector (as the index of @kbd{C-u v r}, "
"say), would sort the vector.  A permutation vector is just a vector of "
"integers from 1 to @var{n}, where each integer occurs exactly once.  One "
"application of this is to sort a matrix of data rows using one column as the "
"sort key; extract that column, grade it with @kbd{V G}, then use the result "
"to reorder the original matrix with @kbd{C-u v r}.  Another interesting "
"property of the @code{V G} command is that, if the input is itself a "
"permutation vector, the result will be the inverse of the permutation.  The "
"inverse of an index table is a rank table, whose @var{k}th element says "
"where the @var{k}th original vector element will rest when the vector is "
"sorted.  To get a rank table, just use @kbd{V G V G}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20105
msgid ""
"With the Inverse flag, @kbd{I V G} produces an index table that would sort "
"the input into decreasing order.  Note that @kbd{V S} and @kbd{V G} use a "
"``stable'' sorting algorithm, i.e., any two elements which are equal will "
"not be moved out of their original order.  Generally there is no way to tell "
"with @kbd{V S}, since two elements which are equal look the same, but with "
"@kbd{V G} this can be an important issue.  In the matrix-of-rows example, "
"suppose you have names and telephone numbers as two columns and you wish to "
"sort by phone number primarily, and by name when the numbers are equal.  You "
"can sort the data matrix by names first, and then again by phone numbers.  "
"Because the sort is stable, any two rows with equal phone numbers will "
"remain sorted by name even after the second sort."
msgstr ""

#. type: cindex
#: ../../calc.texi:20106
#, no-wrap
msgid "Histograms"
msgstr ""

#. type: kindex
#: ../../calc.texi:20107
#, no-wrap
msgid "v H"
msgstr ""

#. type: kindex
#: ../../calc.texi:20108
#, no-wrap
msgid "V H"
msgstr ""

#. type: pindex
#: ../../calc.texi:20109
#, no-wrap
msgid "calc-histogram"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20124
msgid ""
"@tindex histogram The @kbd{V H} (@code{calc-histogram}) [@code{histogram}] "
"command builds a histogram of a vector of numbers.  Vector elements are "
"assumed to be integers or real numbers in the range [0..@var{n}) for some "
"``number of bins'' @var{n}, which is the numeric prefix argument given to "
"the command.  The result is a vector of @var{n} counts of how many times "
"each value appeared in the original vector.  Non-integers in the input are "
"rounded down to integers.  Any vector elements outside the specified range "
"are ignored.  (You can tell if elements have been ignored by noting that the "
"counts in the result vector don't add up to the length of the input vector.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20134
msgid ""
"If no prefix is given, then you will be prompted for a vector which will be "
"used to determine the bins. (If a positive integer is given at this prompt, "
"it will be still treated as if it were given as a prefix.)  Each bin will "
"consist of the interval of numbers closest to the corresponding number of "
"this new vector; if the vector @expr{[a, b, c, ...]} is entered at the "
"prompt, the bins will be @expr{(-inf, (a+b)/2]}, @expr{((a+b)/2, (b+c)/2]}, "
"etc.  The result of this command will be a vector counting how many elements "
"of the original vector are in each bin."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20138
msgid ""
"The result will then be a vector with the same length as this new vector; "
"each element of the new vector will be replaced by the number of elements of "
"the original vector which are closest to it."
msgstr ""

#. type: kindex
#: ../../calc.texi:20139
#, no-wrap
msgid "H v H"
msgstr ""

#. type: kindex
#: ../../calc.texi:20140
#, no-wrap
msgid "H V H"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20147
msgid ""
"With the Hyperbolic flag, @kbd{H V H} pulls two vectors from the stack.  The "
"second-to-top vector is the list of numbers as before.  The top vector is an "
"equal-sized list of ``weights'' to attach to the elements of the data "
"vector.  For example, if the first data element is 4.2 and the first weight "
"is 10, then 10 will be added to bin 4 of the result vector.  Without the "
"hyperbolic flag, every element has a weight of one."
msgstr ""

#. type: kindex
#: ../../calc.texi:20148
#, no-wrap
msgid "v t"
msgstr ""

#. type: kindex
#: ../../calc.texi:20149
#, no-wrap
msgid "V t"
msgstr ""

#. type: pindex
#: ../../calc.texi:20150
#, no-wrap
msgid "calc-transpose"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20156
msgid ""
"@tindex trn The @kbd{v t} (@code{calc-transpose}) [@code{trn}] command "
"computes the transpose of the matrix at the top of the stack.  If the "
"argument is a plain vector, it is treated as a row vector and transposed "
"into a one-column matrix."
msgstr ""

#. type: kindex
#: ../../calc.texi:20157
#, no-wrap
msgid "v v"
msgstr ""

#. type: kindex
#: ../../calc.texi:20158
#, no-wrap
msgid "V v"
msgstr ""

#. type: pindex
#: ../../calc.texi:20159
#, no-wrap
msgid "calc-reverse-vector"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20166
msgid ""
"@tindex rev The @kbd{v v} (@code{calc-reverse-vector}) [@code{rev}] command "
"reverses a vector end-for-end.  Given a matrix, it reverses the order of the "
"rows.  (To reverse the columns instead, just use @kbd{v t v v v t}.  The "
"same principle can be used to apply other vector commands to the columns of "
"a matrix.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:20167
#, no-wrap
msgid "v m"
msgstr ""

#. type: kindex
#: ../../calc.texi:20168
#, no-wrap
msgid "V m"
msgstr ""

#. type: pindex
#: ../../calc.texi:20169
#, no-wrap
msgid "calc-mask-vector"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20179
msgid ""
"@tindex vmask The @kbd{v m} (@code{calc-mask-vector}) [@code{vmask}] command "
"uses one vector as a mask to extract elements of another vector.  The mask "
"is in the second-to-top position; the target vector is on the top of the "
"stack.  These vectors must have the same length.  The result is the same as "
"the target vector, but with all elements which correspond to zeros in the "
"mask vector deleted.  Thus, for example, @samp{vmask([1, 0, 1, 0, 1], [a, b, "
"c, d, e])} produces @samp{[a, c, e]}.  @xref{Logical Operations}."
msgstr ""

#. type: kindex
#: ../../calc.texi:20180
#, no-wrap
msgid "v e"
msgstr ""

#. type: kindex
#: ../../calc.texi:20181
#, no-wrap
msgid "V e"
msgstr ""

#. type: pindex
#: ../../calc.texi:20182
#, no-wrap
msgid "calc-expand-vector"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20193
msgid ""
"@tindex vexp The @kbd{v e} (@code{calc-expand-vector}) [@code{vexp}] command "
"expands a vector according to another mask vector.  The result is a vector "
"the same length as the mask, but with nonzero elements replaced by "
"successive elements from the target vector.  The length of the target vector "
"is normally the number of nonzero elements in the mask.  If the target "
"vector is longer, its last few elements are lost.  If the target vector is "
"shorter, the last few nonzero mask elements are left unreplaced in the "
"result.  Thus @samp{vexp([2, 0, 3, 0, 7], [a, b])} produces @samp{[a, 0, b, "
"0, 7]}."
msgstr ""

#. type: kindex
#: ../../calc.texi:20194
#, no-wrap
msgid "H v e"
msgstr ""

#. type: kindex
#: ../../calc.texi:20195
#, no-wrap
msgid "H V e"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20205
msgid ""
"With the Hyperbolic flag, @kbd{H v e} takes a filler value from the top of "
"the stack; the mask and target vectors come from the third and second "
"elements of the stack.  This filler is used where the mask is zero: "
"@samp{vexp([2, 0, 3, 0, 7], [a, b], z)} produces @samp{[a, z, c, z, 7]}.  If "
"the filler value is itself a vector, then successive values are taken from "
"it, so that the effect is to interleave two vectors according to the mask: "
"@samp{vexp([2, 0, 3, 7, 0, 0], [a, b], [x, y])} produces @samp{[a, x, b, 7, "
"y, 0]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20212
msgid ""
"Another variation on the masking idea is to combine @samp{[a, b, c, d, e]} "
"with the mask @samp{[1, 0, 1, 0, 1]} to produce @samp{[a, 0, c, 0, e]}.  You "
"can accomplish this with @kbd{V M a &}, mapping the logical ``and'' "
"operation across the two vectors.  @xref{Logical Operations}.  Note that the "
"@code{? :} operation also discussed there allows other types of masking "
"using vectors."
msgstr ""

#. type: node
#: ../../calc.texi:20213 ../../calc.texi:20335 ../../calc.texi:20525
#, no-wrap
msgid "Set Operations"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20222
msgid ""
"Basic arithmetic operations like addition and multiplication are defined for "
"vectors and matrices as well as for numbers.  Division of matrices, in the "
"sense of multiplying by the inverse, is supported.  (Division by a matrix "
"actually uses LU-decomposition for greater accuracy and speed.)  @xref{Basic "
"Arithmetic}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20227
msgid ""
"The following functions are applied element-wise if their arguments are "
"vectors or matrices: @code{change-sign}, @code{conj}, @code{arg}, @code{re}, "
"@code{im}, @code{polar}, @code{rect}, @code{clean}, @code{float}, "
"@code{frac}.  @xref{Function Index}."
msgstr ""

#. type: kindex
#: ../../calc.texi:20228
#, no-wrap
msgid "v J"
msgstr ""

#. type: kindex
#: ../../calc.texi:20229
#, no-wrap
msgid "V J"
msgstr ""

#. type: pindex
#: ../../calc.texi:20230
#, no-wrap
msgid "calc-conj-transpose"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20234
msgid ""
"@tindex ctrn The @kbd{V J} (@code{calc-conj-transpose}) [@code{ctrn}] "
"command computes the conjugate transpose of its argument, i.e., "
"@samp{conj(trn(x))}."
msgstr ""

#. type: kindex
#: ../../calc.texi:20238
#, no-wrap
msgid "A @r{(vectors)}"
msgstr ""

#. type: pindex
#: ../../calc.texi:20239
#, no-wrap
msgid "calc-abs (vectors)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20250
msgid ""
"@tindex abs (vectors)  The @kbd{A} (@code{calc-abs}) [@code{abs}] command "
"computes the Frobenius norm of a vector or matrix argument.  This is the "
"square root of the sum of the squares of the absolute values of the elements "
"of the vector or matrix.  If the vector is interpreted as a point in two- or "
"three-dimensional space, this is the distance from that point to the origin."
msgstr ""

#. type: kindex
#: ../../calc.texi:20251
#, no-wrap
msgid "v n"
msgstr ""

#. type: kindex
#: ../../calc.texi:20252
#, no-wrap
msgid "V n"
msgstr ""

#. type: pindex
#: ../../calc.texi:20253
#, no-wrap
msgid "calc-rnorm"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20260
msgid ""
"@tindex rnorm The @kbd{v n} (@code{calc-rnorm}) [@code{rnorm}] command "
"computes the infinity-norm of a vector, or the row norm of a matrix.  For a "
"plain vector, this is the maximum of the absolute values of the elements.  "
"For a matrix, this is the maximum of the row-absolute-value-sums, i.e., of "
"the sums of the absolute values of the elements along the various rows."
msgstr ""

#. type: kindex
#: ../../calc.texi:20261
#, no-wrap
msgid "v N"
msgstr ""

#. type: kindex
#: ../../calc.texi:20262
#, no-wrap
msgid "V N"
msgstr ""

#. type: pindex
#: ../../calc.texi:20263
#, no-wrap
msgid "calc-cnorm"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20272
msgid ""
"@tindex cnorm The @kbd{V N} (@code{calc-cnorm}) [@code{cnorm}] command "
"computes the one-norm of a vector, or column norm of a matrix.  For a plain "
"vector, this is the sum of the absolute values of the elements.  For a "
"matrix, this is the maximum of the column-absolute-value-sums.  General "
"@expr{k}-norms for @expr{k} other than one or infinity are not provided.  "
"However, the 2-norm (or Frobenius norm) is provided for vectors by the "
"@kbd{A} (@code{calc-abs}) command."
msgstr ""

#. type: kindex
#: ../../calc.texi:20273
#, no-wrap
msgid "v C"
msgstr ""

#. type: kindex
#: ../../calc.texi:20274
#, no-wrap
msgid "V C"
msgstr ""

#. type: pindex
#: ../../calc.texi:20275
#, no-wrap
msgid "calc-cross"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20280
msgid ""
"@tindex cross The @kbd{V C} (@code{calc-cross}) [@code{cross}] command "
"computes the right-handed cross product of two vectors, each of which must "
"have exactly three elements."
msgstr ""

#. type: kindex
#: ../../calc.texi:20284
#, no-wrap
msgid "& @r{(matrices)}"
msgstr ""

#. type: pindex
#: ../../calc.texi:20285
#, no-wrap
msgid "calc-inv (matrices)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20296
msgid ""
"@tindex inv (matrices)  The @kbd{&} (@code{calc-inv}) [@code{inv}] command "
"computes the inverse of a square matrix.  If the matrix is singular, the "
"inverse operation is left in symbolic form.  Matrix inverses are recorded so "
"that once an inverse (or determinant) of a particular matrix has been "
"computed, the inverse and determinant of the matrix can be recomputed "
"quickly in the future."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20301
msgid ""
"If the argument to @kbd{&} is a plain number @expr{x}, this command simply "
"computes @expr{1/x}.  This is okay, because the @samp{/} operator also does "
"a matrix inversion when dividing one by a matrix."
msgstr ""

#. type: kindex
#: ../../calc.texi:20302
#, no-wrap
msgid "v D"
msgstr ""

#. type: kindex
#: ../../calc.texi:20303
#, no-wrap
msgid "V D"
msgstr ""

#. type: pindex
#: ../../calc.texi:20304
#, no-wrap
msgid "calc-mdet"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20308
msgid ""
"@tindex det The @kbd{V D} (@code{calc-mdet}) [@code{det}] command computes "
"the determinant of a square matrix."
msgstr ""

#. type: kindex
#: ../../calc.texi:20309
#, no-wrap
msgid "v L"
msgstr ""

#. type: kindex
#: ../../calc.texi:20310
#, no-wrap
msgid "V L"
msgstr ""

#. type: pindex
#: ../../calc.texi:20311
#, no-wrap
msgid "calc-mlud"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20319
msgid ""
"@tindex lud The @kbd{V L} (@code{calc-mlud}) [@code{lud}] command computes "
"the LU decomposition of a matrix.  The result is a list of three matrices "
"which, when multiplied together left-to-right, form the original matrix.  "
"The first is a permutation matrix that arises from pivoting in the "
"algorithm, the second is lower-triangular with ones on the diagonal, and the "
"third is upper-triangular."
msgstr ""

#. type: kindex
#: ../../calc.texi:20320
#, no-wrap
msgid "v T"
msgstr ""

#. type: kindex
#: ../../calc.texi:20321
#, no-wrap
msgid "V T"
msgstr ""

#. type: pindex
#: ../../calc.texi:20322
#, no-wrap
msgid "calc-mtrace"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20327
msgid ""
"@tindex tr The @kbd{V T} (@code{calc-mtrace}) [@code{tr}] command computes "
"the trace of a square matrix.  This is defined as the sum of the diagonal "
"elements of the matrix."
msgstr ""

#. type: kindex
#: ../../calc.texi:20328
#, no-wrap
msgid "v K"
msgstr ""

#. type: kindex
#: ../../calc.texi:20329
#, no-wrap
msgid "V K"
msgstr ""

#. type: pindex
#: ../../calc.texi:20330
#, no-wrap
msgid "calc-kron"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20334
msgid ""
"@tindex kron The @kbd{V K} (@code{calc-kron}) [@code{kron}] command computes "
"the Kronecker product of two matrices."
msgstr ""

#. type: node
#: ../../calc.texi:20335 ../../calc.texi:20525 ../../calc.texi:20554 ../../calc.texi:20823 ../../calc.texi:20884
#, no-wrap
msgid "Statistical Operations"
msgstr ""

#. type: section
#: ../../calc.texi:20336
#, no-wrap
msgid "Set Operations using Vectors"
msgstr ""

#. type: cindex
#: ../../calc.texi:20339
#, no-wrap
msgid "Sets, as vectors"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20352
msgid ""
"Calc includes several commands which interpret vectors as @dfn{sets} of "
"objects.  A set is a collection of objects; any given object can appear only "
"once in the set.  Calc stores sets as vectors of objects in sorted order.  "
"Objects in a Calc set can be any of the usual things, such as numbers, "
"variables, or formulas.  Two set elements are considered equal if they are "
"identical, except that numerically equal numbers like the integer 4 and the "
"float 4.0 are considered equal even though they are not ``identical.'' "
"Variables are treated like plain symbols without attached values by the set "
"operations; subtracting the set @samp{[b]} from @samp{[a, b]} always yields "
"the set @samp{[a]} even though if the variables @samp{a} and @samp{b} both "
"equaled 17, you might expect the answer @samp{[]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20359
msgid ""
"If a set contains interval forms, then it is assumed to be a set of real "
"numbers.  In this case, all set operations require the elements of the set "
"to be only things that are allowed in intervals: Real numbers, plus and "
"minus infinity, HMS forms, and date forms.  If there are variables or other "
"non-real objects present in a real set, all set operations on it will be "
"left in unevaluated form."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20364
msgid ""
"If the input to a set operation is a plain number or interval form @var{a}, "
"it is treated like the one-element vector @samp{[@var{a}]}.  The result is "
"always a vector, except that if the set consists of a single interval, the "
"interval itself is returned instead."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20368
msgid ""
"@xref{Logical Operations}, for the @code{in} function which tests if a "
"certain value is a member of a given set.  To test if the set @expr{A} is a "
"subset of the set @expr{B}, use @samp{vdiff(A, B) = []}."
msgstr ""

#. type: kindex
#: ../../calc.texi:20369
#, no-wrap
msgid "v +"
msgstr ""

#. type: kindex
#: ../../calc.texi:20370
#, no-wrap
msgid "V +"
msgstr ""

#. type: pindex
#: ../../calc.texi:20371
#, no-wrap
msgid "calc-remove-duplicates"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20381
msgid ""
"@tindex rdup The @kbd{V +} (@code{calc-remove-duplicates}) [@code{rdup}] "
"command converts an arbitrary vector into set notation.  It works by sorting "
"the vector as if by @kbd{V S}, then removing duplicates.  (For example, "
"@kbd{[a, 5, 4, a, 4.0]} is sorted to @samp{[4, 4.0, 5, a, a]} and then "
"reduced to @samp{[4, 5, a]}).  Overlapping intervals are merged as "
"necessary.  You rarely need to use @kbd{V +} explicitly, since all the other "
"set-based commands apply @kbd{V +} to their inputs before using them."
msgstr ""

#. type: kindex
#: ../../calc.texi:20382
#, no-wrap
msgid "v V"
msgstr ""

#. type: kindex
#: ../../calc.texi:20383
#, no-wrap
msgid "V V"
msgstr ""

#. type: pindex
#: ../../calc.texi:20384
#, no-wrap
msgid "calc-set-union"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20391
msgid ""
"@tindex vunion The @kbd{V V} (@code{calc-set-union}) [@code{vunion}] command "
"computes the union of two sets.  An object is in the union of two sets if "
"and only if it is in either (or both) of the input sets.  (You could "
"accomplish the same thing by concatenating the sets with @kbd{|}, then using "
"@kbd{V +}.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:20392
#, no-wrap
msgid "v ^"
msgstr ""

#. type: kindex
#: ../../calc.texi:20393
#, no-wrap
msgid "V ^"
msgstr ""

#. type: pindex
#: ../../calc.texi:20394
#, no-wrap
msgid "calc-set-intersect"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20408
msgid ""
"@tindex vint The @kbd{V ^} (@code{calc-set-intersect}) [@code{vint}] command "
"computes the intersection of two sets.  An object is in the intersection if "
"and only if it is in both of the input sets.  Thus if the input sets are "
"disjoint, i.e., if they share no common elements, the result will be the "
"empty vector @samp{[]}.  Note that the characters @kbd{V} and @kbd{^} were "
"chosen to be close to the conventional mathematical notation for set "
"@texline union@tie{}(@math{A \\cup B})  @infoline union and @texline "
"intersection@tie{}(@math{A \\cap B}).  @infoline intersection."
msgstr ""

#. type: kindex
#: ../../calc.texi:20409
#, no-wrap
msgid "v -"
msgstr ""

#. type: kindex
#: ../../calc.texi:20410
#, no-wrap
msgid "V -"
msgstr ""

#. type: pindex
#: ../../calc.texi:20411
#, no-wrap
msgid "calc-set-difference"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20423
msgid ""
"@tindex vdiff The @kbd{V -} (@code{calc-set-difference}) [@code{vdiff}] "
"command computes the difference between two sets.  An object is in the "
"difference @expr{A - B} if and only if it is in @expr{A} but not in "
"@expr{B}.  Thus subtracting @samp{[y,z]} from a set will remove the elements "
"@samp{y} and @samp{z} if they are present.  You can also think of this as a "
"general @dfn{set complement} operator; if @expr{A} is the set of all "
"possible values, then @expr{A - B} is the ``complement'' of @expr{B}.  "
"Obviously this is only practical if the set of all possible values in your "
"problem is small enough to list in a Calc vector (or simple enough to "
"express in a few intervals)."
msgstr ""

#. type: kindex
#: ../../calc.texi:20424
#, no-wrap
msgid "v X"
msgstr ""

#. type: kindex
#: ../../calc.texi:20425
#, no-wrap
msgid "V X"
msgstr ""

#. type: pindex
#: ../../calc.texi:20426
#, no-wrap
msgid "calc-set-xor"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20433
msgid ""
"@tindex vxor The @kbd{V X} (@code{calc-set-xor}) [@code{vxor}] command "
"computes the ``exclusive-or,'' or ``symmetric difference'' of two sets.  An "
"object is in the symmetric difference of two sets if and only if it is in "
"one, but @emph{not} both, of the sets.  Objects that occur in both sets "
"``cancel out.''"
msgstr ""

#. type: kindex
#: ../../calc.texi:20434
#, no-wrap
msgid "v ~"
msgstr ""

#. type: kindex
#: ../../calc.texi:20435
#, no-wrap
msgid "V ~"
msgstr ""

#. type: pindex
#: ../../calc.texi:20436
#, no-wrap
msgid "calc-set-complement"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20443
msgid ""
"@tindex vcompl The @kbd{V ~} (@code{calc-set-complement}) [@code{vcompl}] "
"command computes the complement of a set with respect to the real numbers.  "
"Thus @samp{vcompl(x)} is equivalent to @samp{vdiff([-inf .. inf], x)}.  For "
"example, @samp{vcompl([2, (3 .. 4]])} evaluates to @samp{[[-inf .. 2), (2 "
".. 3], (4 .. inf]]}."
msgstr ""

#. type: kindex
#: ../../calc.texi:20444
#, no-wrap
msgid "v F"
msgstr ""

#. type: kindex
#: ../../calc.texi:20445
#, no-wrap
msgid "V F"
msgstr ""

#. type: pindex
#: ../../calc.texi:20446
#, no-wrap
msgid "calc-set-floor"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20456
msgid ""
"@tindex vfloor The @kbd{V F} (@code{calc-set-floor}) [@code{vfloor}] command "
"reinterprets a set as a set of integers.  Any non-integer values, and "
"intervals that do not enclose any integers, are removed.  Open intervals are "
"converted to equivalent closed intervals.  Successive integers are converted "
"into intervals of integers.  For example, the complement of the set "
"@samp{[2, 6, 7, 8]} is messy, but if you wanted the complement with respect "
"to the set of integers you could type @kbd{V ~ V F} to get @samp{[[-inf "
".. 1], [3 .. 5], [9 .. inf]]}."
msgstr ""

#. type: kindex
#: ../../calc.texi:20457
#, no-wrap
msgid "v E"
msgstr ""

#. type: kindex
#: ../../calc.texi:20458
#, no-wrap
msgid "V E"
msgstr ""

#. type: pindex
#: ../../calc.texi:20459
#, no-wrap
msgid "calc-set-enumerate"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20466
msgid ""
"@tindex venum The @kbd{V E} (@code{calc-set-enumerate}) [@code{venum}] "
"command converts a set of integers into an explicit vector.  Intervals in "
"the set are expanded out to lists of all integers encompassed by the "
"intervals.  This only works for finite sets (i.e., sets which do not involve "
"@samp{-inf} or @samp{inf})."
msgstr ""

#. type: kindex
#: ../../calc.texi:20467
#, no-wrap
msgid "v :"
msgstr ""

#. type: kindex
#: ../../calc.texi:20468
#, no-wrap
msgid "V :"
msgstr ""

#. type: pindex
#: ../../calc.texi:20469
#, no-wrap
msgid "calc-set-span"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20476
msgid ""
"@tindex vspan The @kbd{V :} (@code{calc-set-span}) [@code{vspan}] command "
"converts any set of reals into an interval form that encompasses all its "
"elements.  The lower limit will be the smallest element in the set; the "
"upper limit will be the largest element.  For an empty set, @samp{vspan([])} "
"returns the empty interval @w{@samp{[0 .. 0)}}."
msgstr ""

#. type: kindex
#: ../../calc.texi:20477
#, no-wrap
msgid "v #"
msgstr ""

#. type: kindex
#: ../../calc.texi:20478
#, no-wrap
msgid "V #"
msgstr ""

#. type: pindex
#: ../../calc.texi:20479
#, no-wrap
msgid "calc-set-cardinality"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20485
msgid ""
"@tindex vcard The @kbd{V #} (@code{calc-set-cardinality}) [@code{vcard}] "
"command counts the number of integers in a set.  The result is the length of "
"the vector that would be produced by @kbd{V E}, although the computation is "
"much more efficient than actually producing that vector."
msgstr ""

#. type: cindex
#: ../../calc.texi:20486
#, no-wrap
msgid "Sets, as binary numbers"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20498
msgid ""
"Another representation for sets that may be more appropriate in some cases "
"is binary numbers.  If you are dealing with sets of integers in the range 0 "
"to 49, you can use a 50-bit binary number where a particular bit is 1 if the "
"corresponding element is in the set.  @xref{Binary Functions}, for a list of "
"commands that operate on binary numbers.  Note that many of the above set "
"operations have direct equivalents in binary arithmetic: @kbd{b o} "
"(@code{calc-or}), @kbd{b a} (@code{calc-and}), @kbd{b d} (@code{calc-diff}), "
"@kbd{b x} (@code{calc-xor}), and @kbd{b n} (@code{calc-not}), respectively.  "
"You can use whatever representation for sets is most convenient to you."
msgstr ""

#. type: kindex
#: ../../calc.texi:20499
#, no-wrap
msgid "b p"
msgstr ""

#. type: kindex
#: ../../calc.texi:20500
#, no-wrap
msgid "b u"
msgstr ""

#. type: pindex
#: ../../calc.texi:20501
#, no-wrap
msgid "calc-pack-bits"
msgstr ""

#. type: pindex
#: ../../calc.texi:20502
#, no-wrap
msgid "calc-unpack-bits"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20513
msgid ""
"@tindex vpack @tindex vunpack The @kbd{b u} (@code{calc-unpack-bits}) "
"[@code{vunpack}] command converts an integer that represents a set in binary "
"into a set in vector/interval notation.  For example, @samp{vunpack(67)} "
"returns @samp{[[0 .. 1], 6]}.  If the input is negative, the set it "
"represents is semi-infinite: @samp{vunpack(-4) = [2 .. inf)}.  Use @kbd{V E} "
"afterwards to expand intervals to individual values if you wish.  Note that "
"this command uses the @kbd{b} (binary) prefix key."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20524
msgid ""
"The @kbd{b p} (@code{calc-pack-bits}) [@code{vpack}] command converts the "
"other way, from a vector or interval representing a set of nonnegative "
"integers into a binary integer describing the same set.  The set may include "
"positive infinity, but must not include any negative numbers.  The input is "
"interpreted as a set of integers in the sense of @kbd{V F} (@code{vfloor}).  "
"Beware that a simple input like @samp{[100]} can result in a huge integer "
"representation @texline (@math{2^{100}}, a 31-digit integer, in this case).  "
"@infoline (@expr{2^100}, a 31-digit integer, in this case)."
msgstr ""

#. type: node
#: ../../calc.texi:20525 ../../calc.texi:20884 ../../calc.texi:20914 ../../calc.texi:21065 ../../calc.texi:21162 ../../calc.texi:21243 ../../calc.texi:21323 ../../calc.texi:21360
#, no-wrap
msgid "Reducing and Mapping"
msgstr ""

#. type: section
#: ../../calc.texi:20526
#, no-wrap
msgid "Statistical Operations on Vectors"
msgstr ""

#. type: cindex
#: ../../calc.texi:20529
#, no-wrap
msgid "Statistical functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20536
msgid ""
"The commands in this section take vectors as arguments and compute various "
"statistical measures on the data stored in the vectors.  The references used "
"in the definitions of these functions are Bevington's @emph{Data Reduction "
"and Error Analysis for the Physical Sciences}, and @emph{Numerical Recipes} "
"by Press, Flannery, Teukolsky and Vetterling."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20539
msgid ""
"The statistical commands use the @kbd{u} prefix key followed by a shifted "
"letter or other character."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20542
msgid ""
"@xref{Manipulating Vectors}, for a description of @kbd{V H} "
"(@code{calc-histogram})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20545
msgid ""
"@xref{Curve Fitting}, for the @kbd{a F} command for doing least-squares fits "
"to statistical data."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20548
msgid ""
"@xref{Probability Distribution Functions}, for several common probability "
"distribution functions."
msgstr ""

#. type: menuentry
#: ../../calc.texi:20552
msgid "Single-Variable Statistics::"
msgstr ""

#. type: subsection
#: ../../calc.texi:20552 ../../calc.texi:20554 ../../calc.texi:20823 ../../calc.texi:20824
#, no-wrap
msgid "Paired-Sample Statistics"
msgstr ""

#. type: node
#: ../../calc.texi:20554 ../../calc.texi:20555 ../../calc.texi:20823
#, no-wrap
msgid "Single-Variable Statistics"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20565
msgid ""
"These functions do various statistical computations on single vectors.  "
"Given a numeric prefix argument, they actually pop @var{n} objects from the "
"stack and combine them into a data vector.  Each object may be either a "
"number or a vector; if a vector, any sub-vectors inside it are ``flattened'' "
"as if by @kbd{v a 0}; @pxref{Manipulating Vectors}.  By default one object "
"is popped, which (in order to be useful) is usually a vector."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20570
msgid ""
"If an argument is a variable name, and the value stored in that variable is "
"a vector, then the stored vector is used.  This method has the advantage "
"that if your data vector is large, you can avoid the slow process of "
"manipulating it directly on the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20578
msgid ""
"These functions are left in symbolic form if any of their arguments are not "
"numbers or vectors, e.g., if an argument is a formula, or a non-vector "
"variable.  However, formulas embedded within vector arguments are accepted; "
"the result is a symbolic representation of the computation, based on the "
"assumption that the formula does not itself represent a vector.  All "
"varieties of numbers such as error forms and interval forms are acceptable."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20589
msgid ""
"Some of the functions in this section also accept a single error form or "
"interval as an argument.  They then describe a property of the normal or "
"uniform (respectively) statistical distribution described by the argument.  "
"The arguments are interpreted in the same way as the @var{M} argument of the "
"random number function @kbd{k r}.  In particular, an interval with integer "
"limits is considered an integer distribution, so that @samp{[2 .. 6)} is the "
"same as @samp{[2 .. 5]}.  An interval with at least one floating-point limit "
"is a continuous distribution: @samp{[2.0 .. 6.0)} is @emph{not} the same as "
"@samp{[2.0 .. 5.0]}!"
msgstr ""

#. type: kindex
#: ../../calc.texi:20590
#, no-wrap
msgid "u #"
msgstr ""

#. type: pindex
#: ../../calc.texi:20591
#, no-wrap
msgid "calc-vector-count"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20598
msgid ""
"@tindex vcount The @kbd{u #} (@code{calc-vector-count}) [@code{vcount}] "
"command computes the number of data values represented by the inputs.  For "
"example, @samp{vcount(1, [2, 3], [[4, 5], [], x, y])} returns 7.  If the "
"argument is a single vector with no sub-vectors, this simply computes the "
"length of the vector."
msgstr ""

#. type: kindex
#: ../../calc.texi:20599
#, no-wrap
msgid "u +"
msgstr ""

#. type: kindex
#: ../../calc.texi:20600
#, no-wrap
msgid "u *"
msgstr ""

#. type: pindex
#: ../../calc.texi:20601
#, no-wrap
msgid "calc-vector-sum"
msgstr ""

#. type: pindex
#: ../../calc.texi:20602
#, no-wrap
msgid "calc-vector-prod"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20605
msgid "@tindex vsum @tindex vprod"
msgstr ""

#. type: cindex
#: ../../calc.texi:20605
#, no-wrap
msgid "Summations (statistical)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20612
msgid ""
"The @kbd{u +} (@code{calc-vector-sum}) [@code{vsum}] command computes the "
"sum of the data values.  The @kbd{u *} (@code{calc-vector-prod}) "
"[@code{vprod}] command computes the product of the data values.  If the "
"input is a single flat vector, these are the same as @kbd{V R +} and @kbd{V "
"R *} (@pxref{Reducing and Mapping})."
msgstr ""

#. type: kindex
#: ../../calc.texi:20613
#, no-wrap
msgid "u X"
msgstr ""

#. type: kindex
#: ../../calc.texi:20614
#, no-wrap
msgid "u N"
msgstr ""

#. type: pindex
#: ../../calc.texi:20615
#, no-wrap
msgid "calc-vector-max"
msgstr ""

#. type: pindex
#: ../../calc.texi:20616
#, no-wrap
msgid "calc-vector-min"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20626
msgid ""
"@tindex vmax @tindex vmin The @kbd{u X} (@code{calc-vector-max}) "
"[@code{vmax}] command computes the maximum of the data values, and the "
"@kbd{u N} (@code{calc-vector-min}) [@code{vmin}] command computes the "
"minimum.  If the argument is an interval, this finds the minimum or maximum "
"value in the interval.  (Note that @samp{vmax([2..6)) = 5} as described "
"above.)  If the argument is an error form, this returns plus or minus "
"infinity."
msgstr ""

#. type: kindex
#: ../../calc.texi:20627
#, no-wrap
msgid "u M"
msgstr ""

#. type: pindex
#: ../../calc.texi:20628
#, no-wrap
msgid "calc-vector-mean"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20630
msgid "@tindex vmean"
msgstr ""

#. type: cindex
#: ../../calc.texi:20630
#, no-wrap
msgid "Mean of data values"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20639
msgid ""
"The @kbd{u M} (@code{calc-vector-mean}) [@code{vmean}] command computes the "
"average (arithmetic mean) of the data values.  If the inputs are error forms "
"@texline @math{x \\pm \\sigma}, @infoline @samp{x +/- s}, this is the "
"weighted mean of the @expr{x} values with weights @texline @math{1 "
"/\\sigma^2}.  @infoline @expr{1 / s^2}."
msgstr ""

#. type: tex
#: ../../calc.texi:20642
#, no-wrap
msgid ""
"$$ \\mu = { \\displaystyle \\sum { x_i \\over \\sigma_i^2 } \\over\n"
"           \\displaystyle \\sum { 1 \\over \\sigma_i^2 } } $$\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20645
msgid ""
"If the inputs are not error forms, this is simply the sum of the values "
"divided by the count of the values."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20656
msgid ""
"Note that a plain number can be considered an error form with error @texline "
"@math{\\sigma = 0}.  @infoline @expr{s = 0}.  If the input to @kbd{u M} is a "
"mixture of plain numbers and error forms, the result is the mean of the "
"plain numbers, ignoring all values with non-zero errors.  (By the above "
"definitions it's clear that a plain number effectively has an infinite "
"weight, next to which an error form with a finite weight is completely "
"negligible.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20661
msgid ""
"This function also works for distributions (error forms or intervals).  The "
"mean of an error form `@var{a} @tfn{+/-} @var{b}' is simply @expr{a}.  The "
"mean of an interval is the mean of the minimum and maximum values of the "
"interval."
msgstr ""

#. type: kindex
#: ../../calc.texi:20662
#, no-wrap
msgid "I u M"
msgstr ""

#. type: pindex
#: ../../calc.texi:20663
#, no-wrap
msgid "calc-vector-mean-error"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20672
msgid ""
"@tindex vmeane The @kbd{I u M} (@code{calc-vector-mean-error}) "
"[@code{vmeane}] command computes the mean of the data points expressed as an "
"error form.  This includes the estimated error associated with the mean.  If "
"the inputs are error forms, the error is the square root of the reciprocal "
"of the sum of the reciprocals of the squares of the input errors.  (I.e., "
"the variance is the reciprocal of the sum of the reciprocals of the "
"variances.)"
msgstr ""

#. type: tex
#: ../../calc.texi:20674
#, no-wrap
msgid ""
"$$ \\sigma_\\mu^2 = {1 \\over \\displaystyle \\sum {1 \\over \\sigma_i^2}} "
"$$\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20681
msgid ""
"If the inputs are plain numbers, the error is equal to the standard "
"deviation of the values divided by the square root of the number of values.  "
"(This works out to be equivalent to calculating the standard deviation and "
"then assuming each value's error is equal to this standard deviation.)"
msgstr ""

#. type: tex
#: ../../calc.texi:20683
#, no-wrap
msgid "$$ \\sigma_\\mu^2 = {\\sigma^2 \\over N} $$\n"
msgstr ""

#. type: kindex
#: ../../calc.texi:20685
#, no-wrap
msgid "H u M"
msgstr ""

#. type: pindex
#: ../../calc.texi:20686
#, no-wrap
msgid "calc-vector-median"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20688
msgid "@tindex vmedian"
msgstr ""

#. type: cindex
#: ../../calc.texi:20688
#, no-wrap
msgid "Median of data values"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20700
msgid ""
"The @kbd{H u M} (@code{calc-vector-median}) [@code{vmedian}] command "
"computes the median of the data values.  The values are first sorted into "
"numerical order; the median is the middle value after sorting.  (If the "
"number of data values is even, the median is taken to be the average of the "
"two middle values.)  The median function is different from the other "
"functions in this section in that the arguments must all be real numbers; "
"variables are not accepted even when nested inside vectors.  (Otherwise it "
"is not possible to sort the data values.)  If any of the input values are "
"error forms, their error parts are ignored."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20704
msgid ""
"The median function also accepts distributions.  For both normal (error "
"form) and uniform (interval) distributions, the median is the same as the "
"mean."
msgstr ""

#. type: kindex
#: ../../calc.texi:20705
#, no-wrap
msgid "H I u M"
msgstr ""

#. type: pindex
#: ../../calc.texi:20706
#, no-wrap
msgid "calc-vector-harmonic-mean"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20708
msgid "@tindex vhmean"
msgstr ""

#. type: cindex
#: ../../calc.texi:20708
#, no-wrap
msgid "Harmonic mean"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20713
msgid ""
"The @kbd{H I u M} (@code{calc-vector-harmonic-mean}) [@code{vhmean}] command "
"computes the harmonic mean of the data values.  This is defined as the "
"reciprocal of the arithmetic mean of the reciprocals of the values."
msgstr ""

#. type: tex
#: ../../calc.texi:20715
#, no-wrap
msgid "$$ { N \\over \\displaystyle \\sum {1 \\over x_i} } $$\n"
msgstr ""

#. type: kindex
#: ../../calc.texi:20717
#, no-wrap
msgid "u G"
msgstr ""

#. type: pindex
#: ../../calc.texi:20718
#, no-wrap
msgid "calc-vector-geometric-mean"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20720
msgid "@tindex vgmean"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20726
msgid ""
"The @kbd{u G} (@code{calc-vector-geometric-mean}) [@code{vgmean}] command "
"computes the geometric mean of the data values.  This is the @var{n}th root "
"of the product of the values.  This is also equal to the @code{exp} of the "
"arithmetic mean of the logarithms of the data values."
msgstr ""

#. type: tex
#: ../../calc.texi:20729
#, no-wrap
msgid ""
"$$ \\exp \\left ( \\sum { \\ln x_i } \\right ) =\n"
"   \\left ( \\prod { x_i } \\right)^{1 / N} $$\n"
msgstr ""

#. type: kindex
#: ../../calc.texi:20731
#, no-wrap
msgid "H u G"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20737
msgid ""
"@tindex agmean The @kbd{H u G} [@code{agmean}] command computes the "
"``arithmetic-geometric mean'' of two numbers taken from the stack.  This is "
"computed by replacing the two numbers with their arithmetic mean and "
"geometric mean, then repeating until the two values converge."
msgstr ""

#. type: tex
#: ../../calc.texi:20739
#, no-wrap
msgid "$$ a_{i+1} = { a_i + b_i \\over 2 } , \\qquad b_{i+1} = \\sqrt{a_i b_i} $$\n"
msgstr ""

#. type: kindex
#: ../../calc.texi:20741
#, no-wrap
msgid "u R"
msgstr ""

#. type: cindex
#: ../../calc.texi:20742
#, no-wrap
msgid "Root-mean-square"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20748
msgid ""
"@tindex rms The @kbd{u R} (@code{calc-vector-rms}) [@code{rms}] command "
"computes the RMS (root-mean-square) of the data values.  As its name "
"suggests, this is the square root of the mean of the squares of the data "
"values."
msgstr ""

#. type: kindex
#: ../../calc.texi:20749
#, no-wrap
msgid "u S"
msgstr ""

#. type: pindex
#: ../../calc.texi:20750
#, no-wrap
msgid "calc-vector-sdev"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20752
msgid "@tindex vsdev"
msgstr ""

#. type: cindex
#: ../../calc.texi:20752
#, no-wrap
msgid "Standard deviation"
msgstr ""

#. type: cindex
#: ../../calc.texi:20753
#, no-wrap
msgid "Sample statistics"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20763
msgid ""
"The @kbd{u S} (@code{calc-vector-sdev}) [@code{vsdev}] command computes the "
"standard @texline deviation@tie{}@math{\\sigma} @infoline deviation of the "
"data values.  If the values are error forms, the errors are used as weights "
"just as for @kbd{u M}.  This is the @emph{sample} standard deviation, whose "
"value is the square root of the sum of the squares of the differences "
"between the values and the mean of the @expr{N} values, divided by "
"@expr{N-1}."
msgstr ""

#. type: tex
#: ../../calc.texi:20765
#, no-wrap
msgid "$$ \\sigma^2 = {1 \\over N - 1} \\sum (x_i - \\mu)^2 $$\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20775
msgid ""
"This function also applies to distributions.  The standard deviation of a "
"single error form is simply the error part.  The standard deviation of a "
"continuous interval happens to equal the difference between the limits, "
"divided by @texline @math{\\sqrt{12}}.  @infoline @expr{sqrt(12)}.  The "
"standard deviation of an integer interval is the same as the standard "
"deviation of a vector of those integers."
msgstr ""

#. type: kindex
#: ../../calc.texi:20776
#, no-wrap
msgid "I u S"
msgstr ""

#. type: pindex
#: ../../calc.texi:20777
#, no-wrap
msgid "calc-vector-pop-sdev"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20779
msgid "@tindex vpsdev"
msgstr ""

#. type: cindex
#: ../../calc.texi:20779
#, no-wrap
msgid "Population statistics"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20789
msgid ""
"The @kbd{I u S} (@code{calc-vector-pop-sdev}) [@code{vpsdev}] command "
"computes the @emph{population} standard deviation.  It is defined by the "
"same formula as above but dividing by @expr{N} instead of by @expr{N-1}.  "
"The population standard deviation is used when the input represents the "
"entire set of data values in the distribution; the sample standard deviation "
"is used when the input represents a sample of the set of all data values, so "
"that the mean computed from the input is itself only an estimate of the true "
"mean."
msgstr ""

#. type: tex
#: ../../calc.texi:20791
#, no-wrap
msgid "$$ \\sigma^2 = {1 \\over N} \\sum (x_i - \\mu)^2 $$\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20796
msgid ""
"For error forms and continuous intervals, @code{vpsdev} works exactly like "
"@code{vsdev}.  For integer intervals, it computes the population standard "
"deviation of the equivalent vector of integers."
msgstr ""

#. type: kindex
#: ../../calc.texi:20797
#, no-wrap
msgid "H u S"
msgstr ""

#. type: kindex
#: ../../calc.texi:20798
#, no-wrap
msgid "H I u S"
msgstr ""

#. type: pindex
#: ../../calc.texi:20799
#, no-wrap
msgid "calc-vector-variance"
msgstr ""

#. type: pindex
#: ../../calc.texi:20800
#, no-wrap
msgid "calc-vector-pop-variance"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20803
msgid "@tindex vvar @tindex vpvar"
msgstr ""

#. type: cindex
#: ../../calc.texi:20803
#, no-wrap
msgid "Variance of data values"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20813
msgid ""
"The @kbd{H u S} (@code{calc-vector-variance}) [@code{vvar}] and @kbd{H I u "
"S} (@code{calc-vector-pop-variance}) [@code{vpvar}] commands compute the "
"variance of the data values.  The variance is the @texline "
"square@tie{}@math{\\sigma^2} @infoline square of the standard deviation, "
"i.e., the sum of the squares of the deviations of the data values from the "
"mean.  (This definition also applies when the argument is a distribution.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20822
msgid ""
"@tindex vflat The @code{vflat} algebraic function returns a vector of its "
"arguments, interpreted in the same way as the other functions in this "
"section.  For example, @samp{vflat(1, [2, [3, 4]], 5)} returns @samp{[1, 2, "
"3, 4, 5]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20836
msgid ""
"The functions in this section take two arguments, which must be vectors of "
"equal size.  The vectors are each flattened in the same way as by the "
"single-variable statistical functions.  Given a numeric prefix argument of "
"1, these functions instead take one object from the stack, which must be an "
"@texline @math{N\\times2} @infoline Nx2 matrix of data values.  Once again, "
"variable names can be used in place of actual vectors and matrices."
msgstr ""

#. type: kindex
#: ../../calc.texi:20837
#, no-wrap
msgid "u C"
msgstr ""

#. type: pindex
#: ../../calc.texi:20838
#, no-wrap
msgid "calc-vector-covariance"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20840
msgid "@tindex vcov"
msgstr ""

#. type: cindex
#: ../../calc.texi:20840
#, no-wrap
msgid "Covariance"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20853
msgid ""
"The @kbd{u C} (@code{calc-vector-covariance}) [@code{vcov}] command computes "
"the sample covariance of two vectors.  The covariance of vectors @var{x} and "
"@var{y} is the sum of the products of the differences between the elements "
"of @var{x} and the mean of @var{x} times the differences between the "
"corresponding elements of @var{y} and the mean of @var{y}, all divided by "
"@expr{N-1}.  Note that the variance of a vector is just the covariance of "
"the vector with itself.  Once again, if the inputs are error forms the "
"errors are used as weight factors.  If both @var{x} and @var{y} are composed "
"of error forms, the error for a given data point is taken as the square root "
"of the sum of the squares of the two input errors."
msgstr ""

#. type: tex
#: ../../calc.texi:20860
#, no-wrap
msgid ""
"$$ \\sigma_{x\\!y}^2 = {1 \\over N-1} \\sum (x_i - \\mu_x) (y_i - \\mu_y) "
"$$\n"
"$$ \\sigma_{x\\!y}^2 =\n"
"    {\\displaystyle {1 \\over N-1}\n"
"                   \\sum {(x_i - \\mu_x) (y_i - \\mu_y) \\over "
"\\sigma_i^2}\n"
"     \\over \\displaystyle {1 \\over N} \\sum {1 \\over \\sigma_i^2}}\n"
"$$\n"
msgstr ""

#. type: kindex
#: ../../calc.texi:20862
#, no-wrap
msgid "I u C"
msgstr ""

#. type: pindex
#: ../../calc.texi:20863
#, no-wrap
msgid "calc-vector-pop-covariance"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20869
msgid ""
"@tindex vpcov The @kbd{I u C} (@code{calc-vector-pop-covariance}) "
"[@code{vpcov}] command computes the population covariance, which is the same "
"as the sample covariance computed by @kbd{u C} except dividing by @expr{N} "
"instead of @expr{N-1}."
msgstr ""

#. type: kindex
#: ../../calc.texi:20870
#, no-wrap
msgid "H u C"
msgstr ""

#. type: pindex
#: ../../calc.texi:20871
#, no-wrap
msgid "calc-vector-correlation"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20873
msgid "@tindex vcorr"
msgstr ""

#. type: cindex
#: ../../calc.texi:20873
#, no-wrap
msgid "Correlation coefficient"
msgstr ""

#. type: cindex
#: ../../calc.texi:20874
#, no-wrap
msgid "Linear correlation"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20880
msgid ""
"The @kbd{H u C} (@code{calc-vector-correlation}) [@code{vcorr}] command "
"computes the linear correlation coefficient of two vectors.  This is defined "
"by the covariance of the vectors divided by the product of their standard "
"deviations.  (There is no difference between sample or population statistics "
"here.)"
msgstr ""

#. type: tex
#: ../../calc.texi:20882
#, no-wrap
msgid "$$ r_{x\\!y} = { \\sigma_{x\\!y}^2 \\over \\sigma_x^2 \\sigma_y^2 } $$\n"
msgstr ""

#. type: section
#: ../../calc.texi:20885
#, no-wrap
msgid "Reducing and Mapping Vectors"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20890
msgid ""
"The commands in this section allow for more general operations on the "
"elements of vectors."
msgstr ""

#. type: kindex
#: ../../calc.texi:20891
#, no-wrap
msgid "v A"
msgstr ""

#. type: kindex
#: ../../calc.texi:20892
#, no-wrap
msgid "V A"
msgstr ""

#. type: pindex
#: ../../calc.texi:20893
#, no-wrap
msgid "calc-apply"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20902
msgid ""
"@tindex apply The simplest of these operations is @kbd{V A} "
"(@code{calc-apply})  [@code{apply}], which applies a given operator to the "
"elements of a vector.  For example, applying the hypothetical function "
"@code{f} to the vector @w{@samp{[1, 2, 3]}} would produce the function call "
"@samp{f(1, 2, 3)}.  Applying the @code{+} function to the vector @samp{[a, "
"b]} gives @samp{a + b}.  Applying @code{+} to the vector @samp{[a, b, c]} is "
"an error, since the @code{+} function expects exactly two arguments."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20905
msgid ""
"While @kbd{V A} is useful in some cases, you will usually find that either "
"@kbd{V R} or @kbd{V M}, described below, is closer to what you want."
msgstr ""

#. type: menuentry
#: ../../calc.texi:20912
msgid "Specifying Operators::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:20912
msgid "Mapping::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:20912
msgid "Reducing::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:20912
msgid "Nesting and Fixed Points::"
msgstr ""

#. type: subsection
#: ../../calc.texi:20912 ../../calc.texi:21243 ../../calc.texi:21323 ../../calc.texi:21324
#, no-wrap
msgid "Generalized Products"
msgstr ""

#. type: node
#: ../../calc.texi:20914 ../../calc.texi:20915 ../../calc.texi:21065
#, no-wrap
msgid "Specifying Operators"
msgstr ""

#. type: node
#: ../../calc.texi:20914 ../../calc.texi:21065 ../../calc.texi:21066 ../../calc.texi:21162
#, no-wrap
msgid "Mapping"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20926
msgid ""
"Commands in this section (like @kbd{V A}) prompt you to press the key "
"corresponding to the desired operator.  Press @kbd{?} for a partial list of "
"the available operators.  Generally, an operator is any key or sequence of "
"keys that would normally take one or more arguments from the stack and "
"replace them with a result.  For example, @kbd{V A H C} uses the hyperbolic "
"cosine operator, @code{cosh}.  (Since @code{cosh} expects one argument, "
"@kbd{V A H C} requires a vector with a single element as its argument.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20942
msgid ""
"You can press @kbd{x} at the operator prompt to select any algebraic "
"function by name to use as the operator.  This includes functions you have "
"defined yourself using the @kbd{Z F} command.  (@xref{Algebraic "
"Definitions}.)  If you give a name for which no function has been defined, "
"the result is left in symbolic form, as in @samp{f(1, 2, 3)}.  Calc will "
"prompt for the number of arguments the function takes if it can't figure it "
"out on its own (say, because you named a function that is currently "
"undefined).  It is also possible to type a digit key before the function "
"name to specify the number of arguments, e.g., @kbd{V M 3 x f @key{RET}} "
"calls @code{f} with three arguments even if it looks like it ought to have "
"only two.  This technique may be necessary if the function allows a variable "
"number of arguments.  For example, the @kbd{v e} [@code{vexp}] function "
"accepts two or three arguments; if you want to map with the three-argument "
"version, you will have to type @kbd{V M 3 v e}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20953
msgid ""
"It is also possible to apply any formula to a vector by treating that "
"formula as a function.  When prompted for the operator to use, press @kbd{'} "
"(the apostrophe) and type your formula as an algebraic entry.  You will then "
"be prompted for the argument list, which defaults to a list of all variables "
"that appear in the formula, sorted into alphabetic order.  For example, "
"suppose you enter the formula @w{@samp{x + 2y^x}}.  The default argument "
"list would be @samp{(x y)}, which means that if this function is applied to "
"the arguments @samp{[3, 10]} the result will be @samp{3 + 2*10^3}.  (If you "
"plan to use a certain formula in this way often, you might consider defining "
"it as a function with @kbd{Z F}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20960
msgid ""
"Another way to specify the arguments to the formula you enter is with "
"@kbd{$}, @kbd{$$}, and so on.  For example, @kbd{V A ' $$ + 2$^$$} has the "
"same effect as the previous example.  The argument list is automatically "
"taken to be @samp{($$ $)}.  (The order of the arguments may seem backwards, "
"but it is analogous to the way normal algebraic entry interacts with the "
"stack.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20966
msgid ""
"If you press @kbd{$} at the operator prompt, the effect is similar to the "
"apostrophe except that the relevant formula is taken from top-of-stack "
"instead.  The actual vector arguments of the @kbd{V A $} or related command "
"then start at the second-to-top stack position.  You will still be prompted "
"for an argument list."
msgstr ""

#. type: cindex
#: ../../calc.texi:20967
#, no-wrap
msgid "Nameless functions"
msgstr ""

#. type: cindex
#: ../../calc.texi:20968
#, no-wrap
msgid "Generic functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20980
msgid ""
"A function can be written without a name using the notation @samp{<#1 - "
"#2>}, which means ``a function of two arguments that computes the first "
"argument minus the second argument.'' The symbols @samp{#1} and @samp{#2} "
"are placeholders for the arguments.  You can use any names for these "
"placeholders if you wish, by including an argument list followed by a colon: "
"@samp{<x, y : x - y>}.  When you type @kbd{V A ' $$ + 2$^$$ @key{RET}}, Calc "
"builds the nameless function @samp{<#1 + 2 #2^#1>} as the function to map "
"across the vectors.  When you type @kbd{V A ' x + 2y^x @key{RET} @key{RET}}, "
"Calc builds the nameless function @w{@samp{<x, y : x + 2 y^x>}}.  In both "
"cases, Calc also writes the nameless function to the Trail so that you can "
"get it back later if you wish."
msgstr ""

#. type: Plain text
#: ../../calc.texi:20986
msgid ""
"If there is only one argument, you can write @samp{#} in place of "
"@samp{#1}.  (Note that @samp{< >} notation is also used for date forms.  "
"Calc tells that @samp{<@var{stuff}>} is a nameless function by the presence "
"of @samp{#} signs inside @var{stuff}, or by the fact that @var{stuff} begins "
"with a list of variables followed by a colon.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:20994
msgid ""
"You can type a nameless function directly to @kbd{V A '}, or put one on the "
"stack and use it with @w{@kbd{V A $}}.  Calc will not prompt for an argument "
"list in this case, since the nameless function specifies the argument list "
"as well as the function itself.  In @kbd{V A '}, you can omit the @samp{< >} "
"marks if you use @samp{#} notation for the arguments, so that @kbd{V A ' "
"#1+#2 @key{RET}} is the same as @kbd{V A ' <#1+#2> @key{RET}}, which in turn "
"is the same as @kbd{V A ' $$+$ @key{RET}}."
msgstr ""

#. type: cindex
#: ../../calc.texi:20995
#, no-wrap
msgid "Lambda expressions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21007
msgid ""
"@tindex lambda The internal format for @samp{<x, y : x + y>} is "
"@samp{lambda(x, y, x + y)}.  (The word @code{lambda} derives from Lisp "
"notation and the theory of functions.)  The internal format for @samp{<#1 + "
"#2>} is @samp{lambda(ArgA, ArgB, ArgA + ArgB)}.  Note that there is no "
"actual Calc function called @code{lambda}; the whole point is that the "
"@code{lambda} expression is used in its symbolic form, not evaluated for an "
"answer until it is applied to specific arguments by a command like @kbd{V A} "
"or @kbd{V M}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21012
msgid ""
"(Actually, @code{lambda} does have one special property: Its arguments are "
"never evaluated; for example, putting @samp{<(2/3) #>} on the stack will not "
"simplify the @samp{2/3} until the nameless function is actually called.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21015
msgid "@tindex add @tindex sub"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21019
msgid "@tindex mul"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21023
msgid "@tindex div"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21027
msgid "@tindex pow"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21031
msgid "@tindex neg"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21035
msgid "@tindex mod"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21047
msgid ""
"@tindex vconcat As usual, commands like @kbd{V A} have algebraic function "
"name equivalents.  For example, @kbd{V A k g} with an argument of @samp{v} "
"is equivalent to @samp{apply(gcd, v)}.  The first argument specifies the "
"operator name, and is either a variable whose name is the same as the "
"function name, or a nameless function like @samp{<#^3+1>}.  Operators that "
"are normally written as algebraic symbols have the names @code{add}, "
"@code{sub}, @code{mul}, @code{div}, @code{pow}, @code{neg}, @code{mod}, and "
"@code{vconcat}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21058
msgid ""
"@tindex call The @code{call} function builds a function call out of several "
"arguments: @samp{call(gcd, x, y)} is the same as @samp{apply(gcd, [x, y])}, "
"which in turn is the same as @samp{gcd(x, y)}.  The first argument of "
"@code{call}, like the other functions described here, may be either a "
"variable naming a function, or a nameless function (@samp{call(<#1+2#2>, x, "
"y)} is the same as @samp{x + 2y})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21064
msgid ""
"(Experts will notice that it's not quite proper to use a variable to name a "
"function, since the name @code{gcd} corresponds to the Lisp variable "
"@code{var-gcd} but to the Lisp function @code{calcFunc-gcd}.  Calc "
"automatically makes this translation, so you don't have to worry about it.)"
msgstr ""

#. type: node
#: ../../calc.texi:21065 ../../calc.texi:21162 ../../calc.texi:21163 ../../calc.texi:21243
#, no-wrap
msgid "Reducing"
msgstr ""

#. type: kindex
#: ../../calc.texi:21069
#, no-wrap
msgid "v M"
msgstr ""

#. type: kindex
#: ../../calc.texi:21070
#, no-wrap
msgid "V M"
msgstr ""

#. type: pindex
#: ../../calc.texi:21071
#, no-wrap
msgid "calc-map"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21085
msgid ""
"@tindex map The @kbd{V M} (@code{calc-map}) [@code{map}] command applies a "
"given operator elementwise to one or more vectors.  For example, mapping "
"@code{A} [@code{abs}] produces a vector of the absolute values of the "
"elements in the input vector.  Mapping @code{+} pops two vectors from the "
"stack, which must be of equal length, and produces a vector of the pairwise "
"sums of the elements.  If either argument is a non-vector, it is duplicated "
"for each element of the other vector.  For example, @kbd{[1,2,3] 2 V M ^} "
"squares the elements of the specified vector.  With the 2 listed first, it "
"would have computed a vector of powers of two.  Mapping a user-defined "
"function pops as many arguments from the stack as the function requires.  If "
"you give an undefined name, you will be prompted for the number of arguments "
"to use."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21093
msgid ""
"If any argument to @kbd{V M} is a matrix, the operator is normally mapped "
"across all elements of the matrix.  For example, given the matrix @expr{[[1, "
"-2, 3], [-4, 5, -6]]}, @kbd{V M A} takes six absolute values to produce "
"another @texline @math{3\\times2} @infoline 3x2 matrix, @expr{[[1, 2, 3], "
"[4, 5, 6]]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21104
msgid ""
"@tindex mapr The command @kbd{V M _} [@code{mapr}] (i.e., type an underscore "
"at the operator prompt) maps by rows instead.  For example, @kbd{V M _ A} "
"views the above matrix as a vector of two 3-element row vectors.  It "
"produces a new vector which contains the absolute values of those row "
"vectors, namely @expr{[3.74, 8.77]}.  (Recall, the absolute value of a "
"vector is defined as the square root of the sum of the squares of the "
"elements.)  Some operators accept vectors and return new vectors; for "
"example, @kbd{v v} reverses a vector, so @kbd{V M _ v v} would reverse each "
"row of the matrix to get a new matrix, @expr{[[3, -2, 1], [-6, 5, -4]]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21109
msgid ""
"Sometimes a vector of vectors (representing, say, strings, sets, or lists)  "
"happens to look like a matrix.  If so, remember to use @kbd{V M _} if you "
"want to map a function across the whole strings or sets rather than across "
"their individual elements."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21117
msgid ""
"@tindex mapc The command @kbd{V M :} [@code{mapc}] maps by columns.  "
"Basically, it transposes the input matrix, maps by rows, and then, if the "
"result is a matrix, transposes again.  For example, @kbd{V M : A} takes the "
"absolute values of the three columns of the matrix, treating each as a "
"2-vector, and @kbd{V M : v v} reverses the columns to get the matrix "
"@expr{[[-4, 5, -6], [1, -2, 3]]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21122
msgid ""
"(The symbols @kbd{_} and @kbd{:} were chosen because they had row-like and "
"column-like appearances, and were not already taken by useful operators.  "
"Also, they appear shifted on most keyboards so they are easy to type after "
"@kbd{V M}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21129
msgid ""
"The @kbd{_} and @kbd{:} modifiers have no effect on arguments that are not "
"matrices (so if none of the arguments are matrices, they have no effect at "
"all).  If some of the arguments are matrices and others are plain numbers, "
"the plain numbers are held constant for all rows of the matrix (so that "
"@kbd{2 V M _ ^} squares every row of a matrix; squaring a vector takes a dot "
"product of the vector with itself)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21134
msgid ""
"If some of the arguments are vectors with the same lengths as the rows (for "
"@kbd{V M _}) or columns (for @kbd{V M :}) of the matrix arguments, those "
"vectors are also held constant for every row or column."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21145
msgid ""
"Sometimes it is useful to specify another mapping command as the operator to "
"use with @kbd{V M}.  For example, @kbd{V M _ V A +} applies @kbd{V A +} to "
"each row of the input matrix, which in turn adds the two values on that "
"row.  If you give another vector-operator command as the operator for @kbd{V "
"M}, it automatically uses map-by-rows mode if you don't specify otherwise; "
"thus @kbd{V M V A +} is equivalent to @kbd{V M _ V A +}.  (If you really "
"want to map-by-elements another mapping command, you can use a triple-nested "
"mapping command: @kbd{V M V M V A +} means to map @kbd{V M V A +} over the "
"rows of the matrix; in turn, @kbd{V A +} is mapped over the elements of each "
"row.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21156
msgid ""
"@tindex mapa @tindex mapd Previous versions of Calc had ``map across'' and "
"``map down'' modes that are now considered obsolete; the old ``map across'' "
"is now simply @kbd{V M V A}, and ``map down'' is now @kbd{V M : V A}.  The "
"algebraic functions @code{mapa} and @code{mapd} are still supported, "
"though.  Note also that, while the old mapping modes were persistent (once "
"you set the mode, it would apply to later mapping commands until you reset "
"it), the new @kbd{:} and @kbd{_} modifiers apply only to the current mapping "
"command.  The default @kbd{V M} always means map-by-elements."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21161
msgid ""
"@xref{Algebraic Manipulation}, for the @kbd{a M} command, which is like "
"@kbd{V M} but for equations and inequalities instead of vectors.  "
"@xref{Storing Variables}, for the @kbd{s m} command which modifies a "
"variable's stored value using a @kbd{V M}-like operator."
msgstr ""

#. type: node
#: ../../calc.texi:21162 ../../calc.texi:21243 ../../calc.texi:21244 ../../calc.texi:21323
#, no-wrap
msgid "Nesting and Fixed Points"
msgstr ""

#. type: kindex
#: ../../calc.texi:21166
#, no-wrap
msgid "v R"
msgstr ""

#. type: kindex
#: ../../calc.texi:21167
#, no-wrap
msgid "V R"
msgstr ""

#. type: pindex
#: ../../calc.texi:21168
#, no-wrap
msgid "calc-reduce"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21178
msgid ""
"@tindex reduce The @kbd{V R} (@code{calc-reduce}) [@code{reduce}] command "
"applies a given binary operator across all the elements of a vector.  A "
"binary operator is a function such as @code{+} or @code{max} which takes two "
"arguments.  For example, reducing @code{+} over a vector computes the sum of "
"the elements of the vector.  Reducing @code{-} computes the first element "
"minus each of the remaining elements.  Reducing @code{max} computes the "
"maximum element and so on.  In general, reducing @code{f} over the vector "
"@samp{[a, b, c, d]} produces @samp{f(f(f(a, b), c), d)}."
msgstr ""

#. type: kindex
#: ../../calc.texi:21179
#, no-wrap
msgid "I v R"
msgstr ""

#. type: kindex
#: ../../calc.texi:21180
#, no-wrap
msgid "I V R"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21188
msgid ""
"@tindex rreduce The @kbd{I V R} [@code{rreduce}] command is similar to "
"@kbd{V R} except that works from right to left through the vector.  For "
"example, plain @kbd{V R -} on the vector @samp{[a, b, c, d]} produces "
"@samp{a - b - c - d} but @kbd{I V R -} on the same vector produces @samp{a - "
"(b - (c - d))}, or @samp{a - b + c - d}.  This ``alternating sum'' occurs "
"frequently in power series expansions."
msgstr ""

#. type: kindex
#: ../../calc.texi:21189
#, no-wrap
msgid "v U"
msgstr ""

#. type: kindex
#: ../../calc.texi:21190
#, no-wrap
msgid "V U"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21198
msgid ""
"@tindex accum The @kbd{V U} (@code{calc-accumulate}) [@code{accum}] command "
"does an accumulation operation.  Here Calc does the corresponding reduction "
"operation, but instead of producing only the final result, it produces a "
"vector of all the intermediate results.  Accumulating @code{+} over the "
"vector @samp{[a, b, c, d]} produces the vector @samp{[a, a + b, a + b + c, a "
"+ b + c + d]}."
msgstr ""

#. type: kindex
#: ../../calc.texi:21199
#, no-wrap
msgid "I v U"
msgstr ""

#. type: kindex
#: ../../calc.texi:21200
#, no-wrap
msgid "I V U"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21205
msgid ""
"@tindex raccum The @kbd{I V U} [@code{raccum}] command does a right-to-left "
"accumulation.  For example, @kbd{I V U -} on the vector @samp{[a, b, c, d]} "
"produces the vector @samp{[a - b + c - d, b - c + d, c - d, d]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21219
msgid ""
"@tindex reducea @tindex rreducea @tindex reduced @tindex rreduced As for "
"@kbd{V M}, @kbd{V R} normally reduces a matrix elementwise.  For example, "
"given the matrix @expr{[[a, b, c], [d, e, f]]}, @kbd{V R +} will compute "
"@expr{a + b + c + d + e + f}.  You can type @kbd{V R _} or @kbd{V R :} to "
"modify this behavior.  The @kbd{V R _} [@code{reducea}] command reduces "
"``across'' the matrix; it reduces each row of the matrix as a vector, then "
"collects the results.  Thus @kbd{V R _ +} of this matrix would produce "
"@expr{[a + b + c, d + e + f]}.  Similarly, @kbd{V R :} [@code{reduced}] "
"reduces down; @kbd{V R : +} would produce @expr{[a + d, b + e, c + f]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21229
msgid ""
"@tindex reducer @tindex rreducer There is a third ``by rows'' mode for "
"reduction that is occasionally useful; @kbd{V R =} [@code{reducer}] simply "
"reduces the operator over the rows of the matrix themselves.  Thus @kbd{V R "
"= +} on the above matrix would get the same result as @kbd{V R : +}, since "
"adding two row vectors is equivalent to adding their elements.  But @kbd{V R "
"= *} would multiply the two rows (to get a single number, their dot "
"product), while @kbd{V R : *} would produce a vector of the products of the "
"columns."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21232
msgid ""
"These three matrix reduction modes work with @kbd{V R} and @kbd{I V R}, but "
"they are not currently supported with @kbd{V U} or @kbd{I V U}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21237
msgid ""
"@tindex reducec @tindex rreducec The obsolete reduce-by-columns function, "
"@code{reducec}, is still supported but there is no way to get it through the "
"@kbd{V R} command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21242
msgid ""
"The commands @kbd{C-x * :} and @kbd{C-x * _} are equivalent to typing "
"@kbd{C-x * r} to grab a rectangle of data into Calc, and then typing @kbd{V "
"R : +} or @kbd{V R _ +}, respectively, to sum the columns or rows of the "
"matrix.  @xref{Grabbing From Buffers}."
msgstr ""

#. type: kindex
#: ../../calc.texi:21247
#, no-wrap
msgid "H v R"
msgstr ""

#. type: kindex
#: ../../calc.texi:21248
#, no-wrap
msgid "H V R"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21257
msgid ""
"@tindex nest The @kbd{H V R} [@code{nest}] command applies a function to a "
"given argument repeatedly.  It takes two values, @samp{a} and @samp{n}, from "
"the stack, where @samp{n} must be an integer.  It then applies the function "
"nested @samp{n} times; if the function is @samp{f} and @samp{n} is 3, the "
"result is @samp{f(f(f(a)))}.  The number @samp{n} may be negative if Calc "
"knows an inverse for the function @samp{f}; for example, @samp{nest(sin, a, "
"-2)} returns @samp{arcsin(arcsin(a))}."
msgstr ""

#. type: kindex
#: ../../calc.texi:21258
#, no-wrap
msgid "H v U"
msgstr ""

#. type: kindex
#: ../../calc.texi:21259
#, no-wrap
msgid "H V U"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21266
msgid ""
"@tindex anest The @kbd{H V U} [@code{anest}] command is an accumulating "
"version of @code{nest}: It returns a vector of @samp{n+1} values, e.g., "
"@samp{[a, f(a), f(f(a)), f(f(f(a)))]}.  If @samp{n} is negative and @samp{F} "
"is the inverse of @samp{f}, then the result is of the form @samp{[a, F(a), "
"F(F(a)), F(F(F(a)))]}."
msgstr ""

#. type: kindex
#: ../../calc.texi:21267
#, no-wrap
msgid "H I v R"
msgstr ""

#. type: kindex
#: ../../calc.texi:21268
#, no-wrap
msgid "H I V R"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21270
msgid "@tindex fixp"
msgstr ""

#. type: cindex
#: ../../calc.texi:21270
#, no-wrap
msgid "Fixed points"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21275
msgid ""
"The @kbd{H I V R} [@code{fixp}] command is like @kbd{H V R}, except that it "
"takes only an @samp{a} value from the stack; the function is applied until "
"it reaches a ``fixed point,'' i.e., until the result no longer changes."
msgstr ""

#. type: kindex
#: ../../calc.texi:21276
#, no-wrap
msgid "H I v U"
msgstr ""

#. type: kindex
#: ../../calc.texi:21277
#, no-wrap
msgid "H I V U"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21283
msgid ""
"@tindex afixp The @kbd{H I V U} [@code{afixp}] command is an accumulating "
"@code{fixp}.  The first element of the return vector will be the initial "
"value @samp{a}; the last element will be the final result that would have "
"been returned by @code{fixp}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21290
msgid ""
"For example, 0.739085 is a fixed point of the cosine function (in radians): "
"@samp{cos(0.739085) = 0.739085}.  You can find this value by putting, say, "
"1.0 on the stack and typing @kbd{H I V U C}.  (We use the accumulating "
"version so we can see the intermediate results: @samp{[1, 0.540302, "
"0.857553, 0.65329, ...]}.  With a precision of six, this command will take "
"36 steps to converge to 0.739085.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21298
msgid ""
"Newton's method for finding roots is a classic example of iteration to a "
"fixed point.  To find the square root of five starting with an initial "
"guess, Newton's method would look for a fixed point of the function @samp{(x "
"+ 5/x) / 2}.  Putting a guess of 1 on the stack and typing @kbd{H I V R ' ($ "
"+ 5/$)/2 @key{RET}} quickly yields the result 2.23607.  This is equivalent "
"to using the @kbd{a R} (@code{calc-find-root})  command to find a root of "
"the equation @samp{x^2 = 5}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21307
msgid ""
"These examples used numbers for @samp{a} values.  Calc keeps applying the "
"function until two successive results are equal to within the current "
"precision.  For complex numbers, both the real parts and the imaginary parts "
"must be equal to within the current precision.  If @samp{a} is a formula "
"(say, a variable name), then the function is applied until two successive "
"results are exactly the same formula.  It is up to you to ensure that the "
"function will eventually converge; if it doesn't, you may have to press "
"@kbd{C-g} to stop the Calculator."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21317
msgid ""
"The algebraic @code{fixp} function takes two optional arguments, @samp{n} "
"and @samp{tol}.  The first is the maximum number of steps to be allowed, and "
"must be either an integer or the symbol @samp{inf} (infinity, the default).  "
"The second is a convergence tolerance.  If a tolerance is specified, all "
"results during the calculation must be numbers, not formulas, and the "
"iteration stops when the magnitude of the difference between two successive "
"results is less than or equal to the tolerance.  (This implies that a "
"tolerance of zero iterates until the results are exactly equal.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21322
msgid ""
"Putting it all together, @samp{fixp(<(# + A/#)/2>, B, 20, 1e-10)} computes "
"the square root of @samp{A} given the initial guess @samp{B}, stopping when "
"the result is correct within the specified tolerance, or when 20 steps have "
"been taken, whichever is sooner."
msgstr ""

#. type: kindex
#: ../../calc.texi:21326
#, no-wrap
msgid "v O"
msgstr ""

#. type: kindex
#: ../../calc.texi:21327
#, no-wrap
msgid "V O"
msgstr ""

#. type: pindex
#: ../../calc.texi:21328
#, no-wrap
msgid "calc-outer-product"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21337
msgid ""
"@tindex outer The @kbd{V O} (@code{calc-outer-product}) [@code{outer}] "
"command applies a given binary operator to all possible pairs of elements "
"from two vectors, to produce a matrix.  For example, @kbd{V O *} with "
"@samp{[a, b]} and @samp{[x, y, z]} on the stack produces a multiplication "
"table: @samp{[[a x, a y, a z], [b x, b y, b z]]}.  Element @var{r},@var{c} "
"of the result matrix is obtained by applying the operator to element @var{r} "
"of the lefthand vector and element @var{c} of the righthand vector."
msgstr ""

#. type: kindex
#: ../../calc.texi:21338
#, no-wrap
msgid "v I"
msgstr ""

#. type: kindex
#: ../../calc.texi:21339
#, no-wrap
msgid "V I"
msgstr ""

#. type: pindex
#: ../../calc.texi:21340
#, no-wrap
msgid "calc-inner-product"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21353
msgid ""
"@tindex inner The @kbd{V I} (@code{calc-inner-product}) [@code{inner}] "
"command computes the generalized inner product of two vectors or matrices, "
"given a ``multiplicative'' operator and an ``additive'' operator.  These can "
"each actually be any binary operators; if they are @samp{*} and @samp{+}, "
"respectively, the result is a standard matrix multiplication.  Element "
"@var{r},@var{c} of the result matrix is obtained by mapping the "
"multiplicative operator across row @var{r} of the lefthand matrix and column "
"@var{c} of the righthand matrix, and then reducing with the additive "
"operator.  Just as for the standard @kbd{*} command, this can also do a "
"vector-matrix or matrix-vector inner product, or a vector-vector generalized "
"dot product."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21359
msgid ""
"Since @kbd{V I} requires two operators, it prompts twice.  In each case, you "
"can use any of the usual methods for entering the operator.  If you use "
"@kbd{$} twice to take both operator formulas from the stack, the first "
"(multiplicative) operator is taken from the top of the stack and the second "
"(additive) operator is taken from second-to-top."
msgstr ""

#. type: section
#: ../../calc.texi:21361
#, no-wrap
msgid "Vector and Matrix Display Formats"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21370
msgid ""
"Commands for controlling vector and matrix display use the @kbd{v} prefix "
"instead of the usual @kbd{d} prefix.  But they are display modes; in "
"particular, they are influenced by the @kbd{I} and @kbd{H} prefix keys in "
"the same way (@pxref{Display Modes}).  Matrix display is also influenced by "
"the @kbd{d O} (@code{calc-flat-language}) mode; @pxref{Normal Language "
"Modes}."
msgstr ""

#. type: kindex
#: ../../calc.texi:21371
#, no-wrap
msgid "v <"
msgstr ""

#. type: kindex
#: ../../calc.texi:21372
#, no-wrap
msgid "V <"
msgstr ""

#. type: pindex
#: ../../calc.texi:21373
#, no-wrap
msgid "calc-matrix-left-justify"
msgstr ""

#. type: kindex
#: ../../calc.texi:21374
#, no-wrap
msgid "v ="
msgstr ""

#. type: kindex
#: ../../calc.texi:21375
#, no-wrap
msgid "V ="
msgstr ""

#. type: pindex
#: ../../calc.texi:21376
#, no-wrap
msgid "calc-matrix-center-justify"
msgstr ""

#. type: kindex
#: ../../calc.texi:21377
#, no-wrap
msgid "v >"
msgstr ""

#. type: kindex
#: ../../calc.texi:21378
#, no-wrap
msgid "V >"
msgstr ""

#. type: pindex
#: ../../calc.texi:21379
#, no-wrap
msgid "calc-matrix-right-justify"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21384
msgid ""
"The commands @kbd{v <} (@code{calc-matrix-left-justify}), @kbd{v >} "
"(@code{calc-matrix-right-justify}), and @w{@kbd{v =}} "
"(@code{calc-matrix-center-justify}) control whether matrix elements are "
"justified to the left, right, or center of their columns."
msgstr ""

#. type: kindex
#: ../../calc.texi:21385
#, no-wrap
msgid "v ["
msgstr ""

#. type: kindex
#: ../../calc.texi:21386
#, no-wrap
msgid "V ["
msgstr ""

#. type: pindex
#: ../../calc.texi:21387
#, no-wrap
msgid "calc-vector-brackets"
msgstr ""

#. type: kindex
#: ../../calc.texi:21388
#, no-wrap
msgid "v @{"
msgstr ""

#. type: kindex
#: ../../calc.texi:21389
#, no-wrap
msgid "V @{"
msgstr ""

#. type: pindex
#: ../../calc.texi:21390
#, no-wrap
msgid "calc-vector-braces"
msgstr ""

#. type: kindex
#: ../../calc.texi:21391
#, no-wrap
msgid "v ("
msgstr ""

#. type: kindex
#: ../../calc.texi:21392
#, no-wrap
msgid "V ("
msgstr ""

#. type: pindex
#: ../../calc.texi:21393
#, no-wrap
msgid "calc-vector-parens"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21404
msgid ""
"The @kbd{v [} (@code{calc-vector-brackets}) command turns the square "
"brackets that surround vectors and matrices displayed in the stack on and "
"off.  The @kbd{v @{} (@code{calc-vector-braces}) and @kbd{v (} "
"(@code{calc-vector-parens}) commands use curly braces or parentheses, "
"respectively, instead of square brackets.  For example, @kbd{v @{} might be "
"used in preparation for yanking a matrix into a buffer running Mathematica.  "
"(In fact, the Mathematica language mode uses this mode; @pxref{Mathematica "
"Language Mode}.)  Note that, regardless of the display mode, either brackets "
"or braces may be used to enter vectors, and parentheses may never be used "
"for this purpose."
msgstr ""

#. type: kindex
#: ../../calc.texi:21405
#, no-wrap
msgid "V ]"
msgstr ""

#. type: kindex
#: ../../calc.texi:21406
#, no-wrap
msgid "v ]"
msgstr ""

#. type: kindex
#: ../../calc.texi:21407
#, no-wrap
msgid "V )"
msgstr ""

#. type: kindex
#: ../../calc.texi:21408
#, no-wrap
msgid "v )"
msgstr ""

#. type: kindex
#: ../../calc.texi:21409
#, no-wrap
msgid "V @}"
msgstr ""

#. type: kindex
#: ../../calc.texi:21410
#, no-wrap
msgid "v @}"
msgstr ""

#. type: pindex
#: ../../calc.texi:21411
#, no-wrap
msgid "calc-matrix-brackets"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21421
msgid ""
"The @kbd{v ]} (@code{calc-matrix-brackets}) command controls the ``big'' "
"style display of matrices, for matrices which have more than one row.  It "
"prompts for a string of code letters; currently implemented letters are "
"@code{R}, which enables brackets on each row of the matrix; @code{O}, which "
"enables outer brackets in opposite corners of the matrix; and @code{C}, "
"which enables commas or semicolons at the ends of all rows but the last.  "
"The default format is @samp{RO}.  (Before Calc 2.00, the format was fixed at "
"@samp{ROC}.)  Here are some example matrices:"
msgstr ""

#. type: group
#: ../../calc.texi:21427
#, no-wrap
msgid ""
"[ [ 123,  0,   0  ]       [ [ 123,  0,   0  ],\n"
"  [  0,  123,  0  ]         [  0,  123,  0  ],\n"
"  [  0,   0,  123 ] ]       [  0,   0,  123 ] ]\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:21429
#, no-wrap
msgid ""
"         RO                        ROC\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:21438
#, no-wrap
msgid ""
"  [ 123,  0,   0            [ 123,  0,   0 ;\n"
"     0,  123,  0               0,  123,  0 ;\n"
"     0,   0,  123 ]            0,   0,  123 ]\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:21440
#, no-wrap
msgid ""
"          O                        OC\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:21449
#, no-wrap
msgid ""
"  [ 123,  0,   0  ]           123,  0,   0\n"
"  [  0,  123,  0  ]            0,  123,  0\n"
"  [  0,   0,  123 ]            0,   0,  123\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:21451
#, no-wrap
msgid "          R                       @r{blank}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21458
msgid ""
"Note that of the formats shown here, @samp{RO}, @samp{ROC}, and @samp{OC} "
"are all recognized as matrices during reading, while the others are useful "
"for display only."
msgstr ""

#. type: kindex
#: ../../calc.texi:21459
#, no-wrap
msgid "v ,"
msgstr ""

#. type: kindex
#: ../../calc.texi:21460
#, no-wrap
msgid "V ,"
msgstr ""

#. type: pindex
#: ../../calc.texi:21461
#, no-wrap
msgid "calc-vector-commas"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21464
msgid ""
"The @kbd{v ,} (@code{calc-vector-commas}) command turns commas on and off in "
"vector and matrix display."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21474
msgid ""
"In vectors of length one, and in all vectors when commas have been turned "
"off, Calc adds extra parentheses around formulas that might otherwise be "
"ambiguous.  For example, @samp{[a b]} could be a vector of the one formula "
"@samp{a b}, or it could be a vector of two variables with commas turned "
"off.  Calc will display the former case as @samp{[(a b)]}.  You can disable "
"these extra parentheses (to make the output less cluttered at the expense of "
"allowing some ambiguity) by adding the letter @code{P} to the control string "
"you give to @kbd{v ]} (as described above)."
msgstr ""

#. type: kindex
#: ../../calc.texi:21475
#, no-wrap
msgid "v ."
msgstr ""

#. type: kindex
#: ../../calc.texi:21476
#, no-wrap
msgid "V ."
msgstr ""

#. type: pindex
#: ../../calc.texi:21477
#, no-wrap
msgid "calc-full-vectors"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21485
msgid ""
"The @kbd{v .} (@code{calc-full-vectors}) command turns abbreviated display "
"of long vectors on and off.  In this mode, vectors of six or more elements, "
"or matrices of six or more rows or columns, will be displayed in an "
"abbreviated form that displays only the first three elements and the last "
"element: @samp{[a, b, c, ..., z]}.  When very large vectors are involved "
"this will substantially improve Calc's display speed."
msgstr ""

#. type: kindex
#: ../../calc.texi:21486
#, no-wrap
msgid "t ."
msgstr ""

#. type: pindex
#: ../../calc.texi:21487
#, no-wrap
msgid "calc-full-trail-vectors"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21496
msgid ""
"The @kbd{t .} (@code{calc-full-trail-vectors}) command controls a similar "
"mode for recording vectors in the Trail.  If you turn on this mode, vectors "
"of six or more elements and matrices of six or more rows or columns will be "
"abbreviated when they are put in the Trail.  The @kbd{t y} "
"(@code{calc-trail-yank}) command will be unable to recover those vectors.  "
"If you are working with very large vectors, this mode will improve the speed "
"of all operations that involve the trail."
msgstr ""

#. type: kindex
#: ../../calc.texi:21497
#, no-wrap
msgid "v /"
msgstr ""

#. type: kindex
#: ../../calc.texi:21498
#, no-wrap
msgid "V /"
msgstr ""

#. type: pindex
#: ../../calc.texi:21499
#, no-wrap
msgid "calc-break-vectors"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21506
msgid ""
"The @kbd{v /} (@code{calc-break-vectors}) command turns multi-line vector "
"display on and off.  Normally, matrices are displayed with one row per line "
"but all other types of vectors are displayed in a single line.  This mode "
"causes all vectors, whether matrices or not, to be displayed with a single "
"element per line.  Sub-vectors within the vectors will still use the normal "
"linear form."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21517
msgid ""
"This section covers the Calc features that help you work with algebraic "
"formulas.  First, the general sub-formula selection mechanism is described; "
"this works in conjunction with any Calc commands.  Then, commands for "
"specific algebraic operations are described.  Finally, the flexible "
"@dfn{rewrite rule} mechanism is discussed."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21521
msgid ""
"The algebraic commands use the @kbd{a} key prefix; selection commands use "
"the @kbd{j} (for ``just a letter that wasn't used for anything else'') "
"prefix."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21524
msgid ""
"@xref{Editing Stack Entries}, to see how to manipulate formulas using "
"regular Emacs editing commands."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21532
msgid ""
"When doing algebraic work, you may find several of the Calculator's modes to "
"be helpful, including Algebraic Simplification mode (@kbd{m A})  or "
"No-Simplification mode (@kbd{m O}), Algebraic entry mode (@kbd{m a}), "
"Fraction mode (@kbd{m f}), and Symbolic mode (@kbd{m s}).  @xref{Mode "
"Settings}, for discussions of these modes.  You may also wish to select Big "
"display mode (@kbd{d B}).  @xref{Normal Language Modes}."
msgstr ""

#. type: menuentry
#: ../../calc.texi:21545
msgid "Selecting Subformulas::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:21545
msgid "Algebraic Manipulation::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:21545
msgid "Simplifying Formulas::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:21545
msgid "Polynomials::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:21545
msgid "Calculus::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:21545
msgid "Solving Equations::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:21545
msgid "Numerical Solutions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:21545
msgid "Curve Fitting::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:21545
msgid "Summations::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:21545
msgid "Logical Operations::"
msgstr ""

#. type: node
#: ../../calc.texi:21547 ../../calc.texi:21573 ../../calc.texi:21734 ../../calc.texi:21823 ../../calc.texi:21854 ../../calc.texi:22011 ../../calc.texi:22260
#, no-wrap
msgid "Selecting Subformulas"
msgstr ""

#. type: node
#: ../../calc.texi:21547 ../../calc.texi:22260 ../../calc.texi:22261 ../../calc.texi:22424
#, no-wrap
msgid "Algebraic Manipulation"
msgstr ""

#. type: section
#: ../../calc.texi:21548
#, no-wrap
msgid "Selecting Sub-Formulas"
msgstr ""

#. type: cindex
#: ../../calc.texi:21551
#, no-wrap
msgid "Selections"
msgstr ""

#. type: cindex
#: ../../calc.texi:21552
#, no-wrap
msgid "Sub-formulas"
msgstr ""

#. type: cindex
#: ../../calc.texi:21553
#, no-wrap
msgid "Parts of formulas"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21560
msgid ""
"When working with an algebraic formula it is often necessary to manipulate a "
"portion of the formula rather than the formula as a whole.  Calc allows you "
"to ``select'' a portion of any formula on the stack.  Commands which would "
"normally operate on that stack entry will now operate only on the "
"sub-formula, leaving the surrounding part of the stack entry alone."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21564
msgid ""
"One common non-algebraic use for selection involves vectors.  To work on one "
"element of a vector in-place, simply select that element as a "
"``sub-formula'' of the vector."
msgstr ""

#. type: menuentry
#: ../../calc.texi:21571
msgid "Making Selections::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:21571
msgid "Changing Selections::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:21571
msgid "Displaying Selections::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:21571
msgid "Operating on Selections::"
msgstr ""

#. type: node
#: ../../calc.texi:21571 ../../calc.texi:21854 ../../calc.texi:22011
#, no-wrap
msgid "Rearranging with Selections"
msgstr ""

#. type: node
#: ../../calc.texi:21573 ../../calc.texi:21574 ../../calc.texi:21734
#, no-wrap
msgid "Making Selections"
msgstr ""

#. type: node
#: ../../calc.texi:21573 ../../calc.texi:21734 ../../calc.texi:21735 ../../calc.texi:21823
#, no-wrap
msgid "Changing Selections"
msgstr ""

#. type: kindex
#: ../../calc.texi:21577
#, no-wrap
msgid "j s"
msgstr ""

#. type: pindex
#: ../../calc.texi:21578
#, no-wrap
msgid "calc-select-here"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21586
msgid ""
"To select a sub-formula, move the Emacs cursor to any character in that "
"sub-formula, and press @w{@kbd{j s}} (@code{calc-select-here}).  Calc will "
"highlight the smallest portion of the formula that contains that character.  "
"By default the sub-formula is highlighted by blanking out all of the rest of "
"the formula with dots.  Selection works in any display mode but is perhaps "
"easiest in Big mode (@kbd{d B}).  Suppose you enter the following formula:"
msgstr ""

#. type: group
#: ../../calc.texi:21593
#, no-wrap
msgid ""
"           3    ___\n"
"    (a + b)  + V c\n"
"1:  ---------------\n"
"        2 x + 1\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21600
msgid ""
"(by typing @kbd{' ((a+b)^3 + sqrt(c)) / (2x+1)}).  If you move the cursor to "
"the letter @samp{b} and press @w{@kbd{j s}}, the display changes to"
msgstr ""

#. type: group
#: ../../calc.texi:21607
#, no-wrap
msgid ""
"           .    ...\n"
"    .. . b.  . . .\n"
"1*  ...............\n"
"        . . . .\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21621
msgid ""
"Every character not part of the sub-formula @samp{b} has been changed to a "
"dot. (If the customizable variable "
"@code{calc-highlight-selections-with-faces} is non-@code{nil}, then the "
"characters not part of the sub-formula are de-emphasized by using a less "
"noticeable face instead of using dots. @pxref{Displaying Selections}.)  The "
"@samp{*} next to the line number is to remind you that the formula has a "
"portion of it selected.  (In this case, it's very obvious, but it might not "
"always be.  If Embedded mode is enabled, the word @samp{Sel} also appears in "
"the mode line because the stack may not be visible.  @pxref{Embedded Mode}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21624
msgid ""
"If you had instead placed the cursor on the parenthesis immediately to the "
"right of the @samp{b}, the selection would have been:"
msgstr ""

#. type: group
#: ../../calc.texi:21631
#, no-wrap
msgid ""
"           .    ...\n"
"    (a + b)  . . .\n"
"1*  ...............\n"
"        . . . .\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21639
msgid ""
"The portion selected is always large enough to be considered a complete "
"formula all by itself, so selecting the parenthesis selects the whole "
"formula that it encloses.  Putting the cursor on the @samp{+} sign would "
"have had the same effect."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21644
msgid ""
"(Strictly speaking, the Emacs cursor is really the manifestation of the "
"Emacs ``point,'' which is a position @emph{between} two characters in the "
"buffer.  So purists would say that Calc selects the smallest sub-formula "
"which contains the character to the right of ``point.'')"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21650
msgid ""
"If you supply a numeric prefix argument @var{n}, the selection is expanded "
"to the @var{n}th enclosing sub-formula.  Thus, positioning the cursor on the "
"@samp{b} and typing @kbd{C-u 1 j s} will select @samp{a + b}; typing "
"@kbd{C-u 2 j s} will select @samp{(a + b)^3}, and so on."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21653
msgid ""
"If the cursor is not on any part of the formula, or if you give a numeric "
"prefix that is too large, the entire formula is selected."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21659
msgid ""
"If the cursor is on the @samp{.} line that marks the top of the stack (i.e., "
"its normal ``rest position''), this command selects the entire formula at "
"stack level 1.  Most selection commands similarly operate on the formula at "
"the top of the stack if you haven't positioned the cursor on any stack "
"entry."
msgstr ""

#. type: kindex
#: ../../calc.texi:21660
#, no-wrap
msgid "j a"
msgstr ""

#. type: pindex
#: ../../calc.texi:21661
#, no-wrap
msgid "calc-select-additional"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21668
msgid ""
"The @kbd{j a} (@code{calc-select-additional}) command enlarges the current "
"selection to encompass the cursor.  To select the smallest sub-formula "
"defined by two different points, move to the first and press @kbd{j s}, then "
"move to the other and press @kbd{j a}.  This is roughly analogous to using "
"@kbd{C-@@} (@code{set-mark-command}) to select the two ends of a region of "
"text during normal Emacs editing."
msgstr ""

#. type: kindex
#: ../../calc.texi:21669
#, no-wrap
msgid "j o"
msgstr ""

#. type: pindex
#: ../../calc.texi:21670
#, no-wrap
msgid "calc-select-once"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21676
msgid ""
"The @kbd{j o} (@code{calc-select-once}) command selects a formula in exactly "
"the same way as @kbd{j s}, except that the selection will last only as long "
"as the next command that uses it.  For example, @kbd{j o 1 +} is a handy way "
"to add one to the sub-formula indicated by the cursor."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21681
msgid ""
"(A somewhat more precise definition: The @kbd{j o} command sets a flag such "
"that the next command involving selected stack entries will clear the "
"selections on those stack entries afterwards.  All other selection commands "
"except @kbd{j a} and @kbd{j O} clear this flag.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:21682
#, no-wrap
msgid "j S"
msgstr ""

#. type: kindex
#: ../../calc.texi:21683
#, no-wrap
msgid "j O"
msgstr ""

#. type: pindex
#: ../../calc.texi:21684
#, no-wrap
msgid "calc-select-here-maybe"
msgstr ""

#. type: pindex
#: ../../calc.texi:21685
#, no-wrap
msgid "calc-select-once-maybe"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21694
msgid ""
"The @kbd{j S} (@code{calc-select-here-maybe}) and @kbd{j O} "
"(@code{calc-select-once-maybe}) commands are equivalent to @kbd{j s} and "
"@kbd{j o}, respectively, except that if the formula already has a selection "
"they have no effect.  This is analogous to the behavior of some commands "
"such as @kbd{j r} (@code{calc-rewrite-selection}; @pxref{Selections with "
"Rewrite Rules}) and is mainly intended to be used in keyboard macros that "
"implement your own selection-oriented commands."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21700
msgid ""
"Selection of sub-formulas normally treats associative terms like @samp{a + b "
"- c + d} and @samp{x * y * z} as single levels of the formula.  If you place "
"the cursor anywhere inside @samp{a + b - c + d} except on one of the "
"variable names and use @kbd{j s}, you will select the entire four-term sum."
msgstr ""

#. type: kindex
#: ../../calc.texi:21701
#, no-wrap
msgid "j b"
msgstr ""

#. type: pindex
#: ../../calc.texi:21702
#, no-wrap
msgid "calc-break-selections"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21716
msgid ""
"The @kbd{j b} (@code{calc-break-selections}) command controls a mode in "
"which the ``deep structure'' of these associative formulas shows through.  "
"Calc actually stores the above formulas as @samp{((a + b) - c) + d} and "
"@samp{x * (y * z)}.  (Note that for certain obscure reasons, by default Calc "
"treats multiplication as right-associative.)  Once you have enabled @kbd{j "
"b} mode, selecting with the cursor on the @samp{-} sign would only select "
"the @samp{a + b - c} portion, which makes sense when the deep structure of "
"the sum is considered.  There is no way to select the @samp{b - c + d} "
"portion; although this might initially look like just as legitimate a "
"sub-formula as @samp{a + b - c}, the deep structure shows that it isn't.  "
"The @kbd{d U} command can be used to view the deep structure of any formula "
"(@pxref{Normal Language Modes})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21720
msgid ""
"When @kbd{j b} mode has not been enabled, the deep structure is generally "
"hidden by the selection commands---what you see is what you get."
msgstr ""

#. type: kindex
#: ../../calc.texi:21721
#, no-wrap
msgid "j u"
msgstr ""

#. type: pindex
#: ../../calc.texi:21722
#, no-wrap
msgid "calc-unselect"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21728
msgid ""
"The @kbd{j u} (@code{calc-unselect}) command unselects the formula that the "
"cursor is on.  If there was no selection in the formula, this command has no "
"effect.  With a numeric prefix argument, it unselects the @var{n}th stack "
"element rather than using the cursor position."
msgstr ""

#. type: kindex
#: ../../calc.texi:21729
#, no-wrap
msgid "j c"
msgstr ""

#. type: pindex
#: ../../calc.texi:21730
#, no-wrap
msgid "calc-clear-selections"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21733
msgid ""
"The @kbd{j c} (@code{calc-clear-selections}) command unselects all stack "
"elements."
msgstr ""

#. type: node
#: ../../calc.texi:21734 ../../calc.texi:21823 ../../calc.texi:21824 ../../calc.texi:21854
#, no-wrap
msgid "Displaying Selections"
msgstr ""

#. type: kindex
#: ../../calc.texi:21738
#, no-wrap
msgid "j m"
msgstr ""

#. type: pindex
#: ../../calc.texi:21739
#, no-wrap
msgid "calc-select-more"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21743
msgid ""
"Once you have selected a sub-formula, you can expand it using the @w{@kbd{j "
"m}} (@code{calc-select-more}) command.  If @samp{a + b} is selected, "
"pressing @w{@kbd{j m}} repeatedly works as follows:"
msgstr ""

#. type: group
#: ../../calc.texi:21750
#, no-wrap
msgid ""
"           3    ...                3    ___                3    ___\n"
"    (a + b)  . . .          (a + b)  + V c          (a + b)  + V c\n"
"1*  ...............     1*  ...............     1*  ---------------\n"
"        . . . .                 . . . .                 2 x + 1\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21757
msgid ""
"In the last example, the entire formula is selected.  This is roughly the "
"same as having no selection at all, but because there are subtle differences "
"the @samp{*} character is still there on the line number."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21763
msgid ""
"With a numeric prefix argument @var{n}, @kbd{j m} expands @var{n} times (or "
"until the entire formula is selected).  Note that @kbd{j s} with argument "
"@var{n} is equivalent to plain @kbd{j s} followed by @kbd{j m} with argument "
"@var{n}.  If @w{@kbd{j m}} is used when there is no current selection, it is "
"equivalent to @w{@kbd{j s}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21768
msgid ""
"Even though @kbd{j m} does not explicitly use the location of the cursor "
"within the formula, it nevertheless uses the cursor to determine which stack "
"element to operate on.  As usual, @kbd{j m} when the cursor is not on any "
"stack element operates on the top stack element."
msgstr ""

#. type: kindex
#: ../../calc.texi:21769
#, no-wrap
msgid "j l"
msgstr ""

#. type: pindex
#: ../../calc.texi:21770
#, no-wrap
msgid "calc-select-less"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21776
msgid ""
"The @kbd{j l} (@code{calc-select-less}) command reduces the current "
"selection around the cursor position.  That is, it selects the immediate "
"sub-formula of the current selection which contains the cursor, the opposite "
"of @kbd{j m}.  If the cursor is not inside the current selection, the "
"command de-selects the formula."
msgstr ""

#. type: kindex
#: ../../calc.texi:21777
#, no-wrap
msgid "j 1-9"
msgstr ""

#. type: pindex
#: ../../calc.texi:21778
#, no-wrap
msgid "calc-select-part"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21787
msgid ""
"The @kbd{j 1} through @kbd{j 9} (@code{calc-select-part}) commands select "
"the @var{n}th sub-formula of the current selection.  They are like @kbd{j l} "
"(@code{calc-select-less}) except they use counting rather than the cursor "
"position to decide which sub-formula to select.  For example, if the current "
"selection is @kbd{a + b + c} or @kbd{f(a, b, c)} or @kbd{[a, b, c]}, then "
"@kbd{j 1} selects @samp{a}, @kbd{j 2} selects @samp{b}, and @kbd{j 3} "
"selects @samp{c}; in each of these cases, @kbd{j 4} through @kbd{j 9} would "
"be errors."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21793
msgid ""
"If there is no current selection, @kbd{j 1} through @kbd{j 9} select the "
"@var{n}th top-level sub-formula.  (In other words, they act as if the entire "
"stack entry were selected first.)  To select the @var{n}th sub-formula where "
"@var{n} is greater than nine, you must instead invoke @w{@kbd{j 1}} with "
"@var{n} as a numeric prefix argument."
msgstr ""

#. type: kindex
#: ../../calc.texi:21794
#, no-wrap
msgid "j n"
msgstr ""

#. type: kindex
#: ../../calc.texi:21795
#, no-wrap
msgid "j p"
msgstr ""

#. type: pindex
#: ../../calc.texi:21796
#, no-wrap
msgid "calc-select-next"
msgstr ""

#. type: pindex
#: ../../calc.texi:21797
#, no-wrap
msgid "calc-select-previous"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21808
msgid ""
"The @kbd{j n} (@code{calc-select-next}) and @kbd{j p} "
"(@code{calc-select-previous}) commands change the current selection to the "
"next or previous sub-formula at the same level.  For example, if @samp{b} is "
"selected in @w{@samp{2 + a*b*c + x}}, then @kbd{j n} selects @samp{c}.  "
"Further @kbd{j n} commands would be in error because, even though there is "
"something to the right of @samp{c} (namely, @samp{x}), it is not at the same "
"level; in this case, it is not a term of the same product as @samp{b} and "
"@samp{c}.  However, @kbd{j m} (to select the whole product @samp{a*b*c} as a "
"term of the sum) followed by @w{@kbd{j n}} would successfully select the "
"@samp{x}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21812
msgid ""
"Similarly, @kbd{j p} moves the selection from the @samp{b} in this sample "
"formula to the @samp{a}.  Both commands accept numeric prefix arguments to "
"move several steps at a time."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21822
msgid ""
"It is interesting to compare Calc's selection commands with the Emacs Info "
"system's commands for navigating through hierarchically organized "
"documentation.  Calc's @kbd{j n} command is completely analogous to Info's "
"@kbd{n} command.  Likewise, @kbd{j p} maps to @kbd{p}, @kbd{j 2} maps to "
"@kbd{2}, and Info's @kbd{u} is like @kbd{j m}.  (Note that @kbd{j u} stands "
"for @code{calc-unselect}, not ``up''.)  The Info @kbd{m} command is somewhat "
"similar to Calc's @kbd{j s} and @kbd{j l}; in each case, you can jump "
"directly to a sub-component of the hierarchy simply by pointing to it with "
"the cursor."
msgstr ""

#. type: node
#: ../../calc.texi:21823 ../../calc.texi:21854 ../../calc.texi:21855 ../../calc.texi:22011
#, no-wrap
msgid "Operating on Selections"
msgstr ""

#. type: kindex
#: ../../calc.texi:21827
#, no-wrap
msgid "j d"
msgstr ""

#. type: pindex
#: ../../calc.texi:21828
#, no-wrap
msgid "calc-show-selections"
msgstr ""

#. type: defvar
#: ../../calc.texi:21829 ../../calc.texi:35660
#, no-wrap
msgid "calc-highlight-selections-with-faces"
msgstr ""

#. type: defvarx
#: ../../calc.texi:21830 ../../calc.texi:35661
#, no-wrap
msgid "calc-selected-face"
msgstr ""

#. type: defvarx
#: ../../calc.texi:21831 ../../calc.texi:35662
#, no-wrap
msgid "calc-nonselected-face"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21837
msgid ""
"The @kbd{j d} (@code{calc-show-selections}) command controls how selected "
"sub-formulas are displayed.  One of the alternatives is illustrated in the "
"above examples; if we press @kbd{j d} we switch to the other style in which "
"the selected portion itself is obscured by @samp{#} signs:"
msgstr ""

#. type: group
#: ../../calc.texi:21844
#, no-wrap
msgid ""
"           3    ...                  #    ___\n"
"    (a + b)  . . .            ## # ##  + V c\n"
"1*  ...............       1*  ---------------\n"
"        . . . .                   2 x + 1\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21853
msgid ""
"If the customizable variable @code{calc-highlight-selections-with-faces} is "
"non-@code{nil}, then the non-selected portion of the formula will be "
"de-emphasized by using a less noticeable face (@code{calc-nonselected-face}) "
"instead of dots and the selected sub-formula will be highlighted by using a "
"more noticeable face (@code{calc-selected-face}) instead of @samp{#} "
"signs. (@pxref{Customizing Calc}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21863
msgid ""
"Once a selection is made, all Calc commands that manipulate items on the "
"stack will operate on the selected portions of the items instead.  (Note "
"that several stack elements may have selections at once, though there can be "
"only one selection at a time in any given stack element.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:21864
#, no-wrap
msgid "j e"
msgstr ""

#. type: pindex
#: ../../calc.texi:21865
#, no-wrap
msgid "calc-enable-selections"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21872
msgid ""
"The @kbd{j e} (@code{calc-enable-selections}) command disables the effect "
"that selections have on Calc commands.  The current selections still exist, "
"but Calc commands operate on whole stack elements anyway.  This mode can be "
"identified by the fact that the @samp{*} markers on the line numbers are "
"gone, even though selections are visible.  To reactivate the selections, "
"press @kbd{j e} again."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21877
msgid ""
"To extract a sub-formula as a new formula, simply select the sub-formula and "
"press @key{RET}.  This normally duplicates the top stack element; here it "
"duplicates only the selected portion of that element."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21883
msgid ""
"To replace a sub-formula with something different, you can enter the new "
"value onto the stack and press @key{TAB}.  This normally exchanges the top "
"two stack elements; here it swaps the value you entered into the selected "
"portion of the formula, returning the old selected portion to the top of the "
"stack."
msgstr ""

#. type: group
#: ../../calc.texi:21890
#, no-wrap
msgid ""
"           3    ...                    ...                    ___\n"
"    (a + b)  . . .           17 x y . . .           17 x y + V c\n"
"2*  ...............      2*  .............      2:  -------------\n"
"        . . . .                 . . . .                2 x + 1\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:21893
#, no-wrap
msgid ""
"                                    3                      3\n"
"1:  17 x y               1:  (a + b)            1:  (a + b)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21899
msgid ""
"In this example we select a sub-formula of our original example, enter a new "
"formula, @key{TAB} it into place, then deselect to see the complete, edited "
"formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21902
msgid ""
"If you want to swap whole formulas around even though they contain "
"selections, just use @kbd{j e} before and after."
msgstr ""

#. type: kindex
#: ../../calc.texi:21903
#, no-wrap
msgid "j '"
msgstr ""

#. type: pindex
#: ../../calc.texi:21904
#, no-wrap
msgid "calc-enter-selection"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21914
msgid ""
"The @kbd{j '} (@code{calc-enter-selection}) command is another way to "
"replace a selected sub-formula.  This command does an algebraic entry just "
"like the regular @kbd{'} key.  When you press @key{RET}, the formula you "
"type replaces the original selection.  You can use the @samp{$} symbol in "
"the formula to refer to the original selection.  If there is no selection in "
"the formula under the cursor, the cursor is used to make a temporary "
"selection for the purposes of the command.  Thus, to change a term of a "
"formula, all you have to do is move the Emacs cursor to that term and press "
"@kbd{j '}."
msgstr ""

#. type: kindex
#: ../../calc.texi:21915
#, no-wrap
msgid "j `"
msgstr ""

#. type: pindex
#: ../../calc.texi:21916
#, no-wrap
msgid "calc-edit-selection"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21921
msgid ""
"The @kbd{j `} (@code{calc-edit-selection}) command is a similar analogue of "
"the @kbd{`} (@code{calc-edit}) command.  It edits the selected sub-formula "
"in a separate buffer.  If there is no selection, it edits the sub-formula "
"indicated by the cursor."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21926
msgid ""
"To delete a sub-formula, press @key{DEL}.  This generally replaces the "
"sub-formula with the constant zero, but in a few suitable contexts it uses "
"the constant one instead.  The @key{DEL} key automatically deselects and "
"re-simplifies the entire formula afterwards.  Thus:"
msgstr ""

#. type: group
#: ../../calc.texi:21933
#, no-wrap
msgid ""
"              ###\n"
"    17 x y + # #          17 x y         17 # y          17 y\n"
"1*  -------------     1:  -------    1*  -------    1:  -------\n"
"       2 x + 1            2 x + 1        2 x + 1        2 x + 1\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21941
msgid ""
"In this example, we first delete the @samp{sqrt(c)} term; Calc accomplishes "
"this by replacing @samp{sqrt(c)} with zero and resimplifying.  We then "
"delete the @kbd{x} in the numerator; since this is part of a product, Calc "
"replaces it with @samp{1} and resimplifies."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21945
msgid ""
"If you select an element of a vector and press @key{DEL}, that element is "
"deleted from the vector.  If you delete one side of an equation or "
"inequality, only the opposite side remains."
msgstr ""

#. type: kindex
#: ../../calc.texi:21946
#, no-wrap
msgid "j DEL"
msgstr ""

#. type: pindex
#: ../../calc.texi:21947
#, no-wrap
msgid "calc-del-selection"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21953
msgid ""
"The @kbd{j @key{DEL}} (@code{calc-del-selection}) command is like @key{DEL} "
"but with the auto-selecting behavior of @kbd{j '} and @kbd{j `}.  It deletes "
"the selected portion of the formula indicated by the cursor, or, in the "
"absence of a selection, it deletes the sub-formula indicated by the cursor "
"position."
msgstr ""

#. type: kindex
#: ../../calc.texi:21954
#, no-wrap
msgid "j RET"
msgstr ""

#. type: pindex
#: ../../calc.texi:21955
#, no-wrap
msgid "calc-grab-selection"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21958
msgid ""
"(There is also an auto-selecting @kbd{j @key{RET}} "
"(@code{calc-copy-selection})  command.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21963
msgid ""
"Normal arithmetic operations also apply to sub-formulas.  Here we select the "
"denominator, press @kbd{5 -} to subtract five from the denominator, press "
"@kbd{n} to negate the denominator, then press @kbd{Q} to take the square "
"root."
msgstr ""

#. type: group
#: ../../calc.texi:21970
#, no-wrap
msgid ""
"     .. .           .. .           .. .             .. .\n"
"1*  .......    1*  .......    1*  .......    1*  ..........\n"
"    2 x + 1        2 x - 4        4 - 2 x         _________\n"
"                                                 V 4 - 2 x\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:21980
msgid ""
"Certain types of operations on selections are not allowed.  For example, for "
"an arithmetic function like @kbd{-} no more than one of the arguments may be "
"a selected sub-formula.  (As the above example shows, the result of the "
"subtraction is spliced back into the argument which had the selection; if "
"there were more than one selection involved, this would not be "
"well-defined.)  If you try to subtract two selections, the command will "
"abort with an error message."
msgstr ""

#. type: Plain text
#: ../../calc.texi:21985
msgid ""
"Operations on sub-formulas sometimes leave the formula as a whole in an "
"``un-natural'' state.  Consider negating the @samp{2 x} term of our sample "
"formula by selecting it and pressing @kbd{n} (@code{calc-change-sign})."
msgstr ""

#. type: group
#: ../../calc.texi:21992
#, no-wrap
msgid ""
"       .. .                .. .\n"
"1*  ..........      1*  ...........\n"
"     .........           ..........\n"
"    . . . 2 x           . . . -2 x\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22001
msgid ""
"Unselecting the sub-formula reveals that the minus sign, which would "
"normally have canceled out with the subtraction automatically, has not been "
"able to do so because the subtraction was not part of the selected portion.  "
"Pressing @kbd{=} (@code{calc-evaluate}) or doing any other mathematical "
"operation on the whole formula will cause it to be simplified."
msgstr ""

#. type: group
#: ../../calc.texi:22008
#, no-wrap
msgid ""
"       17 y                17 y\n"
"1:  -----------     1:  ----------\n"
"     __________          _________\n"
"    V 4 - -2 x          V 4 + 2 x\n"
msgstr ""

#. type: subsection
#: ../../calc.texi:22012
#, no-wrap
msgid "Rearranging Formulas using Selections"
msgstr ""

#. type: kindex
#: ../../calc.texi:22015
#, no-wrap
msgid "j R"
msgstr ""

#. type: pindex
#: ../../calc.texi:22016
#, no-wrap
msgid "calc-commute-right"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22021
msgid ""
"The @kbd{j R} (@code{calc-commute-right}) command moves the selected "
"sub-formula to the right in its surrounding formula.  Generally the "
"selection is one term of a sum or product; the sum or product is rearranged "
"according to the commutative laws of algebra."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22026
msgid ""
"As with @kbd{j '} and @kbd{j @key{DEL}}, the term under the cursor is used "
"if there is no selection in the current formula.  All commands described in "
"this section share this property.  In this example, we place the cursor on "
"the @samp{a} and type @kbd{j R}, then repeat."
msgstr ""

#. type: smallexample
#: ../../calc.texi:22029
#, no-wrap
msgid "1:  a + b - c          1:  b + a - c          1:  b - c + a\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22036
msgid ""
"Note that in the final step above, the @samp{a} is switched with the "
"@samp{c} but the signs are adjusted accordingly.  When moving terms of sums "
"and products, @kbd{j R} will never change the mathematical meaning of the "
"formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22041
msgid ""
"The selected term may also be an element of a vector or an argument of a "
"function.  The term is exchanged with the one to its right.  In this case, "
"the ``meaning'' of the vector or function may of course be drastically "
"changed."
msgstr ""

#. type: smallexample
#: ../../calc.texi:22044
#, no-wrap
msgid ""
"1:  [a, b, c]          1:  [b, a, c]          1:  [b, c, a]\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:22046
#, no-wrap
msgid "1:  f(a, b, c)         1:  f(b, a, c)         1:  f(b, c, a)\n"
msgstr ""

#. type: kindex
#: ../../calc.texi:22048
#, no-wrap
msgid "j L"
msgstr ""

#. type: pindex
#: ../../calc.texi:22049
#, no-wrap
msgid "calc-commute-left"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22052
msgid ""
"The @kbd{j L} (@code{calc-commute-left}) command is like @kbd{j R} except "
"that it swaps the selected term with the one to its left."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22058
msgid ""
"With numeric prefix arguments, these commands move the selected term several "
"steps at a time.  It is an error to try to move a term left or right past "
"the end of its enclosing formula.  With numeric prefix arguments of zero, "
"these commands move the selected term as far as possible in the given "
"direction."
msgstr ""

#. type: kindex
#: ../../calc.texi:22059
#, no-wrap
msgid "j D"
msgstr ""

#. type: pindex
#: ../../calc.texi:22060
#, no-wrap
msgid "calc-sel-distribute"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22069
msgid ""
"The @kbd{j D} (@code{calc-sel-distribute}) command mixes the selected sum or "
"product into the surrounding formula using the distributive law.  For "
"example, in @samp{a * (b - c)} with the @samp{b - c} selected, the result is "
"@samp{a b - a c}.  This also distributes products or quotients into "
"surrounding powers, and can also do transformations like @samp{exp(a + b)} "
"to @samp{exp(a) exp(b)}, where @samp{a + b} is the selected term, and "
"@samp{ln(a ^ b)} to @samp{ln(a) b}, where @samp{a ^ b} is the selected term."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22076
msgid ""
"For multiple-term sums or products, @kbd{j D} takes off one term at a time: "
"@samp{a * (b + c - d)} goes to @samp{a * (c - d) + a b} with the @samp{c - "
"d} selected so that you can type @kbd{j D} repeatedly to expand completely.  "
"The @kbd{j D} command allows a numeric prefix argument which specifies the "
"maximum number of times to expand at once; the default is one time only."
msgstr ""

#. type: vindex
#: ../../calc.texi:22077
#, no-wrap
msgid "DistribRules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22085
msgid ""
"The @kbd{j D} command is implemented using rewrite rules.  @xref{Selections "
"with Rewrite Rules}.  The rules are stored in the Calc variable "
"@code{DistribRules}.  A convenient way to view these rules is to use @kbd{s "
"e} (@code{calc-edit-variable}) which displays and edits the stored value of "
"a variable.  Press @kbd{C-c C-c} to return from editing mode; be careful not "
"to make any actual changes or else you will affect the behavior of future "
"@kbd{j D} commands!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22090
msgid ""
"To extend @kbd{j D} to handle new cases, just edit @code{DistribRules} as "
"described above.  You can then use the @kbd{s p} command to save this "
"variable's value permanently for future Calc sessions.  @xref{Operations on "
"Variables}."
msgstr ""

#. type: kindex
#: ../../calc.texi:22091
#, no-wrap
msgid "j M"
msgstr ""

#. type: pindex
#: ../../calc.texi:22092
#, no-wrap
msgid "calc-sel-merge"
msgstr ""

#. type: vindex
#: ../../calc.texi:22093
#, no-wrap
msgid "MergeRules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22100
msgid ""
"The @kbd{j M} (@code{calc-sel-merge}) command is the complement of @kbd{j "
"D}; given @samp{a b - a c} with either @samp{a b} or @samp{a c} selected, "
"the result is @samp{a * (b - c)}.  Once again, @kbd{j M} can also merge "
"calls to functions like @code{exp} and @code{ln}; examine the variable "
"@code{MergeRules} to see all the relevant rules."
msgstr ""

#. type: kindex
#: ../../calc.texi:22101
#, no-wrap
msgid "j C"
msgstr ""

#. type: pindex
#: ../../calc.texi:22102
#, no-wrap
msgid "calc-sel-commute"
msgstr ""

#. type: vindex
#: ../../calc.texi:22103
#, no-wrap
msgid "CommuteRules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22113
msgid ""
"The @kbd{j C} (@code{calc-sel-commute}) command swaps the arguments of the "
"selected sum, product, or equation.  It always behaves as if @kbd{j b} mode "
"were in effect, i.e., the sum @samp{a + b + c} is treated as the nested sums "
"@samp{(a + b) + c} by this command.  If you put the cursor on the first "
"@samp{+}, the result is @samp{(b + a) + c}; if you put the cursor on the "
"second @samp{+}, the result is @samp{c + (a + b)} (which the default "
"simplifications will rearrange to @samp{(c + a) + b}).  The relevant rules "
"are stored in the variable @code{CommuteRules}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22120
msgid ""
"You may need to turn default simplifications off (with the @kbd{m O} "
"command) in order to get the full benefit of @kbd{j C}.  For example, "
"commuting @samp{a - b} produces @samp{-b + a}, but the default "
"simplifications will ``simplify'' this right back to @samp{a - b} if you "
"don't turn them off.  The same is true of some of the other manipulations "
"described in this section."
msgstr ""

#. type: kindex
#: ../../calc.texi:22121
#, no-wrap
msgid "j N"
msgstr ""

#. type: pindex
#: ../../calc.texi:22122
#, no-wrap
msgid "calc-sel-negate"
msgstr ""

#. type: vindex
#: ../../calc.texi:22123
#, no-wrap
msgid "NegateRules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22132
msgid ""
"The @kbd{j N} (@code{calc-sel-negate}) command replaces the selected term "
"with the negative of that term, then adjusts the surrounding formula in "
"order to preserve the meaning.  For example, given @samp{exp(a - b)} where "
"@samp{a - b} is selected, the result is @samp{1 / exp(b - a)}.  By contrast, "
"selecting a term and using the regular @kbd{n} (@code{calc-change-sign}) "
"command negates the term without adjusting the surroundings, thus changing "
"the meaning of the formula as a whole.  The rules variable is "
"@code{NegateRules}."
msgstr ""

#. type: kindex
#: ../../calc.texi:22133
#, no-wrap
msgid "j &"
msgstr ""

#. type: pindex
#: ../../calc.texi:22134
#, no-wrap
msgid "calc-sel-invert"
msgstr ""

#. type: vindex
#: ../../calc.texi:22135
#, no-wrap
msgid "InvertRules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22140
msgid ""
"The @kbd{j &} (@code{calc-sel-invert}) command is similar to @kbd{j N} "
"except it takes the reciprocal of the selected term.  For example, given "
"@samp{a - ln(b)} with @samp{b} selected, the result is @samp{a + ln(1/b)}.  "
"The rules variable is @code{InvertRules}."
msgstr ""

#. type: kindex
#: ../../calc.texi:22141
#, no-wrap
msgid "j E"
msgstr ""

#. type: pindex
#: ../../calc.texi:22142
#, no-wrap
msgid "calc-sel-jump-equals"
msgstr ""

#. type: vindex
#: ../../calc.texi:22143
#, no-wrap
msgid "JumpRules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22150
msgid ""
"The @kbd{j E} (@code{calc-sel-jump-equals}) command moves the selected term "
"from one side of an equation to the other.  Given @samp{a + b = c + d} with "
"@samp{c} selected, the result is @samp{a + b - c = d}.  This command also "
"works if the selected term is part of a @samp{*}, @samp{/}, or @samp{^} "
"formula.  The relevant rules variable is @code{JumpRules}."
msgstr ""

#. type: kindex
#: ../../calc.texi:22151
#, no-wrap
msgid "j I"
msgstr ""

#. type: kindex
#: ../../calc.texi:22152
#, no-wrap
msgid "H j I"
msgstr ""

#. type: pindex
#: ../../calc.texi:22153
#, no-wrap
msgid "calc-sel-isolate"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22161
msgid ""
"The @kbd{j I} (@code{calc-sel-isolate}) command isolates the selected term "
"on its side of an equation.  It uses the @kbd{a S} (@code{calc-solve-for}) "
"command to solve the equation, and the Hyperbolic flag affects it in the "
"same way.  @xref{Solving Equations}.  When it applies, @kbd{j I} is often "
"easier to use than @kbd{j E}.  It understands more rules of algebra, and "
"works for inequalities as well as equations."
msgstr ""

#. type: kindex
#: ../../calc.texi:22162
#, no-wrap
msgid "j *"
msgstr ""

#. type: kindex
#: ../../calc.texi:22163
#, no-wrap
msgid "j /"
msgstr ""

#. type: pindex
#: ../../calc.texi:22164
#, no-wrap
msgid "calc-sel-mult-both-sides"
msgstr ""

#. type: pindex
#: ../../calc.texi:22165
#, no-wrap
msgid "calc-sel-div-both-sides"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22174
msgid ""
"The @kbd{j *} (@code{calc-sel-mult-both-sides}) command prompts for a "
"formula using algebraic entry, then multiplies both sides of the selected "
"quotient or equation by that formula.  It performs the default algebraic "
"simplifications before re-forming the quotient or equation.  You can "
"suppress this simplification by providing a prefix argument: @kbd{C-u j *}.  "
"There is also a @kbd{j /} (@code{calc-sel-div-both-sides}) which is similar "
"to @kbd{j *} but dividing instead of multiplying by the factor you enter."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22185
msgid ""
"If the selection is a quotient with numerator 1, then Calc's default "
"simplifications would normally cancel the new factors.  To prevent this, "
"when the @kbd{j *} command is used on a selection whose numerator is 1 or "
"-1, the denominator is expanded at the top level using the distributive law "
"(as if using the @kbd{C-u 1 a x} command).  Suppose the formula on the stack "
"is @samp{1 / (a + 1)} and you wish to multiplying the top and bottom by "
"@samp{a - 1}.  Calc's default simplifications would normally change the "
"result @samp{(a - 1) /(a + 1) (a - 1)} back to the original form by "
"cancellation; when @kbd{j *} is used, Calc expands the denominator to "
"@samp{a (a - 1) + a - 1} to prevent this."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22198
msgid ""
"If you wish the @kbd{j *} command to completely expand the denominator of a "
"quotient you can call it with a zero prefix: @kbd{C-u 0 j *}.  For example, "
"if the formula on the stack is @samp{1 / (sqrt(a) + 1)}, you may wish to "
"eliminate the square root in the denominator by multiplying the top and "
"bottom by @samp{sqrt(a) - 1}.  If you did this simply by using a simple "
"@kbd{j *} command, you would get @samp{(sqrt(a)-1)/ (sqrt(a) (sqrt(a) - 1) + "
"sqrt(a) - 1)}.  Instead, you would probably want to use @kbd{C-u 0 j *}, "
"which would expand the bottom and give you the desired result "
"@samp{(sqrt(a)-1)/(a-1)}.  More generally, if @kbd{j *} is called with an "
"argument of a positive integer @var{n}, then the denominator of the "
"expression will be expanded @var{n} times (as if with the @kbd{C-u @var{n} a "
"x} command)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22207
msgid ""
"If the selection is an inequality, @kbd{j *} and @kbd{j /} will accept any "
"factor, but will warn unless they can prove the factor is either positive or "
"negative.  (In the latter case the direction of the inequality will be "
"switched appropriately.)  @xref{Declarations}, for ways to inform Calc that "
"a given variable is positive or negative.  If Calc can't tell for sure what "
"the sign of the factor will be, it will assume it is positive and display a "
"warning message."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22212
msgid ""
"For selections that are not quotients, equations, or inequalities, these "
"commands pull out a multiplicative factor: They divide (or multiply) by the "
"entered formula, simplify, then multiply (or divide)  back by the formula."
msgstr ""

#. type: kindex
#: ../../calc.texi:22213
#, no-wrap
msgid "j +"
msgstr ""

#. type: kindex
#: ../../calc.texi:22214
#, no-wrap
msgid "j -"
msgstr ""

#. type: pindex
#: ../../calc.texi:22215
#, no-wrap
msgid "calc-sel-add-both-sides"
msgstr ""

#. type: pindex
#: ../../calc.texi:22216
#, no-wrap
msgid "calc-sel-sub-both-sides"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22223
msgid ""
"The @kbd{j +} (@code{calc-sel-add-both-sides}) and @kbd{j -} "
"(@code{calc-sel-sub-both-sides}) commands analogously add to or subtract "
"from both sides of an equation or inequality.  For other types of "
"selections, they extract an additive factor.  A numeric prefix argument "
"suppresses simplification of the intermediate results."
msgstr ""

#. type: kindex
#: ../../calc.texi:22224
#, no-wrap
msgid "j U"
msgstr ""

#. type: pindex
#: ../../calc.texi:22225
#, no-wrap
msgid "calc-sel-unpack"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22232
msgid ""
"The @kbd{j U} (@code{calc-sel-unpack}) command replaces the selected "
"function call with its argument.  For example, given @samp{a + sin(x^2)} "
"with @samp{sin(x^2)} selected, the result is @samp{a + x^2}.  (The "
"@samp{x^2} will remain selected; if you wanted to change the @code{sin} to "
"@code{cos}, just press @kbd{C} now to take the cosine of the selected part.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:22233
#, no-wrap
msgid "j v"
msgstr ""

#. type: pindex
#: ../../calc.texi:22234
#, no-wrap
msgid "calc-sel-evaluate"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22242
msgid ""
"The @kbd{j v} (@code{calc-sel-evaluate}) command performs the basic "
"simplifications on the selected sub-formula.  These simplifications would "
"normally be done automatically on all results, but may have been partially "
"inhibited by previous selection-related operations, or turned off altogether "
"by the @kbd{m O} command.  This command is just an auto-selecting version of "
"the @w{@kbd{a v}} command (@pxref{Algebraic Manipulation})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22251
msgid ""
"With a numeric prefix argument of 2, @kbd{C-u 2 j v} applies the default "
"algebraic simplifications to the selected sub-formula.  With a prefix "
"argument of 3 or more, e.g., @kbd{C-u j v} applies the @kbd{a e} "
"(@code{calc-simplify-extended}) command.  @xref{Simplifying Formulas}.  With "
"a negative prefix argument it simplifies at the top level only, just as with "
"@kbd{a v}.  Here the ``top'' level refers to the top level of the selected "
"sub-formula."
msgstr ""

#. type: kindex
#: ../../calc.texi:22252
#, no-wrap
msgid "j \""
msgstr ""

#. type: pindex
#: ../../calc.texi:22253
#, no-wrap
msgid "calc-sel-expand-formula"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22256
msgid ""
"The @kbd{j \"} (@code{calc-sel-expand-formula}) command is to @kbd{a \"} "
"(@pxref{Algebraic Manipulation}) what @kbd{j v} is to @kbd{a v}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22259
msgid ""
"You can use the @kbd{j r} (@code{calc-rewrite-selection}) command to define "
"other algebraic operations on sub-formulas.  @xref{Rewrite Rules}."
msgstr ""

#. type: node
#: ../../calc.texi:22260 ../../calc.texi:22424 ../../calc.texi:22425 ../../calc.texi:22473 ../../calc.texi:22803 ../../calc.texi:23036 ../../calc.texi:23129 ../../calc.texi:23214
#, no-wrap
msgid "Simplifying Formulas"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22268
msgid ""
"The commands in this section perform general-purpose algebraic "
"manipulations.  They work on the whole formula at the top of the stack "
"(unless, of course, you have made a selection in that formula)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22273
msgid ""
"Many algebra commands prompt for a variable name or formula.  If you answer "
"the prompt with a blank line, the variable or formula is taken from "
"top-of-stack, and the normal argument for the command is taken from the "
"second-to-top stack level."
msgstr ""

#. type: kindex
#: ../../calc.texi:22274
#, no-wrap
msgid "a v"
msgstr ""

#. type: pindex
#: ../../calc.texi:22275
#, no-wrap
msgid "calc-alg-evaluate"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22282
msgid ""
"The @kbd{a v} (@code{calc-alg-evaluate}) command performs the normal default "
"simplifications on a formula; for example, @samp{a - -b} is changed to "
"@samp{a + b}.  These simplifications are normally done automatically on all "
"Calc results, so this command is useful only if you have turned default "
"simplifications off with an @kbd{m O} command.  @xref{Simplification Modes}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22286
msgid ""
"It is often more convenient to type @kbd{=}, which is like @kbd{a v} but "
"which also substitutes stored values for variables in the formula.  Use "
"@kbd{a v} if you want the variables to ignore their stored values."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22291
msgid ""
"If you give a numeric prefix argument of 2 to @kbd{a v}, it simplifies using "
"Calc's algebraic simplifications; @pxref{Simplifying Formulas}.  If you give "
"a numeric prefix of 3 or more, it uses Extended Simplification mode (@kbd{a "
"e})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22301
msgid ""
"If you give a negative prefix argument @mathit{-1}, @mathit{-2}, or "
"@mathit{-3}, it simplifies in the corresponding mode but only works on the "
"top-level function call of the formula.  For example, @samp{(2 + 3) * (2 + "
"3)} will simplify to @samp{(2 + 3)^2}, without simplifying the sub-formulas "
"@samp{2 + 3}.  As another example, typing @kbd{V R +} to sum the vector "
"@samp{[1, 2, 3, 4]} produces the formula @samp{reduce(add, [1, 2, 3, 4])} in "
"No-Simplify mode.  Using @kbd{a v} will evaluate this all the way to 10; "
"using @kbd{C-u - a v} will evaluate it only to @samp{1 + 2 + 3 + 4}.  "
"(@xref{Reducing and Mapping}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22311
msgid ""
"@tindex evalv @tindex evalvn The @kbd{=} command corresponds to the "
"@code{evalv} function, and the related @kbd{N} command, which is like "
"@kbd{=} but temporarily disables Symbolic mode (@kbd{m s}) during the "
"evaluation, corresponds to the @code{evalvn} function.  (These commands "
"interpret their prefix arguments differently than @kbd{a v}; @kbd{=} treats "
"the prefix as the number of stack elements to evaluate at once, and @kbd{N} "
"treats it as a temporary different working precision.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22324
msgid ""
"The @code{evalvn} function can take an alternate working precision as an "
"optional second argument.  This argument can be either an integer, to set "
"the precision absolutely, or a vector containing a single integer, to adjust "
"the precision relative to the current precision.  Note that @code{evalvn} "
"with a larger than current precision will do the calculation at this higher "
"precision, but the result will as usual be rounded back down to the current "
"precision afterward.  For example, @samp{evalvn(pi - 3.1415)} at a precision "
"of 12 will return @samp{9.265359e-5}; @samp{evalvn(pi - 3.1415, 30)} will "
"return @samp{9.26535897932e-5} (computing a 25-digit result which is then "
"rounded down to 12); and @samp{evalvn(pi - 3.1415, [-2])} will return "
"@samp{9.2654e-5}."
msgstr ""

#. type: kindex
#: ../../calc.texi:22325
#, no-wrap
msgid "a \""
msgstr ""

#. type: pindex
#: ../../calc.texi:22326
#, no-wrap
msgid "calc-expand-formula"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22341
msgid ""
"The @kbd{a \"} (@code{calc-expand-formula}) command expands functions into "
"their defining formulas wherever possible.  For example, @samp{deg(x^2)} is "
"changed to @samp{180 x^2 / pi}.  Most functions, like @code{sin} and "
"@code{gcd}, are not defined by simple formulas and so are unaffected by this "
"command.  One important class of functions which @emph{can} be expanded is "
"the user-defined functions created by the @kbd{Z F} command.  "
"@xref{Algebraic Definitions}.  Other functions which @kbd{a \"} can expand "
"include the probability distribution functions, most of the financial "
"functions, and the hyperbolic and inverse hyperbolic functions.  A numeric "
"prefix argument affects @kbd{a \"} in the same way as it does @kbd{a v}: A "
"positive argument expands all functions in the formula and then simplifies "
"in various ways; a negative argument expands and simplifies only the "
"top-level function call."
msgstr ""

#. type: kindex
#: ../../calc.texi:22342
#, no-wrap
msgid "a M"
msgstr ""

#. type: pindex
#: ../../calc.texi:22343
#, no-wrap
msgid "calc-map-equation"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22354
msgid ""
"@tindex mapeq The @kbd{a M} (@code{calc-map-equation}) [@code{mapeq}] "
"command applies a given function or operator to one or more equations.  It "
"is analogous to @kbd{V M}, which operates on vectors instead of equations.  "
"@pxref{Reducing and Mapping}.  For example, @kbd{a M S} changes @samp{x = "
"y+1} to @samp{sin(x) = sin(y+1)}, and @kbd{a M +} with @samp{x = y+1} and "
"@expr{6} on the stack produces @samp{x+6 = y+7}.  With two equations on the "
"stack, @kbd{a M +} would add the lefthand sides together and the righthand "
"sides together to get the two respective sides of a new equation."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22365
msgid ""
"Mapping also works on inequalities.  Mapping two similar inequalities "
"produces another inequality of the same type.  Mapping an inequality with an "
"equation produces an inequality of the same type.  Mapping a @samp{<=} with "
"a @samp{<} or @samp{!=} (not-equal) produces a @samp{<}.  If inequalities "
"with opposite direction (e.g., @samp{<} and @samp{>})  are mapped, the "
"direction of the second inequality is reversed to match the first: Using "
"@kbd{a M +} on @samp{a < b} and @samp{a > 2} reverses the latter to get "
"@samp{2 < a}, which then allows the combination @samp{a + 2 < b + a}, which "
"the algebraic simplifications can reduce to @samp{2 < b}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22371
msgid ""
"Using @kbd{a M *}, @kbd{a M /}, @kbd{a M n}, or @kbd{a M &} to negate or "
"invert an inequality will reverse the direction of the inequality.  Other "
"adjustments to inequalities are @emph{not} done automatically; @kbd{a M S} "
"will change @w{@samp{x < y}} to @samp{sin(x) < sin(y)} even though this is "
"not true for all values of the variables."
msgstr ""

#. type: kindex
#: ../../calc.texi:22372
#, no-wrap
msgid "H a M"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22379
msgid ""
"@tindex mapeqp With the Hyperbolic flag, @kbd{H a M} [@code{mapeqp}] does a "
"plain mapping operation without reversing the direction of any "
"inequalities.  Thus, @kbd{H a M &} would change @kbd{x > 2} to @kbd{1/x > "
"0.5}.  (This change is mathematically incorrect, but perhaps you were fixing "
"an inequality which was already incorrect.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:22380
#, no-wrap
msgid "I a M"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22386
msgid ""
"@tindex mapeqr With the Inverse flag, @kbd{I a M} [@code{mapeqr}] always "
"reverses the direction of the inequality.  You might use @kbd{I a M C} to "
"change @samp{x < y} to @samp{cos(x) > cos(y)} if you know you are working "
"with small positive angles."
msgstr ""

#. type: kindex
#: ../../calc.texi:22387
#, no-wrap
msgid "a b"
msgstr ""

#. type: pindex
#: ../../calc.texi:22388
#, no-wrap
msgid "calc-substitute"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22400
msgid ""
"@tindex subst The @kbd{a b} (@code{calc-substitute}) [@code{subst}] command "
"substitutes all occurrences of some variable or sub-expression of an "
"expression with a new sub-expression.  For example, substituting "
"@samp{sin(x)} with @samp{cos(y)} in @samp{2 sin(x)^2 + x sin(x) + sin(2 x)} "
"produces @samp{2 cos(y)^2 + x cos(y) + @w{sin(2 x)}}.  Note that this is a "
"purely structural substitution; the lone @samp{x} and the @samp{sin(2 x)} "
"stayed the same because they did not look like @samp{sin(x)}.  @xref{Rewrite "
"Rules}, for a more general method for doing substitutions."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22408
msgid ""
"The @kbd{a b} command normally prompts for two formulas, the old one and the "
"new one.  If you enter a blank line for the first prompt, all three "
"arguments are taken from the stack (new, then old, then target expression).  "
"If you type an old formula but then enter a blank line for the new one, the "
"new formula is taken from top-of-stack and the target from second-to-top.  "
"If you answer both prompts, the target is taken from top-of-stack as usual."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22417
msgid ""
"Note that @kbd{a b} has no understanding of commutativity or associativity.  "
"The pattern @samp{x+y} will not match the formula @samp{y+x}.  Also, "
"@samp{y+z} will not match inside the formula @samp{x+y+z} because the "
"@samp{+} operator is left-associative, so the ``deep structure'' of that "
"formula is @samp{(x+y) + z}.  Use @kbd{d U} "
"(@code{calc-unformatted-language}) mode to see the true structure of a "
"formula.  The rewrite rule mechanism, discussed later, does not have these "
"limitations."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22423
msgid ""
"As an algebraic function, @code{subst} takes three arguments: Target "
"expression, old, new.  Note that @code{subst} is always evaluated "
"immediately, even if its arguments are variables, so if you wish to put a "
"call to @code{subst} onto the stack you must turn the default "
"simplifications off first (with @kbd{m O})."
msgstr ""

#. type: node
#: ../../calc.texi:22424 ../../calc.texi:23214 ../../calc.texi:23215 ../../calc.texi:23438
#, no-wrap
msgid "Polynomials"
msgstr ""

#. type: kindex
#: ../../calc.texi:22428 ../../calc.texi:22808
#, no-wrap
msgid "a s"
msgstr ""

#. type: kindex
#: ../../calc.texi:22429
#, no-wrap
msgid "I a s"
msgstr ""

#. type: kindex
#: ../../calc.texi:22430
#, no-wrap
msgid "H a s"
msgstr ""

#. type: pindex
#: ../../calc.texi:22431
#, no-wrap
msgid "calc-simplify"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22433
msgid "@tindex simplify"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22442
msgid ""
"The sections below describe all the various kinds of simplifications Calc "
"provides in full detail.  None of Calc's simplification commands are "
"designed to pull rabbits out of hats; they simply apply certain specific "
"rules to put formulas into less redundant or more pleasing forms.  Serious "
"algebra in Calc must be done manually, usually with a combination of "
"selections and rewrite rules.  @xref{Rearranging with Selections}.  "
"@xref{Rewrite Rules}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22449
msgid ""
"@xref{Simplification Modes}, for commands to control what level of "
"simplification occurs automatically.  Normally the algebraic simplifications "
"described below occur.  If you have turned on a simplification mode which "
"does not do these algebraic simplifications, you can still apply them to a "
"formula with the @kbd{a s} (@code{calc-simplify}) [@code{simplify}] command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22465
msgid ""
"There are some simplifications that, while sometimes useful, are never done "
"automatically.  For example, the @kbd{I} prefix can be given to @kbd{a s}; "
"the @kbd{I a s} command will change any trigonometric function to the "
"appropriate combination of @samp{sin}s and @samp{cos}s before simplifying.  "
"This can be useful in simplifying even mildly complicated trigonometric "
"expressions.  For example, while the algebraic simplifications can reduce "
"@samp{sin(x) csc(x)} to @samp{1}, they will not simplify @samp{sin(x)^2 "
"csc(x)}.  The command @kbd{I a s} can be used to simplify this latter "
"expression; it will transform @samp{sin(x)^2 csc(x)} into @samp{sin(x)}.  "
"However, @kbd{I a s} will also perform some ``simplifications'' which may "
"not be desired; for example, it will transform @samp{tan(x)^2} into "
"@samp{sin(x)^2 / cos(x)^2}.  The Hyperbolic prefix @kbd{H} can be used "
"similarly; the @kbd{H a s} will replace any hyperbolic functions in the "
"formula with the appropriate combinations of @samp{sinh}s and @samp{cosh}s "
"before simplifying."
msgstr ""

#. type: menuentry
#: ../../calc.texi:22471
msgid "Basic Simplifications::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:22471
msgid "Algebraic Simplifications::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:22471
msgid "Unsafe Simplifications::"
msgstr ""

#. type: subsection
#: ../../calc.texi:22471 ../../calc.texi:23036 ../../calc.texi:23129 ../../calc.texi:23130
#, no-wrap
msgid "Simplification of Units"
msgstr ""

#. type: node
#: ../../calc.texi:22473 ../../calc.texi:22474 ../../calc.texi:22803
#, no-wrap
msgid "Basic Simplifications"
msgstr ""

#. type: node
#: ../../calc.texi:22473 ../../calc.texi:22803 ../../calc.texi:22804 ../../calc.texi:23036
#, no-wrap
msgid "Algebraic Simplifications"
msgstr ""

#. type: cindex
#: ../../calc.texi:22477
#, no-wrap
msgid "Basic simplifications"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22483
msgid ""
"This section describes basic simplifications which Calc performs in many "
"situations.  For example, both binary simplifications and algebraic "
"simplifications begin by performing these basic simplifications.  You can "
"type @kbd{m I} to restrict the simplifications done on the stack to these "
"simplifications."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22492
msgid ""
"The most basic simplification is the evaluation of functions.  For example, "
"@expr{2 + 3} is evaluated to @expr{5}, and @expr{@tfn{sqrt}(9)} is evaluated "
"to @expr{3}.  Evaluation does not occur if the arguments to a function are "
"somehow of the wrong type @expr{@tfn{tan}([2,3,4])}), range "
"(@expr{@tfn{tan}(90)}), or number (@expr{@tfn{tan}(3,5)}), or if the "
"function name is not recognized (@expr{@tfn{f}(5)}), or if Symbolic mode "
"(@pxref{Symbolic Mode}) prevents evaluation (@expr{@tfn{sqrt}(2)})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22501
msgid ""
"Calc simplifies (evaluates) the arguments to a function before it simplifies "
"the function itself.  Thus @expr{@tfn{sqrt}(5+4)} is simplified to "
"@expr{@tfn{sqrt}(9)} before the @code{sqrt} function itself is applied.  "
"There are very few exceptions to this rule: @code{quote}, @code{lambda}, and "
"@code{condition} (the @code{::} operator) do not evaluate their arguments, "
"@code{if} (the @code{? :} operator) does not evaluate all of its arguments, "
"and @code{evalto} does not evaluate its lefthand argument."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22510
msgid ""
"Most commands apply at least these basic simplifications to all arguments "
"they take from the stack, perform a particular operation, then simplify the "
"result before pushing it back on the stack.  In the common special case of "
"regular arithmetic commands like @kbd{+} and @kbd{Q} [@code{sqrt}], the "
"arguments are simply popped from the stack and collected into a suitable "
"function call, which is then simplified (the arguments being simplified "
"first as part of the process, as described above)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22516
msgid ""
"Even the basic set of simplifications are too numerous to describe "
"completely here, but this section will describe the ones that apply to the "
"major arithmetic operators.  This list will be rather technical in nature, "
"and will probably be interesting to you only if you are a serious user of "
"Calc's algebra facilities."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22525
msgid ""
"As well as the simplifications described here, if you have stored any "
"rewrite rules in the variable @code{EvalRules} then these rules will also be "
"applied before any of the basic simplifications.  @xref{Automatic Rewrites}, "
"for details."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22531
msgid "And now, on with the basic simplifications:"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22543
msgid ""
"Arithmetic operators like @kbd{+} and @kbd{*} always take two arguments in "
"Calc's internal form.  Sums and products of three or more terms are arranged "
"by the associative law of algebra into a left-associative form for sums, "
"@expr{((a + b) + c) + d}, and (by default) a right-associative form for "
"products, @expr{a * (b * (c * d))}.  Formulas like @expr{(a + b) + (c + d)} "
"are rearranged to left-associative form, though this rarely matters since "
"Calc's algebra commands are designed to hide the inner structure of sums and "
"products as much as possible.  Sums and products in their proper associative "
"form will be written without parentheses in the examples below."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22554
msgid ""
"Sums and products are @emph{not} rearranged according to the commutative law "
"(@expr{a + b} to @expr{b + a}) except in a few special cases described "
"below.  Some algebra programs always rearrange terms into a canonical order, "
"which enables them to see that @expr{a b + b a} can be simplified to @expr{2 "
"a b}.  If you are using Basic Simplification mode, Calc assumes you have put "
"the terms into the order you want and generally leaves that order alone, "
"with the consequence that formulas like the above will only be simplified if "
"you explicitly give the @kbd{a s} command.  @xref{Algebraic "
"Simplifications}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22562
msgid ""
"Differences @expr{a - b} are treated like sums @expr{a + (-b)} for purposes "
"of simplification; one of the default simplifications is to rewrite @expr{a "
"+ (-b)} or @expr{(-b) + a}, where @expr{-b} represents a "
"``negative-looking'' term, into @expr{a - b} form.  ``Negative-looking'' "
"means negative numbers, negated formulas like @expr{-x}, and products or "
"quotients in which either term is negative-looking."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22571
msgid ""
"Other simplifications involving negation are @expr{-(-x)} to @expr{x}; "
"@expr{-(a b)} or @expr{-(a/b)} where either @expr{a} or @expr{b} is "
"negative-looking, simplified by negating that term, or else where @expr{a} "
"or @expr{b} is any number, by negating that number; @expr{-(a + b)} to "
"@expr{-a - b}, and @expr{-(b - a)} to @expr{a - b}.  (This, and rewriting "
"@expr{(-b) + a} to @expr{a - b}, are the only cases where the order of terms "
"in a sum is changed by the default simplifications.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22578
msgid ""
"The distributive law is used to simplify sums in some cases: @expr{a x + b "
"x} to @expr{(a + b) x}, where @expr{a} represents a number or an implicit 1 "
"or @mathit{-1} (as in @expr{x} or @expr{-x})  and similarly for @expr{b}.  "
"Use the @kbd{a c}, @w{@kbd{a f}}, or @kbd{j M} commands to merge sums with "
"non-numeric coefficients using the distributive law."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22586
msgid ""
"The distributive law is only used for sums of two terms, or for adjacent "
"terms in a larger sum.  Thus @expr{a + b + b + c} is simplified to @expr{a + "
"2 b + c}, but @expr{a + b + c + b} is not simplified.  The reason is that "
"comparing all terms of a sum with one another would require time "
"proportional to the square of the number of terms; Calc omits potentially "
"slow operations like this in basic simplification mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22590
msgid ""
"Finally, @expr{a + 0} and @expr{0 + a} are simplified to @expr{a}.  A "
"consequence of the above rules is that @expr{0 - a} is simplified to "
"@expr{-a}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22601
msgid ""
"The products @expr{1 a} and @expr{a 1} are simplified to @expr{a}; "
"@expr{(-1) a} and @expr{a (-1)} are simplified to @expr{-a}; @expr{0 a} and "
"@expr{a 0} are simplified to @expr{0}, except that in Matrix mode where "
"@expr{a} is not provably scalar the result is the generic zero matrix "
"@samp{idn(0)}, and that if @expr{a} is infinite the result is @samp{nan}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22605
msgid ""
"Also, @expr{(-a) b} and @expr{a (-b)} are simplified to @expr{-(a b)}, where "
"this occurs for negated formulas but not for regular negative numbers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22608
msgid ""
"Products are commuted only to move numbers to the front: @expr{a b 2} is "
"commuted to @expr{2 a b}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22614
msgid ""
"The product @expr{a (b + c)} is distributed over the sum only if @expr{a} "
"and at least one of @expr{b} and @expr{c} are numbers: @expr{2 (x + 3)} goes "
"to @expr{2 x + 6}.  The formula @expr{(-a) (b - c)}, where @expr{-a} is a "
"negative number, is rewritten to @expr{a (c - b)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22625
msgid ""
"The distributive law of products and powers is used for adjacent terms of "
"the product: @expr{x^a x^b} goes to @texline @math{x^{a+b}} @infoline "
"@expr{x^(a+b)} where @expr{a} is a number, or an implicit 1 (as in "
"@expr{x}), or the implicit one-half of @expr{@tfn{sqrt}(x)}, and similarly "
"for @expr{b}.  The result is written using @samp{sqrt} or @samp{1/sqrt} if "
"the sum of the powers is @expr{1/2} or @expr{-1/2}, respectively.  If the "
"sum of the powers is zero, the product is simplified to @expr{1} or to "
"@samp{idn(1)} if Matrix mode is enabled."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22633
msgid ""
"The product of a negative power times anything but another negative power is "
"changed to use division: @texline @math{x^{-2} y} @infoline @expr{x^(-2) y} "
"goes to @expr{y / x^2} unless Matrix mode is in effect and neither @expr{x} "
"nor @expr{y} are scalar (in which case it is considered unsafe to rearrange "
"the order of the terms)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22636
msgid ""
"Finally, @expr{a (b/c)} is rewritten to @expr{(a b)/c}, and also @expr{(a/b) "
"c} is changed to @expr{(a c)/b} unless in Matrix mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22646
msgid ""
"Simplifications for quotients are analogous to those for products.  The "
"quotient @expr{0 / x} is simplified to @expr{0}, with the same exceptions "
"that were noted for @expr{0 x}.  Likewise, @expr{x / 1} and @expr{x / (-1)} "
"are simplified to @expr{x} and @expr{-x}, respectively."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22650
msgid ""
"The quotient @expr{x / 0} is left unsimplified or changed to an infinite "
"quantity, as directed by the current infinite mode.  @xref{Infinite Mode}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22659
msgid ""
"The expression @texline @math{a / b^{-c}} @infoline @expr{a / b^(-c)} is "
"changed to @expr{a b^c}, where @expr{-c} is any negative-looking power.  "
"Also, @expr{1 / b^c} is changed to @texline @math{b^{-c}} @infoline "
"@expr{b^(-c)} for any power @expr{c}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22665
msgid ""
"Also, @expr{(-a) / b} and @expr{a / (-b)} go to @expr{-(a/b)}; @expr{(a/b) / "
"c} goes to @expr{a / (b c)}; and @expr{a / (b/c)} goes to @expr{(a c) / b} "
"unless Matrix mode prevents this rearrangement.  Similarly, @expr{a / (b:c)} "
"is simplified to @expr{(c:b) a} for any fraction @expr{b:c}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22670
msgid ""
"The distributive law is applied to @expr{(a + b) / c} only if @expr{c} and "
"at least one of @expr{a} and @expr{b} are numbers.  Quotients of powers and "
"square roots are distributed just as described for multiplication."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22676
msgid ""
"Quotients of products cancel only in the leading terms of the numerator and "
"denominator.  In other words, @expr{a x b / a y b} is canceled to @expr{x b "
"/ y b} but not to @expr{x / y}.  Once again this is because full "
"cancellation can be slow; use @kbd{a s} to cancel all terms of the quotient."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22680
msgid ""
"Quotients of negative-looking values are simplified according to @expr{(-a) "
"/ (-b)} to @expr{a / b}, @expr{(-a) / (b - c)} to @expr{a / (c - b)}, and "
"@expr{(a - b) / (-c)} to @expr{(b - a) / c}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22691
msgid ""
"The formula @expr{x^0} is simplified to @expr{1}, or to @samp{idn(1)} in "
"Matrix mode.  The formula @expr{0^x} is simplified to @expr{0} unless "
"@expr{x} is a negative number, complex number or zero.  If @expr{x} is "
"negative, complex or @expr{0.0}, @expr{0^x} is an infinity or an "
"unsimplified formula according to the current infinite mode.  The expression "
"@expr{0^0} is simplified to @expr{1}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22709
msgid ""
"Powers of products or quotients @expr{(a b)^c}, @expr{(a/b)^c} are "
"distributed to @expr{a^c b^c}, @expr{a^c / b^c} only if @expr{c} is an "
"integer, or if either @expr{a} or @expr{b} are nonnegative real numbers.  "
"Powers of powers @expr{(a^b)^c} are simplified to @texline @math{a^{b c}} "
"@infoline @expr{a^(b c)} only when @expr{c} is an integer and @expr{b c} "
"also evaluates to an integer.  Without these restrictions these "
"simplifications would not be safe because of problems with principal "
"values.  (In other words, @texline @math{((-3)^{1/2})^2} @infoline "
"@expr{((-3)^1:2)^2} is safe to simplify, but @texline @math{((-3)^2)^{1/2}} "
"@infoline @expr{((-3)^2)^1:2} is not.)  @xref{Declarations}, for ways to "
"inform Calc that your variables satisfy these requirements."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22714
msgid ""
"As a special case of this rule, @expr{@tfn{sqrt}(x)^n} is simplified to "
"@texline @math{x^{n/2}} @infoline @expr{x^(n/2)} only for even integers "
"@expr{n}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22718
msgid ""
"If @expr{a} is known to be real, @expr{b} is an even integer, and @expr{c} "
"is a half- or quarter-integer, then @expr{(a^b)^c} is simplified to "
"@expr{@tfn{abs}(a^(b c))}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22722
msgid ""
"Also, @expr{(-a)^b} is simplified to @expr{a^b} if @expr{b} is an even "
"integer, or to @expr{-(a^b)} if @expr{b} is an odd integer, for any "
"negative-looking expression @expr{-a}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22727
msgid ""
"Square roots @expr{@tfn{sqrt}(x)} generally act like one-half powers "
"@texline @math{x^{1:2}} @infoline @expr{x^1:2} for the purposes of the "
"above-listed simplifications."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22735
msgid ""
"Also, note that @texline @math{1 / x^{1:2}} @infoline @expr{1 / x^1:2} is "
"changed to @texline @math{x^{-1:2}}, @infoline @expr{x^(-1:2)}, but @expr{1 "
"/ @tfn{sqrt}(x)} is left alone."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22750
msgid ""
"Generic identity matrices (@pxref{Matrix Mode}) are simplified by the "
"following rules: @expr{@tfn{idn}(a) + b} to @expr{a + b} if @expr{b} is "
"provably scalar, or expanded out if @expr{b} is a matrix; @expr{@tfn{idn}(a) "
"+ @tfn{idn}(b)} to @expr{@tfn{idn}(a + b)}; @expr{-@tfn{idn}(a)} to "
"@expr{@tfn{idn}(-a)}; @expr{a @tfn{idn}(b)} to @expr{@tfn{idn}(a b)} if "
"@expr{a} is provably scalar, or to @expr{a b} if @expr{a} is provably "
"non-scalar; @expr{@tfn{idn}(a) @tfn{idn}(b)} to @expr{@tfn{idn}(a b)}; "
"analogous simplifications for quotients involving @code{idn}; and "
"@expr{@tfn{idn}(a)^n} to @expr{@tfn{idn}(a^n)} where @expr{n} is an integer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22761
msgid ""
"The @code{floor} function and other integer truncation functions vanish if "
"the argument is provably integer-valued, so that "
"@expr{@tfn{floor}(@tfn{round}(x))} simplifies to @expr{@tfn{round}(x)}.  "
"Also, combinations of @code{float}, @code{floor} and its friends, and "
"@code{ffloor} and its friends, are simplified in appropriate ways.  "
"@xref{Integer Truncation}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22767
msgid ""
"The expression @expr{@tfn{abs}(-x)} changes to @expr{@tfn{abs}(x)}.  The "
"expression @expr{@tfn{abs}(@tfn{abs}(x))} changes to @expr{@tfn{abs}(x)}; in "
"fact, @expr{@tfn{abs}(x)} changes to @expr{x} or @expr{-x} if @expr{x} is "
"provably nonnegative or nonpositive (@pxref{Declarations})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22771
msgid ""
"While most functions do not recognize the variable @code{i} as an imaginary "
"number, the @code{arg} function does handle the two cases "
"@expr{@tfn{arg}(@tfn{i})} and @expr{@tfn{arg}(-@tfn{i})} just for "
"convenience."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22779
msgid ""
"The expression @expr{@tfn{conj}(@tfn{conj}(x))} simplifies to @expr{x}.  "
"Various other expressions involving @code{conj}, @code{re}, and @code{im} "
"are simplified, especially if some of the arguments are provably real or "
"involve the constant @code{i}.  For example, @expr{@tfn{conj}(a + b i)} is "
"changed to @expr{@tfn{conj}(a) - @tfn{conj}(b) i}, or to @expr{a - b i} if "
"@expr{a} and @expr{b} are known to be real."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22785
msgid ""
"Functions like @code{sin} and @code{arctan} generally don't have any default "
"simplifications beyond simply evaluating the functions for suitable numeric "
"arguments and infinity.  The algebraic simplifications described in the next "
"section do provide some simplifications for these functions, though."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22791
msgid ""
"One important simplification that does occur is that "
"@expr{@tfn{ln}(@tfn{e})} is simplified to 1, and @expr{@tfn{ln}(@tfn{e}^x)} "
"is simplified to @expr{x} for any @expr{x}.  This occurs even if you have "
"stored a different value in the Calc variable @samp{e}; but this would be a "
"bad idea in any case if you were also using natural logarithms!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22798
msgid ""
"Among the logical functions, @tfn{!(@var{a} <= @var{b})} changes to "
"@tfn{@var{a} > @var{b}} and so on.  Equations and inequalities where both "
"sides are either negative-looking or zero are simplified by negating both "
"sides and reversing the inequality.  While it might seem reasonable to "
"simplify @expr{!!x} to @expr{x}, this would not be valid in general because "
"@expr{!!2} is 1, not 2."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22802
msgid ""
"Most other Calc functions have few if any basic simplifications defined, "
"aside of course from evaluation when the arguments are suitable numbers."
msgstr ""

#. type: node
#: ../../calc.texi:22803 ../../calc.texi:23036 ../../calc.texi:23129
#, no-wrap
msgid "Unsafe Simplifications"
msgstr ""

#. type: cindex
#: ../../calc.texi:22807
#, no-wrap
msgid "Algebraic simplifications"
msgstr ""

#. type: Plain text
#: ../../calc.texi:22816
msgid ""
"This section describes all simplifications that are performed by the "
"algebraic simplification mode, which is the default simplification mode.  If "
"you have switched to a different simplification mode, you can switch back "
"with the @kbd{m A} command. Even in other simplification modes, the @kbd{a "
"s} command will use these algebraic simplifications to simplify the formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22826
msgid ""
"There is a variable, @code{AlgSimpRules}, in which you can put rewrites to "
"be applied. Its use is analogous to @code{EvalRules}, but without the "
"special restrictions.  Basically, the simplifier does @samp{@w{a r} "
"AlgSimpRules} with an infinite repeat count on the whole expression being "
"simplified, then it traverses the expression applying the built-in rules "
"described below.  If the result is different from the original expression, "
"the process repeats with the basic simplifications (including "
"@code{EvalRules}), then @code{AlgSimpRules}, then the built-in "
"simplifications, and so on."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22836
msgid ""
"Sums are simplified in two ways.  Constant terms are commuted to the end of "
"the sum, so that @expr{a + 2 + b} changes to @expr{a + b + 2}.  The only "
"exception is that a constant will not be commuted away from the first "
"position of a difference, i.e., @expr{2 - x} is not commuted to @expr{-x + "
"2}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22841
msgid ""
"Also, terms of sums are combined by the distributive law, as in @expr{x + y "
"+ 2 x} to @expr{y + 3 x}.  This always occurs for adjacent terms, but Calc's "
"algebraic simplifications compare all pairs of terms including non-adjacent "
"ones."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22853
msgid ""
"Products are sorted into a canonical order using the commutative law.  For "
"example, @expr{b c a} is commuted to @expr{a b c}.  This allows easier "
"comparison of products; for example, the basic simplifications will not "
"change @expr{x y + y x} to @expr{2 x y}, but the algebraic simplifications; "
"it first rewrites the sum to @expr{x y + x y} which can then be recognized "
"as a sum of identical terms."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22858
msgid ""
"The canonical ordering used to sort terms of products has the property that "
"real-valued numbers, interval forms and infinities come first, and are "
"sorted into increasing order.  The @kbd{V S} command uses the same ordering "
"when sorting a vector."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22862
msgid ""
"Sorting of terms of products is inhibited when Matrix mode is turned on; in "
"this case, Calc will never exchange the order of two terms unless it knows "
"at least one of the terms is a scalar."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22866
msgid ""
"Products of powers are distributed by comparing all pairs of terms, using "
"the same method that the default simplifications use for adjacent terms of "
"products."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22874
msgid ""
"Even though sums are not sorted, the commutative law is still taken into "
"account when terms of a product are being compared.  Thus @expr{(x + y) (y + "
"x)} will be simplified to @expr{(x + y)^2}.  A subtle point is that @expr{(x "
"- y) (y - x)} will @emph{not} be simplified to @expr{-(x - y)^2}; Calc does "
"not notice that one term can be written as a constant times the other, even "
"if that constant is @mathit{-1}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22880
msgid ""
"A fraction times any expression, @expr{(a:b) x}, is changed to a quotient "
"involving integers: @expr{a x / b}.  This is not done for floating-point "
"numbers like @expr{0.5}, however.  This is one reason why you may find it "
"convenient to turn Fraction mode on while doing algebra; @pxref{Fraction "
"Mode}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22893
msgid ""
"Quotients are simplified by comparing all terms in the numerator with all "
"terms in the denominator for possible cancellation using the distributive "
"law.  For example, @expr{a x^2 b / c x^3 d} will cancel @expr{x^2} from the "
"top and bottom to get @expr{a b / c x d}.  (The terms in the denominator "
"will then be rearranged to @expr{c d x} as described above.)  If there is "
"any common integer or fractional factor in the numerator and denominator, it "
"is canceled out; for example, @expr{(4 x + 6) / 8 x} simplifies to @expr{(2 "
"x + 3) / 4 x}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22899
msgid ""
"Non-constant common factors are not found even by algebraic "
"simplifications.  To cancel the factor @expr{a} in @expr{(a x + a) / a^2} "
"you could first use @kbd{j M} on the product @expr{a x} to Merge the "
"numerator to @expr{a (1+x)}, which can then be simplified successfully."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22911
msgid ""
"Integer powers of the variable @code{i} are simplified according to the "
"identity @expr{i^2 = -1}.  If you store a new value other than the complex "
"number @expr{(0,1)} in @code{i}, this simplification will no longer occur.  "
"This is not done by the basic simplifications; in case someone (unwisely) "
"wants to use the name @code{i} for a variable unrelated to complex numbers, "
"they can use basic simplification mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22921
msgid ""
"Square roots of integer or rational arguments are simplified in several "
"ways.  (Note that these will be left unevaluated only in Symbolic mode.)  "
"First, square integer or rational factors are pulled out so that "
"@expr{@tfn{sqrt}(8)} is rewritten as @texline @math{2\\,@tfn{sqrt}(2)}.  "
"@infoline @expr{2 sqrt(2)}.  Conceptually speaking this implies factoring "
"the argument into primes and moving pairs of primes out of the square root, "
"but for reasons of efficiency Calc only looks for primes up to 29."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22926
msgid ""
"Square roots in the denominator of a quotient are moved to the numerator: "
"@expr{1 / @tfn{sqrt}(3)} changes to @expr{@tfn{sqrt}(3) / 3}.  The same "
"effect occurs for the square root of a fraction: @expr{@tfn{sqrt}(2:3)} "
"changes to @expr{@tfn{sqrt}(6) / 3}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22936
msgid ""
"The @code{%} (modulo) operator is simplified in several ways when the "
"modulus @expr{M} is a positive real number.  First, if the argument is of "
"the form @expr{x + n} for some real number @expr{n}, then @expr{n} is itself "
"reduced modulo @expr{M}.  For example, @samp{(x - 23) % 10} is simplified to "
"@samp{(x + 7) % 10}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22944
msgid ""
"If the argument is multiplied by a constant, and this constant has a common "
"integer divisor with the modulus, then this factor is canceled out.  For "
"example, @samp{12 x % 15} is changed to @samp{3 (4 x % 5)} by factoring out "
"3.  Also, @samp{(12 x + 1) % 15} is changed to @samp{3 ((4 x + 1:3) % 5)}.  "
"While these forms may not seem ``simpler,'' they allow Calc to discover "
"useful information about modulo forms in the presence of declarations."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22952
msgid ""
"If the modulus is 1, then Calc can use @code{int} declarations to evaluate "
"the expression.  For example, the idiom @samp{x % 2} is often used to check "
"whether a number is odd or even.  As described above, @w{@samp{2 n % 2}} and "
"@samp{(2 n + 1) % 2} are simplified to @samp{2 (n % 1)} and @samp{2 ((n + "
"1:2) % 1)}, respectively; Calc can simplify these to 0 and 1 (respectively) "
"if @code{n} has been declared to be an integer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22965
msgid ""
"Trigonometric functions are simplified in several ways.  Whenever a products "
"of two trigonometric functions can be replaced by a single function, the "
"replacement is made; for example, @expr{@tfn{tan}(x) @tfn{cos}(x)} is "
"simplified to @expr{@tfn{sin}(x)}.  Reciprocals of trigonometric functions "
"are replaced by their reciprocal function; for example, "
"@expr{1/@tfn{sec}(x)} is simplified to @expr{@tfn{cos}(x)}.  The "
"corresponding simplifications for the hyperbolic functions are also handled."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22972
msgid ""
"Trigonometric functions of their inverse functions are simplified. The "
"expression @expr{@tfn{sin}(@tfn{arcsin}(x))} is simplified to @expr{x}, and "
"similarly for @code{cos} and @code{tan}.  Trigonometric functions of "
"inverses of different trigonometric functions can also be simplified, as in "
"@expr{@tfn{sin}(@tfn{arccos}(x))} to @expr{@tfn{sqrt}(1 - x^2)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22977
msgid ""
"If the argument to @code{sin} is negative-looking, it is simplified to "
"@expr{-@tfn{sin}(x)}, and similarly for @code{cos} and @code{tan}.  Finally, "
"certain special values of the argument are recognized; @pxref{Trigonometric "
"and Hyperbolic Functions}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22981
msgid ""
"Hyperbolic functions of their inverses and of negative-looking arguments are "
"also handled, as are exponentials of inverse hyperbolic functions."
msgstr ""

#. type: Plain text
#: ../../calc.texi:22991
msgid ""
"No simplifications for inverse trigonometric and hyperbolic functions are "
"known, except for negative arguments of @code{arcsin}, @code{arctan}, "
"@code{arcsinh}, and @code{arctanh}.  Note that "
"@expr{@tfn{arcsin}(@tfn{sin}(x))} can @emph{not} safely change to @expr{x}, "
"since this only correct within an integer multiple of @texline @math{2 \\pi} "
"@infoline @expr{2 pi} radians or 360 degrees.  However, "
"@expr{@tfn{arcsinh}(@tfn{sinh}(x))} is simplified to @expr{x} if @expr{x} is "
"known to be real."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23010
msgid ""
"Several simplifications that apply to logarithms and exponentials are that "
"@expr{@tfn{exp}(@tfn{ln}(x))}, @texline @tfn{e}@math{^{\\ln(x)}}, @infoline "
"@expr{e^@tfn{ln}(x)}, and @texline @math{10^{{\\rm log10}(x)}} @infoline "
"@expr{10^@tfn{log10}(x)} all reduce to @expr{x}.  Also, "
"@expr{@tfn{ln}(@tfn{exp}(x))}, etc., can reduce to @expr{x} if @expr{x} is "
"provably real.  The form @expr{@tfn{exp}(x)^y} is simplified to "
"@expr{@tfn{exp}(x y)}.  If @expr{x} is a suitable multiple of @texline "
"@math{\\pi i} @infoline @expr{pi i} (as described above for the "
"trigonometric functions), then @expr{@tfn{exp}(x)} or @expr{e^x} will be "
"expanded.  Finally, @expr{@tfn{ln}(x)} is simplified to a form involving "
"@code{pi} and @code{i} where @expr{x} is provably negative, positive "
"imaginary, or negative imaginary."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23014
msgid ""
"The error functions @code{erf} and @code{erfc} are simplified when their "
"arguments are negative-looking or are calls to the @code{conj} function."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23027
msgid ""
"Equations and inequalities are simplified by canceling factors of products, "
"quotients, or sums on both sides.  Inequalities change sign if a negative "
"multiplicative factor is canceled.  Non-constant multiplicative factors as "
"in @expr{a b = a c} are canceled from equations only if they are provably "
"nonzero (generally because they were declared so; @pxref{Declarations}).  "
"Factors are canceled from inequalities only if they are nonzero and their "
"sign is known."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23035
msgid ""
"Simplification also replaces an equation or inequality with 1 or 0 (``true'' "
"or ``false'') if it can through the use of declarations.  If @expr{x} is "
"declared to be an integer greater than 5, then @expr{x < 3}, @expr{x = 3}, "
"and @expr{x = 7.5} are all simplified to 0, but @expr{x > 3} is simplified "
"to 1.  By a similar analysis, @expr{abs(x) >= 0} is simplified to 1, as is "
"@expr{x^2 >= 0} if @expr{x} is known to be real."
msgstr ""

#. type: subsection
#: ../../calc.texi:23037
#, no-wrap
msgid "``Unsafe'' Simplifications"
msgstr ""

#. type: cindex
#: ../../calc.texi:23040
#, no-wrap
msgid "Unsafe simplifications"
msgstr ""

#. type: cindex
#: ../../calc.texi:23041
#, no-wrap
msgid "Extended simplification"
msgstr ""

#. type: kindex
#: ../../calc.texi:23042
#, no-wrap
msgid "a e"
msgstr ""

#. type: pindex
#: ../../calc.texi:23044
#, no-wrap
msgid "calc-simplify-extended"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23057
msgid ""
"@tindex esimplify Calc is capable of performing some simplifications which "
"may sometimes be desired but which are not ``safe'' in all cases.  The "
"@kbd{a e} (@code{calc-simplify-extended}) [@code{esimplify}] command applies "
"the algebraic simplifications as well as these extended, or ``unsafe'', "
"simplifications.  Use this only if you know the values in your formula lie "
"in the restricted ranges for which these simplifications are valid.  You can "
"use Extended Simplification mode (@kbd{m E}) to have these simplifications "
"done automatically."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23063
msgid ""
"The symbolic integrator uses these extended simplifications; one effect of "
"this is that the integrator's results must be used with caution.  Where an "
"integral table will often attach conditions like ``for positive @expr{a} "
"only,'' Calc (like most other symbolic integration programs)  will simply "
"produce an unqualified result."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23069
msgid ""
"Because @kbd{a e}'s simplifications are unsafe, it is sometimes better to "
"type @kbd{C-u -3 a v}, which does extended simplification only on the top "
"level of the formula without affecting the sub-formulas.  In fact, @kbd{C-u "
"-3 j v} allows you to target extended simplification to any specific part of "
"a formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23074
msgid ""
"The variable @code{ExtSimpRules} contains rewrites to be applied when the "
"extended simplifications are used.  These are applied in addition to "
"@code{EvalRules} and @code{AlgSimpRules}.  (The @kbd{a r AlgSimpRules} step "
"described above is simply followed by an @kbd{a r ExtSimpRules} step.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23076
msgid "Following is a complete list of the ``unsafe'' simplifications."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23090
msgid ""
"Inverse trigonometric or hyperbolic functions, called with their "
"corresponding non-inverse functions as arguments, are simplified.  For "
"example, @expr{@tfn{arcsin}(@tfn{sin}(x))} changes to @expr{x}.  Also, "
"@expr{@tfn{arcsin}(@tfn{cos}(x))} and @expr{@tfn{arccos}(@tfn{sin}(x))} both "
"change to @expr{@tfn{pi}/2 - x}.  These simplifications are unsafe because "
"they are valid only for values of @expr{x} in a certain range; outside that "
"range, values are folded down to the 360-degree range that the inverse "
"trigonometric functions always produce."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23100
msgid ""
"Powers of powers @expr{(x^a)^b} are simplified to @texline @math{x^{a b}} "
"@infoline @expr{x^(a b)} for all @expr{a} and @expr{b}.  These results will "
"be valid only in a restricted range of @expr{x}; for example, in @texline "
"@math{(x^2)^{1:2}} @infoline @expr{(x^2)^1:2} the powers cancel to get "
"@expr{x}, which is valid for positive values of @expr{x} but not for "
"negative or complex values."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23105
msgid ""
"Similarly, @expr{@tfn{sqrt}(x^a)} and @expr{@tfn{sqrt}(x)^a} are both "
"simplified (possibly unsafely) to @texline @math{x^{a/2}}.  @infoline "
"@expr{x^(a/2)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23109
msgid ""
"Forms like @expr{@tfn{sqrt}(1 - sin(x)^2)} are simplified to, e.g., "
"@expr{@tfn{cos}(x)}.  Calc has identities of this sort for @code{sin}, "
"@code{cos}, @code{tan}, @code{sinh}, and @code{cosh}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23114
msgid ""
"Arguments of square roots are partially factored to look for squared terms "
"that can be extracted.  For example, @expr{@tfn{sqrt}(a^2 b^3 + a^3 b^2)} "
"simplifies to @expr{a b @tfn{sqrt}(a+b)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23119
msgid ""
"The simplifications of @expr{@tfn{ln}(@tfn{exp}(x))}, "
"@expr{@tfn{ln}(@tfn{e}^x)}, and @expr{@tfn{log10}(10^x)} to @expr{x} are "
"also unsafe because of problems with principal values (although these "
"simplifications are safe if @expr{x} is known to be real)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23128
msgid ""
"Common factors are canceled from products on both sides of an equation, even "
"if those factors may be zero: @expr{a x / b x} to @expr{a / b}.  Such "
"factors are never canceled from inequalities: Even the extended "
"simplifications are not bold enough to reduce @expr{a x < b x} to @expr{a < "
"b} (or @expr{a > b}, depending on whether you believe @expr{x} is positive "
"or negative).  The @kbd{a M /} command can be used to divide a factor out of "
"both sides of an inequality."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23138
msgid ""
"The simplifications described in this section (as well as the algebraic "
"simplifications) are applied when units need to be simplified.  They can be "
"applied using the @kbd{u s} (@code{calc-simplify-units}) command, or will be "
"done automatically in Units Simplification mode (@kbd{m U}).  @xref{Basic "
"Operations on Units}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23142
msgid ""
"The variable @code{UnitSimpRules} contains rewrites to be applied by units "
"simplifications.  These are applied in addition to @code{EvalRules} and "
"@code{AlgSimpRules}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23145
msgid ""
"Scalar mode is automatically put into effect when simplifying units.  "
"@xref{Matrix Mode}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23152
msgid ""
"Sums @expr{a + b} involving units are simplified by extracting the units of "
"@expr{a} as if by the @kbd{u x} command (call the result @expr{u_a}), then "
"simplifying the expression @expr{b / u_a} using @kbd{u b} and @kbd{u s}.  If "
"the result has units then the sum is inconsistent and is left alone.  "
"Otherwise, it is rewritten in terms of the units @expr{u_a}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23156
msgid ""
"If units auto-ranging mode is enabled, products or quotients in which the "
"first argument is a number which is out of range for the leading unit are "
"modified accordingly."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23162
msgid ""
"When canceling and combining units in products and quotients, Calc accounts "
"for unit names that differ only in the prefix letter.  For example, @samp{2 "
"km m} is simplified to @samp{2000 m^2}.  However, compatible but different "
"units like @code{ft} and @code{in} are not combined in this way."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23166
msgid ""
"Quotients @expr{a / b} are simplified in three additional ways.  First, if "
"@expr{b} is a number or a product beginning with a number, Calc computes the "
"reciprocal of this number and moves it to the numerator."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23172
msgid ""
"Second, for each pair of unit names from the numerator and denominator of a "
"quotient, if the units are compatible (e.g., they are both units of area) "
"then they are replaced by the ratio between those units.  For example, in "
"@samp{3 s in N / kg cm} the units @samp{in / cm} will be replaced by "
"@expr{2.54}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23176
msgid ""
"Third, if the units in the quotient exactly cancel out, so that a @kbd{u b} "
"command on the quotient would produce a dimensionless number for an answer, "
"then the quotient simplifies to that number."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23185
msgid ""
"For powers and square roots, the ``unsafe'' simplifications @expr{(a b)^c} "
"to @expr{a^c b^c}, @expr{(a/b)^c} to @expr{a^c / b^c}, and @expr{(a^b)^c} to "
"@texline @math{a^{b c}} @infoline @expr{a^(b c)} are done if the powers are "
"real numbers.  (These are safe in the context of units because all numbers "
"involved can reasonably be assumed to be real.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23201
msgid ""
"Also, if a unit name is raised to a fractional power, and the base units in "
"that unit name all occur to powers which are a multiple of the denominator "
"of the power, then the unit name is expanded out into its base units, which "
"can then be simplified according to the previous paragraph.  For example, "
"@samp{acre^1.5} is simplified by noting that @expr{1.5 = 3:2}, that "
"@samp{acre} is defined in terms of @samp{m^2}, and that the 2 in the power "
"of @code{m} is a multiple of 2 in @expr{3:2}.  Thus, @code{acre^1.5} is "
"replaced by approximately @texline @math{(4046 m^2)^{1.5}} @infoline "
"@expr{(4046 m^2)^1.5}, which is then changed to @texline @math{4046^{1.5} "
"\\, (m^2)^{1.5}}, @infoline @expr{4046^1.5 (m^2)^1.5}, then to @expr{257440 "
"m^3}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23208
msgid ""
"The functions @code{float}, @code{frac}, @code{clean}, @code{abs}, as well "
"as @code{floor} and the other integer truncation functions, applied to unit "
"names or products or quotients involving units, are simplified.  For "
"example, @samp{round(1.6 in)} is changed to @samp{round(1.6) round(in)}; the "
"lefthand term evaluates to 2, and the righthand term simplifies to "
"@code{in}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23213
msgid ""
"The functions @code{sin}, @code{cos}, and @code{tan} with arguments that "
"have angular units like @code{rad} or @code{arcmin} are simplified by "
"converting to base units (radians), then evaluating with the angular mode "
"temporarily set to radians."
msgstr ""

#. type: node
#: ../../calc.texi:23214 ../../calc.texi:23438 ../../calc.texi:23439 ../../calc.texi:23456 ../../calc.texi:23514 ../../calc.texi:23601 ../../calc.texi:23727 ../../calc.texi:23765 ../../calc.texi:23786
#, no-wrap
msgid "Calculus"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23224
msgid ""
"A @dfn{polynomial} is a sum of terms which are coefficients times various "
"powers of a ``base'' variable.  For example, @expr{2 x^2 + 3 x - 4} is a "
"polynomial in @expr{x}.  Some formulas can be considered polynomials in "
"several different variables: @expr{1 + 2 x + 3 y + 4 x y^2} is a polynomial "
"in both @expr{x} and @expr{y}.  Polynomial coefficients are often numbers, "
"but they may in general be any formulas not involving the base variable."
msgstr ""

#. type: kindex
#: ../../calc.texi:23225
#, no-wrap
msgid "a f"
msgstr ""

#. type: pindex
#: ../../calc.texi:23226
#, no-wrap
msgid "calc-factor"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23233
msgid ""
"@tindex factor The @kbd{a f} (@code{calc-factor}) [@code{factor}] command "
"factors a polynomial into a product of terms.  For example, the polynomial "
"@expr{x^3 + 2 x^2 + x} is factored into @samp{x*(x+1)^2}.  As another "
"example, @expr{a c + b d + b c + a d} is factored into the product @expr{(a "
"+ b) (c + d)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23243
msgid ""
"Calc currently has three algorithms for factoring.  Formulas which are "
"linear in several variables, such as the second example above, are merged "
"according to the distributive law.  Formulas which are polynomials in a "
"single variable, with constant integer or fractional coefficients, are "
"factored into irreducible linear and/or quadratic terms.  The first example "
"above factors into three linear terms (@expr{x}, @expr{x+1}, and @expr{x+1} "
"again).  Finally, formulas which do not fit the above criteria are handled "
"by the algebraic rewrite mechanism."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23255
msgid ""
"Calc's polynomial factorization algorithm works by using the general "
"root-finding command (@w{@kbd{a P}}) to solve for the roots of the "
"polynomial.  It then looks for roots which are rational numbers or "
"complex-conjugate pairs, and converts these into linear and quadratic terms, "
"respectively.  Because it uses floating-point arithmetic, it may be unable "
"to find terms that involve large integers (whose number of digits approaches "
"the current precision).  Also, irreducible factors of degree higher than "
"quadratic are not found, and polynomials in more than one variable are not "
"treated.  (A more robust factorization algorithm may be included in a future "
"version of Calc.)"
msgstr ""

#. type: vindex
#: ../../calc.texi:23256
#, no-wrap
msgid "FactorRules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23261
msgid "@tindex thecoefs"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23286
msgid ""
"@tindex thefactors The rewrite-based factorization method uses rules stored "
"in the variable @code{FactorRules}.  @xref{Rewrite Rules}, for a discussion "
"of the operation of rewrite rules.  The default @code{FactorRules} are able "
"to factor quadratic forms symbolically into two linear terms, @expr{(a x + "
"b) (c x + d)}.  You can edit these rules to include other cases if you "
"wish.  To use the rules, Calc builds the formula @samp{thecoefs(x, [a, b, c, "
"...])} where @code{x} is the polynomial base variable and @code{a}, "
"@code{b}, etc., are polynomial coefficients (which may be numbers or "
"formulas).  The constant term is written first, i.e., in the @code{a} "
"position.  When the rules complete, they should have changed the formula "
"into the form @samp{thefactors(x, [f1, f2, f3, ...])} where each @code{fi} "
"should be a factored term, e.g., @samp{x - ai}.  Calc then multiplies these "
"terms together to get the complete factored form of the polynomial.  If the "
"rules do not change the @code{thecoefs} call to a @code{thefactors} call, "
"@kbd{a f} leaves the polynomial alone on the assumption that it is "
"unfactorable.  (Note that the function names @code{thecoefs} and "
"@code{thefactors} are used only as placeholders; there are no actual Calc "
"functions by those names.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:23287
#, no-wrap
msgid "H a f"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23300
msgid ""
"@tindex factors The @kbd{H a f} [@code{factors}] command also factors a "
"polynomial, but it returns a list of factors instead of an expression which "
"is the product of the factors.  Each factor is represented by a sub-vector "
"of the factor, and the power with which it appears.  For example, @expr{x^5 "
"+ x^4 - 33 x^3 + 63 x^2} factors to @expr{(x + 7) x^2 (x - 3)^2} in @kbd{a "
"f}, or to @expr{[ [x, 2], [x+7, 1], [x-3, 2] ]} in @kbd{H a f}.  If there is "
"an overall numeric factor, it always comes first in the list.  The functions "
"@code{factor} and @code{factors} allow a second argument when written in "
"algebraic form; @samp{factor(x,v)} factors @expr{x} with respect to the "
"specific variable @expr{v}.  The default is to factor with respect to all "
"the variables that appear in @expr{x}."
msgstr ""

#. type: kindex
#: ../../calc.texi:23301
#, no-wrap
msgid "a c"
msgstr ""

#. type: pindex
#: ../../calc.texi:23302
#, no-wrap
msgid "calc-collect"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23314
msgid ""
"@tindex collect The @kbd{a c} (@code{calc-collect}) [@code{collect}] command "
"rearranges a formula as a polynomial in a given variable, ordered in "
"decreasing powers of that variable.  For example, given @expr{1 + 2 x + 3 y "
"+ 4 x y^2} on the stack, @kbd{a c x} would produce @expr{(2 + 4 y^2) x + (1 "
"+ 3 y)}, and @kbd{a c y} would produce @expr{(4 x) y^2 + 3 y + (1 + 2 x)}.  "
"The polynomial will be expanded out using the distributive law as necessary: "
"Collecting @expr{x} in @expr{(x - 1)^3} produces @expr{x^3 - 3 x^2 + 3 x - "
"1}.  Terms not involving @expr{x} will not be expanded."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23320
msgid ""
"The ``variable'' you specify at the prompt can actually be any expression: "
"@kbd{a c ln(x+1)} will collect together all terms multiplied by "
"@samp{ln(x+1)} or integer powers thereof.  If @samp{x} also appears in the "
"formula in a context other than @samp{ln(x+1)}, @kbd{a c} will treat those "
"occurrences as unrelated to @samp{ln(x+1)}, i.e., as constants."
msgstr ""

#. type: kindex
#: ../../calc.texi:23321
#, no-wrap
msgid "a x"
msgstr ""

#. type: pindex
#: ../../calc.texi:23322
#, no-wrap
msgid "calc-expand"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23330
msgid ""
"@tindex expand The @kbd{a x} (@code{calc-expand}) [@code{expand}] command "
"expands an expression by applying the distributive law everywhere.  It "
"applies to products, quotients, and powers involving sums.  By default, it "
"fully distributes all parts of the expression.  With a numeric prefix "
"argument, the distributive law is applied only the specified number of "
"times, then the partially expanded expression is left on the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23339
msgid ""
"The @kbd{a x} and @kbd{j D} commands are somewhat redundant.  Use @kbd{a x} "
"if you want to expand all products of sums in your formula.  Use @kbd{j D} "
"if you want to expand a particular specified term of the formula.  There is "
"an exactly analogous correspondence between @kbd{a f} and @kbd{j M}.  (The "
"@kbd{j D} and @kbd{j M} commands also know many other kinds of expansions, "
"such as @samp{exp(a + b) = exp(a) exp(b)}, which @kbd{a x} and @kbd{a f} do "
"not do.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23348
msgid ""
"Calc's automatic simplifications will sometimes reverse a partial "
"expansion.  For example, the first step in expanding @expr{(x+1)^3} is to "
"write @expr{(x+1) (x+1)^2}.  If @kbd{a x} stops there and tries to put this "
"formula onto the stack, though, Calc will automatically simplify it back to "
"@expr{(x+1)^3} form.  The solution is to turn simplification off first "
"(@pxref{Simplification Modes}), or to run @kbd{a x} without a numeric prefix "
"argument so that it expands all the way in one step."
msgstr ""

#. type: kindex
#: ../../calc.texi:23349
#, no-wrap
msgid "a a"
msgstr ""

#. type: pindex
#: ../../calc.texi:23350
#, no-wrap
msgid "calc-apart"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23359
msgid ""
"@tindex apart The @kbd{a a} (@code{calc-apart}) [@code{apart}] command "
"expands a rational function by partial fractions.  A rational function is "
"the quotient of two polynomials; @code{apart} pulls this apart into a sum of "
"rational functions with simple denominators.  In algebraic notation, the "
"@code{apart} function allows a second argument that specifies which variable "
"to use as the ``base''; by default, Calc chooses the base variable "
"automatically."
msgstr ""

#. type: kindex
#: ../../calc.texi:23360
#, no-wrap
msgid "a n"
msgstr ""

#. type: pindex
#: ../../calc.texi:23361
#, no-wrap
msgid "calc-normalize-rat"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23369
msgid ""
"@tindex nrat The @kbd{a n} (@code{calc-normalize-rat}) [@code{nrat}] command "
"attempts to arrange a formula into a quotient of two polynomials.  For "
"example, given @expr{1 + (a + b/c) / d}, the result would be @expr{(b + a c "
"+ c d) / c d}.  The quotient is reduced, so that @kbd{a n} will simplify "
"@expr{(x^2 + 2x + 1) / (x^2 - 1)} by dividing out the common factor @expr{x "
"+ 1}, yielding @expr{(x + 1) / (x - 1)}."
msgstr ""

#. type: kindex
#: ../../calc.texi:23370
#, no-wrap
msgid "a \\"
msgstr ""

#. type: pindex
#: ../../calc.texi:23371
#, no-wrap
msgid "calc-poly-div"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23382
msgid ""
"@tindex pdiv The @kbd{a \\} (@code{calc-poly-div}) [@code{pdiv}] command "
"divides two polynomials @expr{u} and @expr{v}, yielding a new polynomial "
"@expr{q}.  If several variables occur in the inputs, the inputs are "
"considered multivariate polynomials.  (Calc divides by the variable with the "
"largest power in @expr{u} first, or, in the case of equal powers, chooses "
"the variables in alphabetical order.)  For example, dividing @expr{x^2 + 3 x "
"+ 2} by @expr{x + 2} yields @expr{x + 1}.  The remainder from the division, "
"if any, is reported at the bottom of the screen and is also placed in the "
"Trail along with the quotient."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23388
msgid ""
"Using @code{pdiv} in algebraic notation, you can specify the particular "
"variable to be used as the base: @code{pdiv(@var{a},@var{b},@var{x})}.  If "
"@code{pdiv} is given only two arguments (as is always the case with the "
"@kbd{a \\} command), then it does a multivariate division as outlined above."
msgstr ""

#. type: kindex
#: ../../calc.texi:23389
#, no-wrap
msgid "a %"
msgstr ""

#. type: pindex
#: ../../calc.texi:23390
#, no-wrap
msgid "calc-poly-rem"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23398
msgid ""
"@tindex prem The @kbd{a %} (@code{calc-poly-rem}) [@code{prem}] command "
"divides two polynomials and keeps the remainder @expr{r}.  The quotient "
"@expr{q} is discarded.  For any formulas @expr{a} and @expr{b}, the results "
"of @kbd{a \\} and @kbd{a %} satisfy @expr{a = q b + r}.  (This is analogous "
"to plain @kbd{\\} and @kbd{%}, which compute the integer quotient and "
"remainder from dividing two numbers.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:23399
#, no-wrap
msgid "a /"
msgstr ""

#. type: kindex
#: ../../calc.texi:23400
#, no-wrap
msgid "H a /"
msgstr ""

#. type: pindex
#: ../../calc.texi:23401
#, no-wrap
msgid "calc-poly-div-rem"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23410
msgid ""
"@tindex pdivrem @tindex pdivide The @kbd{a /} (@code{calc-poly-div-rem}) "
"[@code{pdivrem}] command divides two polynomials and reports both the "
"quotient and the remainder as a vector @expr{[q, r]}.  The @kbd{H a /} "
"[@code{pdivide}] command divides two polynomials and constructs the formula "
"@expr{q + r/b} on the stack.  (Naturally if the remainder is zero, this will "
"immediately simplify to @expr{q}.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:23411
#, no-wrap
msgid "a g"
msgstr ""

#. type: pindex
#: ../../calc.texi:23412
#, no-wrap
msgid "calc-poly-gcd"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23422
msgid ""
"@tindex pgcd The @kbd{a g} (@code{calc-poly-gcd}) [@code{pgcd}] command "
"computes the greatest common divisor of two polynomials.  (The GCD actually "
"is unique only to within a constant multiplier; Calc attempts to choose a "
"GCD which will be unsurprising.)  For example, the @kbd{a n} command uses "
"@kbd{a g} to take the GCD of the numerator and denominator of a quotient, "
"then divides each by the result using @kbd{a \\}.  (The definition of GCD "
"ensures that this division can take place without leaving a remainder.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23430
msgid ""
"While the polynomials used in operations like @kbd{a /} and @kbd{a g} often "
"have integer coefficients, this is not required.  Calc can also deal with "
"polynomials over the rationals or floating-point reals.  Polynomials with "
"modulo-form coefficients are also useful in many applications; if you enter "
"@samp{(x^2 + 3 x - 1) mod 5}, Calc automatically transforms this into a "
"polynomial over the field of integers mod 5: @samp{(1 mod 5) x^2 + (3 mod 5) "
"x + (4 mod 5)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23434
msgid ""
"Congratulations and thanks go to Ove Ewerlid "
"(@code{ewerlid@@mizar.DoCS.UU.SE}), who contributed many of the polynomial "
"routines used in the above commands."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23437
msgid ""
"@xref{Decomposing Polynomials}, for several useful functions for extracting "
"the individual coefficients of a polynomial."
msgstr ""

#. type: node
#: ../../calc.texi:23438 ../../calc.texi:23786 ../../calc.texi:23787 ../../calc.texi:23830 ../../calc.texi:23944 ../../calc.texi:24011 ../../calc.texi:24155
#, no-wrap
msgid "Solving Equations"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23447
msgid ""
"The following calculus commands do not automatically simplify their inputs "
"or outputs using @code{calc-simplify}.  You may find it helps to do this by "
"hand by typing @kbd{a s} or @kbd{a e}.  It may also help to use @kbd{a x} "
"and/or @kbd{a c} to arrange a result in the most readable way."
msgstr ""

#. type: menuentry
#: ../../calc.texi:23454
msgid "Differentiation::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:23454
msgid "Integration::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:23454
msgid "Customizing the Integrator::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:23454
msgid "Numerical Integration::"
msgstr ""

#. type: subsection
#: ../../calc.texi:23454 ../../calc.texi:23727 ../../calc.texi:23765 ../../calc.texi:23766
#, no-wrap
msgid "Taylor Series"
msgstr ""

#. type: node
#: ../../calc.texi:23456 ../../calc.texi:23457 ../../calc.texi:23514
#, no-wrap
msgid "Differentiation"
msgstr ""

#. type: node
#: ../../calc.texi:23456 ../../calc.texi:23514 ../../calc.texi:23515 ../../calc.texi:23601
#, no-wrap
msgid "Integration"
msgstr ""

#. type: kindex
#: ../../calc.texi:23460
#, no-wrap
msgid "a d"
msgstr ""

#. type: kindex
#: ../../calc.texi:23461
#, no-wrap
msgid "H a d"
msgstr ""

#. type: pindex
#: ../../calc.texi:23462
#, no-wrap
msgid "calc-derivative"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23476
msgid ""
"@tindex deriv @tindex tderiv The @kbd{a d} (@code{calc-derivative}) "
"[@code{deriv}] command computes the derivative of the expression on the top "
"of the stack with respect to some variable, which it will prompt you to "
"enter.  Normally, variables in the formula other than the specified "
"differentiation variable are considered constant, i.e., @samp{deriv(y,x)} is "
"reduced to zero.  With the Hyperbolic flag, the @code{tderiv} (total "
"derivative) operation is used instead, in which derivatives of variables are "
"not reduced to zero unless those variables are known to be ``constant,'' "
"i.e., independent of any other variables.  (The built-in special variables "
"like @code{pi} are considered constant, as are variables that have been "
"declared @code{const}; @pxref{Declarations}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23479
msgid ""
"With a numeric prefix argument @var{n}, this command computes the @var{n}th "
"derivative."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23484
msgid ""
"When working with trigonometric functions, it is best to switch to Radians "
"mode first (with @w{@kbd{m r}}).  The derivative of @samp{sin(x)} in degrees "
"is @samp{(pi/180) cos(x)}, probably not the expected answer!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23490
msgid ""
"If you use the @code{deriv} function directly in an algebraic formula, you "
"can write @samp{deriv(f,x,x0)} which represents the derivative of @expr{f} "
"with respect to @expr{x}, evaluated at the point @texline @math{x=x_0}.  "
"@infoline @expr{x=x0}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23496
msgid ""
"If the formula being differentiated contains functions which Calc does not "
"know, the derivatives of those functions are produced by adding primes "
"(apostrophe characters).  For example, @samp{deriv(f(2x), x)} produces "
"@samp{2 f'(2 x)}, where the function @code{f'} represents the derivative of "
"@code{f}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23505
msgid ""
"For functions you have defined with the @kbd{Z F} command, Calc expands the "
"functions according to their defining formulas unless you have also defined "
"@code{f'} suitably.  For example, suppose we define @samp{sinc(x) = "
"sin(x)/x} using @kbd{Z F}.  If we then differentiate the formula "
"@samp{sinc(2 x)}, the formula will be expanded to @samp{sin(2 x) / (2 x)} "
"and differentiated.  However, if we also define @samp{sinc'(x) = dsinc(x)}, "
"say, then Calc will write the result as @samp{2 dsinc(2 x)}.  "
"@xref{Algebraic Definitions}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23513
msgid ""
"For multi-argument functions @samp{f(x,y,z)}, the derivative with respect to "
"the first argument is written @samp{f'(x,y,z)}; derivatives with respect to "
"the other arguments are @samp{f'2(x,y,z)} and @samp{f'3(x,y,z)}.  Various "
"higher-order derivatives can be formed in the obvious way, e.g., "
"@samp{f'@var{}'(x)} (the second derivative of @code{f}) or "
"@samp{f'@var{}'2'3(x,y,z)} (@code{f} differentiated with respect to each "
"argument once)."
msgstr ""

#. type: node
#: ../../calc.texi:23514 ../../calc.texi:23601 ../../calc.texi:23602 ../../calc.texi:23727
#, no-wrap
msgid "Customizing the Integrator"
msgstr ""

#. type: kindex
#: ../../calc.texi:23518
#, no-wrap
msgid "a i"
msgstr ""

#. type: pindex
#: ../../calc.texi:23519
#, no-wrap
msgid "calc-integral"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23535
msgid ""
"@tindex integ The @kbd{a i} (@code{calc-integral}) [@code{integ}] command "
"computes the indefinite integral of the expression on the top of the stack "
"with respect to a prompted-for variable.  The integrator is not guaranteed "
"to work for all integrable functions, but it is able to integrate several "
"large classes of formulas.  In particular, any polynomial or rational "
"function (a polynomial divided by a polynomial) is acceptable.  (Rational "
"functions don't have to be in explicit quotient form, however; @texline "
"@math{x/(1+x^{-2})} @infoline @expr{x/(1+x^-2)} is not strictly a quotient "
"of polynomials, but it is equivalent to @expr{x^3/(x^2+1)}, which is.)  "
"Also, square roots of terms involving @expr{x} and @expr{x^2} may appear in "
"rational functions being integrated.  Finally, rational functions involving "
"trigonometric or hyperbolic functions can be integrated."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23540
msgid ""
"With an argument (@kbd{C-u a i}), this command will compute the definite "
"integral of the expression on top of the stack.  In this case, the command "
"will again prompt for an integration variable, then prompt for a lower limit "
"and an upper limit."
msgstr ""

#. type: ifnottex
#: ../../calc.texi:23547
msgid ""
"If you use the @code{integ} function directly in an algebraic formula, you "
"can also write @samp{integ(f,x,v)} which expresses the resulting indefinite "
"integral in terms of variable @code{v} instead of @code{x}.  With four "
"arguments, @samp{integ(f(x),x,a,b)} represents a definite integral from "
"@code{a} to @code{b}."
msgstr ""

#. type: tex
#: ../../calc.texi:23554
#, no-wrap
msgid ""
"If you use the @code{integ} function directly in an algebraic formula,\n"
"you can also write @samp{integ(f,x,v)} which expresses the resulting\n"
"indefinite integral in terms of variable @code{v} instead of @code{x}.\n"
"With four arguments, @samp{integ(f(x),x,a,b)} represents a definite\n"
"integral $\\int_a^b f(x) \\, dx$.\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23574
msgid ""
"Please note that the current implementation of Calc's integrator sometimes "
"produces results that are significantly more complex than they need to be.  "
"For example, the integral Calc finds for @texline @math{1/(x+\\sqrt{x^2+1})} "
"@infoline @expr{1/(x+sqrt(x^2+1))} is several times more complicated than "
"the answer Mathematica returns for the same input, although the two forms "
"are numerically equivalent.  Also, any indefinite integral should be "
"considered to have an arbitrary constant of integration added to it, "
"although Calc does not write an explicit constant of integration in its "
"result.  For example, Calc's solution for @texline @math{1/(1+\\tan x)} "
"@infoline @expr{1/(1+tan(x))} differs from the solution given in the "
"@emph{CRC Math Tables} by a constant factor of @texline @math{\\pi i / 2} "
"@infoline @expr{pi i / 2}, due to a different choice of constant of "
"integration."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23580
msgid ""
"The Calculator remembers all the integrals it has done.  If conditions "
"change in a way that would invalidate the old integrals, say, a switch from "
"Degrees to Radians mode, then they will be thrown out.  If you suspect this "
"is not happening when it should, use the @code{calc-flush-caches} command; "
"@pxref{Caches}."
msgstr ""

#. type: vindex
#: ../../calc.texi:23581
#, no-wrap
msgid "IntegLimit"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23594
msgid ""
"Calc normally will pursue integration by substitution or integration by "
"parts up to 3 nested times before abandoning an approach as fruitless.  If "
"the integrator is taking too long, you can lower this limit by storing a "
"number (like 2) in the variable @code{IntegLimit}.  (The @kbd{s I} command "
"is a convenient way to edit @code{IntegLimit}.)  If this variable has no "
"stored value or does not contain a nonnegative integer, a limit of 3 is "
"used.  The lower this limit is, the greater the chance that Calc will be "
"unable to integrate a function it could otherwise handle.  Raising this "
"limit allows the Calculator to solve more integrals, though the time it "
"takes may grow exponentially.  You can monitor the integrator's actions by "
"creating an Emacs buffer called @file{*Trace*}.  If such a buffer exists, "
"the @kbd{a i} command will write a log of its actions there."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23600
msgid ""
"If you want to manipulate integrals in a purely symbolic way, you can set "
"the integration nesting limit to 0 to prevent all but fast table-lookup "
"solutions of integrals.  You might then wish to define rewrite rules for "
"integration by parts, various kinds of substitutions, and so on.  "
"@xref{Rewrite Rules}."
msgstr ""

#. type: node
#: ../../calc.texi:23601 ../../calc.texi:23727 ../../calc.texi:23728 ../../calc.texi:23765
#, no-wrap
msgid "Numerical Integration"
msgstr ""

#. type: vindex
#: ../../calc.texi:23605
#, no-wrap
msgid "IntegRules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23622
msgid ""
"Calc has two built-in rewrite rules called @code{IntegRules} and "
"@code{IntegAfterRules} which you can edit to define new integration "
"methods.  @xref{Rewrite Rules}.  At each step of the integration process, "
"Calc wraps the current integrand in a call to the fictitious function "
"@samp{integtry(@var{expr},@var{var})}, where @var{expr} is the integrand and "
"@var{var} is the integration variable.  If your rules rewrite this to be a "
"plain formula (not a call to @code{integtry}), then Calc will use this "
"formula as the integral of @var{expr}.  For example, the rule "
"@samp{integtry(mysin(x),x) := -mycos(x)} would define a rule to integrate a "
"function @code{mysin} that acts like the sine function.  Then, putting "
"@samp{4 mysin(2y+1)} on the stack and typing @kbd{a i y} will produce the "
"integral @samp{-2 mycos(2y+1)}.  Note that Calc has automatically made "
"various transformations on the integral to allow it to use your rule; "
"integral tables generally give rules for @samp{mysin(a x + b)}, but you "
"don't need to use this much generality in your @code{IntegRules}."
msgstr ""

#. type: cindex
#: ../../calc.texi:23623
#, no-wrap
msgid "Exponential integral Ei(x)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23643
msgid ""
"@tindex Ei As a more serious example, the expression @samp{exp(x)/x} cannot "
"be integrated in terms of the standard functions, so the ``exponential "
"integral'' function @texline @math{{\\rm Ei}(x)} @infoline @expr{Ei(x)} was "
"invented to describe it.  We can get Calc to do this integral in terms of a "
"made-up @code{Ei} function by adding the rule @samp{[integtry(exp(x)/x, x) "
":= Ei(x)]} to @code{IntegRules}.  Now entering @samp{exp(2x)/x} on the stack "
"and typing @kbd{a i x} yields @samp{Ei(2 x)}.  This new rule will work with "
"Calc's various built-in integration methods (such as integration by "
"substitution) to solve a variety of other problems involving @code{Ei}: For "
"example, now Calc will also be able to integrate @samp{exp(exp(x))} and "
"@samp{ln(ln(x))} (to get @samp{Ei(exp(x))} and @samp{x ln(ln(x)) - "
"Ei(ln(x))}, respectively)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23657
msgid ""
"Your rule may do further integration by calling @code{integ}.  For example, "
"@samp{integtry(twice(u),x) := twice(integ(u))} allows Calc to integrate "
"@samp{twice(sin(x))} to get @samp{twice(-cos(x))}.  Note that @code{integ} "
"was called with only one argument.  This notation is allowed only within "
"@code{IntegRules}; it means ``integrate this with respect to the same "
"integration variable.'' If Calc is unable to integrate @code{u}, the "
"integration that invoked @code{IntegRules} also fails.  Thus integrating "
"@samp{twice(f(x))} fails, returning the unevaluated integral "
"@samp{integ(twice(f(x)), x)}.  It is still valid to call @code{integ} with "
"two or more arguments, however; in this case, if @code{u} is not integrable, "
"@code{twice} itself will still be integrated: If the above rule is changed "
"to @samp{... := twice(integ(u,x))}, then integrating @samp{twice(f(x))} will "
"yield @samp{twice(integ(f(x),x))}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23670
msgid ""
"If a rule instead produces the formula @samp{integsubst(@var{sexpr}, "
"@var{svar})}, either replacing the top-level @code{integtry} call or nested "
"anywhere inside the expression, then Calc will apply the substitution "
"@samp{@var{u} = @var{sexpr}(@var{svar})} to try to integrate the original "
"@var{expr}.  For example, the rule @samp{sqrt(a) := integsubst(sqrt(x),x)} "
"says that if Calc ever finds a square root in the integrand, it should "
"attempt the substitution @samp{u = sqrt(x)}.  (This particular rule is "
"unnecessary because Calc always tries ``obvious'' substitutions where "
"@var{sexpr} actually appears in the integrand.)  The variable @var{svar} may "
"be the same as the @var{var} that appeared in the call to @code{integtry}, "
"but it need not be."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23685
msgid ""
"When integrating according to an @code{integsubst}, Calc uses the equation "
"solver to find the inverse of @var{sexpr} (if the integrand refers to "
"@var{var} anywhere except in subexpressions that exactly match "
"@var{sexpr}).  It uses the differentiator to find the derivative of "
"@var{sexpr} and/or its inverse (it has two methods that use one derivative "
"or the other).  You can also specify these items by adding extra arguments "
"to the @code{integsubst} your rules construct; the general form is "
"@samp{integsubst(@var{sexpr}, @var{svar}, @var{sinv}, @var{sprime})}, where "
"@var{sinv} is the inverse of @var{sexpr} (still written as a function of "
"@var{svar}), and @var{sprime} is the derivative of @var{sexpr} with respect "
"to @var{svar}.  If you don't specify these things, and Calc is not able to "
"work them out on its own with the information it knows, then your "
"substitution rule will work only in very specific, simple cases."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23691
msgid ""
"Calc applies @code{IntegRules} as if by @kbd{C-u 1 a r IntegRules}; in other "
"words, Calc stops rewriting as soon as any rule in your rule set succeeds.  "
"(If it weren't for this, the @samp{integsubst(sqrt(x),x)} example above "
"would keep on adding layers of @code{integsubst} calls forever!)"
msgstr ""

#. type: vindex
#: ../../calc.texi:23692
#, no-wrap
msgid "IntegSimpRules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23699
msgid ""
"Another set of rules, stored in @code{IntegSimpRules}, are applied every "
"time the integrator uses algebraic simplifications to simplify an "
"intermediate result.  For example, putting the rule @samp{twice(x) := 2 x} "
"into @code{IntegSimpRules} would tell Calc to convert the @code{twice} "
"function into a form it knows whenever integration is attempted."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23707
msgid ""
"One more way to influence the integrator is to define a function with the "
"@kbd{Z F} command (@pxref{Algebraic Definitions}).  Calc's integrator "
"automatically expands such functions according to their defining formulas, "
"even if you originally asked for the function to be left unevaluated for "
"symbolic arguments.  (Certain other Calc systems, such as the differentiator "
"and the equation solver, also do this.)"
msgstr ""

#. type: vindex
#: ../../calc.texi:23708
#, no-wrap
msgid "IntegAfterRules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23726
msgid ""
"Sometimes Calc is able to find a solution to your integral, but it expresses "
"the result in a way that is unnecessarily complicated.  If this happens, you "
"can either use @code{integsubst} as described above to try to hint at a more "
"direct path to the desired result, or you can use @code{IntegAfterRules}.  "
"This is an extra rule set that runs after the main integrator returns its "
"result; basically, Calc does an @kbd{a r IntegAfterRules} on the result "
"before showing it to you.  (It also does algebraic simplifications, without "
"@code{IntegSimpRules}, after that to further simplify the result.)  For "
"example, Calc's integrator sometimes produces expressions of the form "
"@samp{ln(1+x) - ln(1-x)}; the default @code{IntegAfterRules} rewrite this "
"into the more readable form @samp{2 arctanh(x)}.  Note that, unlike "
"@code{IntegRules}, @code{IntegSimpRules} and @code{IntegAfterRules} are "
"applied any number of times until no further changes are possible.  "
"Rewriting by @code{IntegAfterRules} occurs only after the main integrator "
"has finished, not at every step as for @code{IntegRules} and "
"@code{IntegSimpRules}."
msgstr ""

#. type: kindex
#: ../../calc.texi:23731
#, no-wrap
msgid "a I"
msgstr ""

#. type: pindex
#: ../../calc.texi:23732
#, no-wrap
msgid "calc-num-integral"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23740
msgid ""
"@tindex ninteg If you want a purely numerical answer to an integration "
"problem, you can use the @kbd{a I} (@code{calc-num-integral}) "
"[@code{ninteg}] command.  This command prompts for an integration variable, "
"a lower limit, and an upper limit.  Except for the integration variable, all "
"other variables that appear in the integrand formula must have stored "
"values.  (A stored value, if any, for the integration variable itself is "
"ignored.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23749
msgid ""
"Numerical integration works by evaluating your formula at many points in the "
"specified interval.  Calc uses an ``open Romberg'' method; this means that "
"it does not evaluate the formula actually at the endpoints (so that it is "
"safe to integrate @samp{sin(x)/x} from zero, for example).  Also, the "
"Romberg method works especially well when the function being integrated is "
"fairly smooth.  If the function is not smooth, Calc will have to evaluate it "
"at quite a few points before it can accurately determine the value of the "
"integral."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23756
msgid ""
"Integration is much faster when the current precision is small.  It is best "
"to set the precision to the smallest acceptable number of digits before you "
"use @kbd{a I}.  If Calc appears to be taking too long, press @kbd{C-g} to "
"halt it and try a lower precision.  If Calc still appears to need hundreds "
"of evaluations, check to make sure your function is well-behaved in the "
"specified interval."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23764
msgid ""
"It is possible for the lower integration limit to be @samp{-inf} (minus "
"infinity).  Likewise, the upper limit may be plus infinity.  Calc internally "
"transforms the integral into an equivalent one with finite limits.  However, "
"integration to or across singularities is not supported: The integral of "
"@samp{1/sqrt(x)} from 0 to 1 exists (it can be found by Calc's symbolic "
"integrator, for example), but @kbd{a I} will fail because the integrand goes "
"to infinity at one of the endpoints."
msgstr ""

#. type: kindex
#: ../../calc.texi:23769
#, no-wrap
msgid "a t"
msgstr ""

#. type: pindex
#: ../../calc.texi:23770
#, no-wrap
msgid "calc-taylor"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23781
msgid ""
"@tindex taylor The @kbd{a t} (@code{calc-taylor}) [@code{taylor}] command "
"computes a power series expansion or Taylor series of a function.  You "
"specify the variable and the desired number of terms.  You may give an "
"expression of the form @samp{@var{var} = @var{a}} or @samp{@var{var} - "
"@var{a}} instead of just a variable to produce a Taylor expansion about the "
"point @var{a}.  You may specify the number of terms with a numeric prefix "
"argument; otherwise the command will prompt you for the number of terms.  "
"Note that many series expansions have coefficients of zero for some terms, "
"so you may appear to get fewer terms than you asked for."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23785
msgid ""
"If the @kbd{a i} command is unable to find a symbolic integral for a "
"function, you can get an approximation by integrating the function's Taylor "
"series."
msgstr ""

#. type: node
#: ../../calc.texi:23786 ../../calc.texi:24155 ../../calc.texi:24156 ../../calc.texi:24174 ../../calc.texi:24250 ../../calc.texi:24322 ../../calc.texi:24348
#, no-wrap
msgid "Numerical Solutions"
msgstr ""

#. type: kindex
#: ../../calc.texi:23790
#, no-wrap
msgid "a S"
msgstr ""

#. type: pindex
#: ../../calc.texi:23791
#, no-wrap
msgid "calc-solve-for"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23793
msgid "@tindex solve"
msgstr ""

#. type: cindex
#: ../../calc.texi:23793
#, no-wrap
msgid "Equations, solving"
msgstr ""

#. type: cindex
#: ../../calc.texi:23794
#, no-wrap
msgid "Solving equations"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23801
msgid ""
"The @kbd{a S} (@code{calc-solve-for}) [@code{solve}] command rearranges an "
"equation to solve for a specific variable.  An equation is an expression of "
"the form @expr{L = R}.  For example, the command @kbd{a S x} will rearrange "
"@expr{y = 3x + 6} to the form, @expr{x = y/3 - 2}.  If the input is not an "
"equation, it is treated like an equation of the form @expr{X = 0}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23818
msgid ""
"This command also works for inequalities, as in @expr{y < 3x + 6}.  Some "
"inequalities cannot be solved where the analogous equation could be; for "
"example, solving @texline @math{a < b \\, c} @infoline @expr{a < b c} for "
"@expr{b} is impossible without knowing the sign of @expr{c}.  In this case, "
"@kbd{a S} will produce the result @texline @math{b "
"\\mathbin{\\hbox{\\code{!=}}} a/c} @infoline @expr{b != a/c} (using the "
"not-equal-to operator) to signify that the direction of the inequality is "
"now unknown.  The inequality @texline @math{a \\le b \\, c} @infoline "
"@expr{a <= b c} is not even partially solved.  @xref{Declarations}, for a "
"way to tell Calc that the signs of the variables in a formula are in fact "
"known."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23823
msgid ""
"Two useful commands for working with the result of @kbd{a S} are @kbd{a .} "
"(@pxref{Logical Operations}), which converts @expr{x = y/3 - 2} to @expr{y/3 "
"- 2}, and @kbd{s l} (@pxref{Let Command}) which evaluates another formula "
"with @expr{x} set equal to @expr{y/3 - 2}."
msgstr ""

#. type: menuentry
#: ../../calc.texi:23828
msgid "Multiple Solutions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:23828
msgid "Solving Systems of Equations::"
msgstr ""

#. type: subsection
#: ../../calc.texi:23828 ../../calc.texi:23944 ../../calc.texi:24011 ../../calc.texi:24012
#, no-wrap
msgid "Decomposing Polynomials"
msgstr ""

#. type: node
#: ../../calc.texi:23830 ../../calc.texi:23831 ../../calc.texi:23944
#, no-wrap
msgid "Multiple Solutions"
msgstr ""

#. type: node
#: ../../calc.texi:23830 ../../calc.texi:23944 ../../calc.texi:23945 ../../calc.texi:24011
#, no-wrap
msgid "Solving Systems of Equations"
msgstr ""

#. type: kindex
#: ../../calc.texi:23834
#, no-wrap
msgid "H a S"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23848
msgid ""
"@tindex fsolve Some equations have more than one solution.  The Hyperbolic "
"flag (@code{H a S}) [@code{fsolve}] tells the solver to report the fully "
"general family of solutions.  It will invent variables @code{n1}, @code{n2}, "
"@dots{}, which represent independent arbitrary integers, and @code{s1}, "
"@code{s2}, @dots{}, which represent independent arbitrary signs (either "
"@mathit{+1} or @mathit{-1}).  If you don't use the Hyperbolic flag, Calc "
"will use zero in place of all arbitrary integers, and plus one in place of "
"all arbitrary signs.  Note that variables like @code{n1} and @code{s1} are "
"not given any special interpretation in Calc except by the equation solver "
"itself.  As usual, you can use the @w{@kbd{s l}} (@code{calc-let}) command "
"to obtain solutions for various actual values of these variables."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23857
msgid ""
"For example, @kbd{' x^2 = y @key{RET} H a S x @key{RET}} solves to get "
"@samp{x = s1 sqrt(y)}, indicating that the two solutions to the equation are "
"@samp{sqrt(y)} and @samp{-sqrt(y)}.  Another way to think about it is that "
"the square-root operation is really a two-valued function; since every Calc "
"function must return a single result, @code{sqrt} chooses to return the "
"positive result.  Then @kbd{H a S} doctors this result using @code{s1} to "
"indicate the full set of possible values of the mathematical square-root."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23866
msgid ""
"There is a similar phenomenon going the other direction: Suppose we solve "
"@samp{sqrt(y) = x} for @code{y}.  Calc squares both sides to get @samp{y = "
"x^2}.  This is correct, except that it introduces some dubious solutions.  "
"Consider solving @samp{sqrt(y) = -3}: Calc will report @expr{y = 9} as a "
"valid solution, which is true in the mathematical sense of square-root, but "
"false (there is no solution) for the actual Calc positive-valued "
"@code{sqrt}.  This happens for both @kbd{a S} and @kbd{H a S}."
msgstr ""

#. type: cindex
#: ../../calc.texi:23867
#, no-wrap
msgid "@code{GenCount} variable"
msgstr ""

#. type: vindex
#: ../../calc.texi:23868
#, no-wrap
msgid "GenCount"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23873
msgid "@tindex an"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23891
msgid ""
"@tindex as If you store a positive integer in the Calc variable "
"@code{GenCount}, then Calc will generate formulas of the form "
"@samp{as(@var{n})} for arbitrary signs, and @samp{an(@var{n})} for arbitrary "
"integers, where @var{n} represents successive values taken by incrementing "
"@code{GenCount} by one.  While the normal arbitrary sign and integer symbols "
"start over at @code{s1} and @code{n1} with each new Calc command, the "
"@code{GenCount} approach will give each arbitrary value a name that is "
"unique throughout the entire Calc session.  Also, the arbitrary values are "
"function calls instead of variables, which is advantageous in some cases.  "
"For example, you can make a rewrite rule that recognizes all arbitrary signs "
"using a pattern like @samp{as(n)}.  The @kbd{s l} command only works on "
"variables, but you can use the @kbd{a b} (@code{calc-substitute})  command "
"to substitute actual values for function calls like @samp{as(3)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23894
msgid ""
"The @kbd{s G} (@code{calc-edit-GenCount}) command is a convenient way to "
"create or edit this variable.  Press @kbd{C-c C-c} to finish."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23898
msgid ""
"If you have not stored a value in @code{GenCount}, or if the value in that "
"variable is not a positive integer, the regular @code{s1}/@code{n1} notation "
"is used."
msgstr ""

#. type: kindex
#: ../../calc.texi:23899
#, no-wrap
msgid "I a S"
msgstr ""

#. type: kindex
#: ../../calc.texi:23900
#, no-wrap
msgid "H I a S"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23909
msgid ""
"@tindex finv @tindex ffinv With the Inverse flag, @kbd{I a S} [@code{finv}] "
"treats the expression on top of the stack as a function of the specified "
"variable and solves to find the inverse function, written in terms of the "
"same variable.  For example, @kbd{I a S x} inverts @expr{2x + 6} to "
"@expr{x/2 - 3}.  You can use both Inverse and Hyperbolic [@code{ffinv}] to "
"obtain a fully general inverse, as described above."
msgstr ""

#. type: kindex
#: ../../calc.texi:23910
#, no-wrap
msgid "a P"
msgstr ""

#. type: pindex
#: ../../calc.texi:23911
#, no-wrap
msgid "calc-poly-roots"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23926
msgid ""
"@tindex roots Some equations, specifically polynomials, have a known, finite "
"number of solutions.  The @kbd{a P} (@code{calc-poly-roots}) [@code{roots}] "
"command uses @kbd{H a S} to solve an equation in general form, then, for all "
"arbitrary-sign variables like @code{s1}, and all arbitrary-integer variables "
"like @code{n1} for which @code{n1} only usefully varies over a finite range, "
"it expands these variables out to all their possible values.  The results "
"are collected into a vector, which is returned.  For example, "
"@samp{roots(x^4 = 1, x)} returns the four solutions @samp{[1, -1, (0, 1), "
"(0, -1)]}.  Generally an @var{n}th degree polynomial will always have "
"@var{n} roots on the complex plane.  (If you have given a @code{real} "
"declaration for the solution variable, then only the real-valued solutions, "
"if any, will be reported; @pxref{Declarations}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23943
msgid ""
"Note that because @kbd{a P} uses @kbd{H a S}, it is able to deliver symbolic "
"solutions if the polynomial has symbolic coefficients.  Also note that "
"Calc's solver is not able to get exact symbolic solutions to all "
"polynomials.  Polynomials containing powers up to @expr{x^4} can always be "
"solved exactly; polynomials of higher degree sometimes can be: @expr{x^6 + "
"x^3 + 1} is converted to @expr{(x^3)^2 + (x^3) + 1}, which can be solved for "
"@expr{x^3} using the quadratic equation, and then for @expr{x} by taking "
"cube roots.  But in many cases, like @expr{x^6 + x + 1}, Calc does not know "
"how to rewrite the polynomial into a form it can solve.  The @kbd{a P} "
"command can still deliver a list of numerical roots, however, provided that "
"Symbolic mode (@kbd{m s})  is not turned on.  (If you work with Symbolic "
"mode on, recall that the @kbd{N} (@code{calc-eval-num}) key is a handy way "
"to reevaluate the formula on the stack with Symbolic mode temporarily off.)  "
"Naturally, @kbd{a P} can only provide numerical roots if the polynomial "
"coefficients are all numbers (real or complex)."
msgstr ""

#. type: cindex
#: ../../calc.texi:23948
#, no-wrap
msgid "Systems of equations, symbolic"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23954
msgid ""
"You can also use the commands described above to solve systems of "
"simultaneous equations.  Just create a vector of equations, then specify a "
"vector of variables for which to solve.  (You can omit the surrounding "
"brackets when entering the vector of variables at the prompt.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:23963
msgid ""
"For example, putting @samp{[x + y = a, x - y = b]} on the stack and typing "
"@kbd{a S x,y @key{RET}} produces the vector of solutions @samp{[x = a - "
"(a-b)/2, y = (a-b)/2]}.  The result vector will have the same length as the "
"variables vector, and the variables will be listed in the same order there.  "
"Note that the solutions are not always simplified as far as possible; the "
"solution for @expr{x} here could be improved by an application of the @kbd{a "
"n} command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23974
msgid ""
"Calc's algorithm works by trying to eliminate one variable at a time by "
"solving one of the equations for that variable and then substituting into "
"the other equations.  Calc will try all the possibilities, but you can speed "
"things up by noting that Calc first tries to eliminate the first variable "
"with the first equation, then the second variable with the second equation, "
"and so on.  It also helps to put the simpler (e.g., more linear)  equations "
"toward the front of the list.  Calc's algorithm will solve any system of "
"linear equations, and also many kinds of nonlinear systems."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23991
msgid ""
"@tindex elim Normally there will be as many variables as equations.  If you "
"give fewer variables than equations (an ``over-determined'' system of "
"equations), Calc will find a partial solution.  For example, typing @kbd{a S "
"y @key{RET}} with the above system of equations would produce @samp{[y = a - "
"x]}.  There are now several ways to express this solution in terms of the "
"original variables; Calc uses the first one that it finds.  You can control "
"the choice by adding variable specifiers of the form @samp{elim(@var{v})} to "
"the variables list.  This says that @var{v} should be eliminated from the "
"equations; the variable will not appear at all in the solution.  For "
"example, typing @kbd{a S y,elim(x)} would yield @samp{[y = a - (b+a)/2]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:23998
msgid ""
"If the variables list contains only @code{elim} specifiers, Calc simply "
"eliminates those variables from the equations and then returns the resulting "
"set of equations.  For example, @kbd{a S elim(x)} produces @samp{[a - 2 y = "
"b]}.  Every variable eliminated will reduce the number of equations in the "
"system by one."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24006
msgid ""
"Again, @kbd{a S} gives you one solution to the system of equations.  If "
"there are several solutions, you can use @kbd{H a S} to get a general family "
"of solutions, or, if there is a finite number of solutions, you can use "
"@kbd{a P} to get a list.  (In the latter case, the result will take the form "
"of a matrix where the rows are different solutions and the columns "
"correspond to the variables you requested.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24010
msgid ""
"Another way to deal with certain kinds of overdetermined systems of "
"equations is the @kbd{a F} command, which does least-squares fitting to "
"satisfy the equations.  @xref{Curve Fitting}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24031
msgid ""
"@tindex poly The @code{poly} function takes a polynomial and a variable as "
"arguments, and returns a vector of polynomial coefficients (constant "
"coefficient first).  For example, @samp{poly(x^3 + 2 x, x)} returns "
"@expr{[0, 2, 0, 1]}.  If the input is not a polynomial in @expr{x}, the call "
"to @code{poly} is left in symbolic form.  If the input does not involve the "
"variable @expr{x}, the input is returned in a list of length one, "
"representing a polynomial with only a constant coefficient.  The call "
"@samp{poly(x, x)} returns the vector @expr{[0, 1]}.  The last element of the "
"returned vector is guaranteed to be nonzero; note that @samp{poly(0, x)} "
"returns the empty vector @expr{[]}.  Note also that @expr{x} may actually be "
"any formula; for example, @samp{poly(sin(x)^2 - sin(x) + 3, sin(x))} returns "
"@expr{[3, -1, 1]}."
msgstr ""

#. type: cindex
#: ../../calc.texi:24032
#, no-wrap
msgid "Coefficients of polynomial"
msgstr ""

#. type: cindex
#: ../../calc.texi:24033
#, no-wrap
msgid "Degree of polynomial"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24039
msgid ""
"To get the @expr{x^k} coefficient of polynomial @expr{p}, use @samp{poly(p, "
"x)_(k+1)}.  To get the degree of polynomial @expr{p}, use @samp{vlen(poly(p, "
"x)) - 1}.  For example, @samp{poly((x+1)^4, x)} returns @samp{[1, 4, 6, 4, "
"1]}, so @samp{poly((x+1)^4, x)_(2+1)} gives the @expr{x^2} coefficient of "
"this polynomial, 6."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24061
msgid ""
"@tindex gpoly One important feature of the solver is its ability to "
"recognize formulas which are ``essentially'' polynomials.  This ability is "
"made available to the user through the @code{gpoly} function, which is used "
"just like @code{poly}: @samp{gpoly(@var{expr}, @var{var})}.  If @var{expr} "
"is a polynomial in some term which includes @var{var}, then this function "
"will return a vector @samp{[@var{x}, @var{c}, @var{a}]} where @var{x} is the "
"term that depends on @var{var}, @var{c} is a vector of polynomial "
"coefficients (like the one returned by @code{poly}), and @var{a} is a "
"multiplier which is usually 1.  Basically, @samp{@var{expr} = "
"@var{a}*(@var{c}_1 + @var{c}_2 @var{x} + @var{c}_3 @var{x}^2 + ...)}.  The "
"last element of @var{c} is guaranteed to be non-zero, and @var{c} will not "
"equal @samp{[1]} (i.e., the trivial decomposition @var{expr} = @var{x} is "
"not considered a polynomial).  One side effect is that @samp{gpoly(x, x)} "
"and @samp{gpoly(6, x)}, both of which might be expected to recognize their "
"arguments as polynomials, will not because the decomposition is considered "
"trivial."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24064
msgid ""
"For example, @samp{gpoly((x-2)^2, x)} returns @samp{[x, [4, -4, 1], 1]}, "
"since the expanded form of this polynomial is @expr{4 - 4 x + x^2}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24070
msgid ""
"The term @var{x} may itself be a polynomial in @var{var}.  This is done to "
"reduce the size of the @var{c} vector.  For example, @samp{gpoly(x^4 + x^2 - "
"1, x)} returns @samp{[x^2, [-1, 1, 1], 1]}, since a quadratic polynomial in "
"@expr{x^2} is easier to solve than a quartic polynomial in @expr{x}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24073
msgid "A few more examples of the kinds of polynomials @code{gpoly} can discover:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:24082
#, no-wrap
msgid ""
"sin(x) - 1               [sin(x), [-1, 1], 1]\n"
"x + 1/x - 1              [x, [1, -1, 1], 1/x]\n"
"x + 1/x                  [x^2, [1, 1], 1/x]\n"
"x^3 + 2 x                [x^2, [2, 1], x]\n"
"x + x^2:3 + sqrt(x)      [x^1:6, [1, 1, 0, 1], x^1:2]\n"
"x^(2a) + 2 x^a + 5       [x^a, [5, 2, 1], 1]\n"
"(exp(-x) + exp(x)) / 2   [e^(2 x), [0.5, 0.5], e^-x]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24092
msgid ""
"The @code{poly} and @code{gpoly} functions accept a third integer argument "
"which specifies the largest degree of polynomial that is acceptable.  If "
"this is @expr{n}, then only @var{c} vectors of length @expr{n+1} or less "
"will be returned.  Otherwise, the @code{poly} or @code{gpoly} call will "
"remain in symbolic form.  For example, the equation solver can handle "
"quartics and smaller polynomials, so it calls @samp{gpoly(@var{expr}, "
"@var{var}, 4)} to discover whether @var{expr} can be treated by its linear, "
"quadratic, cubic, or quartic formulas."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24109
msgid ""
"@tindex pdeg The @code{pdeg} function computes the degree of a polynomial; "
"@samp{pdeg(p,x)} is the highest power of @code{x} that appears in @code{p}.  "
"This is the same as @samp{vlen(poly(p,x))-1}, but is much more efficient.  "
"If @code{p} is constant with respect to @code{x}, then @samp{pdeg(p,x) = "
"0}.  If @code{p} is not a polynomial in @code{x} (e.g., @samp{pdeg(2 cos(x), "
"x)}, the function remains unevaluated.  It is possible to omit the second "
"argument @code{x}, in which case @samp{pdeg(p)} returns the highest total "
"degree of any term of the polynomial, counting all variables that appear in "
"@code{p}.  Note that @code{pdeg(c) = pdeg(c,x) = 0} for any nonzero constant "
"@code{c}; the degree of the constant zero is considered to be @code{-inf} "
"(minus infinity)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24119
msgid ""
"@tindex plead The @code{plead} function finds the leading term of a "
"polynomial.  Thus @samp{plead(p,x)} is equivalent to "
"@samp{poly(p,x)_vlen(poly(p,x))}, though again more efficient.  In "
"particular, @samp{plead((2x+1)^10, x)} returns 1024 without expanding out "
"the list of coefficients.  The value of @code{plead(p,x)} will be zero only "
"if @expr{p = 0}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24133
msgid ""
"@tindex pcont The @code{pcont} function finds the @dfn{content} of a "
"polynomial.  This is the greatest common divisor of all the coefficients of "
"the polynomial.  With two arguments, @code{pcont(p,x)} effectively uses "
"@samp{poly(p,x)} to get a list of coefficients, then uses @code{pgcd} (the "
"polynomial GCD function) to combine these into an answer.  For example, "
"@samp{pcont(4 x y^2 + 6 x^2 y, x)} is @samp{2 y}.  The content is basically "
"the ``biggest'' polynomial that can be divided into @code{p} exactly.  The "
"sign of the content is the same as the sign of the leading coefficient."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24144
msgid ""
"With only one argument, @samp{pcont(p)} computes the numerical content of "
"the polynomial, i.e., the @code{gcd} of the numerical coefficients of all "
"the terms in the formula.  Note that @code{gcd} is defined on rational "
"numbers as well as integers; it computes the @code{gcd} of the numerators "
"and the @code{lcm} of the denominators.  Thus @samp{pcont(4:3 x y^2 + 6 x^2 "
"y)} returns 2:3.  Dividing the polynomial by this number will clear all the "
"denominators, as well as dividing by any common content in the numerators.  "
"The numerical content of a polynomial is negative only if all the "
"coefficients in the polynomial are negative."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24154
msgid ""
"@tindex pprim The @code{pprim} function finds the @dfn{primitive part} of a "
"polynomial, which is simply the polynomial divided (using @code{pdiv} if "
"necessary) by its content.  If the input polynomial has rational "
"coefficients, the result will have integer coefficients in simplest terms."
msgstr ""

#. type: node
#: ../../calc.texi:24155 ../../calc.texi:24348 ../../calc.texi:24349 ../../calc.texi:24374 ../../calc.texi:24540 ../../calc.texi:24655 ../../calc.texi:24816 ../../calc.texi:25000 ../../calc.texi:25392 ../../calc.texi:25449
#, no-wrap
msgid "Curve Fitting"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24164
msgid ""
"Not all equations can be solved symbolically.  The commands in this section "
"use numerical algorithms that can find a solution to a specific instance of "
"an equation to any desired accuracy.  Note that the numerical commands are "
"slower than their algebraic cousins; it is a good idea to try @kbd{a S} "
"before resorting to these commands."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24167
msgid ""
"(@xref{Curve Fitting}, for some other, more specialized, operations on "
"numerical data.)"
msgstr ""

#. type: menuentry
#: ../../calc.texi:24172
msgid "Root Finding::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:24172
msgid "Minimization::"
msgstr ""

#. type: node
#: ../../calc.texi:24172 ../../calc.texi:24250 ../../calc.texi:24322
#, no-wrap
msgid "Numerical Systems of Equations"
msgstr ""

#. type: node
#: ../../calc.texi:24174 ../../calc.texi:24175 ../../calc.texi:24250
#, no-wrap
msgid "Root Finding"
msgstr ""

#. type: node
#: ../../calc.texi:24174 ../../calc.texi:24250 ../../calc.texi:24251 ../../calc.texi:24322
#, no-wrap
msgid "Minimization"
msgstr ""

#. type: kindex
#: ../../calc.texi:24178
#, no-wrap
msgid "a R"
msgstr ""

#. type: pindex
#: ../../calc.texi:24179
#, no-wrap
msgid "calc-find-root"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24181
msgid "@tindex root"
msgstr ""

#. type: cindex
#: ../../calc.texi:24182
#, no-wrap
msgid "Roots of equations"
msgstr ""

#. type: cindex
#: ../../calc.texi:24183
#, no-wrap
msgid "Numerical root-finding"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24188
msgid ""
"The @kbd{a R} (@code{calc-find-root}) [@code{root}] command finds a "
"numerical solution (or @dfn{root}) of an equation.  (This command treats "
"inequalities the same as equations.  If the input is any other kind of "
"formula, it is interpreted as an equation of the form @expr{X = 0}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24197
msgid ""
"The @kbd{a R} command requires an initial guess on the top of the stack, and "
"a formula in the second-to-top position.  It prompts for a solution "
"variable, which must appear in the formula.  All other variables that appear "
"in the formula must have assigned values, i.e., when a value is assigned to "
"the solution variable and the formula is evaluated with @kbd{=}, it should "
"evaluate to a number.  Any assigned value for the solution variable itself "
"is ignored and unaffected by this command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24206
msgid ""
"When the command completes, the initial guess is replaced on the stack by a "
"vector of two numbers: The value of the solution variable that solves the "
"equation, and the difference between the lefthand and righthand sides of the "
"equation at that value.  Ordinarily, the second number will be zero or very "
"nearly zero.  (Note that Calc uses a slightly higher precision while finding "
"the root, and thus the second number may be slightly different from the "
"value you would compute from the equation yourself.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24209
msgid ""
"The @kbd{v h} (@code{calc-head}) command is a handy way to extract the first "
"element of the result vector, discarding the error term."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24215
msgid ""
"The initial guess can be a real number, in which case Calc searches for a "
"real solution near that number, or a complex number, in which case Calc "
"searches the whole complex plane near that number for a solution, or it can "
"be an interval form which restricts the search to real numbers inside that "
"interval."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24223
msgid ""
"Calc tries to use @kbd{a d} to take the derivative of the equation.  If this "
"succeeds, it uses Newton's method.  If the equation is not differentiable "
"Calc uses a bisection method.  (If Newton's method appears to be going "
"astray, Calc switches over to bisection if it can, or otherwise gives up.  "
"In this case it may help to try again with a slightly different initial "
"guess.)  If the initial guess is a complex number, the function must be "
"differentiable."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24230
msgid ""
"If the formula (or the difference between the sides of an equation)  is "
"negative at one end of the interval you specify and positive at the other "
"end, the root finder is guaranteed to find a root.  Otherwise, Calc "
"subdivides the interval into small parts looking for positive and negative "
"values to bracket the root.  When your guess is an interval, Calc will not "
"look outside that interval for a root."
msgstr ""

#. type: kindex
#: ../../calc.texi:24231
#, no-wrap
msgid "H a R"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24238
msgid ""
"@tindex wroot The @kbd{H a R} [@code{wroot}] command is similar to @kbd{a "
"R}, except that if the initial guess is an interval for which the function "
"has the same sign at both ends, then rather than subdividing the interval "
"Calc attempts to widen it to enclose a root.  Use this mode if you are not "
"sure if the function has a root in your interval."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24244
msgid ""
"If the function is not differentiable, and you give a simple number instead "
"of an interval as your initial guess, Calc uses this widening process even "
"if you did not type the Hyperbolic flag.  (If the function @emph{is} "
"differentiable, Calc uses Newton's method which does not require a bounding "
"interval in order to work.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24249
msgid ""
"If Calc leaves the @code{root} or @code{wroot} function in symbolic form on "
"the stack, it will normally display an explanation for why no root was "
"found.  If you miss this explanation, press @kbd{w} (@code{calc-why}) to get "
"it back."
msgstr ""

#. type: kindex
#: ../../calc.texi:24254
#, no-wrap
msgid "a N"
msgstr ""

#. type: kindex
#: ../../calc.texi:24255
#, no-wrap
msgid "H a N"
msgstr ""

#. type: kindex
#: ../../calc.texi:24256
#, no-wrap
msgid "a X"
msgstr ""

#. type: kindex
#: ../../calc.texi:24257
#, no-wrap
msgid "H a X"
msgstr ""

#. type: pindex
#: ../../calc.texi:24258
#, no-wrap
msgid "calc-find-minimum"
msgstr ""

#. type: pindex
#: ../../calc.texi:24259
#, no-wrap
msgid "calc-find-maximum"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24262
msgid "@tindex minimize @tindex maximize"
msgstr ""

#. type: cindex
#: ../../calc.texi:24262
#, no-wrap
msgid "Minimization, numerical"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24271
msgid ""
"The @kbd{a N} (@code{calc-find-minimum}) [@code{minimize}] command finds a "
"minimum value for a formula.  It is very similar in operation to @kbd{a R} "
"(@code{calc-find-root}): You give the formula and an initial guess on the "
"stack, and are prompted for the name of a variable.  The guess may be either "
"a number near the desired minimum, or an interval enclosing the desired "
"minimum.  The function returns a vector containing the value of the variable "
"which minimizes the formula's value, along with the minimum value itself."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24284
msgid ""
"Note that this command looks for a @emph{local} minimum.  Many functions "
"have more than one minimum; some, like @texline @math{x \\sin x}, @infoline "
"@expr{x sin(x)}, have infinitely many.  In fact, there is no easy way to "
"define the ``global'' minimum of @texline @math{x \\sin x} @infoline @expr{x "
"sin(x)} but Calc can still locate any particular local minimum for you.  "
"Calc basically goes downhill from the initial guess until it finds a point "
"at which the function's value is greater both to the left and to the right.  "
"Calc does not use derivatives when minimizing a function."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24293
msgid ""
"If your initial guess is an interval and it looks like the minimum occurs at "
"one or the other endpoint of the interval, Calc will return that endpoint "
"only if that endpoint is closed; thus, minimizing @expr{17 x} over "
"@expr{[2..3]} will return @expr{[2, 38]}, but minimizing over @expr{(2..3]} "
"would report no minimum found.  In general, you should use closed intervals "
"to find literally the minimum value in that range of @expr{x}, or open "
"intervals to find the local minimum, if any, that happens to lie in that "
"range."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24299
msgid ""
"Most functions are smooth and flat near their minimum values.  Because of "
"this flatness, if the current precision is, say, 12 digits, the variable can "
"only be determined meaningfully to about six digits.  Thus you should set "
"the precision to twice as many digits as you need in your answer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24304
msgid "@tindex wminimize"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24311
msgid ""
"@tindex wmaximize The @kbd{H a N} [@code{wminimize}] command, analogously to "
"@kbd{H a R}, expands the guess interval to enclose a minimum rather than "
"requiring that the minimum lie inside the interval you supply."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24315
msgid ""
"The @kbd{a X} (@code{calc-find-maximum}) [@code{maximize}] and @kbd{H a X} "
"[@code{wmaximize}] commands effectively minimize the negative of the formula "
"you supply."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24321
msgid ""
"The formula must evaluate to a real number at all points inside the interval "
"(or near the initial guess if the guess is a number).  If the initial guess "
"is a complex number the variable will be minimized over the complex numbers; "
"if it is real or an interval it will be minimized over the reals."
msgstr ""

#. type: subsection
#: ../../calc.texi:24323
#, no-wrap
msgid "Systems of Equations"
msgstr ""

#. type: cindex
#: ../../calc.texi:24326
#, no-wrap
msgid "Systems of equations, numerical"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24339
msgid ""
"The @kbd{a R} command can also solve systems of equations.  In this case, "
"the equation should instead be a vector of equations, the guess should "
"instead be a vector of numbers (intervals are not supported), and the "
"variable should be a vector of variables.  You can omit the brackets while "
"entering the list of variables.  Each equation must be differentiable by "
"each variable for this mode to work.  The result will be a vector of two "
"vectors: The variable values that solved the system of equations, and the "
"differences between the sides of the equations with those variable values.  "
"There must be the same number of equations as variables.  Since only plain "
"numbers are allowed as guesses, the Hyperbolic flag has no effect when "
"solving a system of equations."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24347
msgid ""
"It is also possible to minimize over many variables with @kbd{a N} (or "
"maximize with @kbd{a X}).  Once again the variable name should be replaced "
"by a vector of variables, and the initial guess should be an equal-sized "
"vector of initial guesses.  But, unlike the case of multidimensional @kbd{a "
"R}, the formula being minimized should still be a single formula, @emph{not} "
"a vector.  Beware that multidimensional minimization is currently "
"@emph{very} slow."
msgstr ""

#. type: node
#: ../../calc.texi:24348 ../../calc.texi:25449 ../../calc.texi:25450 ../../calc.texi:25610
#, no-wrap
msgid "Summations"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24359
msgid ""
"The @kbd{a F} command fits a set of data to a @dfn{model formula}, such as "
"@expr{y = m x + b} where @expr{m} and @expr{b} are parameters to be "
"determined.  For a typical set of measured data there will be no single "
"@expr{m} and @expr{b} that exactly fit the data; in this case, Calc chooses "
"values of the parameters that provide the closest possible fit.  The model "
"formula can be entered in various ways after the key sequence @kbd{a F} is "
"pressed."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24364
msgid ""
"If the letter @kbd{P} is pressed after @kbd{a F} but before the model "
"description is entered, the data as well as the model formula will be "
"plotted after the formula is determined.  This will be indicated by a ``P'' "
"in the minibuffer after the help message."
msgstr ""

#. type: menuentry
#: ../../calc.texi:24372
msgid "Linear Fits::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:24372
msgid "Polynomial and Multilinear Fits::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:24372
msgid "Error Estimates for Fits::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:24372
msgid "Standard Nonlinear Models::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:24372
msgid "Curve Fitting Details::"
msgstr ""

#. type: node
#: ../../calc.texi:24372 ../../calc.texi:25000 ../../calc.texi:25392
#, no-wrap
msgid "Interpolation"
msgstr ""

#. type: node
#: ../../calc.texi:24374 ../../calc.texi:24375 ../../calc.texi:24540
#, no-wrap
msgid "Linear Fits"
msgstr ""

#. type: node
#: ../../calc.texi:24374 ../../calc.texi:24540 ../../calc.texi:24541 ../../calc.texi:24655
#, no-wrap
msgid "Polynomial and Multilinear Fits"
msgstr ""

#. type: kindex
#: ../../calc.texi:24378
#, no-wrap
msgid "a F"
msgstr ""

#. type: pindex
#: ../../calc.texi:24379
#, no-wrap
msgid "calc-curve-fit"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24381
msgid "@tindex fit"
msgstr ""

#. type: cindex
#: ../../calc.texi:24381
#, no-wrap
msgid "Linear regression"
msgstr ""

#. type: cindex
#: ../../calc.texi:24382
#, no-wrap
msgid "Least-squares fits"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24389
msgid ""
"The @kbd{a F} (@code{calc-curve-fit}) [@code{fit}] command attempts to fit a "
"set of data (@expr{x} and @expr{y} vectors of numbers) to a straight line, "
"polynomial, or other function of @expr{x}.  For the moment we will consider "
"only the case of fitting to a line, and we will ignore the issue of whether "
"or not the model was in fact a good fit for the data."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24398
msgid ""
"In a standard linear least-squares fit, we have a set of @expr{(x,y)} data "
"points that we wish to fit to the model @expr{y = m x + b} by adjusting the "
"parameters @expr{m} and @expr{b} to make the @expr{y} values calculated from "
"the formula be as close as possible to the actual @expr{y} values in the "
"data set.  (In a polynomial fit, the model is instead, say, @expr{y = a x^3 "
"+ b x^2 + c x + d}.  In a multilinear fit, we have data points of the form "
"@expr{(x_1,x_2,x_3,y)} and our model is @expr{y = a x_1 + b x_2 + c x_3 + "
"d}.  These will be discussed later.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24403
msgid ""
"In the model formula, variables like @expr{x} and @expr{x_2} are called the "
"@dfn{independent variables}, and @expr{y} is the @dfn{dependent variable}.  "
"Variables like @expr{m}, @expr{a}, and @expr{b} are called the "
"@dfn{parameters} of the model."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24413
msgid ""
"The @kbd{a F} command takes the data set to be fitted from the stack.  By "
"default, it expects the data in the form of a matrix.  For example, for a "
"linear or polynomial fit, this would be a @texline @math{2\\times N} "
"@infoline 2xN matrix where the first row is a list of @expr{x} values and "
"the second row has the corresponding @expr{y} values.  For the multilinear "
"fit shown above, the matrix would have four rows (@expr{x_1}, @expr{x_2}, "
"@expr{x_3}, and @expr{y}, respectively)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24421
msgid ""
"If you happen to have an @texline @math{N\\times2} @infoline Nx2 matrix "
"instead of a @texline @math{2\\times N} @infoline 2xN matrix, just press "
"@kbd{v t} first to transpose the matrix."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24424
msgid ""
"After you type @kbd{a F}, Calc prompts you to select a model.  For a linear "
"fit, press the digit @kbd{1}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24432
msgid ""
"Calc then prompts for you to name the variables.  By default it chooses high "
"letters like @expr{x} and @expr{y} for independent variables and low letters "
"like @expr{a} and @expr{b} for parameters.  (The dependent variable doesn't "
"need a name.)  The two kinds of variables are separated by a semicolon.  "
"Since you generally care more about the names of the independent variables "
"than of the parameters, Calc also allows you to name only those and let the "
"parameters use default names."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24434
msgid "For example, suppose the data matrix"
msgstr ""

#. type: group
#: ../../calc.texi:24440
#, no-wrap
msgid ""
"[ [ 1, 2, 3, 4,  5  ]\n"
"  [ 5, 7, 9, 11, 13 ] ]\n"
msgstr ""

#. type: tex
#: ../../calc.texi:24449
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ \\pmatrix{ 1 & 2 & 3 & 4  & 5  \\cr\n"
"             5 & 7 & 9 & 11 & 13 }\n"
"$$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24460
msgid ""
"is on the stack and we wish to do a simple linear fit.  Type @kbd{a F}, then "
"@kbd{1} for the model, then @key{RET} to use the default names.  The result "
"will be the formula @expr{3. + 2. x} on the stack.  Calc has created the "
"model expression @kbd{a + b x}, then found the optimal values of @expr{a} "
"and @expr{b} to fit the data.  (In this case, it was able to find an exact "
"fit.)  Calc then substituted those values for @expr{a} and @expr{b} in the "
"model formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24467
msgid ""
"The @kbd{a F} command puts two entries in the trail.  One is, as always, a "
"copy of the result that went to the stack; the other is a vector of the "
"actual parameter values, written as equations: @expr{[a = 3, b = 2]}, in "
"case you'd rather read them in a list than pick them out of the formula.  "
"(You can type @kbd{t y} to move this vector to the stack; see @ref{Trail "
"Commands}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24472
msgid ""
"Specifying a different independent variable name will affect the resulting "
"formula: @kbd{a F 1 k @key{RET}} produces @kbd{3 + 2 k}.  Changing the "
"parameter names (say, @kbd{a F 1 k;b,m @key{RET}}) will affect the equations "
"that go into the trail."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24480
msgid ""
"To see what happens when the fit is not exact, we could change the number 13 "
"in the data matrix to 14 and try the fit again.  The result is:"
msgstr ""

#. type: example
#: ../../calc.texi:24483
#, no-wrap
msgid "2.6 + 2.2 x\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24487
msgid ""
"Evaluating this formula, say with @kbd{v x 5 @key{RET} @key{TAB} V M $ "
"@key{RET}}, shows a reasonably close match to the y-values in the data."
msgstr ""

#. type: example
#: ../../calc.texi:24490
#, no-wrap
msgid "[4.8, 7., 9.2, 11.4, 13.6]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24496
msgid ""
"Since there is no line which passes through all the @var{n} data points, "
"Calc has chosen a line that best approximates the data points using the "
"method of least squares.  The idea is to define the @dfn{chi-square} error "
"measure"
msgstr ""

#. type: example
#: ../../calc.texi:24500
#, no-wrap
msgid "chi^2 = sum((y_i - (a + b x_i))^2, i, 1, N)\n"
msgstr ""

#. type: tex
#: ../../calc.texi:24506
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ \\chi^2 = \\sum_{i=1}^N (y_i - (a + b x_i))^2 $$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24520
msgid ""
"which is clearly zero if @expr{a + b x} exactly fits all data points, and "
"increases as various @expr{a + b x_i} values fail to match the corresponding "
"@expr{y_i} values.  There are several reasons why the summand is squared, "
"one of them being to ensure that @texline @math{\\chi^2 \\ge 0}.  @infoline "
"@expr{chi^2 >= 0}.  Least-squares fitting simply chooses the values of "
"@expr{a} and @expr{b} for which the error @texline @math{\\chi^2} @infoline "
"@expr{chi^2} is as small as possible."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24523
msgid ""
"Other kinds of models do the same thing but with a different model formula "
"in place of @expr{a + b x_i}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24533
msgid ""
"A numeric prefix argument causes the @kbd{a F} command to take the data in "
"some other form than one big matrix.  A positive argument @var{n} will take "
"@var{N} items from the stack, corresponding to the @var{n} rows of a data "
"matrix.  In the linear case, @var{n} must be 2 since there is always one "
"independent variable and one dependent variable."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24539
msgid ""
"A prefix of zero or plain @kbd{C-u} is a compromise; Calc takes two items "
"from the stack, an @var{n}-row matrix of @expr{x} values, and a vector of "
"@expr{y} values.  If there is only one independent variable, the @expr{x} "
"values can be either a one-row matrix or a plain vector, in which case the "
"@kbd{C-u} prefix is the same as a @w{@kbd{C-u 2}} prefix."
msgstr ""

#. type: node
#: ../../calc.texi:24540 ../../calc.texi:24655 ../../calc.texi:24656 ../../calc.texi:24816
#, no-wrap
msgid "Error Estimates for Fits"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24549
msgid ""
"To fit the data to higher-order polynomials, just type one of the digits "
"@kbd{2} through @kbd{9} when prompted for a model.  For example, we could "
"fit the original data matrix from the previous section (with 13, not 14) to "
"a parabola instead of a line by typing @kbd{a F 2 @key{RET}}."
msgstr ""

#. type: example
#: ../../calc.texi:24552
#, no-wrap
msgid "2.00000000001 x - 1.5e-12 x^2 + 2.99999999999\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24562
msgid ""
"Note that since the constant and linear terms are enough to fit the data "
"exactly, it's no surprise that Calc chose a tiny contribution for "
"@expr{x^2}.  (The fact that it's not exactly zero is due only to roundoff "
"error.  Since our data are exact integers, we could get an exact answer by "
"typing @kbd{m f} first to get Fraction mode.  Then the @expr{x^2} term would "
"vanish altogether.  Usually, though, the data being fitted will be "
"approximate floats so Fraction mode won't help.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24566
msgid ""
"Doing the @kbd{a F 2} fit on the data set with 14 instead of 13 gives a much "
"larger @expr{x^2} contribution, as Calc bends the line slightly to improve "
"the fit."
msgstr ""

#. type: example
#: ../../calc.texi:24569
#, no-wrap
msgid "0.142857142855 x^2 + 1.34285714287 x + 3.59999999998\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24576
msgid ""
"An important result from the theory of polynomial fitting is that it is "
"always possible to fit @var{n} data points exactly using a polynomial of "
"degree @mathit{@var{n}-1}, sometimes called an @dfn{interpolating "
"polynomial}.  Using the modified (14) data matrix, a model number of 4 gives "
"a polynomial that exactly matches all five data points:"
msgstr ""

#. type: example
#: ../../calc.texi:24579
#, no-wrap
msgid "0.04167 x^4 - 0.4167 x^3 + 1.458 x^2 - 0.08333 x + 4.\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24587
msgid ""
"The actual coefficients we get with a precision of 12, like "
"@expr{0.0416666663588}, clearly suffer from loss of precision.  It is a good "
"idea to increase the working precision to several digits beyond what you "
"need when you do a fitting operation.  Or, if your data are exact, use "
"Fraction mode to get exact results."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24592
msgid ""
"You can type @kbd{i} instead of a digit at the model prompt to fit the data "
"exactly to a polynomial.  This just counts the number of columns of the data "
"matrix to choose the degree of the polynomial automatically."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24599
msgid ""
"Fitting data ``exactly'' to high-degree polynomials is not always a good "
"idea, though.  High-degree polynomials have a tendency to wiggle "
"uncontrollably in between the fitting data points.  Also, if the exact-fit "
"polynomial is going to be used to interpolate or extrapolate the data, it is "
"numerically better to use the @kbd{a p} command described below.  "
"@xref{Interpolation}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24609
msgid ""
"Another generalization of the linear model is to assume the @expr{y} values "
"are a sum of linear contributions from several @expr{x} values.  This is a "
"@dfn{multilinear} fit, and it is also selected by the @kbd{1} digit key.  "
"(Calc decides whether the fit is linear or multilinear by counting the rows "
"in the data matrix.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24611
msgid "Given the data matrix,"
msgstr ""

#. type: group
#: ../../calc.texi:24617
#, no-wrap
msgid ""
"[ [  1,   2,   3,    4,   5  ]\n"
"  [  7,   2,   3,    5,   2  ]\n"
"  [ 14.5, 15, 18.5, 22.5, 24 ] ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24624
msgid ""
"the command @kbd{a F 1 @key{RET}} will call the first row @expr{x} and the "
"second row @expr{y}, and will fit the values in the third row to the model "
"@expr{a + b x + c y}."
msgstr ""

#. type: example
#: ../../calc.texi:24627
#, no-wrap
msgid "8. + 3. x + 0.5 y\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24631
msgid ""
"Calc can do multilinear fits with any number of independent variables (i.e., "
"with any number of data rows)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24645
msgid ""
"Yet another variation is @dfn{homogeneous} linear models, in which the "
"constant term is known to be zero.  In the linear case, this means the model "
"formula is simply @expr{a x}; in the multilinear case, the model might be "
"@expr{a x + b y + c z}; and in the polynomial case, the model could be "
"@expr{a x + b x^2 + c x^3}.  You can get a homogeneous linear or multilinear "
"model by pressing the letter @kbd{h} followed by a regular model key, like "
"@kbd{1} or @kbd{2}.  This will be indicated by an ``h'' in the minibuffer "
"after the help message."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24651
msgid ""
"It is certainly possible to have other constrained linear models, like "
"@expr{2.3 + a x} or @expr{a - 4 x}.  While there is no single key to select "
"models like these, a later section shows how to enter any desired model by "
"hand.  In the first case, for example, you would enter @kbd{a F ' 2.3 + a "
"x}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24654
msgid ""
"Another class of models that will work but must be entered by hand are "
"multinomial fits, e.g., @expr{a + b x + c y + d x^2 + e y^2 + f x y}."
msgstr ""

#. type: node
#: ../../calc.texi:24655 ../../calc.texi:24816 ../../calc.texi:24817 ../../calc.texi:25000
#, no-wrap
msgid "Standard Nonlinear Models"
msgstr ""

#. type: kindex
#: ../../calc.texi:24659
#, no-wrap
msgid "H a F"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24665
msgid ""
"@tindex efit With the Hyperbolic flag, @kbd{H a F} [@code{efit}] performs "
"the same fitting operation as @kbd{a F}, but reports the coefficients as "
"error forms instead of plain numbers.  Fitting our two data matrices (first "
"with 13, then with 14) to a line with @kbd{H a F} gives the results,"
msgstr ""

#. type: example
#: ../../calc.texi:24669
#, no-wrap
msgid ""
"3. + 2. x\n"
"2.6 +/- 0.382970843103 + 2.2 +/- 0.115470053838 x\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24674
msgid ""
"In the first case the estimated errors are zero because the linear fit is "
"perfect.  In the second case, the errors are nonzero but moderately small, "
"because the data are still very close to linear."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24686
msgid ""
"It is also possible for the @emph{input} to a fitting operation to contain "
"error forms.  The data values must either all include errors or all be plain "
"numbers.  Error forms can go anywhere but generally go on the numbers in the "
"last row of the data matrix.  If the last row contains error forms @texline "
"`@var{y_i}@w{ @tfn{+/-} }@math{\\sigma_i}', @infoline `@var{y_i}@w{ "
"@tfn{+/-} }@var{sigma_i}', then the @texline @math{\\chi^2} @infoline "
"@expr{chi^2} statistic is now,"
msgstr ""

#. type: example
#: ../../calc.texi:24690
#, no-wrap
msgid "chi^2 = sum(((y_i - (a + b x_i)) / sigma_i)^2, i, 1, N)\n"
msgstr ""

#. type: tex
#: ../../calc.texi:24696
#, no-wrap
msgid ""
"\\beforedisplay\n"
"$$ \\chi^2 = \\sum_{i=1}^N \\left(y_i - (a + b x_i) \\over "
"\\sigma_i\\right)^2 $$\n"
"\\afterdisplay\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24701
msgid ""
"so that data points with larger error estimates contribute less to the "
"fitting operation."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24708
msgid ""
"If there are error forms on other rows of the data matrix, all the errors "
"for a given data point are combined; the square root of the sum of the "
"squares of the errors forms the @texline @math{\\sigma_i} @infoline "
"@expr{sigma_i} used for the data point."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24713
msgid ""
"Both @kbd{a F} and @kbd{H a F} can accept error forms in the input matrix, "
"although if you are concerned about error analysis you will probably use "
"@kbd{H a F} so that the output also contains error estimates."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24727
msgid ""
"If the input contains error forms but all the @texline @math{\\sigma_i} "
"@infoline @expr{sigma_i} values are the same, it is easy to see that the "
"resulting fitted model will be the same as if the input did not have error "
"forms at all @texline (@math{\\chi^2} @infoline (@expr{chi^2} is simply "
"scaled uniformly by @texline @math{1 / \\sigma^2}, @infoline @expr{1 / "
"sigma^2}, which doesn't affect where it has a minimum).  But there "
"@emph{will} be a difference in the estimated errors of the coefficients "
"reported by @kbd{H a F}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24731
msgid ""
"Consult any text on statistical modeling of data for a discussion of where "
"these error estimates come from and how they should be interpreted."
msgstr ""

#. type: kindex
#: ../../calc.texi:24736
#, no-wrap
msgid "I a F"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24740
msgid ""
"@tindex xfit With the Inverse flag, @kbd{I a F} [@code{xfit}] produces even "
"more information.  The result is a vector of six items:"
msgstr ""

#. type: enumerate
#: ../../calc.texi:24746
msgid ""
"The model formula with error forms for its coefficients or parameters.  This "
"is the result that @kbd{H a F} would have produced."
msgstr ""

#. type: enumerate
#: ../../calc.texi:24753
msgid ""
"A vector of ``raw'' parameter values for the model.  These are the "
"polynomial coefficients or other parameters as plain numbers, in the same "
"order as the parameters appeared in the final prompt of the @kbd{I a F} "
"command.  For polynomials of degree @expr{d}, this vector will have length "
"@expr{M = d+1} with the constant term first."
msgstr ""

#. type: enumerate
#: ../../calc.texi:24772
msgid ""
"The covariance matrix @expr{C} computed from the fit.  This is an "
"@var{m}x@var{m} symmetric matrix; the diagonal elements @texline "
"@math{C_{jj}} @infoline @expr{C_j_j} are the variances @texline "
"@math{\\sigma_j^2} @infoline @expr{sigma_j^2} of the parameters.  The other "
"elements are covariances @texline @math{\\sigma_{ij}^2} @infoline "
"@expr{sigma_i_j^2} that describe the correlation between pairs of "
"parameters.  (A related set of numbers, the @dfn{linear correlation "
"coefficients} @texline @math{r_{ij}}, @infoline @expr{r_i_j}, are defined as "
"@texline @math{\\sigma_{ij}^2 / \\sigma_i \\, \\sigma_j}.)  @infoline "
"@expr{sigma_i_j^2 / sigma_i sigma_j}.)"
msgstr ""

#. type: enumerate
#: ../../calc.texi:24778
msgid ""
"A vector of @expr{M} ``parameter filter'' functions whose meanings are "
"described below.  If no filters are necessary this will instead be an empty "
"vector; this is always the case for the polynomial and multilinear fits "
"described so far."
msgstr ""

#. type: enumerate
#: ../../calc.texi:24789
msgid ""
"The value of @texline @math{\\chi^2} @infoline @expr{chi^2} for the fit, "
"calculated by the formulas shown above.  This gives a measure of the quality "
"of the fit; statisticians consider @texline @math{\\chi^2 \\approx N - M} "
"@infoline @expr{chi^2 = N - M} to indicate a moderately good fit (where "
"again @expr{N} is the number of data points and @expr{M} is the number of "
"parameters)."
msgstr ""

#. type: enumerate
#: ../../calc.texi:24805
msgid ""
"A measure of goodness of fit expressed as a probability @expr{Q}.  This is "
"computed from the @code{utpc} probability distribution function using "
"@texline @math{\\chi^2} @infoline @expr{chi^2} with @expr{N - M} degrees of "
"freedom.  A value of 0.5 implies a good fit; some texts recommend that often "
"@expr{Q = 0.1} or even 0.001 can signify an acceptable fit.  In particular, "
"@texline @math{\\chi^2} @infoline @expr{chi^2} statistics assume the errors "
"in your inputs follow a normal (Gaussian) distribution; if they don't, you "
"may have to accept smaller values of @expr{Q}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:24814
msgid ""
"The @expr{Q} value is computed only if the input included error estimates.  "
"Otherwise, Calc will report the symbol @code{nan} for @expr{Q}.  The reason "
"is that in this case the @texline @math{\\chi^2} @infoline @expr{chi^2} "
"value has effectively been used to estimate the original errors in the "
"input, and thus there is no redundant information left over to use for a "
"confidence test."
msgstr ""

#. type: node
#: ../../calc.texi:24816 ../../calc.texi:25000 ../../calc.texi:25001 ../../calc.texi:25392
#, no-wrap
msgid "Curve Fitting Details"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24823
msgid ""
"The @kbd{a F} command also accepts other kinds of models besides lines and "
"polynomials.  Some common models have quick single-key abbreviations; others "
"must be entered by hand as algebraic formulas."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24825
msgid "Here is a complete list of the standard models recognized by @kbd{a F}:"
msgstr ""

#. type: table
#: ../../calc.texi:24829
msgid "Linear or multilinear.  @mathit{a + b x + c y + d z}."
msgstr ""

#. type: item
#: ../../calc.texi:24829
#, no-wrap
msgid "2-9"
msgstr ""

#. type: table
#: ../../calc.texi:24831
msgid "Polynomials.  @mathit{a + b x + c x^2 + d x^3}."
msgstr ""

#. type: table
#: ../../calc.texi:24833
msgid "Exponential.  @mathit{a} @tfn{exp}@mathit{(b x)} @tfn{exp}@mathit{(c y)}."
msgstr ""

#. type: table
#: ../../calc.texi:24835
msgid ""
"Base-10 exponential.  @mathit{a} @tfn{10^}@mathit{(b x)} @tfn{10^}@mathit{(c "
"y)}."
msgstr ""

#. type: table
#: ../../calc.texi:24837
msgid "Exponential (alternate notation).  @tfn{exp}@mathit{(a + b x + c y)}."
msgstr ""

#. type: table
#: ../../calc.texi:24839
msgid "Base-10 exponential (alternate).  @tfn{10^}@mathit{(a + b x + c y)}."
msgstr ""

#. type: item
#: ../../calc.texi:24839
#, no-wrap
msgid "l"
msgstr ""

#. type: table
#: ../../calc.texi:24841
msgid "Logarithmic.  @mathit{a + b} @tfn{ln}@mathit{(x) + c} @tfn{ln}@mathit{(y)}."
msgstr ""

#. type: table
#: ../../calc.texi:24843
msgid ""
"Base-10 logarithmic.  @mathit{a + b} @tfn{log10}@mathit{(x) + c} "
"@tfn{log10}@mathit{(y)}."
msgstr ""

#. type: table
#: ../../calc.texi:24845
msgid "General exponential.  @mathit{a b^x c^y}."
msgstr ""

#. type: table
#: ../../calc.texi:24847
msgid "Power law.  @mathit{a x^b y^c}."
msgstr ""

#. type: table
#: ../../calc.texi:24849
msgid "Quadratic.  @mathit{a + b (x-c)^2 + d (x-e)^2}."
msgstr ""

#. type: item
#: ../../calc.texi:24849
#, no-wrap
msgid "g"
msgstr ""

#. type: table
#: ../../calc.texi:24853
msgid ""
"Gaussian.  @texline @math{{a \\over b \\sqrt{2 \\pi}} \\exp\\left( -{1 "
"\\over 2} \\left( x - c \\over b \\right)^2 \\right)}.  @infoline @mathit{(a "
"/ b sqrt(2 pi)) exp(-0.5*((x-c)/b)^2)}."
msgstr ""

#. type: table
#: ../../calc.texi:24857
msgid ""
"Logistic @emph{s} curve.  @texline @math{a/(1+e^{b(x-c)})}.  @infoline "
"@mathit{a/(1 + exp(b (x - c)))}."
msgstr ""

#. type: item
#: ../../calc.texi:24857
#, no-wrap
msgid "b"
msgstr ""

#. type: table
#: ../../calc.texi:24861
msgid ""
"Logistic bell curve.  @texline @math{ae^{b(x-c)}/(1+e^{b(x-c)})^2}.  "
"@infoline @mathit{a exp(b (x - c))/(1 + exp(b (x - c)))^2}."
msgstr ""

#. type: table
#: ../../calc.texi:24865
msgid ""
"Hubbert linearization.  @texline @math{{y \\over x} = a(1-x/b)}.  @infoline "
"@mathit{(y/x) = a (1 - x/b)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24872
msgid ""
"All of these models are used in the usual way; just press the appropriate "
"letter at the model prompt, and choose variable names if you wish.  The "
"result will be a formula as shown in the above table, with the best-fit "
"values of the parameters substituted.  (You may find it easier to read the "
"parameter values from the vector that is placed in the trail.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24879
msgid ""
"All models except Gaussian, logistics, Hubbert and polynomials can "
"generalize as shown to any number of independent variables.  Also, all the "
"built-in models except for the logistic and Hubbert curves have an additive "
"or multiplicative parameter shown as @expr{a} in the above table which can "
"be replaced by zero or one, as appropriate, by typing @kbd{h} before the "
"model key."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24886
msgid ""
"Note that many of these models are essentially equivalent, but express the "
"parameters slightly differently.  For example, @expr{a b^x} and the other "
"two exponential models are all algebraic rearrangements of each other.  "
"Also, the ``quadratic'' model is just a degree-2 polynomial with the "
"parameters expressed differently.  Use whichever form best matches the "
"problem."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24893
msgid ""
"The HP-28/48 calculators support four different models for curve fitting, "
"called @code{LIN}, @code{LOG}, @code{EXP}, and @code{PWR}.  These correspond "
"to Calc models @samp{a + b x}, @samp{a + b ln(x)}, @samp{a exp(b x)}, and "
"@samp{a x^b}, respectively.  In each case, @expr{a} is what the HP-48 "
"identifies as the ``intercept,'' and @expr{b} is what it calls the "
"``slope.''"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24902
msgid ""
"If the model you want doesn't appear on this list, press @kbd{'} (the "
"apostrophe key) at the model prompt to enter any algebraic formula, such as "
"@kbd{m x - b}, as the model.  (Not all models will work, though---see the "
"next section for details.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24911
msgid ""
"The model can also be an equation like @expr{y = m x + b}.  In this case, "
"Calc thinks of all the rows of the data matrix on equal terms; this model "
"effectively has two parameters (@expr{m} and @expr{b}) and two independent "
"variables (@expr{x} and @expr{y}), with no ``dependent'' variables.  Model "
"equations do not need to take this @expr{y =} form.  For example, the "
"implicit line equation @expr{a x + b y = 1} works fine as a model."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24918
msgid ""
"When you enter a model, Calc makes an alphabetical list of all the variables "
"that appear in the model.  These are used for the default parameters, "
"independent variables, and dependent variable (in that order).  If you enter "
"a plain formula (not an equation), Calc assumes the dependent variable does "
"not appear in the formula and thus does not need a name."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24926
msgid ""
"For example, if the model formula has the variables @expr{a,mu,sigma,t,x}, "
"and the data matrix has three rows (meaning two independent variables), Calc "
"will use @expr{a,mu,sigma} as the default parameters, and the data rows will "
"be named @expr{t} and @expr{x}, respectively.  If you enter an equation "
"instead of a plain formula, Calc will use @expr{a,mu} as the parameters, and "
"@expr{sigma,t,x} as the three independent variables."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24934
msgid ""
"You can, of course, override these choices by entering something different "
"at the prompt.  If you leave some variables out of the list, those variables "
"must have stored values and those stored values will be used as constants in "
"the model.  (Stored values for the parameters and independent variables are "
"ignored by the @kbd{a F} command.)  If you list only independent variables, "
"all the remaining variables in the model formula will become parameters."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24940
msgid ""
"If there are @kbd{$} signs in the model you type, they will stand for "
"parameters and all other variables (in alphabetical order)  will be "
"independent.  Use @kbd{$} for one parameter, @kbd{$$} for another, and so "
"on.  Thus @kbd{$ x + $$} is another way to describe a linear model."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24946
msgid ""
"If you type a @kbd{$} instead of @kbd{'} at the model prompt itself, Calc "
"will take the model formula from the stack.  (The data must then appear at "
"the second stack level.)  The same conventions are used to choose which "
"variables in the formula are independent by default and which are "
"parameters."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24953
msgid ""
"Models taken from the stack can also be expressed as vectors of two or three "
"elements, @expr{[@var{model}, @var{vars}]} or @expr{[@var{model}, "
"@var{vars}, @var{params}]}.  Each of @var{vars} and @var{params} may be "
"either a variable or a vector of variables.  (If @var{params} is omitted, "
"all variables in @var{model} except those listed as @var{vars} are "
"parameters.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24956
msgid ""
"When you enter a model manually with @kbd{'}, Calc puts a 3-vector "
"describing the model in the trail so you can get it back if you wish."
msgstr ""

#. type: vindex
#: ../../calc.texi:24961
#, no-wrap
msgid "Model1"
msgstr ""

#. type: vindex
#: ../../calc.texi:24962
#, no-wrap
msgid "Model2"
msgstr ""

#. type: Plain text
#: ../../calc.texi:24968
msgid ""
"Finally, you can store a model in one of the Calc variables @code{Model1} or "
"@code{Model2}, then use this model by typing @kbd{a F u} or @kbd{a F U} "
"(respectively).  The value stored in the variable can be any of the formats "
"that @kbd{a F $} would accept for a model on the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24991
msgid ""
"Calc uses the principal values of inverse functions like @code{ln} and "
"@code{arcsin} when doing fits.  For example, when you enter the model "
"@samp{y = sin(a t + b)} Calc actually uses the easier form @samp{arcsin(y) = "
"a t + b}.  The @code{arcsin} function always returns results in the range "
"from @mathit{-90} to 90 degrees (or the equivalent range in radians).  "
"Suppose you had data that you believed to represent roughly three "
"oscillations of a sine wave, so that the argument of the sine might go from "
"zero to @texline @math{3\\times360} @infoline @mathit{3*360} degrees.  The "
"above model would appear to be a good way to determine the true frequency "
"and phase of the sine wave, but in practice it would fail utterly.  The "
"righthand side of the actual model @samp{arcsin(y) = a t + b} will grow "
"smoothly with @expr{t}, but the lefthand side will bounce back and forth "
"between @mathit{-90} and 90.  No values of @expr{a} and @expr{b} can make "
"the two sides match, even approximately."
msgstr ""

#. type: Plain text
#: ../../calc.texi:24999
msgid ""
"There is no good solution to this problem at present.  You could restrict "
"your data to small enough ranges so that the above problem doesn't occur "
"(i.e., not straddling any peaks in the sine wave).  Or, in this case, you "
"could use a totally different method such as Fourier analysis, which is "
"beyond the scope of the @kbd{a F} command.  (Unfortunately, Calc does not "
"currently have any facilities for taking Fourier and related transforms.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25009
msgid ""
"Calc's internal least-squares fitter can only handle multilinear models.  "
"More precisely, it can handle any model of the form @expr{a f(x,y,z) + b "
"g(x,y,z) + c h(x,y,z)}, where @expr{a,b,c} are the parameters and "
"@expr{x,y,z} are the independent variables (of course there can be any "
"number of each, not just three)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25014
msgid ""
"In a simple multilinear or polynomial fit, it is easy to see how to convert "
"the model into this form.  For example, if the model is @expr{a + b x + c "
"x^2}, then @expr{f(x) = 1}, @expr{g(x) = x}, and @expr{h(x) = x^2} are "
"suitable functions."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25017
msgid ""
"For most other models, Calc uses a variety of algebraic manipulations to try "
"to put the problem into the form"
msgstr ""

#. type: smallexample
#: ../../calc.texi:25020
#, no-wrap
msgid "Y(x,y,z) = A(a,b,c) F(x,y,z) + B(a,b,c) G(x,y,z) + C(a,b,c) H(x,y,z)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25028
msgid ""
"where @expr{Y,A,B,C,F,G,H} are arbitrary functions.  It computes @expr{Y}, "
"@expr{F}, @expr{G}, and @expr{H} for all the data points, does a standard "
"linear fit to find the values of @expr{A}, @expr{B}, and @expr{C}, then uses "
"the equation solver to solve for @expr{a,b,c} in terms of @expr{A,B,C}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25033
msgid ""
"A remarkable number of models can be cast into this general form.  We'll "
"look at two examples here to see how it works.  The power-law model @expr{y "
"= a x^b} with two independent variables and two parameters can be rewritten "
"as follows:"
msgstr ""

#. type: example
#: ../../calc.texi:25039
#, no-wrap
msgid ""
"y = a x^b\n"
"y = a exp(b ln(x))\n"
"y = exp(ln(a) + b ln(x))\n"
"ln(y) = ln(a) + b ln(x)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25055
msgid ""
"which matches the desired form with @texline @math{Y = \\ln(y)}, @infoline "
"@expr{Y = ln(y)}, @texline @math{A = \\ln(a)}, @infoline @expr{A = ln(a)}, "
"@expr{F = 1}, @expr{B = b}, and @texline @math{G = \\ln(x)}.  @infoline "
"@expr{G = ln(x)}.  Calc thus computes the logarithms of your @expr{y} and "
"@expr{x} values, does a linear fit for @expr{A} and @expr{B}, then solves to "
"get @texline @math{a = \\exp(A)} @infoline @expr{a = exp(A)} and @expr{b = "
"B}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25058
msgid ""
"Another interesting example is the ``quadratic'' model, which can be handled "
"by expanding according to the distributive law."
msgstr ""

#. type: example
#: ../../calc.texi:25062
#, no-wrap
msgid ""
"y = a + b*(x - c)^2\n"
"y = a + b c^2 - 2 b c x + b x^2\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25069
msgid ""
"which matches with @expr{Y = y}, @expr{A = a + b c^2}, @expr{F = 1}, @expr{B "
"= -2 b c}, @expr{G = x} (the @mathit{-2} factor could just as easily have "
"been put into @expr{G} instead of @expr{B}), @expr{C = b}, and @expr{H = "
"x^2}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25073
msgid ""
"The Gaussian model looks quite complicated, but a closer examination shows "
"that it's actually similar to the quadratic model but with an exponential "
"that can be brought to the top and moved into @expr{Y}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25078
msgid ""
"The logistic models cannot be put into general linear form.  For these "
"models, and the Hubbert linearization, Calc computes a rough approximation "
"for the parameters, then uses the Levenberg-Marquardt iterative method to "
"refine the approximations."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25091
msgid ""
"Another model that cannot be put into general linear form is a Gaussian with "
"a constant background added on, i.e., @expr{d} + the regular Gaussian "
"formula.  If you have a model like this, your best bet is to replace enough "
"of your parameters with constants to make the model linearizable, then "
"adjust the constants manually by doing a series of fits.  You can compare "
"the fits by graphing them, by examining the goodness-of-fit measures "
"returned by @kbd{I a F}, or by some other method suitable to your "
"application.  Note that some models can be linearized in several ways.  The "
"Gaussian-plus-@var{d} model can be linearized by setting @expr{d} (the "
"background) to a constant, or by setting @expr{b} (the standard deviation) "
"and @expr{c} (the mean) to constants."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25095
msgid ""
"To fit a model with constants substituted for some parameters, just store "
"suitable values in those parameter variables, then omit them from the list "
"of parameters when you answer the variables prompt."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25109
msgid ""
"A last desperate step would be to use the general-purpose @code{minimize} "
"function rather than @code{fit}.  After all, both functions solve the "
"problem of minimizing an expression (the @texline @math{\\chi^2} @infoline "
"@expr{chi^2} sum) by adjusting certain parameters in the expression.  The "
"@kbd{a F} command is able to use a vastly more efficient algorithm due to "
"its special knowledge about linear chi-square sums, but the @kbd{a N} "
"command can do the same thing by brute force."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25117
msgid ""
"A compromise would be to pick out a few parameters without which the fit is "
"linearizable, and use @code{minimize} on a call to @code{fit} which "
"efficiently takes care of the rest of the parameters.  The thing to be "
"minimized would be the value of @texline @math{\\chi^2} @infoline "
"@expr{chi^2} returned as the fifth result of the @code{xfit} function:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:25120
#, no-wrap
msgid "minimize(xfit(gaus(a,b,c,d,x), x, [a,b,c], data)_5, d, guess)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25129
msgid ""
"where @code{gaus} represents the Gaussian model with background, @code{data} "
"represents the data matrix, and @code{guess} represents the initial guess "
"for @expr{d} that @code{minimize} requires.  This operation will only be, "
"shall we say, extraordinarily slow rather than astronomically slow (as would "
"be the case if @code{minimize} were used by itself to solve the problem)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25148
msgid ""
"The @kbd{I a F} [@code{xfit}] command is somewhat trickier when nonlinear "
"models are used.  The second item in the result is the vector of ``raw'' "
"parameters @expr{A}, @expr{B}, @expr{C}.  The covariance matrix is written "
"in terms of those raw parameters.  The fifth item is a vector of "
"@dfn{filter} expressions.  This is the empty vector @samp{[]} if the raw "
"parameters were the same as the requested parameters, i.e., if @expr{A = a}, "
"@expr{B = b}, and so on (which is always true if the model is already linear "
"in the parameters as written, e.g., for polynomial fits).  If the parameters "
"had to be rearranged, the fifth item is instead a vector of one formula per "
"parameter in the original model.  The raw parameters are expressed in these "
"``filter'' formulas as @samp{fitdummy(1)} for @expr{A}, @samp{fitdummy(2)} "
"for @expr{B}, and so on."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25158
msgid ""
"When Calc needs to modify the model to return the result, it replaces "
"@samp{fitdummy(1)} in all the filters with the first item in the raw "
"parameters list, and so on for the other raw parameters, then evaluates the "
"resulting filter formulas to get the actual parameter values to be "
"substituted into the original model.  In the case of @kbd{H a F} and @kbd{I "
"a F} where the parameters must be error forms, Calc uses the square roots of "
"the diagonal entries of the covariance matrix as error values for the raw "
"parameters, then lets Calc's standard error-form arithmetic take it from "
"there."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25164
msgid ""
"If you use @kbd{I a F} with a nonlinear model, be sure to remember that the "
"covariance matrix is in terms of the raw parameters, @emph{not} the actual "
"requested parameters.  It's up to you to figure out how to interpret the "
"covariances in the presence of nontrivial filter functions."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25184
msgid ""
"Things are also complicated when the input contains error forms.  Suppose "
"there are three independent and dependent variables, @expr{x}, @expr{y}, and "
"@expr{z}, one or more of which are error forms in the data.  Calc combines "
"all the error values by taking the square root of the sum of the squares of "
"the errors.  It then changes @expr{x} and @expr{y} to be plain numbers, and "
"makes @expr{z} into an error form with this combined error.  The "
"@expr{Y(x,y,z)} part of the linearized model is evaluated, and the result "
"should be an error form.  The error part of that result is used for @texline "
"@math{\\sigma_i} @infoline @expr{sigma_i} for the data point.  If for some "
"reason @expr{Y(x,y,z)} does not return an error form, the combined error "
"from @expr{z} is used directly for @texline @math{\\sigma_i}.  @infoline "
"@expr{sigma_i}.  Finally, @expr{z} is also stripped of its error for use in "
"computing @expr{F(x,y,z)}, @expr{G(x,y,z)} and so on; the righthand side of "
"the linearized model is computed in regular arithmetic with no error forms."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25193
msgid ""
"(While these rules may seem complicated, they are designed to do the most "
"reasonable thing in the typical case that @expr{Y(x,y,z)} depends only on "
"the dependent variable @expr{z}, and in fact is often simply equal to "
"@expr{z}.  For common cases like polynomials and multilinear models, the "
"combined error is simply used as the @texline @math{\\sigma} @infoline "
"@expr{sigma} for the data point with no further ado.)"
msgstr ""

#. type: vindex
#: ../../calc.texi:25198
#, no-wrap
msgid "FitRules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25206
msgid ""
"It may be the case that the model you wish to use is linearizable, but "
"Calc's built-in rules are unable to figure it out.  Calc uses its algebraic "
"rewrite mechanism to linearize a model.  The rewrite rules are kept in the "
"variable @code{FitRules}.  You can edit this variable using the @kbd{s e "
"FitRules} command; in fact, there is a special @kbd{s F} command just for "
"editing @code{FitRules}.  @xref{Operations on Variables}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25208
msgid "@xref{Rewrite Rules}, for a discussion of rewrite rules."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25213
msgid "@tindex fitvar"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25220
msgid "@tindex fitparam"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25227
msgid "@tindex fitmodel"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25234
msgid "@tindex fitsystem"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25250
msgid ""
"@tindex fitdummy Calc uses @code{FitRules} as follows.  First, it converts "
"the model to an equation if necessary and encloses the model equation in a "
"call to the function @code{fitmodel} (which is not actually a defined "
"function in Calc; it is only used as a placeholder by the rewrite rules).  "
"Parameter variables are renamed to function calls @samp{fitparam(1)}, "
"@samp{fitparam(2)}, and so on, and independent variables are renamed to "
"@samp{fitvar(1)}, @samp{fitvar(2)}, etc.  The dependent variable is the "
"highest-numbered @code{fitvar}.  For example, the power law model @expr{a "
"x^b} is converted to @expr{y = a x^b}, then to"
msgstr ""

#. type: group
#: ../../calc.texi:25254
#, no-wrap
msgid "fitmodel(fitvar(2) = fitparam(1) fitvar(1)^fitparam(2))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25260
msgid ""
"Calc then applies the rewrites as if by @samp{C-u 0 a r FitRules}.  (The "
"zero prefix means that rewriting should continue until no further changes "
"are possible.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25263
msgid ""
"When rewriting is complete, the @code{fitmodel} call should have been "
"replaced by a @code{fitsystem} call that looks like this:"
msgstr ""

#. type: example
#: ../../calc.texi:25266
#, no-wrap
msgid "fitsystem(@var{Y}, @var{FGH}, @var{abc})\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25276
msgid ""
"where @var{Y} is a formula that describes the function @expr{Y(x,y,z)}, "
"@var{FGH} is the vector of formulas @expr{[F(x,y,z), G(x,y,z), H(x,y,z)]}, "
"and @var{abc} is the vector of parameter filters which refer to the raw "
"parameters as @samp{fitdummy(1)} for @expr{A}, @samp{fitdummy(2)} for "
"@expr{B}, etc.  While the number of raw parameters (the length of the "
"@var{FGH} vector) is usually the same as the number of original parameters "
"(the length of the @var{abc} vector), this is not required."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25278
msgid "The power law model eventually boils down to"
msgstr ""

#. type: group
#: ../../calc.texi:25284
#, no-wrap
msgid ""
"fitsystem(ln(fitvar(2)),\n"
"          [1, ln(fitvar(1))],\n"
"          [exp(fitdummy(1)), fitdummy(2)])\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25300
msgid ""
"The actual implementation of @code{FitRules} is complicated; it proceeds in "
"four phases.  First, common rearrangements are done to try to bring linear "
"terms together and to isolate functions like @code{exp} and @code{ln} either "
"all the way ``out'' (so that they can be put into @var{Y}) or all the way "
"``in'' (so that they can be put into @var{abc} or @var{FGH}).  In "
"particular, all non-constant powers are converted to logs-and-exponentials "
"form, and the distributive law is used to expand products of sums.  "
"Quotients are rewritten to use the @samp{fitinv} function, where "
"@samp{fitinv(x)} represents @expr{1/x} while the @code{FitRules} are "
"operating.  (The use of @code{fitinv} makes recognition of linear-looking "
"forms easier.)  If you modify @code{FitRules}, you will probably only need "
"to modify the rules for this phase."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25313
msgid ""
"Phase two, whose rules can actually also apply during phases one and three, "
"first rewrites @code{fitmodel} to a two-argument form "
"@samp{fitmodel(@var{Y}, @var{model})}, where @var{Y} is initially zero and "
"@var{model} has been changed from @expr{a=b} to @expr{a-b} form.  It then "
"tries to peel off invertible functions from the outside of @var{model} and "
"put them into @var{Y} instead, calling the equation solver to invert the "
"functions.  Finally, when this is no longer possible, the @code{fitmodel} is "
"changed to a four-argument @code{fitsystem}, where the fourth argument is "
"@var{model} and the @var{FGH} and @var{abc} vectors are initially empty.  "
"(The last vector is really @var{ABC}, corresponding to raw parameters, for "
"now.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25325
msgid ""
"Phase three converts a sum of items in the @var{model} to a sum of "
"@samp{fitpart(@var{a}, @var{b}, @var{c})} terms which represent terms "
"@samp{@var{a}*@var{b}*@var{c}} of the sum, where @var{a} is all factors that "
"do not involve any variables, @var{b} is all factors that involve only "
"parameters, and @var{c} is the factors that involve only independent "
"variables.  (If this decomposition is not possible, the rule set will not "
"complete and Calc will complain that the model is too complex.)  Then "
"@code{fitpart}s with equal @var{b} or @var{c} components are merged back "
"together using the distributive law in order to minimize the number of raw "
"parameters needed."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25334
msgid ""
"Phase four moves the @code{fitpart} terms into the @var{FGH} and @var{ABC} "
"vectors.  Also, some of the algebraic expansions that were done in phase 1 "
"are undone now to make the formulas more computationally efficient.  "
"Finally, it calls the solver one more time to convert the @var{ABC} vector "
"to an @var{abc} vector, and removes the fourth @var{model} argument (which "
"by now will be zero)  to obtain the three-argument @code{fitsystem} that the "
"linear least-squares solver wants to see."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25342
msgid "@tindex hasfitparams"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25358
msgid ""
"@tindex hasfitvars Two functions which are useful in connection with "
"@code{FitRules} are @samp{hasfitparams(x)} and @samp{hasfitvars(x)}, which "
"check whether @expr{x} refers to any parameters or independent variables, "
"respectively.  Specifically, these functions return ``true'' if the argument "
"contains any @code{fitparam} (or @code{fitvar}) function calls, and "
"``false'' otherwise.  (Recall that ``true'' means a nonzero number, and "
"``false'' means zero.  The actual nonzero number returned is the largest "
"@var{n} from all the @samp{fitparam(@var{n})}s or @samp{fitvar(@var{n})}s, "
"respectively, that appear in the formula.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25373
msgid ""
"The @code{fit} function in algebraic notation normally takes four arguments, "
"@samp{fit(@var{model}, @var{vars}, @var{params}, @var{data})}, where "
"@var{model} is the model formula as it would be typed after @kbd{a F '}, "
"@var{vars} is the independent variable or a vector of independent variables, "
"@var{params} likewise gives the parameter(s), and @var{data} is the data "
"matrix.  Note that the length of @var{vars} must be equal to the number of "
"rows in @var{data} if @var{model} is an equation, or one less than the "
"number of rows if @var{model} is a plain formula.  (Actually, a name for the "
"dependent variable is allowed but will be ignored in the plain-formula "
"case.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25379
msgid ""
"If @var{params} is omitted, the parameters are all variables in @var{model} "
"except those that appear in @var{vars}.  If @var{vars} is also omitted, Calc "
"sorts all the variables that appear in @var{model} alphabetically and uses "
"the higher ones for @var{vars} and the lower ones for @var{params}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25383
msgid ""
"Alternatively, @samp{fit(@var{modelvec}, @var{data})} is allowed where "
"@var{modelvec} is a 2- or 3-vector describing the model and variables, as "
"discussed previously."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25388
msgid ""
"If Calc is unable to do the fit, the @code{fit} function is left in symbolic "
"form, ordinarily with an explanatory message.  The message will be ``Model "
"expression is too complex'' if the linearizer was unable to put the model "
"into the required form."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25391
msgid ""
"The @code{efit} (corresponding to @kbd{H a F}) and @code{xfit} (for @kbd{I a "
"F}) functions are completely analogous."
msgstr ""

#. type: subsection
#: ../../calc.texi:25393
#, no-wrap
msgid "Polynomial Interpolation"
msgstr ""

#. type: kindex
#: ../../calc.texi:25395
#, no-wrap
msgid "a p"
msgstr ""

#. type: pindex
#: ../../calc.texi:25396
#, no-wrap
msgid "calc-poly-interp"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25407
msgid ""
"@tindex polint The @kbd{a p} (@code{calc-poly-interp}) [@code{polint}] "
"command does a polynomial interpolation at a particular @expr{x} value.  It "
"takes two arguments from the stack: A data matrix of the sort used by @kbd{a "
"F}, and a single number which represents the desired @expr{x} value.  Calc "
"effectively does an exact polynomial fit as if by @kbd{a F i}, then "
"substitutes the @expr{x} value into the result in order to get an "
"approximate @expr{y} value based on the fit.  (Calc does not actually use "
"@kbd{a F i}, however; it uses a direct method which is both more efficient "
"and more numerically stable.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25414
msgid ""
"The result of @kbd{a p} is actually a vector of two values: The @expr{y} "
"value approximation, and an error measure @expr{dy} that reflects Calc's "
"estimation of the probable error of the approximation at that value of "
"@expr{x}.  If the input @expr{x} is equal to any of the @expr{x} values in "
"the data matrix, the output @expr{y} will be the corresponding @expr{y} "
"value from the matrix, and the output @expr{dy} will be exactly zero."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25417
msgid ""
"A prefix argument of 2 causes @kbd{a p} to take separate x- and y-vectors "
"from the stack instead of one data matrix."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25424
msgid ""
"If @expr{x} is a vector of numbers, @kbd{a p} will return a matrix of "
"interpolated results for each of those @expr{x} values.  (The matrix will "
"have two columns, the @expr{y} values and the @expr{dy} values.)  If "
"@expr{x} is a formula instead of a number, the @code{polint} function "
"remains in symbolic form; use the @kbd{a \"} command to expand it out to a "
"formula that describes the fit in symbolic terms."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25427
msgid ""
"In all cases, the @kbd{a p} command leaves the data vectors or matrix on the "
"stack.  Only the @expr{x} value is replaced by the result."
msgstr ""

#. type: kindex
#: ../../calc.texi:25428
#, no-wrap
msgid "H a p"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25436
msgid ""
"@tindex ratint The @kbd{H a p} [@code{ratint}] command does a rational "
"function interpolation.  It is used exactly like @kbd{a p}, except that it "
"uses as its model the quotient of two polynomials.  If there are @expr{N} "
"data points, the numerator and denominator polynomials will each have degree "
"@expr{N/2} (if @expr{N} is odd, the denominator will have degree one higher "
"than the numerator)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25443
msgid ""
"Rational approximations have the advantage that they can accurately describe "
"functions that have poles (points at which the function's value goes to "
"infinity, so that the denominator polynomial of the approximation goes to "
"zero).  If @expr{x} corresponds to a pole of the fitted rational function, "
"then the result will be a division by zero.  If Infinite mode is enabled, "
"the result will be @samp{[uinf, uinf]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25448
msgid ""
"There is no way to get the actual coefficients of the rational function used "
"by @kbd{H a p}.  (The algorithm never generates these coefficients "
"explicitly, and quotients of polynomials are beyond @w{@kbd{a F}}'s "
"capabilities to fit.)"
msgstr ""

#. type: node
#: ../../calc.texi:25449 ../../calc.texi:25610 ../../calc.texi:25611 ../../calc.texi:25988
#, no-wrap
msgid "Logical Operations"
msgstr ""

#. type: cindex
#: ../../calc.texi:25453
#, no-wrap
msgid "Summation of a series"
msgstr ""

#. type: kindex
#: ../../calc.texi:25454
#, no-wrap
msgid "a +"
msgstr ""

#. type: pindex
#: ../../calc.texi:25455
#, no-wrap
msgid "calc-summation"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25466
msgid ""
"@tindex sum The @kbd{a +} (@code{calc-summation}) [@code{sum}] command "
"computes the sum of a formula over a certain range of index values.  The "
"formula is taken from the top of the stack; the command prompts for the name "
"of the summation index variable, the lower limit of the sum (any formula), "
"and the upper limit of the sum.  If you enter a blank line at any of these "
"prompts, that prompt and any later ones are answered by reading additional "
"elements from the stack.  Thus, @kbd{' k^2 @key{RET} ' k @key{RET} 1 "
"@key{RET} 5 @key{RET} a + @key{RET}} produces the result 55."
msgstr ""

#. type: tex
#: ../../calc.texi:25468
#, no-wrap
msgid "$$ \\sum_{k=1}^5 k^2 = 55 $$\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25479
msgid ""
"The choice of index variable is arbitrary, but it's best not to use a "
"variable with a stored value.  In particular, while @code{i} is often a "
"favorite index variable, it should be avoided in Calc because @code{i} has "
"the imaginary constant @expr{(0, 1)} as a value.  If you pressed @kbd{=} on "
"a sum over @code{i}, it would be changed to a nonsensical sum over the "
"``variable'' @expr{(0, 1)}! If you really want to use @code{i} as an index "
"variable, use @w{@kbd{s u i @key{RET}}} first to ``unstore'' this variable.  "
"(@xref{Storing Variables}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25489
msgid ""
"A numeric prefix argument steps the index by that amount rather than by "
"one.  Thus @kbd{' a_k @key{RET} C-u -2 a + k @key{RET} 10 @key{RET} 0 "
"@key{RET}} yields @samp{a_10 + a_8 + a_6 + a_4 + a_2 + a_0}.  A prefix "
"argument of plain @kbd{C-u} causes @kbd{a +} to prompt for the step value, "
"in which case you can enter any formula or enter a blank line to take the "
"step value from the stack.  With the @kbd{C-u} prefix, @kbd{a +} can take up "
"to five arguments from the stack: The formula, the variable, the lower "
"limit, the upper limit, and (at the top of the stack), the step value."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25500
msgid ""
"Calc knows how to do certain sums in closed form.  For example, @samp{sum(6 "
"k^2, k, 1, n) = @w{2 n^3} + 3 n^2 + n}.  In particular, this is possible if "
"the formula being summed is polynomial or exponential in the index "
"variable.  Sums of logarithms are transformed into logarithms of products.  "
"Sums of trigonometric and hyperbolic functions are transformed to sums of "
"exponentials and then done in closed form.  Also, of course, sums in which "
"the lower and upper limits are both numbers can always be evaluated just by "
"grinding them out, although Calc will use closed forms whenever it can for "
"the sake of efficiency."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25507
msgid ""
"The notation for sums in algebraic formulas is @samp{sum(@var{expr}, "
"@var{var}, @var{low}, @var{high}, @var{step})}.  If @var{step} is omitted, "
"it defaults to one.  If @var{high} is omitted, @var{low} is actually the "
"upper limit and the lower limit is one.  If @var{low} is also omitted, the "
"limits are @samp{-inf} and @samp{inf}, respectively."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25516
msgid ""
"Infinite sums can sometimes be evaluated: @samp{sum(.5^k, k, 1, inf)} "
"returns @expr{1}.  This is done by evaluating the sum in closed form (to "
"@samp{1. - 0.5^n} in this case), then evaluating this formula with @code{n} "
"set to @code{inf}.  Calc's usual rules for ``infinite'' arithmetic can find "
"the answer from there.  If infinite arithmetic yields a @samp{nan}, or if "
"the sum cannot be solved in closed form, Calc leaves the @code{sum} function "
"in symbolic form.  @xref{Infinities}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25523
msgid ""
"As a special feature, if the limits are infinite (or omitted, as described "
"above) but the formula includes vectors subscripted by expressions that "
"involve the iteration variable, Calc narrows the limits to include only the "
"range of integers which result in valid subscripts for the vector.  For "
"example, the sum @samp{sum(k [a,b,c,d,e,f,g]_(2k),k)} evaluates to @samp{b + "
"2 d + 3 f}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25529
msgid ""
"The limits of a sum do not need to be integers.  For example, @samp{sum(a_k, "
"k, 0, 2 n, n)} produces @samp{a_0 + a_n + a_(2 n)}.  Calc computes the "
"number of iterations using the formula @samp{1 + (@var{high} - @var{low}) / "
"@var{step}}, which must, after algebraic simplification, evaluate to an "
"integer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25538
msgid ""
"If the number of iterations according to the above formula does not come out "
"to an integer, the sum is invalid and will be left in symbolic form.  "
"However, closed forms are still supplied, and you are on your honor not to "
"misuse the resulting formulas by substituting mismatched bounds into them.  "
"For example, @samp{sum(k, k, 1, 10, 2)} is invalid, but Calc will go ahead "
"and evaluate the closed form solution for the limits 1 and 10 to get the "
"rather dubious answer, 29.25."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25546
msgid ""
"If the lower limit is greater than the upper limit (assuming a positive step "
"size), the result is generally zero.  However, Calc only guarantees a zero "
"result when the upper limit is exactly one step less than the lower limit, "
"i.e., if the number of iterations is @mathit{-1}.  Thus @samp{sum(f(k), k, "
"n, n-1)} is zero but the sum from @samp{n} to @samp{n-2} may report a "
"nonzero value if Calc used a closed form solution."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25558
msgid ""
"Calc's logical predicates like @expr{a < b} return 1 for ``true'' and 0 for "
"``false.'' @xref{Logical Operations}.  This can be used to advantage for "
"building conditional sums.  For example, @samp{sum(prime(k)*k^2, k, 1, 20)} "
"is the sum of the squares of all prime numbers from 1 to 20; the "
"@code{prime} predicate returns 1 if its argument is prime and 0 otherwise.  "
"You can read this expression as ``the sum of @expr{k^2}, where @expr{k} is "
"prime.'' Indeed, @samp{sum(prime(k)*k^2, k)} would represent the sum of "
"@emph{all} primes squared, since the limits default to plus and minus "
"infinity, but there are no such sums that Calc's built-in rules can do in "
"closed form."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25573
msgid ""
"As another example, @samp{sum((k != k_0) * f(k), k, 1, n)} is the sum of "
"@expr{f(k)} for all @expr{k} from 1 to @expr{n}, excluding one value "
"@expr{k_0}.  Slightly more tricky is the summand @samp{(k != k_0) / (k - "
"k_0)}, which is an attempt to describe the sum of all @expr{1/(k-k_0)} "
"except at @expr{k = k_0}, where this would be a division by zero.  But at "
"@expr{k = k_0}, this formula works out to the indeterminate form @expr{0 / "
"0}, which Calc will not assume is zero.  Better would be to use @samp{(k != "
"k_0) ? 1/(k-k_0) : 0}; the @samp{? :} operator does an ``if-then-else'' "
"test: This expression says, ``if @texline @math{k \\ne k_0}, @infoline "
"@expr{k != k_0}, then @expr{1/(k-k_0)}, else zero.'' Now the formula "
"@expr{1/(k-k_0)} will not even be evaluated by Calc when @expr{k = k_0}."
msgstr ""

#. type: cindex
#: ../../calc.texi:25574
#, no-wrap
msgid "Alternating sums"
msgstr ""

#. type: kindex
#: ../../calc.texi:25575
#, no-wrap
msgid "a -"
msgstr ""

#. type: pindex
#: ../../calc.texi:25576
#, no-wrap
msgid "calc-alt-summation"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25590
msgid ""
"@tindex asum The @kbd{a -} (@code{calc-alt-summation}) [@code{asum}] command "
"computes an alternating sum.  Successive terms of the sequence are given "
"alternating signs, with the first term (corresponding to the lower index "
"value) being positive.  Alternating sums are converted to normal sums with "
"an extra term of the form @samp{(-1)^(k-@var{low})}.  This formula is "
"adjusted appropriately if the step value is other than one.  For example, "
"the Taylor series for the sine function is @samp{asum(x^k / k!, k, 1, inf, "
"2)}.  (Calc cannot evaluate this infinite series, but it can approximate it "
"if you replace @code{inf} with any particular odd number.)  Calc converts "
"this series to a regular sum with a step of one, namely @samp{sum((-1)^k "
"x^(2k+1) / (2k+1)!, k, 0, inf)}."
msgstr ""

#. type: cindex
#: ../../calc.texi:25591
#, no-wrap
msgid "Product of a sequence"
msgstr ""

#. type: kindex
#: ../../calc.texi:25592
#, no-wrap
msgid "a *"
msgstr ""

#. type: pindex
#: ../../calc.texi:25593
#, no-wrap
msgid "calc-product"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25600
msgid ""
"@tindex prod The @kbd{a *} (@code{calc-product}) [@code{prod}] command is "
"the analogous way to take a product of many terms.  Calc also knows some "
"closed forms for products, such as @samp{prod(k, k, 1, n) = n!}.  "
"Conditional products can be written @samp{prod(k^prime(k), k, 1, n)} or "
"@samp{prod(prime(k) ? k : 1, k, 1, n)}."
msgstr ""

#. type: kindex
#: ../../calc.texi:25601
#, no-wrap
msgid "a T"
msgstr ""

#. type: pindex
#: ../../calc.texi:25602
#, no-wrap
msgid "calc-tabulate"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25609
msgid ""
"@tindex table The @kbd{a T} (@code{calc-tabulate}) [@code{table}] command "
"evaluates a formula at a series of iterated index values, just like "
"@code{sum} and @code{prod}, but its result is simply a vector of the "
"results.  For example, @samp{table(a_i, i, 1, 7, 2)} produces @samp{[a_1, "
"a_3, a_5, a_7]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25628
msgid ""
"The following commands and algebraic functions return true/false values, "
"where 1 represents ``true'' and 0 represents ``false.'' In cases where a "
"truth value is required (such as for the condition part of a rewrite rule, "
"or as the condition for a @w{@kbd{Z [ Z ]}} control structure), any nonzero "
"value is accepted to mean ``true.'' (Specifically, anything for which "
"@code{dnonzero} returns 1 is ``true,'' and anything for which "
"@code{dnonzero} returns 0 or cannot decide is assumed ``false.'' Note that "
"this means that @w{@kbd{Z [ Z ]}} will execute the ``then'' portion if its "
"condition is provably true, but it will execute the ``else'' portion for any "
"condition like @expr{a = b} that is not provably true, even if it might be "
"true.  Algebraic functions that have conditions as arguments, like @code{? "
":} and @code{&&}, remain unevaluated if the condition is neither provably "
"true nor provably false.  @xref{Declarations}.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:25629
#, no-wrap
msgid "a ="
msgstr ""

#. type: pindex
#: ../../calc.texi:25630
#, no-wrap
msgid "calc-equal-to"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25643
msgid ""
"@tindex eq @tindex = @tindex == The @kbd{a =} (@code{calc-equal-to}) "
"command, or @samp{eq(a,b)} function (which can also be written @samp{a = b} "
"or @samp{a == b} in an algebraic formula) is true if @expr{a} and @expr{b} "
"are equal, either because they are identical expressions, or because they "
"are numbers which are numerically equal.  (Thus the integer 1 is considered "
"equal to the float 1.0.)  If the equality of @expr{a} and @expr{b} cannot be "
"determined, the comparison is left in symbolic form.  Note that as a "
"command, this operation pops two values from the stack and pushes back "
"either a 1 or a 0, or a formula @samp{a = b} if the values' equality cannot "
"be determined."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25653
msgid ""
"Many Calc commands use @samp{=} formulas to represent @dfn{equations}.  For "
"example, the @kbd{a S} (@code{calc-solve-for}) command rearranges an "
"equation to solve for a given variable.  The @kbd{a M} "
"(@code{calc-map-equation}) command can be used to apply any function to both "
"sides of an equation; for example, @kbd{2 a M *} multiplies both sides of "
"the equation by two.  Note that just @kbd{2 *} would not do the same thing; "
"it would produce the formula @samp{2 (a = b)} which represents 2 if the "
"equality is true or zero if not."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25661
msgid ""
"The @code{eq} function with more than two arguments (e.g., @kbd{C-u 3 a =} "
"or @samp{a = b = c}) tests if all of its arguments are equal.  In algebraic "
"notation, the @samp{=} operator is unusual in that it is neither left- nor "
"right-associative: @samp{a = b = c} is not the same as @samp{(a = b) = c} or "
"@samp{a = (b = c)} (which each compare one variable with the 1 or 0 that "
"results from comparing two other variables)."
msgstr ""

#. type: kindex
#: ../../calc.texi:25662
#, no-wrap
msgid "a #"
msgstr ""

#. type: pindex
#: ../../calc.texi:25663
#, no-wrap
msgid "calc-not-equal-to"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25671
msgid ""
"@tindex neq @tindex != The @kbd{a #} (@code{calc-not-equal-to}) command, or "
"@samp{neq(a,b)} or @samp{a != b} function, is true if @expr{a} and @expr{b} "
"are not equal.  This also works with more than two arguments; @samp{a != b "
"!= c != d} tests that all four of @expr{a}, @expr{b}, @expr{c}, and @expr{d} "
"are distinct numbers."
msgstr ""

#. type: kindex
#: ../../calc.texi:25672
#, no-wrap
msgid "a <"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25674
msgid "@tindex lt"
msgstr ""

#. type: kindex
#: ../../calc.texi:25677
#, no-wrap
msgid "a >"
msgstr ""

#. type: kindex
#: ../../calc.texi:25681
#, no-wrap
msgid "a ["
msgstr ""

#. type: kindex
#: ../../calc.texi:25685
#, no-wrap
msgid "a ]"
msgstr ""

#. type: pindex
#: ../../calc.texi:25686
#, no-wrap
msgid "calc-less-than"
msgstr ""

#. type: pindex
#: ../../calc.texi:25687
#, no-wrap
msgid "calc-greater-than"
msgstr ""

#. type: pindex
#: ../../calc.texi:25688
#, no-wrap
msgid "calc-less-equal"
msgstr ""

#. type: pindex
#: ../../calc.texi:25689
#, no-wrap
msgid "calc-greater-equal"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25694
msgid "@tindex gt"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25698
msgid "@tindex leq"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25702
msgid "@tindex geq"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25706
msgid "@tindex <"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25710
msgid "@tindex >"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25714
msgid "@tindex <="
msgstr ""

#. type: Plain text
#: ../../calc.texi:25723
msgid ""
"@tindex >= The @kbd{a <} (@code{calc-less-than}) [@samp{lt(a,b)} or @samp{a "
"< b}] operation is true if @expr{a} is less than @expr{b}.  Similar "
"functions are @kbd{a >} (@code{calc-greater-than}) [@samp{gt(a,b)} or "
"@samp{a > b}], @kbd{a [} (@code{calc-less-equal}) [@samp{leq(a,b)} or "
"@samp{a <= b}], and @kbd{a ]} (@code{calc-greater-equal}) [@samp{geq(a,b)} "
"or @samp{a >= b}]."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25732
msgid ""
"While the inequality functions like @code{lt} do not accept more than two "
"arguments, the syntax @w{@samp{a <= b < c}} is translated to an equivalent "
"expression involving intervals: @samp{b in [a .. c)}.  (See the description "
"of @code{in} below.)  All four combinations of @samp{<} and @samp{<=} are "
"allowed, or any of the four combinations of @samp{>} and @samp{>=}.  "
"Four-argument constructions like @samp{a < b < c < d}, and mixtures like "
"@w{@samp{a < b = c}} that involve both equations and inequalities, are not "
"allowed."
msgstr ""

#. type: kindex
#: ../../calc.texi:25733
#, no-wrap
msgid "a ."
msgstr ""

#. type: pindex
#: ../../calc.texi:25734
#, no-wrap
msgid "calc-remove-equal"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25746
msgid ""
"@tindex rmeq The @kbd{a .} (@code{calc-remove-equal}) [@code{rmeq}] command "
"extracts the righthand side of the equation or inequality on the top of the "
"stack.  It also works elementwise on vectors.  For example, if @samp{[x = "
"2.34, y = z / 2]} is on the stack, then @kbd{a .} produces @samp{[2.34, z / "
"2]}.  As a special case, if the righthand side is a variable and the "
"lefthand side is a number (as in @samp{2.34 = x}), then Calc keeps the "
"lefthand side instead.  Finally, this command works with assignments @samp{x "
":= 2.34} as well as equations, always taking the righthand side, and for "
"@samp{=>} (evaluates-to) operators, always taking the lefthand side."
msgstr ""

#. type: kindex
#: ../../calc.texi:25747
#, no-wrap
msgid "a &"
msgstr ""

#. type: pindex
#: ../../calc.texi:25748
#, no-wrap
msgid "calc-logical-and"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25756
msgid ""
"@tindex land @tindex && The @kbd{a &} (@code{calc-logical-and}) "
"[@samp{land(a,b)} or @samp{a && b}] function is true if both of its "
"arguments are true, i.e., are non-zero numbers.  In this case, the result "
"will be either @expr{a} or @expr{b}, chosen arbitrarily.  If either argument "
"is zero, the result is zero.  Otherwise, the formula is left in symbolic "
"form."
msgstr ""

#. type: kindex
#: ../../calc.texi:25757
#, no-wrap
msgid "a |"
msgstr ""

#. type: pindex
#: ../../calc.texi:25758
#, no-wrap
msgid "calc-logical-or"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25766
msgid ""
"@tindex lor @tindex || The @kbd{a |} (@code{calc-logical-or}) "
"[@samp{lor(a,b)} or @samp{a || b}] function is true if either or both of its "
"arguments are true (nonzero).  The result is whichever argument was nonzero, "
"choosing arbitrarily if both are nonzero.  If both @expr{a} and @expr{b} are "
"zero, the result is zero."
msgstr ""

#. type: kindex
#: ../../calc.texi:25767
#, no-wrap
msgid "a !"
msgstr ""

#. type: pindex
#: ../../calc.texi:25768
#, no-wrap
msgid "calc-logical-not"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25775
msgid ""
"@tindex lnot @tindex ! The @kbd{a !} (@code{calc-logical-not}) "
"[@samp{lnot(a)} or @samp{!@: a}] function is true if @expr{a} is false "
"(zero), or false if @expr{a} is true (nonzero).  It is left in symbolic form "
"if @expr{a} is not a number."
msgstr ""

#. type: kindex
#: ../../calc.texi:25776
#, no-wrap
msgid "a :"
msgstr ""

#. type: pindex
#: ../../calc.texi:25777
#, no-wrap
msgid "calc-logical-if"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25779
msgid "@tindex if"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25783
msgid "@tindex ?"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25787
msgid "@tindex :"
msgstr ""

#. type: cindex
#: ../../calc.texi:25787
#, no-wrap
msgid "Arguments, not evaluated"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25796
msgid ""
"The @kbd{a :} (@code{calc-logical-if}) [@samp{if(a,b,c)} or @samp{a ? b :@: "
"c}] function is equal to either @expr{b} or @expr{c} if @expr{a} is a "
"nonzero number or zero, respectively.  If @expr{a} is not a number, the test "
"is left in symbolic form and neither @expr{b} nor @expr{c} is evaluated in "
"any way.  In algebraic formulas, this is one of the few Calc functions whose "
"arguments are not automatically evaluated when the function itself is "
"evaluated.  The others are @code{lambda}, @code{quote}, and "
"@code{condition}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25801
msgid ""
"One minor surprise to watch out for is that the formula @samp{a?3:4} will "
"not work because the @samp{3:4} is parsed as a fraction instead of as three "
"separate symbols.  Type something like @samp{a ? 3 : 4} or @samp{a?(3):4} "
"instead."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25809
msgid ""
"As a special case, if @expr{a} evaluates to a vector, then both @expr{b} and "
"@expr{c} are evaluated; the result is a vector of the same length as "
"@expr{a} whose elements are chosen from corresponding elements of @expr{b} "
"and @expr{c} according to whether each element of @expr{a} is zero or "
"nonzero.  Each of @expr{b} and @expr{c} must be either a vector of the same "
"length as @expr{a}, or a non-vector which is matched with all elements of "
"@expr{a}."
msgstr ""

#. type: kindex
#: ../../calc.texi:25810
#, no-wrap
msgid "a @{"
msgstr ""

#. type: pindex
#: ../../calc.texi:25811
#, no-wrap
msgid "calc-in-set"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25822
msgid ""
"@tindex in The @kbd{a @{} (@code{calc-in-set}) [@samp{in(a,b)}] function is "
"true if the number @expr{a} is in the set of numbers represented by "
"@expr{b}.  If @expr{b} is an interval form, @expr{a} must be one of the "
"values encompassed by the interval.  If @expr{b} is a vector, @expr{a} must "
"be equal to one of the elements of the vector.  (If any vector elements are "
"intervals, @expr{a} must be in any of the intervals.)  If @expr{b} is a "
"plain number, @expr{a} must be numerically equal to @expr{b}.  @xref{Set "
"Operations}, for a group of commands that manipulate sets of this sort."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25830
msgid ""
"@tindex typeof The @samp{typeof(a)} function produces an integer or variable "
"which characterizes @expr{a}.  If @expr{a} is a number, vector, or variable, "
"the result will be one of the following numbers:"
msgstr ""

#. type: example
#: ../../calc.texi:25847
#, no-wrap
msgid ""
" 1   Integer\n"
" 2   Fraction\n"
" 3   Floating-point number\n"
" 4   HMS form\n"
" 5   Rectangular complex number\n"
" 6   Polar complex number\n"
" 7   Error form\n"
" 8   Interval form\n"
" 9   Modulo form\n"
"10   Date-only form\n"
"11   Date/time form\n"
"12   Infinity (inf, uinf, or nan)\n"
"100  Variable\n"
"101  Vector (but not a matrix)\n"
"102  Matrix\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25851
msgid ""
"Otherwise, @expr{a} is a formula, and the result is a variable which "
"represents the name of the top-level function call."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25856
msgid "@tindex integer"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25860
msgid "@tindex real"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25873
msgid ""
"@tindex constant The @samp{integer(a)} function returns true if @expr{a} is "
"an integer.  The @samp{real(a)} function is true if @expr{a} is a real "
"number, either integer, fraction, or float.  The @samp{constant(a)} function "
"returns true if @expr{a} is any of the objects for which @code{typeof} would "
"produce an integer code result except for variables, and provided that the "
"components of an object like a vector or error form are themselves "
"constant.  Note that infinities do not satisfy any of these tests, nor do "
"special constants like @code{pi} and @code{e}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25879
msgid ""
"@xref{Declarations}, for a set of similar functions that recognize formulas "
"as well as actual numbers.  For example, @samp{dint(floor(x))} is true "
"because @samp{floor(x)} is provably integer-valued, but "
"@samp{integer(floor(x))} does not because @samp{floor(x)} is not literally "
"an integer constant."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25890
msgid ""
"@tindex refers The @samp{refers(a,b)} function is true if the variable (or "
"sub-expression)  @expr{b} appears in @expr{a}, or false otherwise.  Unlike "
"the other tests described here, this function returns a definite ``no'' "
"answer even if its arguments are still in symbolic form.  The only case "
"where @code{refers} will be left unevaluated is if @expr{a} is a plain "
"variable (different from @expr{b})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25903
msgid ""
"@tindex negative The @samp{negative(a)} function returns true if @expr{a} "
"``looks'' negative, because it is a negative number, because it is of the "
"form @expr{-x}, or because it is a product or quotient with a term that "
"looks negative.  This is most useful in rewrite rules.  Beware that "
"@samp{negative(a)} evaluates to 1 or 0 for @emph{any} argument @expr{a}, so "
"it can only be stored in a formula if the default simplifications are turned "
"off first with @kbd{m O} (or if it appears in an unevaluated context such as "
"a rewrite rule condition)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25912
msgid ""
"@tindex variable The @samp{variable(a)} function is true if @expr{a} is a "
"variable, or false if not.  If @expr{a} is a function call, this test is "
"left in symbolic form.  Built-in variables like @code{pi} and @code{inf} are "
"considered variables like any others by this test."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25922
msgid ""
"@tindex nonvar The @samp{nonvar(a)} function is true if @expr{a} is a "
"non-variable.  If its argument is a variable it is left unsimplified; it "
"never actually returns zero.  However, since Calc's condition-testing "
"commands consider ``false'' anything not provably true, this is often good "
"enough."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25927
msgid "@tindex lin"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25931
msgid "@tindex linnt"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25935
msgid "@tindex islin"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25939
msgid "@tindex islinnt"
msgstr ""

#. type: cindex
#: ../../calc.texi:25939
#, no-wrap
msgid "Linearity testing"
msgstr ""

#. type: Plain text
#: ../../calc.texi:25955
msgid ""
"The functions @code{lin}, @code{linnt}, @code{islin}, and @code{islinnt} "
"check if an expression is ``linear,'' i.e., can be written in the form "
"@expr{a + b x} for some constants @expr{a} and @expr{b}, and some variable "
"or subformula @expr{x}.  The function @samp{islin(f,x)} checks if formula "
"@expr{f} is linear in @expr{x}, returning 1 if so.  For example, "
"@samp{islin(x,x)}, @samp{islin(-x,x)}, @samp{islin(3,x)}, and @samp{islin(x "
"y / 3 - 2, x)} all return 1.  The @samp{lin(f,x)} function is similar, "
"except that instead of returning 1 it returns the vector @expr{[a, b, x]}.  "
"For the above examples, this vector would be @expr{[0, 1, x]}, @expr{[0, -1, "
"x]}, @expr{[3, 0, x]}, and @expr{[-2, y/3, x]}, respectively.  Both "
"@code{lin} and @code{islin} generally remain unevaluated for expressions "
"which are not linear, e.g., @samp{lin(2 x^2, x)} and @samp{lin(sin(x), x)}.  "
"The second argument can also be a formula; @samp{islin(2 + 3 sin(x), "
"sin(x))} returns true."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25963
msgid ""
"The @code{linnt} and @code{islinnt} functions perform a similar check, but "
"require a ``non-trivial'' linear form, which means that the @expr{b} "
"coefficient must be non-zero.  For example, @samp{lin(2,x)} returns "
"@expr{[2, 0, x]} and @samp{lin(y,x)} returns @expr{[y, 0, x]}, but "
"@samp{linnt(2,x)} and @samp{linnt(y,x)} are left unevaluated (in other "
"words, these formulas are considered to be only ``trivially'' linear in "
"@expr{x})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25974
msgid ""
"All four linearity-testing functions allow you to omit the second argument, "
"in which case the input may be linear in any non-constant formula.  Here, "
"the @expr{a=0}, @expr{b=1} case is also considered trivial, and only "
"constant values for @expr{a} and @expr{b} are recognized.  Thus, @samp{lin(2 "
"x y)} returns @expr{[0, 2, x y]}, @samp{lin(2 - x y)} returns @expr{[2, -1, "
"x y]}, and @samp{lin(x y)} returns @expr{[0, 1, x y]}.  The @code{linnt} "
"function would allow the first two cases but not the third.  Also, neither "
"@code{lin} nor @code{linnt} accept plain constants as linear in the "
"one-argument case: @samp{islin(2,x)} is true, but @samp{islin(2)} is false."
msgstr ""

#. type: Plain text
#: ../../calc.texi:25987
msgid ""
"@tindex istrue The @samp{istrue(a)} function returns 1 if @expr{a} is a "
"nonzero number or provably nonzero formula, or 0 if @expr{a} is anything "
"else.  Calls to @code{istrue} can only be manipulated if @kbd{m O} mode is "
"used to make sure they are not evaluated prematurely.  (Note that "
"declarations are used when deciding whether a formula is true; @code{istrue} "
"returns 1 when @code{dnonzero} would return 1, and it returns 0 when "
"@code{dnonzero} would return 0 or leave itself in symbolic form.)"
msgstr ""

#. type: cindex
#: ../../calc.texi:25992
#, no-wrap
msgid "Rewrite rules"
msgstr ""

#. type: cindex
#: ../../calc.texi:25993
#, no-wrap
msgid "Transformations"
msgstr ""

#. type: cindex
#: ../../calc.texi:25994
#, no-wrap
msgid "Pattern matching"
msgstr ""

#. type: kindex
#: ../../calc.texi:25995
#, no-wrap
msgid "a r"
msgstr ""

#. type: pindex
#: ../../calc.texi:25996
#, no-wrap
msgid "calc-rewrite"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26007
msgid ""
"@tindex rewrite The @kbd{a r} (@code{calc-rewrite}) [@code{rewrite}] command "
"makes substitutions in a formula according to a specified pattern or "
"patterns known as @dfn{rewrite rules}.  Whereas @kbd{a b} "
"(@code{calc-substitute})  matches literally, so that substituting "
"@samp{sin(x)} with @samp{cos(x)} matches only the @code{sin} function "
"applied to the variable @code{x}, rewrite rules match general kinds of "
"formulas; rewriting using the rule @samp{sin(x) := cos(x)} matches "
"@code{sin} of any argument and replaces it with @code{cos} of that same "
"argument.  The only significance of the name @code{x} is that the same name "
"is used on both sides of the rule."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26013
msgid ""
"Rewrite rules rearrange formulas already in Calc's memory.  @xref{Syntax "
"Tables}, to read about @dfn{syntax rules}, which are similar to algebraic "
"rewrite rules but operate when new algebraic entries are being parsed, "
"converting strings of characters into Calc formulas."
msgstr ""

#. type: menuentry
#: ../../calc.texi:26028
msgid "Entering Rewrite Rules::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:26028
msgid "Basic Rewrite Rules::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:26028
msgid "Conditional Rewrite Rules::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:26028
msgid "Algebraic Properties of Rewrite Rules::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:26028
msgid "Other Features of Rewrite Rules::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:26028
msgid "Composing Patterns in Rewrite Rules::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:26028
msgid "Nested Formulas with Rewrite Rules::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:26028
msgid "Multi-Phase Rewrite Rules::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:26028
msgid "Selections with Rewrite Rules::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:26028
msgid "Matching Commands::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:26028
msgid "Automatic Rewrites::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:26028
msgid "Debugging Rewrites::"
msgstr ""

#. type: subsection
#: ../../calc.texi:26028 ../../calc.texi:27637 ../../calc.texi:27657 ../../calc.texi:27658
#, no-wrap
msgid "Examples of Rewrite Rules"
msgstr ""

#. type: node
#: ../../calc.texi:26030 ../../calc.texi:26031 ../../calc.texi:26096
#, no-wrap
msgid "Entering Rewrite Rules"
msgstr ""

#. type: node
#: ../../calc.texi:26030 ../../calc.texi:26096 ../../calc.texi:26097 ../../calc.texi:26140
#, no-wrap
msgid "Basic Rewrite Rules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26041
msgid ""
"Rewrite rules normally use the ``assignment'' operator @samp{@var{old} := "
"@var{new}}.  This operator is equivalent to the function call "
"@samp{assign(old, new)}.  The @code{assign} function is undefined by itself "
"in Calc, so an assignment formula such as a rewrite rule will be left alone "
"by ordinary Calc commands.  But certain commands, like the rewrite system, "
"interpret assignments in special ways."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26047
msgid ""
"For example, the rule @samp{sin(x)^2 := 1-cos(x)^2} says to replace every "
"occurrence of the sine of something, squared, with one minus the square of "
"the cosine of that same thing.  All by itself as a formula on the stack it "
"does nothing, but when given to the @kbd{a r} command it turns that command "
"into a sine-squared-to-cosine-squared converter."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26050
msgid "To specify a set of rules to be applied all at once, make a vector of rules."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26053
msgid ""
"When @kbd{a r} prompts you to enter the rewrite rules, you can answer in "
"several ways:"
msgstr ""

#. type: enumerate
#: ../../calc.texi:26057
msgid "With a rule: @kbd{f(x) := g(x) @key{RET}}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:26060
msgid ""
"With a vector of rules: @kbd{[f1(x) := g1(x), f2(x) := g2(x)] @key{RET}}.  "
"(You can omit the enclosing square brackets if you wish.)"
msgstr ""

#. type: enumerate
#: ../../calc.texi:26063
msgid ""
"With the name of a variable that contains the rule or rules vector: "
"@kbd{myrules @key{RET}}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:26068
msgid ""
"With any formula except a rule, a vector, or a variable name; this will be "
"interpreted as the @var{old} half of a rewrite rule, and you will be "
"prompted a second time for the @var{new} half: @kbd{f(x) @key{RET} g(x) "
"@key{RET}}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:26072
msgid ""
"With a blank line, in which case the rule, rules vector, or variable will be "
"taken from the top of the stack (and the formula to be rewritten will come "
"from the second-to-top position)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26077
msgid ""
"If you enter the rules directly (as opposed to using rules stored in a "
"variable), those rules will be put into the Trail so that you can retrieve "
"them later.  @xref{Trail Commands}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26084
msgid ""
"It is most convenient to store rules you use often in a variable and invoke "
"them by giving the variable name.  The @kbd{s e} (@code{calc-edit-variable}) "
"command is an easy way to create or edit a rule set stored in a variable.  "
"You may also wish to use @kbd{s p} (@code{calc-permanent-variable}) to save "
"your rules permanently; @pxref{Operations on Variables}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26091
msgid ""
"Rewrite rules are compiled into a special internal form for faster "
"matching.  If you enter a rule set directly it must be recompiled every "
"time.  If you store the rules in a variable and refer to them through that "
"variable, they will be compiled once and saved away along with the variable "
"for later reference.  This is another good reason to store your rules in a "
"variable."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26095
msgid ""
"Calc also accepts an obsolete notation for rules, as vectors "
"@samp{[@var{old}, @var{new}]}.  But because it is easily confused with a "
"vector of two rules, the use of this notation is no longer recommended."
msgstr ""

#. type: node
#: ../../calc.texi:26096 ../../calc.texi:26140 ../../calc.texi:26141 ../../calc.texi:26223
#, no-wrap
msgid "Conditional Rewrite Rules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26111
msgid ""
"To match a particular formula @expr{x} with a particular rewrite rule "
"@samp{@var{old} := @var{new}}, Calc compares the structure of @expr{x} with "
"the structure of @var{old}.  Variables that appear in @var{old} are treated "
"as @dfn{meta-variables}; the corresponding positions in @expr{x} may contain "
"any sub-formulas.  For example, the pattern @samp{f(x,y)} would match the "
"expression @samp{f(12, a+1)} with the meta-variable @samp{x} corresponding "
"to 12 and with @samp{y} corresponding to @samp{a+1}.  However, this pattern "
"would not match @samp{f(12)} or @samp{g(12, a+1)}, since there is no "
"assignment of the meta-variables that will make the pattern match these "
"expressions.  Notice that if the pattern is a single meta-variable, it will "
"match any expression."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26117
msgid ""
"If a given meta-variable appears more than once in @var{old}, the "
"corresponding sub-formulas of @expr{x} must be identical.  Thus the pattern "
"@samp{f(x,x)} would match @samp{f(12, 12)} and @samp{f(a+1, a+1)} but not "
"@samp{f(12, a+1)} or @samp{f(a+b, b+a)}.  (@xref{Conditional Rewrite Rules}, "
"for a way to match the latter.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26123
msgid ""
"Things other than variables must match exactly between the pattern and the "
"target formula.  To match a particular variable exactly, use the "
"pseudo-function @samp{quote(v)} in the pattern.  For example, the pattern "
"@samp{x+quote(y)} matches @samp{x+y}, @samp{2+y}, or @samp{sin(a)+y}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26128
msgid ""
"The special variable names @samp{e}, @samp{pi}, @samp{i}, @samp{phi}, "
"@samp{gamma}, @samp{inf}, @samp{uinf}, and @samp{nan} always match "
"literally.  Thus the pattern @samp{sin(d + e + f)} acts exactly like "
"@samp{sin(d + quote(e) + f)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26134
msgid ""
"If the @var{old} pattern is found to match a given formula, that formula is "
"replaced by @var{new}, where any occurrences in @var{new} of meta-variables "
"from the pattern are replaced with the sub-formulas that they matched.  "
"Thus, applying the rule @samp{f(x,y) := g(y+x,x)} to @samp{f(12, a+1)} would "
"produce @samp{g(a+13, 12)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26139
msgid ""
"The normal @kbd{a r} command applies rewrite rules over and over throughout "
"the target formula until no further changes are possible (up to a limit of "
"100 times).  Use @kbd{C-u 1 a r} to make only one change at a time."
msgstr ""

#. type: node
#: ../../calc.texi:26140 ../../calc.texi:26223 ../../calc.texi:26224 ../../calc.texi:26562
#, no-wrap
msgid "Algebraic Properties of Rewrite Rules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26158
msgid ""
"A rewrite rule can also be @dfn{conditional}, written in the form "
"@samp{@var{old} := @var{new} :: @var{cond}}.  (There is also the obsolete "
"form @samp{[@var{old}, @var{new}, @var{cond}]}.)  If a @var{cond} part is "
"present in the rule, this is an additional condition that must be satisfied "
"before the rule is accepted.  Once @var{old} has been successfully matched "
"to the target expression, @var{cond} is evaluated (with all the "
"meta-variables substituted for the values they matched) and simplified with "
"Calc's algebraic simplifications.  If the result is a nonzero number or any "
"other object known to be nonzero (@pxref{Declarations}), the rule is "
"accepted.  If the result is zero or if it is a symbolic formula that is not "
"known to be nonzero, the rule is rejected.  @xref{Logical Operations}, for a "
"number of functions that return 1 or 0 according to the results of various "
"tests."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26168
msgid ""
"For example, the formula @samp{n > 0} simplifies to 1 or 0 if @expr{n} is "
"replaced by a positive or nonpositive number, respectively (or if @expr{n} "
"has been declared to be positive or nonpositive).  Thus, the rule "
"@samp{f(x,y) := g(y+x,x) :: x+y > 0} would apply to @samp{f(0, 4)} but not "
"to @samp{f(-3, 2)} or @samp{f(12, a+1)} (assuming no outstanding "
"declarations for @expr{a}).  In the case of @samp{f(-3, 2)}, the condition "
"can be shown not to be satisfied; in the case of @samp{f(12, a+1)}, the "
"condition merely cannot be shown to be satisfied, but that is enough to "
"reject the rule."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26178
msgid ""
"While Calc will use declarations to reason about variables in the formula "
"being rewritten, declarations do not apply to meta-variables.  For example, "
"the rule @samp{f(a) := g(a+1)} will match for any values of @samp{a}, such "
"as complex numbers, vectors, or formulas, even if @samp{a} has been declared "
"to be real or scalar.  If you want the meta-variable @samp{a} to match only "
"literal real numbers, use @samp{f(a) := g(a+1) :: real(a)}.  If you want "
"@samp{a} to match only reals and formulas which are provably real, use "
"@samp{dreal(a)} as the condition."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26182
msgid ""
"The @samp{::} operator is a shorthand for the @code{condition} function; "
"@samp{@var{old} := @var{new} :: @var{cond}} is equivalent to the formula "
"@samp{condition(assign(@var{old}, @var{new}), @var{cond})}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26185
msgid ""
"If you have several conditions, you can use @samp{... :: c1 :: c2 :: c3} or "
"@samp{... :: c1 && c2 && c3}.  The two are entirely equivalent."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26192
msgid ""
"It is also possible to embed conditions inside the pattern: @samp{f(x :: "
"x>0, y) := g(y+x, x)}.  This is purely a notational convenience, though; "
"where a condition appears in a rule has no effect on when it is tested.  The "
"rewrite-rule compiler automatically decides when it is best to test each "
"condition while a rule is being matched."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26202
msgid ""
"Certain conditions are handled as special cases by the rewrite rule system "
"and are tested very efficiently: Where @expr{x} is any meta-variable, these "
"conditions are @samp{integer(x)}, @samp{real(x)}, @samp{constant(x)}, "
"@samp{negative(x)}, @samp{x >= y} where @expr{y} is either a constant or "
"another meta-variable and @samp{>=} may be replaced by any of the six "
"relational operators, and @samp{x % a = b} where @expr{a} and @expr{b} are "
"constants.  Other conditions, like @samp{x >= y+1} or @samp{dreal(x)}, will "
"be less efficient to check since Calc must bring the whole evaluator and "
"simplifier into play."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26212
msgid ""
"An interesting property of @samp{::} is that neither of its arguments will "
"be touched by Calc's default simplifications.  This is important because "
"conditions often are expressions that cannot safely be evaluated early.  For "
"example, the @code{typeof} function never remains in symbolic form; entering "
"@samp{typeof(a)} will put the number 100 (the type code for variables like "
"@samp{a}) on the stack.  But putting the condition @samp{... :: typeof(a) = "
"6} on the stack is safe since @samp{::} prevents the @code{typeof} from "
"being evaluated until the condition is actually used by the rewrite system."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26222
msgid ""
"Since @samp{::} protects its lefthand side, too, you can use a dummy "
"condition to protect a rule that must itself not evaluate early.  For "
"example, it's not safe to put @samp{a(f,x) := apply(f, [x])} on the stack "
"because it will immediately evaluate to @samp{a(f,x) := f(x)}, where the "
"meta-variable-ness of @code{f} on the righthand side has been lost.  But "
"@samp{a(f,x) := apply(f, [x]) :: 1} is safe, and of course the condition "
"@samp{1} is always true (nonzero) so it has no effect on the functioning of "
"the rule.  (The rewrite compiler will ensure that it doesn't even impact the "
"speed of matching the rule.)"
msgstr ""

#. type: node
#: ../../calc.texi:26223 ../../calc.texi:26562 ../../calc.texi:26563 ../../calc.texi:26964
#, no-wrap
msgid "Other Features of Rewrite Rules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26231
msgid ""
"The rewrite mechanism understands the algebraic properties of functions like "
"@samp{+} and @samp{*}.  In particular, pattern matching takes the "
"associativity and commutativity of the following functions into account:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:26234
#, no-wrap
msgid "+ - *  = !=  && ||  and or xor  vint vunion vxor  gcd lcm  max min  beta\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26237
msgid "For example, the rewrite rule:"
msgstr ""

#. type: example
#: ../../calc.texi:26240
#, no-wrap
msgid "a x + b x  :=  (a + b) x\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26244
msgid "will match formulas of the form,"
msgstr ""

#. type: example
#: ../../calc.texi:26247
#, no-wrap
msgid "a x + b x,  x a + x b,  a x + x b,  x a + b x\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26251
msgid ""
"Rewrites also understand the relationship between the @samp{+} and @samp{-} "
"operators.  The above rewrite rule will also match the formulas,"
msgstr ""

#. type: example
#: ../../calc.texi:26254
#, no-wrap
msgid "a x - b x,  x a - x b,  a x - x b,  x a - b x\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26258
msgid "by matching @samp{b} in the pattern to @samp{-b} from the formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26262
msgid ""
"Applied to a sum of many terms like @samp{r + a x + s + b x + t}, this "
"pattern will check all pairs of terms for possible matches.  The rewrite "
"will take whichever suitable pair it discovers first."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26271
msgid ""
"In general, a pattern using an associative operator like @samp{a + b} will "
"try @var{2 n} different ways to match a sum of @var{n} terms like @samp{x + "
"y + z - w}.  First, @samp{a} is matched against each of @samp{x}, @samp{y}, "
"@samp{z}, and @samp{-w} in turn, with @samp{b} being matched to the "
"remainders @samp{y + z - w}, @samp{x + z - w}, etc.  If none of these "
"succeed, then @samp{b} is matched against each of the four terms with "
"@samp{a} matching the remainder.  Half-and-half matches, like @samp{(x + y) "
"+ (z - w)}, are not tried."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26281
msgid ""
"Note that @samp{*} is not commutative when applied to matrices, but rewrite "
"rules pretend that it is.  If you type @kbd{m v} to enable Matrix mode "
"(@pxref{Matrix Mode}), rewrite rules will match @samp{*} literally, ignoring "
"its usual commutativity property.  (In the current implementation, the "
"associativity also vanishes---it is as if the pattern had been enclosed in a "
"@code{plain} marker; see below.)  If you are applying rewrites to formulas "
"with matrices, it's best to enable Matrix mode first to prevent "
"algebraically incorrect rewrites from occurring."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26284
msgid ""
"The pattern @samp{-x} will actually match any expression.  For example, the "
"rule"
msgstr ""

#. type: example
#: ../../calc.texi:26287
#, no-wrap
msgid "f(-x)  :=  -f(x)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26296
msgid ""
"will rewrite @samp{f(a)} to @samp{-f(-a)}.  To avoid this, either use a "
"@code{plain} marker as described below, or add a @samp{negative(x)} "
"condition.  The @code{negative} function is true if its argument ``looks'' "
"negative, for example, because it is a negative number or because it is a "
"formula like @samp{-x}.  The new rule using this condition is:"
msgstr ""

#. type: example
#: ../../calc.texi:26300
#, no-wrap
msgid ""
"f(x)  :=  -f(-x)  :: negative(x)    @r{or, equivalently,}\n"
"f(-x)  :=  -f(x)  :: negative(-x)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26304
msgid ""
"In the same way, the pattern @samp{x - y} will match the sum @samp{a + b} by "
"matching @samp{y} to @samp{-b}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26309
msgid ""
"The pattern @samp{a b} will also match the formula @samp{x/y} if @samp{y} is "
"a number.  Thus the rule @samp{a x + @w{b x} := (a+b) x} will also convert "
"@samp{a x + x / 2} to @samp{(a + 0.5) x} (or @samp{(a + 1:2) x}, depending "
"on the current fraction mode)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26320
msgid ""
"Calc will @emph{not} take other liberties with @samp{*}, @samp{/}, and "
"@samp{^}.  For example, the pattern @samp{f(a b)} will not match "
"@samp{f(x^2)}, and @samp{f(a + b)} will not match @samp{f(2 x)}, even though "
"conceivably these patterns could match with @samp{a = b = x}.  Nor will "
"@samp{f(a b)} match @samp{f(x / y)} if @samp{y} is not a constant, even "
"though it could be considered to match with @samp{a = x} and @samp{b = "
"1/y}.  The reasons are partly for efficiency, and partly because while few "
"mathematical operations are substantively different for addition and "
"subtraction, often it is preferable to treat the cases of multiplication, "
"division, and integer powers separately."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26322
msgid "Even more subtle is the rule set"
msgstr ""

#. type: example
#: ../../calc.texi:26325
#, no-wrap
msgid "[ f(a) + f(b) := f(a + b),  -f(a) := f(-a) ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26339
msgid ""
"attempting to match @samp{f(x) - f(y)}.  You might think that Calc will view "
"this subtraction as @samp{f(x) + (-f(y))} and then apply the above two rules "
"in turn, but actually this will not work because Calc only does this when "
"considering rules for @samp{+} (like the first rule in this set).  So it "
"will see first that @samp{f(x) + (-f(y))} does not match @samp{f(a) + f(b)} "
"for any assignments of the meta-variables, and then it will see that "
"@samp{f(x) - f(y)} does not match @samp{-f(a)} for any assignment of "
"@samp{a}.  Because Calc tries only one rule at a time, it will not be able "
"to rewrite @samp{f(x) - f(y)} with this rule set.  An explicit @samp{f(a) - "
"f(b)} rule will have to be added."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26345
msgid ""
"Another thing patterns will @emph{not} do is break up complex numbers.  The "
"pattern @samp{myconj(a + @w{b i)} := a - b i} will work for formulas "
"involving the special constant @samp{i} (such as @samp{3 - 4 i}), but it "
"will not match actual complex numbers like @samp{(3, -4)}.  A version of the "
"above rule for complex numbers would be"
msgstr ""

#. type: example
#: ../../calc.texi:26348
#, no-wrap
msgid "myconj(a)  :=  re(a) - im(a) (0,1)  :: im(a) != 0\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26357
msgid ""
"(Because the @code{re} and @code{im} functions understand the properties of "
"the special constant @samp{i}, this rule will also work for @samp{3 - 4 i}.  "
"In fact, this particular rule would probably be better without the "
"@samp{im(a) != 0} condition, since if @samp{im(a) = 0} the righthand side of "
"the rule will still give the correct answer for the conjugate of a real "
"number.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26359
msgid "It is also possible to specify optional arguments in patterns.  The rule"
msgstr ""

#. type: example
#: ../../calc.texi:26362
#, no-wrap
msgid "opt(a) x + opt(b) (x^opt(c) + opt(d))  :=  f(a, b, c, d)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26366
msgid "will match the formula"
msgstr ""

#. type: example
#: ../../calc.texi:26369
#, no-wrap
msgid "5 (x^2 - 4) + 3 x\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26374
msgid ""
"in a fairly straightforward manner, but it will also match reduced formulas "
"like"
msgstr ""

#. type: example
#: ../../calc.texi:26377
#, no-wrap
msgid "x + x^2,    2(x + 1) - x,    x + x\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26381
msgid "producing, respectively,"
msgstr ""

#. type: example
#: ../../calc.texi:26384
#, no-wrap
msgid "f(1, 1, 2, 0),   f(-1, 2, 1, 1),   f(1, 1, 1, 0)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26388
msgid ""
"(The latter two formulas can be entered only if default simplifications have "
"been turned off with @kbd{m O}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26393
msgid ""
"The default value for a term of a sum is zero.  The default value for a part "
"of a product, for a power, or for the denominator of a quotient, is one.  "
"Also, @samp{-x} matches the pattern @samp{opt(a) b} with @samp{a = -1}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26395
msgid "In particular, the distributive-law rule can be refined to"
msgstr ""

#. type: example
#: ../../calc.texi:26398
#, no-wrap
msgid "opt(a) x + opt(b) x  :=  (a + b) x\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26402
msgid "so that it will convert, e.g., @samp{a x - x}, to @samp{(a - 1) x}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26411
msgid ""
"The pattern @samp{opt(a) + opt(b) x} matches almost any formulas which are "
"linear in @samp{x}.  You can also use the @code{lin} and @code{islin} "
"functions with rewrite conditions to test for this; @pxref{Logical "
"Operations}.  These functions are not as convenient to use in rewrite rules, "
"but they recognize more kinds of formulas as linear: @samp{x/z} is "
"considered linear with @expr{b = 1/z} by @code{lin}, but it will not match "
"the above pattern because that pattern calls for a multiplication, not a "
"division."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26414
msgid ""
"As another example, the obvious rule to replace @samp{sin(x)^2 + cos(x)^2} "
"by 1,"
msgstr ""

#. type: example
#: ../../calc.texi:26417
#, no-wrap
msgid "sin(x)^2 + cos(x)^2  :=  1\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26422
msgid ""
"misses many cases because the sine and cosine may both be multiplied by an "
"equal factor.  Here's a more successful rule:"
msgstr ""

#. type: example
#: ../../calc.texi:26425
#, no-wrap
msgid "opt(a) sin(x)^2 + opt(a) cos(x)^2  :=  a\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26429
msgid ""
"Note that this rule will @emph{not} match @samp{sin(x)^2 + 6 cos(x)^2} "
"because one @expr{a} would have ``matched'' 1 while the other matched 6."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26431
msgid "Calc automatically converts a rule like"
msgstr ""

#. type: example
#: ../../calc.texi:26434
#, no-wrap
msgid "f(x-1, x)  :=  g(x)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26438
msgid "into the form"
msgstr ""

#. type: example
#: ../../calc.texi:26441
#, no-wrap
msgid "f(temp, x)  :=  g(x)  :: temp = x-1\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26449
msgid ""
"(where @code{temp} stands for a new, invented meta-variable that doesn't "
"actually have a name).  This modified rule will successfully match "
"@samp{f(6, 7)}, binding @samp{temp} and @samp{x} to 6 and 7, respectively, "
"then verifying that they differ by one even though @samp{6} does not "
"superficially look like @samp{x-1}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26452
msgid ""
"However, Calc does not solve equations to interpret a rule.  The following "
"rule,"
msgstr ""

#. type: example
#: ../../calc.texi:26455
#, no-wrap
msgid "f(x-1, x+1)  :=  g(x)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26465
msgid ""
"will not work.  That is, it will match @samp{f(a - 1 + b, a + 1 + b)} but "
"not @samp{f(6, 8)}.  Calc always interprets at least one occurrence of a "
"variable by literal matching.  If the variable appears ``isolated'' then "
"Calc is smart enough to use it for literal matching.  But in this last "
"example, Calc is forced to rewrite the rule to @samp{f(x-1, temp)  := g(x) "
":: temp = x+1} where the @samp{x-1} term must correspond to an actual "
"``something-minus-one'' in the target formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26469
msgid ""
"A successful way to write this would be @samp{f(x, x+2) := g(x+1)}.  You "
"could make this resemble the original form more closely by using @code{let} "
"notation, which is described in the next section:"
msgstr ""

#. type: example
#: ../../calc.texi:26472
#, no-wrap
msgid "f(xm1, x+1)  :=  g(x)  :: let(x := xm1+1)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26482
msgid ""
"Calc does this rewriting or ``conditionalizing'' for any sub-pattern which "
"involves only the functions in the following list, operating only on "
"constants and meta-variables which have already been matched elsewhere in "
"the pattern.  When matching a function call, Calc is careful to match "
"arguments which are plain variables before arguments which are calls to any "
"of the functions below, so that a pattern like @samp{f(x-1, x)} can be "
"conditionalized even though the isolated @samp{x} comes after the "
"@samp{x-1}."
msgstr ""

#. type: smallexample
#: ../../calc.texi:26486
#, no-wrap
msgid ""
"+ - * / \\ % ^  abs sign  round rounde roundu trunc floor ceil\n"
"max min  re im conj arg\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26495
msgid ""
"You can suppress all of the special treatments described in this section by "
"surrounding a function call with a @code{plain} marker.  This marker causes "
"the function call which is its argument to be matched literally, without "
"regard to commutativity, associativity, negation, or conditionalization.  "
"When you use @code{plain}, the ``deep structure'' of the formula being "
"matched can show through.  For example,"
msgstr ""

#. type: example
#: ../../calc.texi:26498
#, no-wrap
msgid "plain(a - a b)  :=  f(a, b)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26507
msgid ""
"will match only literal subtractions.  However, the @code{plain} marker does "
"not affect its arguments' arguments.  In this case, commutativity and "
"associativity is still considered while matching the @w{@samp{a b}} "
"sub-pattern, so the whole pattern will match @samp{x - y x} as well as "
"@samp{x - x y}.  We could go still further and use"
msgstr ""

#. type: example
#: ../../calc.texi:26510
#, no-wrap
msgid "plain(a - plain(a b))  :=  f(a, b)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26514
msgid "which would do a completely strict match for the pattern."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26518
msgid ""
"By contrast, the @code{quote} marker means that not only the function name "
"but also the arguments must be literally the same.  The above pattern will "
"match @samp{x - x y} but"
msgstr ""

#. type: example
#: ../../calc.texi:26521
#, no-wrap
msgid "quote(a - a b)  :=  f(a, b)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26525
msgid "will match only the single formula @samp{a - a b}.  Also,"
msgstr ""

#. type: example
#: ../../calc.texi:26528
#, no-wrap
msgid "quote(a - quote(a b))  :=  f(a, b)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26533
msgid "will match only @samp{a - quote(a b)}---probably not the desired effect!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26537
msgid ""
"A certain amount of algebra is also done when substituting the "
"meta-variables on the righthand side of a rule.  For example, in the rule"
msgstr ""

#. type: example
#: ../../calc.texi:26540
#, no-wrap
msgid "a + f(b)  :=  f(a + b)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26552
msgid ""
"matching @samp{f(x) - y} would produce @samp{f((-y) + x)} if taken "
"literally, but the rewrite mechanism will simplify the righthand side to "
"@samp{f(x - y)} automatically.  (Of course, the default simplifications "
"would do this anyway, so this special simplification is only noticeable if "
"you have turned the default simplifications off.)  This rewriting is done "
"only when a meta-variable expands to a ``negative-looking'' expression.  If "
"this simplification is not desirable, you can use a @code{plain} marker on "
"the righthand side:"
msgstr ""

#. type: example
#: ../../calc.texi:26555
#, no-wrap
msgid "a + f(b)  :=  f(plain(a + b))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26561
msgid ""
"In this example, we are still allowing the pattern-matcher to use all the "
"algebra it can muster, but the righthand side will always simplify to a "
"literal addition like @samp{f((-y) + x)}."
msgstr ""

#. type: node
#: ../../calc.texi:26562 ../../calc.texi:26964 ../../calc.texi:26965 ../../calc.texi:27133
#, no-wrap
msgid "Composing Patterns in Rewrite Rules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26570
msgid ""
"Certain ``function names'' serve as markers in rewrite rules.  Here is a "
"complete list of these markers.  First are listed the markers that work "
"inside a pattern; then come the markers that work in the righthand side of a "
"rule."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26600
msgid ""
"@tindex import One kind of marker, @samp{import(x)}, takes the place of a "
"whole rule.  Here @expr{x} is the name of a variable containing another rule "
"set; those rules are ``spliced into'' the rule set that imports them.  For "
"example, if @samp{[f(a+b) := f(a) + f(b), f(a b) := a f(b) :: real(a)]} is "
"stored in variable @samp{linearF}, then the rule set @samp{[f(0) := 0, "
"import(linearF)]} will apply all three rules.  It is possible to modify the "
"imported rules slightly: @samp{import(x, v1, x1, v2, x2, @dots{})} imports "
"the rule set @expr{x} with all occurrences of @texline @math{v_1}, @infoline "
"@expr{v1}, as either a variable name or a function name, replaced with "
"@texline @math{x_1} @infoline @expr{x1} and so on.  (If @texline @math{v_1} "
"@infoline @expr{v1} is used as a function name, then @texline @math{x_1} "
"@infoline @expr{x1} must be either a function name itself or a @w{@samp{< "
">}} nameless function; @pxref{Specifying Operators}.)  For example, "
"@samp{[g(0) := 0, import(linearF, f, g)]} applies the linearity rules to the "
"function @samp{g} instead of @samp{f}.  Imports can be nested, but the "
"import-with-renaming feature may fail to rename sub-imports properly."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26602
msgid "The special functions allowed in patterns are:"
msgstr ""

#. type: item
#: ../../calc.texi:26604 ../../calc.texi:26775
#, no-wrap
msgid "quote(x)"
msgstr ""

#. type: table
#: ../../calc.texi:26617
msgid ""
"@tindex quote This pattern matches exactly @expr{x}; variable names in "
"@expr{x} are not interpreted as meta-variables.  The only flexibility is "
"that numbers are compared for numeric equality, so that the pattern "
"@samp{f(quote(12))} will match both @samp{f(12)} and @samp{f(12.0)}.  "
"(Numbers are always treated this way by the rewrite mechanism: The rule "
"@samp{f(x,x) := g(x)} will match @samp{f(12, 12.0)}.  The rewrite may "
"produce either @samp{g(12)} or @samp{g(12.0)} as a result in this case.)"
msgstr ""

#. type: item
#: ../../calc.texi:26618 ../../calc.texi:26787
#, no-wrap
msgid "plain(x)"
msgstr ""

#. type: table
#: ../../calc.texi:26631
msgid ""
"@tindex plain Here @expr{x} must be a function call "
"@samp{f(x1,x2,@dots{})}.  This pattern matches a call to function @expr{f} "
"with the specified argument patterns.  No special knowledge of the "
"properties of the function @expr{f} is used in this case; @samp{+} is not "
"commutative or associative.  Unlike @code{quote}, the arguments "
"@samp{x1,x2,@dots{}} are treated as patterns.  If you wish them to be "
"treated ``plainly'' as well, you must enclose them with more @code{plain} "
"markers: @samp{plain(plain(@w{-a}) + plain(b c))}."
msgstr ""

#. type: item
#: ../../calc.texi:26632
#, no-wrap
msgid "opt(x,def)"
msgstr ""

#. type: table
#: ../../calc.texi:26646
msgid ""
"@tindex opt Here @expr{x} must be a variable name.  This must appear as an "
"argument to a function or an element of a vector; it specifies that the "
"argument or element is optional.  As an argument to @samp{+}, @samp{-}, "
"@samp{*}, @samp{&&}, or @samp{||}, or as the second argument to @samp{/} or "
"@samp{^}, the value @var{def} may be omitted.  The pattern @samp{x + opt(y)} "
"matches a sum by binding one summand to @expr{x} and the other to @expr{y}, "
"and it matches anything else by binding the whole expression to @expr{x} and "
"zero to @expr{y}.  The other operators above work similarly."
msgstr ""

#. type: table
#: ../../calc.texi:26656
msgid ""
"For general miscellaneous functions, the default value @code{def} must be "
"specified.  Optional arguments are dropped starting with the rightmost one "
"during matching.  For example, the pattern @samp{f(opt(a,0), b, opt(c,b))} "
"will match @samp{f(b)}, @samp{f(a,b)}, or @samp{f(a,b,c)}.  Default values "
"of zero and @expr{b} are supplied in this example for the omitted "
"arguments.  Note that the literal variable @expr{b} will be the default in "
"the latter case, @emph{not} the value that matched the meta-variable "
"@expr{b}.  In other words, the default @var{def} is effectively quoted."
msgstr ""

#. type: item
#: ../../calc.texi:26657
#, no-wrap
msgid "condition(x,c)"
msgstr ""

#. type: table
#: ../../calc.texi:26665
msgid ""
"@tindex condition @tindex :: This matches the pattern @expr{x}, with the "
"attached condition @expr{c}.  It is the same as @samp{x :: c}."
msgstr ""

#. type: item
#: ../../calc.texi:26666
#, no-wrap
msgid "pand(x,y)"
msgstr ""

#. type: table
#: ../../calc.texi:26675
msgid ""
"@tindex pand @tindex &&& This matches anything that matches both pattern "
"@expr{x} and pattern @expr{y}.  It is the same as @samp{x &&& y}.  "
"@pxref{Composing Patterns in Rewrite Rules}."
msgstr ""

#. type: item
#: ../../calc.texi:26676
#, no-wrap
msgid "por(x,y)"
msgstr ""

#. type: table
#: ../../calc.texi:26684
msgid ""
"@tindex por @tindex ||| This matches anything that matches either pattern "
"@expr{x} or pattern @expr{y}.  It is the same as @w{@samp{x ||| y}}."
msgstr ""

#. type: item
#: ../../calc.texi:26685
#, no-wrap
msgid "pnot(x)"
msgstr ""

#. type: table
#: ../../calc.texi:26693
msgid ""
"@tindex pnot @tindex !!! This matches anything that does not match pattern "
"@expr{x}.  It is the same as @samp{!!! x}."
msgstr ""

#. type: item
#: ../../calc.texi:26694 ../../calc.texi:26796
#, no-wrap
msgid "cons(h,t)"
msgstr ""

#. type: table
#: ../../calc.texi:26705
msgid ""
"@tindex cons (rewrites)  This matches any vector of one or more elements.  "
"The first element is matched to @expr{h}; a vector of the remaining elements "
"is matched to @expr{t}.  Note that vectors of fixed length can also be "
"matched as actual vectors: The rule @samp{cons(a,cons(b,[])) := "
"cons(a+b,[])} is equivalent to the rule @samp{[a,b] := [a+b]}."
msgstr ""

#. type: item
#: ../../calc.texi:26706 ../../calc.texi:26804
#, no-wrap
msgid "rcons(t,h)"
msgstr ""

#. type: table
#: ../../calc.texi:26714
msgid ""
"@tindex rcons (rewrites)  This is like @code{cons}, except that the "
"@emph{last} element is matched to @expr{h}, with the remaining elements "
"matched to @expr{t}."
msgstr ""

#. type: item
#: ../../calc.texi:26715 ../../calc.texi:26808
#, no-wrap
msgid "apply(f,args)"
msgstr ""

#. type: table
#: ../../calc.texi:26734
msgid ""
"@tindex apply (rewrites)  This matches any function call.  The name of the "
"function, in the form of a variable, is matched to @expr{f}.  The arguments "
"of the function, as a vector of zero or more objects, are matched to "
"@samp{args}.  Constants, variables, and vectors do @emph{not} match an "
"@code{apply} pattern.  For example, @samp{apply(f,x)} matches any function "
"call, @samp{apply(quote(f),x)} matches any call to the function @samp{f}, "
"@samp{apply(f,[a,b])} matches any function call with exactly two arguments, "
"and @samp{apply(quote(f), cons(a,cons(b,x)))} matches any call to the "
"function @samp{f} with two or more arguments.  Another way to implement the "
"latter, if the rest of the rule does not need to refer to the first two "
"arguments of @samp{f} by name, would be @samp{apply(quote(f), x :: vlen(x) "
">= 2)}.  Here's a more interesting sample use of @code{apply}:"
msgstr ""

#. type: example
#: ../../calc.texi:26738
#, no-wrap
msgid ""
"apply(f,[x+n])  :=  n + apply(f,[x])\n"
"   :: in(f, [floor,ceil,round,trunc]) :: integer(n)\n"
msgstr ""

#. type: table
#: ../../calc.texi:26747
msgid ""
"Note, however, that this will be slower to match than a rule set with four "
"separate rules.  The reason is that Calc sorts the rules of a rule set "
"according to top-level function name; if the top-level function is "
"@code{apply}, Calc must try the rule for every single formula and "
"sub-formula.  If the top-level function in the pattern is, say, "
"@code{floor}, then Calc invokes the rule only for sub-formulas which are "
"calls to @code{floor}."
msgstr ""

#. type: table
#: ../../calc.texi:26751
msgid ""
"Formulas normally written with operators like @code{+} are still considered "
"function calls: @code{apply(f,x)} matches @samp{a+b} with @samp{f = add}, "
"@samp{x = [a,b]}."
msgstr ""

#. type: table
#: ../../calc.texi:26762
msgid ""
"You must use @code{apply} for meta-variables with function names on both "
"sides of a rewrite rule: @samp{apply(f, [x]) := f(x+1)} is @emph{not} "
"correct, because it rewrites @samp{spam(6)} into @samp{f(7)}.  The righthand "
"side should be @samp{apply(f, [x+1])}.  Also note that you will have to use "
"No-Simplify mode (@kbd{m O})  when entering this rule so that the "
"@code{apply} isn't evaluated immediately to get the new rule @samp{f(x) := "
"f(x+1)}.  Or, use @kbd{s e} to enter the rule without going through the "
"stack, or enter the rule as @samp{apply(f, [x]) := apply(f, [x+1]) @w{:: "
"1}}.  @xref{Conditional Rewrite Rules}."
msgstr ""

#. type: item
#: ../../calc.texi:26763 ../../calc.texi:26842
#, no-wrap
msgid "select(x)"
msgstr ""

#. type: table
#: ../../calc.texi:26770
msgid ""
"@tindex select This is used for applying rules to formulas with selections; "
"@pxref{Selections with Rewrite Rules}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26773
msgid "Special functions for the righthand sides of rules are:"
msgstr ""

#. type: table
#: ../../calc.texi:26786
msgid ""
"The notation @samp{quote(x)} is changed to @samp{x} when the righthand side "
"is used.  As far as the rewrite rule is concerned, @code{quote} is "
"invisible.  However, @code{quote} has the special property in Calc that its "
"argument is not evaluated.  Thus, while it will not work to put the rule "
"@samp{t(a) := typeof(a)} on the stack because @samp{typeof(a)} is evaluated "
"immediately to produce @samp{t(a) := 100}, you can use @code{quote} to "
"protect the righthand side: @samp{t(a) := quote(typeof(a))}.  "
"(@xref{Conditional Rewrite Rules}, for another trick for protecting rules "
"from evaluation.)"
msgstr ""

#. type: table
#: ../../calc.texi:26795
msgid ""
"Special properties of and simplifications for the function call @expr{x} are "
"not used.  One interesting case where @code{plain} is useful is the rule, "
"@samp{q(x) := quote(x)}, trying to expand a shorthand notation for the "
"@code{quote} function.  This rule will not work as shown; instead of "
"replacing @samp{q(foo)} with @samp{quote(foo)}, it will replace it with "
"@samp{foo}! The correct rule would be @samp{q(x) := plain(quote(x))}."
msgstr ""

#. type: table
#: ../../calc.texi:26803
msgid ""
"Where @expr{t} is a vector, this is converted into an expanded vector during "
"rewrite processing.  Note that @code{cons} is a regular Calc function which "
"normally does this anyway; the only way @code{cons} is treated specially by "
"rewrites is that @code{cons} on the righthand side of a rule will be "
"evaluated even if default simplifications have been turned off."
msgstr ""

#. type: table
#: ../../calc.texi:26807
msgid ""
"Analogous to @code{cons} except putting @expr{h} at the @emph{end} of the "
"vector @expr{t}."
msgstr ""

#. type: table
#: ../../calc.texi:26812
msgid ""
"Where @expr{f} is a variable and @var{args} is a vector, this is converted "
"to a function call.  Once again, note that @code{apply} is also a regular "
"Calc function."
msgstr ""

#. type: item
#: ../../calc.texi:26813
#, no-wrap
msgid "eval(x)"
msgstr ""

#. type: table
#: ../../calc.texi:26825
msgid ""
"@tindex eval The formula @expr{x} is handled in the usual way, then the "
"default simplifications are applied to it even if they have been turned off "
"normally.  This allows you to treat any function similarly to the way "
"@code{cons} and @code{apply} are always treated.  However, there is a slight "
"difference: @samp{cons(2+3, [])} with default simplifications off will be "
"converted to @samp{[2+3]}, whereas @samp{eval(cons(2+3, []))} will be "
"converted to @samp{[5]}."
msgstr ""

#. type: item
#: ../../calc.texi:26826
#, no-wrap
msgid "evalsimp(x)"
msgstr ""

#. type: table
#: ../../calc.texi:26833
msgid ""
"@tindex evalsimp The formula @expr{x} has meta-variables substituted in the "
"usual way, then algebraically simplified."
msgstr ""

#. type: item
#: ../../calc.texi:26834
#, no-wrap
msgid "evalextsimp(x)"
msgstr ""

#. type: table
#: ../../calc.texi:26841
msgid ""
"@tindex evalextsimp The formula @expr{x} has meta-variables substituted in "
"the normal way, then ``extendedly'' simplified as if by the @kbd{a e} "
"command."
msgstr ""

#. type: table
#: ../../calc.texi:26844
msgid "@xref{Selections with Rewrite Rules}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26847
msgid "There are also some special functions you can use in conditions."
msgstr ""

#. type: item
#: ../../calc.texi:26849
#, no-wrap
msgid "let(v := x)"
msgstr ""

#. type: table
#: ../../calc.texi:26870
msgid ""
"@tindex let The expression @expr{x} is evaluated with meta-variables "
"substituted.  The algebraic simplifications are @emph{not} applied by "
"default, but @expr{x} can include calls to @code{evalsimp} or "
"@code{evalextsimp} as described above to invoke higher levels of "
"simplification.  The result of @expr{x} is then bound to the meta-variable "
"@expr{v}.  As usual, if this meta-variable has already been matched to "
"something else the two values must be equal; if the meta-variable is new "
"then it is bound to the result of the expression.  This variable can then "
"appear in later conditions, and on the righthand side of the rule.  In fact, "
"@expr{v} may be any pattern in which case the result of evaluating @expr{x} "
"is matched to that pattern, binding any meta-variables that appear in that "
"pattern.  Note that @code{let} can only appear by itself as a condition, or "
"as one term of an @samp{&&} which is a whole condition: It cannot be inside "
"an @samp{||} term or otherwise buried."
msgstr ""

#. type: table
#: ../../calc.texi:26875
msgid ""
"The alternate, equivalent form @samp{let(v, x)} is also recognized.  Note "
"that the use of @samp{:=} by @code{let}, while still being assignment-like "
"in character, is unrelated to the use of @samp{:=} in the main part of a "
"rewrite rule."
msgstr ""

#. type: table
#: ../../calc.texi:26887
msgid ""
"As an example, @samp{f(a) := g(ia) :: let(ia := 1/a) :: constant(ia)} "
"replaces @samp{f(a)} with @samp{g} of the inverse of @samp{a}, if that "
"inverse exists and is constant.  For example, if @samp{a} is a singular "
"matrix the operation @samp{1/a} is left unsimplified and @samp{constant(ia)} "
"fails, but if @samp{a} is an invertible matrix then the rule succeeds.  "
"Without @code{let} there would be no way to express this rule that didn't "
"have to invert the matrix twice.  Note that, because the meta-variable "
"@samp{ia} is otherwise unbound in this rule, the @code{let} condition itself "
"always ``succeeds'' because no matter what @samp{1/a} evaluates to, it can "
"successfully be bound to @code{ia}."
msgstr ""

#. type: table
#: ../../calc.texi:26898
msgid ""
"Here's another example, for integrating cosines of linear terms: "
"@samp{myint(cos(y),x) := sin(y)/b :: let([a,b,x] := lin(y,x))}.  The "
"@code{lin} function returns a 3-vector if its argument is linear, or leaves "
"itself unevaluated if not.  But an unevaluated @code{lin} call will not "
"match the 3-vector on the lefthand side of the @code{let}, so this "
"@code{let} both verifies that @code{y} is linear, and binds the coefficients "
"@code{a} and @code{b} for use elsewhere in the rule.  (It would have been "
"possible to use @samp{sin(a x + b)/b} for the righthand side instead, but "
"using @samp{sin(y)/b} avoids gratuitous rearrangement of the argument of the "
"sine.)"
msgstr ""

#. type: table
#: ../../calc.texi:26909
msgid ""
"@tindex ierf Similarly, here is a rule that implements an inverse-@code{erf} "
"function.  It uses @code{root} to search for a solution.  If @code{root} "
"succeeds, it will return a vector of two numbers where the first number is "
"the desired solution.  If no solution is found, @code{root} remains in "
"symbolic form.  So we use @code{let} to check that the result was indeed a "
"vector."
msgstr ""

#. type: example
#: ../../calc.texi:26912
#, no-wrap
msgid "ierf(x)  :=  y  :: let([y,z] := root(erf(a) = x, a, .5))\n"
msgstr ""

#. type: item
#: ../../calc.texi:26914
#, no-wrap
msgid "matches(v,p)"
msgstr ""

#. type: table
#: ../../calc.texi:26923
msgid ""
"The meta-variable @var{v}, which must already have been matched to something "
"elsewhere in the rule, is compared against pattern @var{p}.  Since "
"@code{matches} is a standard Calc function, it can appear anywhere in a "
"condition.  But if it appears alone or as a term of a top-level @samp{&&}, "
"then you get the special extra feature that meta-variables which are bound "
"to things inside @var{p} can be used elsewhere in the surrounding rewrite "
"rule."
msgstr ""

#. type: table
#: ../../calc.texi:26927
msgid ""
"The only real difference between @samp{let(p := v)} and @samp{matches(v, p)} "
"is that the former evaluates @samp{v} using the default simplifications, "
"while the latter does not."
msgstr ""

#. type: vindex
#: ../../calc.texi:26928 ../../calc.texi:26929
#, no-wrap
msgid "remember"
msgstr ""

#. type: table
#: ../../calc.texi:26937
msgid ""
"This is actually a variable, not a function.  If @code{remember} appears as "
"a condition in a rule, then when that rule succeeds the original expression "
"and rewritten expression are added to the front of the rule set that "
"contained the rule.  If the rule set was not stored in a variable, "
"@code{remember} is ignored.  The lefthand side is enclosed in @code{quote} "
"in the added rule if it contains any variables."
msgstr ""

#. type: table
#: ../../calc.texi:26944
msgid ""
"For example, the rule @samp{f(n) := n f(n-1) :: remember} applied to "
"@samp{f(7)} will add the rule @samp{f(7) := 7 f(6)} to the front of the rule "
"set.  The rule set @code{EvalRules} works slightly differently: There, the "
"evaluation of @samp{f(6)} will complete before the result is added to the "
"rule set, in this case as @samp{f(7) := 5040}.  Thus @code{remember} is most "
"useful inside @code{EvalRules}."
msgstr ""

#. type: table
#: ../../calc.texi:26952
msgid ""
"It is up to you to ensure that the optimization performed by @code{remember} "
"is safe.  For example, the rule @samp{foo(n) := n :: evalv(eatfoo) > 0 :: "
"remember} is a bad idea (@code{evalv} is the function equivalent of the "
"@kbd{=} command); if the variable @code{eatfoo} ever contains 1, rules like "
"@samp{foo(7) := 7} will be added to the rule set and will continue to "
"operate even if @code{eatfoo} is later changed to 0."
msgstr ""

#. type: item
#: ../../calc.texi:26953
#, no-wrap
msgid "remember(c)"
msgstr ""

#. type: table
#: ../../calc.texi:26962
msgid ""
"@tindex remember Remember the match as described above, but only if "
"condition @expr{c} is true.  For example, @samp{remember(n % 4 = 0)} in the "
"above factorial rule remembers only every fourth result.  Note that "
"@samp{remember(1)} is equivalent to @samp{remember}, and @samp{remember(0)} "
"has no effect."
msgstr ""

#. type: node
#: ../../calc.texi:26964 ../../calc.texi:27133 ../../calc.texi:27134 ../../calc.texi:27217
#, no-wrap
msgid "Nested Formulas with Rewrite Rules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26973
msgid ""
"There are three operators, @samp{&&&}, @samp{|||}, and @samp{!!!}, that "
"combine rewrite patterns to make larger patterns.  The combinations are "
"``and,'' ``or,'' and ``not,'' respectively, and these operators are the "
"pattern equivalents of @samp{&&}, @samp{||} and @samp{!} (which operate on "
"zero-or-nonzero logical values)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26977
msgid ""
"Note that @samp{&&&}, @samp{|||}, and @samp{!!!} are left in symbolic form "
"by all regular Calc features; they have special meaning only in the context "
"of rewrite rule patterns."
msgstr ""

#. type: Plain text
#: ../../calc.texi:26982
msgid ""
"The pattern @samp{@var{p1} &&& @var{p2}} matches anything that matches both "
"@var{p1} and @var{p2}.  One especially useful case is when one of @var{p1} "
"or @var{p2} is a meta-variable.  For example, here is a rule that operates "
"on error forms:"
msgstr ""

#. type: example
#: ../../calc.texi:26985
#, no-wrap
msgid "f(x &&& a +/- b, x)  :=  g(x)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26988
msgid "This does the same thing, but is arguably simpler than, the rule"
msgstr ""

#. type: example
#: ../../calc.texi:26991
#, no-wrap
msgid "f(a +/- b, a +/- b)  :=  g(a +/- b)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:26998
msgid "@tindex ends Here's another interesting example:"
msgstr ""

#. type: example
#: ../../calc.texi:27001
#, no-wrap
msgid "ends(cons(a, x) &&& rcons(y, b))  :=  [a, b]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27007
msgid ""
"which effectively clips out the middle of a vector leaving just the first "
"and last elements.  This rule will change a one-element vector @samp{[a]} to "
"@samp{[a, a]}.  The similar rule"
msgstr ""

#. type: example
#: ../../calc.texi:27010
#, no-wrap
msgid "ends(cons(a, rcons(y, b)))  :=  [a, b]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27015
msgid ""
"would do the same thing except that it would fail to match a one-element "
"vector."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27023
msgid ""
"The pattern @samp{@var{p1} ||| @var{p2}} matches anything that matches "
"either @var{p1} or @var{p2}.  Calc first tries matching against @var{p1}; if "
"that fails, it goes on to try @var{p2}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27029
msgid "@tindex curve A simple example of @samp{|||} is"
msgstr ""

#. type: example
#: ../../calc.texi:27032
#, no-wrap
msgid "curve(inf ||| -inf)  :=  0\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27036
msgid "which converts both @samp{curve(inf)} and @samp{curve(-inf)} to zero."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27038
msgid "Here is a larger example:"
msgstr ""

#. type: example
#: ../../calc.texi:27041
#, no-wrap
msgid "log(a, b) ||| (ln(a) :: let(b := e))  :=  mylog(a, b)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27046
msgid ""
"This matches both generalized and natural logarithms in a single rule.  Note "
"that the @samp{::} term must be enclosed in parentheses because that "
"operator has lower precedence than @samp{|||} or @samp{:=}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27049
msgid ""
"(In practice this rule would probably include a third alternative, omitted "
"here for brevity, to take care of @code{log10}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27058
msgid ""
"While Calc generally treats interior conditions exactly the same as "
"conditions on the outside of a rule, it does guarantee that if all the "
"variables in the condition are special names like @code{e}, or already bound "
"in the pattern to which the condition is attached (say, if @samp{a} had "
"appeared in this condition), then Calc will process this condition right "
"after matching the pattern to the left of the @samp{::}.  Thus, we know that "
"@samp{b} will be bound to @samp{e} only if the @code{ln} branch of the "
"@samp{|||} was taken."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27063
msgid ""
"Note that this rule was careful to bind the same set of meta-variables on "
"both sides of the @samp{|||}.  Calc does not check this, but if you bind a "
"certain meta-variable only in one branch and then use that meta-variable "
"elsewhere in the rule, results are unpredictable:"
msgstr ""

#. type: example
#: ../../calc.texi:27066
#, no-wrap
msgid "f(a,b) ||| g(b)  :=  h(a,b)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27070
msgid ""
"Here if the pattern matches @samp{g(17)}, Calc makes no promises about the "
"value that will be substituted for @samp{a} on the righthand side."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27078
msgid ""
"The pattern @samp{!!! @var{pat}} matches anything that does not match "
"@var{pat}.  Any meta-variables that are bound while matching @var{pat} "
"remain unbound outside of @var{pat}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27080 ../../calc.texi:32662
msgid "For example,"
msgstr ""

#. type: example
#: ../../calc.texi:27083
#, no-wrap
msgid "f(x &&& !!! a +/- b, !!![])  :=  g(x)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27089
msgid ""
"converts @code{f} whose first argument is anything @emph{except} an error "
"form, and whose second argument is not the empty vector, into a similar call "
"to @code{g} (but without the second argument)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27092
msgid ""
"If we know that the second argument will be a vector (empty or not), then an "
"equivalent rule would be:"
msgstr ""

#. type: example
#: ../../calc.texi:27095
#, no-wrap
msgid "f(x, y)  :=  g(x)  :: typeof(x) != 7 :: vlen(y) > 0\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27105
msgid ""
"where of course 7 is the @code{typeof} code for error forms.  Another final "
"condition, that works for any kind of @samp{y}, would be @samp{!istrue(y == "
"[])}.  (The @code{istrue} function returns an explicit 0 if its argument was "
"left in symbolic form; plain @samp{!(y == [])} or @samp{y != []} would not "
"work to replace @samp{!!![]} since these would be left unsimplified, and "
"thus cause the rule to fail, if @samp{y} was something like a variable "
"name.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27108
msgid ""
"It is possible for a @samp{!!!} to refer to meta-variables bound elsewhere "
"in the pattern.  For example,"
msgstr ""

#. type: example
#: ../../calc.texi:27111
#, no-wrap
msgid "f(a, !!!a)  :=  g(a)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27116
msgid ""
"matches any call to @code{f} with different arguments, changing this to "
"@code{g} with only the first argument."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27120
msgid ""
"If a function call is to be matched and one of the argument patterns "
"contains a @samp{!!!} somewhere inside it, that argument will be matched "
"last.  Thus"
msgstr ""

#. type: example
#: ../../calc.texi:27123
#, no-wrap
msgid "f(!!!a, a)  :=  g(a)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27132
msgid ""
"will be careful to bind @samp{a} to the second argument of @code{f} before "
"testing the first argument.  If Calc had tried to match the first argument "
"of @code{f} first, the results would have been disastrous: since @code{a} "
"was unbound so far, the pattern @samp{a} would have matched anything at all, "
"and the pattern @samp{!!!a} therefore would @emph{not} have matched anything "
"at all!"
msgstr ""

#. type: node
#: ../../calc.texi:27133 ../../calc.texi:27217 ../../calc.texi:27218 ../../calc.texi:27338
#, no-wrap
msgid "Multi-Phase Rewrite Rules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27145
msgid ""
"When @kbd{a r} (@code{calc-rewrite}) is used, it takes an expression from "
"the top of the stack and attempts to match any of the specified rules to any "
"part of the expression, starting with the whole expression and then, if that "
"fails, trying deeper and deeper sub-expressions.  For each part of the "
"expression, the rules are tried in the order they appear in the rules "
"vector.  The first rule to match the first sub-expression wins; it replaces "
"the matched sub-expression according to the @var{new} part of the rule."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27154
msgid ""
"Often, the rule set will match and change the formula several times.  The "
"top-level formula is first matched and substituted repeatedly until it no "
"longer matches the pattern; then, sub-formulas are tried, and so on.  Once "
"every part of the formula has gotten its chance, the rewrite mechanism "
"starts over again with the top-level formula (in case a substitution of one "
"of its arguments has caused it again to match).  This continues until no "
"further matches can be made anywhere in the formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27164
msgid ""
"It is possible for a rule set to get into an infinite loop.  The most "
"obvious case, replacing a formula with itself, is not a problem because a "
"rule is not considered to ``succeed'' unless the righthand side actually "
"comes out to something different from the original formula or sub-formula "
"that was matched.  But if you accidentally had both @samp{ln(a b) := ln(a) + "
"ln(b)} and the reverse @samp{ln(a) + ln(b) := ln(a b)} in your rule set, "
"Calc would run forever switching a formula back and forth between the two "
"forms."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27170
msgid ""
"To avoid disaster, Calc normally stops after 100 changes have been made to "
"the formula.  This will be enough for most multiple rewrites, but it will "
"keep an endless loop of rewrites from locking up the computer forever.  (On "
"most systems, you can also type @kbd{C-g} to halt any Emacs command "
"prematurely.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27175
msgid ""
"To change this limit, give a positive numeric prefix argument.  In "
"particular, @kbd{M-1 a r} applies only one rewrite at a time, useful when "
"you are first testing your rule (or just if repeated rewriting is not what "
"is called for by your application)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27190
msgid ""
"@tindex iterations You can also put a ``function call'' "
"@samp{iterations(@var{n})} in place of a rule anywhere in your rules vector "
"(but usually at the top).  Then, @var{n} will be used instead of 100 as the "
"default number of iterations for this rule set.  You can use "
"@samp{iterations(inf)} if you want no iteration limit by default.  A prefix "
"argument will override the @code{iterations} limit in the rule set."
msgstr ""

#. type: example
#: ../../calc.texi:27194
#, no-wrap
msgid ""
"[ iterations(1),\n"
"  f(x) := f(x+1) ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27201
msgid ""
"More precisely, the limit controls the number of ``iterations,'' where each "
"iteration is a successful matching of a rule pattern whose righthand side, "
"after substituting meta-variables and applying the default simplifications, "
"is different from the original sub-formula that was matched."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27203
msgid "A prefix argument of zero sets the limit to infinity.  Use with caution!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27207
msgid ""
"Given a negative numeric prefix argument, @kbd{a r} will match and "
"substitute the top-level expression up to that many times, but will not "
"attempt to match the rules to any sub-expressions."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27216
msgid ""
"In a formula, @code{rewrite(@var{expr}, @var{rules}, @var{n})} does a "
"rewriting operation.  Here @var{expr} is the expression being rewritten, "
"@var{rules} is the rule, vector of rules, or variable containing the rules, "
"and @var{n} is the optional iteration limit, which may be a positive "
"integer, a negative integer, or @samp{inf} or @samp{-inf}.  If @var{n} is "
"omitted the @code{iterations} value from the rule set is used; if both are "
"omitted, 100 is used."
msgstr ""

#. type: node
#: ../../calc.texi:27217 ../../calc.texi:27338 ../../calc.texi:27339 ../../calc.texi:27411
#, no-wrap
msgid "Selections with Rewrite Rules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27225
msgid ""
"It is possible to separate a rewrite rule set into several @dfn{phases}.  "
"During each phase, certain rules will be enabled while certain others will "
"be disabled.  A @dfn{phase schedule} controls the order in which phases "
"occur during the rewriting process."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27230
msgid "@tindex phase"
msgstr ""

#. type: vindex
#: ../../calc.texi:27230
#, no-wrap
msgid "all"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27237
msgid ""
"If a call to the marker function @code{phase} appears in the rules vector in "
"place of a rule, all rules following that point will be members of the "
"phase(s) identified in the arguments to @code{phase}.  Phases are given "
"integer numbers.  The markers @samp{phase()} and @samp{phase(all)} both mean "
"the following rules belong to all phases; this is the default at the start "
"of the rule set."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27241
msgid ""
"If you do not explicitly schedule the phases, Calc sorts all phase numbers "
"that appear in the rule set and executes the phases in ascending order.  For "
"example, the rule set"
msgstr ""

#. type: group
#: ../../calc.texi:27253
#, no-wrap
msgid ""
"[ f0(x) := g0(x),\n"
"  phase(1),\n"
"  f1(x) := g1(x),\n"
"  phase(2),\n"
"  f2(x) := g2(x),\n"
"  phase(3),\n"
"  f3(x) := g3(x),\n"
"  phase(1,2),\n"
"  f4(x) := g4(x) ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27261
msgid ""
"has three phases, 1 through 3.  Phase 1 consists of the @code{f0}, "
"@code{f1}, and @code{f4} rules (in that order).  Phase 2 consists of "
"@code{f0}, @code{f2}, and @code{f4}.  Phase 3 consists of @code{f0} and "
"@code{f3}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27271
msgid ""
"When Calc rewrites a formula using this rule set, it first rewrites the "
"formula using only the phase 1 rules until no further changes are possible.  "
"Then it switches to the phase 2 rule set and continues until no further "
"changes occur, then finally rewrites with phase 3.  When no more phase 3 "
"rules apply, rewriting finishes.  (This is assuming @kbd{a r} with a large "
"enough prefix argument to allow the rewriting to run to completion; the "
"sequence just described stops early if the number of iterations specified in "
"the prefix argument, 100 by default, is reached.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27278
msgid ""
"During each phase, Calc descends through the nested levels of the formula as "
"described previously.  (@xref{Nested Formulas with Rewrite Rules}.)  "
"Rewriting starts at the top of the formula, then works its way down to the "
"parts, then goes back to the top and works down again.  The phase 2 rules do "
"not begin until no phase 1 rules apply anywhere in the formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27293
msgid ""
"@tindex schedule A @code{schedule} marker appearing in the rule set "
"(anywhere, but conventionally at the top) changes the default schedule of "
"phases.  In the simplest case, @code{schedule} has a sequence of phase "
"numbers for arguments; each phase number is invoked in turn until the "
"arguments to @code{schedule} are exhausted.  Thus adding "
"@samp{schedule(3,2,1)} at the top of the above rule set would reverse the "
"order of the phases; @samp{schedule(1,2,3)} would have no effect since this "
"is the default schedule; and @samp{schedule(1,2,1,3)} would give phase 1 a "
"second chance after phase 2 has completed, before moving on to phase 3."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27302
msgid ""
"Any argument to @code{schedule} can instead be a vector of phase numbers (or "
"even of sub-vectors).  Then the sub-sequence of phases described by the "
"vector are tried repeatedly until no change occurs in any phase in the "
"sequence.  For example, @samp{schedule([1, 2], 3)} tries phase 1, then phase "
"2, then, if either phase made any changes to the formula, repeats these two "
"phases until they can make no further progress.  Finally, it goes on to "
"phase 3 for finishing touches."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27310
msgid ""
"Also, items in @code{schedule} can be variable names as well as numbers.  A "
"variable name is interpreted as the name of a function to call on the whole "
"formula.  For example, @samp{schedule(1, simplify)} says to apply the "
"phase-1 rules (presumably, all of them), then to call @code{simplify} which "
"is the function name equivalent of @kbd{a s}.  Likewise, @samp{schedule([1, "
"simplify])} says to alternate between phase 1 and @kbd{a s} until no further "
"changes occur."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27317
msgid ""
"Phases can be used purely to improve efficiency; if it is known that a "
"certain group of rules will apply only at the beginning of rewriting, and a "
"certain other group will apply only at the end, then rewriting will be "
"faster if these groups are identified as separate phases.  Once the phase 1 "
"rules are done, Calc can put them aside and no longer spend any time on them "
"while it works on phase 2."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27329
msgid ""
"There are also some problems that can only be solved with several rewrite "
"phases.  For a real-world example of a multi-phase rule set, examine the set "
"@code{FitRules}, which is used by the curve-fitting command to convert a "
"model expression to linear form.  @xref{Curve Fitting Details}.  This set is "
"divided into four phases.  The first phase rewrites certain kinds of "
"expressions to be more easily linearizable, but less computationally "
"efficient.  After the linear components have been picked out, the final "
"phase includes the opposite rewrites to put each component back into an "
"efficient form.  If both sets of rules were included in one big phase, Calc "
"could get into an infinite loop going back and forth between the two forms."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27337
msgid ""
"Elsewhere in @code{FitRules}, the components are first isolated, then "
"recombined where possible to reduce the complexity of the linear fit, then "
"finally packaged one component at a time into vectors.  If the packaging "
"rules were allowed to begin before the recombining rules were finished, some "
"components might be put away into vectors before they had a chance to "
"recombine.  By putting these rules in two separate phases, this problem is "
"neatly avoided."
msgstr ""

#. type: node
#: ../../calc.texi:27338 ../../calc.texi:27411 ../../calc.texi:27412 ../../calc.texi:27463
#, no-wrap
msgid "Matching Commands"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27347
msgid ""
"If a sub-formula of the current formula is selected (as by @kbd{j s}; "
"@pxref{Selecting Subformulas}), the @kbd{a r} (@code{calc-rewrite})  command "
"applies only to that sub-formula.  Together with a negative prefix argument, "
"you can use this fact to apply a rewrite to one specific part of a formula "
"without affecting any other parts."
msgstr ""

#. type: kindex
#: ../../calc.texi:27348
#, no-wrap
msgid "j r"
msgstr ""

#. type: pindex
#: ../../calc.texi:27349
#, no-wrap
msgid "calc-rewrite-selection"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27358
msgid ""
"The @kbd{j r} (@code{calc-rewrite-selection}) command allows more "
"sophisticated operations on selections.  This command prompts for the rules "
"in the same way as @kbd{a r}, but it then applies those rules to the whole "
"formula in question even though a sub-formula of it has been selected.  "
"However, the selected sub-formula will first have been surrounded by a "
"@samp{select( )} function call.  (Calc's evaluator does not understand the "
"function name @code{select}; this is only a tag used by the @kbd{j r} "
"command.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27365
msgid ""
"For example, suppose the formula on the stack is @samp{2 (a + b)^2} and the "
"sub-formula @samp{a + b} is selected.  This formula will be rewritten to "
"@samp{2 select(a + b)^2} and then the rewrite rules will be applied in the "
"usual way.  The rewrite rules can include references to @code{select} to "
"tell where in the pattern the selected sub-formula should appear."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27370
msgid ""
"If there is still exactly one @samp{select( )} function call in the formula "
"after rewriting is done, it indicates which part of the formula should be "
"selected afterwards.  Otherwise, the formula will be unselected."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27379
msgid ""
"You can make @kbd{j r} act much like @kbd{a r} by enclosing both parts of "
"the rewrite rule with @samp{select()}.  However, @kbd{j r} allows you to use "
"the current selection in more flexible ways.  Suppose you wished to make a "
"rule which removed the exponent from the selected term; the rule "
"@samp{select(a)^x := select(a)} would work.  In the above example, it would "
"rewrite @samp{2 select(a + b)^2} to @samp{2 select(a + b)}.  This would then "
"be returned to the stack as @samp{2 (a + b)} with the @samp{a + b} selected."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27384
msgid ""
"The @kbd{j r} command uses one iteration by default, unlike @kbd{a r} which "
"defaults to 100 iterations.  A numeric prefix argument affects @kbd{j r} in "
"the same way as @kbd{a r}.  @xref{Nested Formulas with Rewrite Rules}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27389
msgid ""
"As with other selection commands, @kbd{j r} operates on the stack entry that "
"contains the cursor.  (If the cursor is on the top-of-stack @samp{.} marker, "
"it works as if the cursor were on the formula at stack level 1.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27395
msgid ""
"If you don't specify a set of rules, the rules are taken from the top of the "
"stack, just as with @kbd{a r}.  In this case, the cursor must indicate stack "
"entry 2 or above as the formula to be rewritten (otherwise the same formula "
"would be used as both the target and the rewrite rules)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27402
msgid ""
"If the indicated formula has no selection, the cursor position within the "
"formula temporarily selects a sub-formula for the purposes of this command.  "
"If the cursor is not on any sub-formula (e.g., it is in the line-number area "
"to the left of the formula), the @samp{select( )} markers are ignored by the "
"rewrite mechanism and the rules are allowed to apply anywhere in the "
"formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27410
msgid ""
"As a special feature, the normal @kbd{a r} command also ignores "
"@samp{select( )} calls in rewrite rules.  For example, if you used the above "
"rule @samp{select(a)^x := select(a)} with @kbd{a r}, it would apply the rule "
"as if it were @samp{a^x := a}.  Thus, you can write general purpose rules "
"with @samp{select( )} hints inside them so that they will ``do the right "
"thing'' in both @kbd{a r} and @kbd{j r}, both with and without selections."
msgstr ""

#. type: node
#: ../../calc.texi:27411 ../../calc.texi:27463 ../../calc.texi:27464 ../../calc.texi:27637
#, no-wrap
msgid "Automatic Rewrites"
msgstr ""

#. type: kindex
#: ../../calc.texi:27415
#, no-wrap
msgid "a m"
msgstr ""

#. type: pindex
#: ../../calc.texi:27416
#, no-wrap
msgid "calc-match"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27429
msgid ""
"@tindex match The @kbd{a m} (@code{calc-match}) [@code{match}] function "
"takes a vector of formulas and a rewrite-rule-style pattern, and produces a "
"vector of all formulas which match the pattern.  The command prompts you to "
"enter the pattern; as for @kbd{a r}, you can enter a single pattern (i.e., a "
"formula with meta-variables), or a vector of patterns, or a variable which "
"contains patterns, or you can give a blank response in which case the "
"patterns are taken from the top of the stack.  The pattern set will be "
"compiled once and saved if it is stored in a variable.  If there are several "
"patterns in the set, vector elements are kept if they match any of the "
"patterns."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27432
msgid ""
"For example, @samp{match(a+b, [x, x+y, x-y, 7, x+y+z])} will return "
"@samp{[x+y, x-y, x+y+z]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27434
msgid "The @code{import} mechanism is not available for pattern sets."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27438
msgid ""
"The @kbd{a m} command can also be used to extract all vector elements which "
"satisfy any condition: The pattern @samp{x :: x>0} will select all the "
"positive vector elements."
msgstr ""

#. type: kindex
#: ../../calc.texi:27439
#, no-wrap
msgid "I a m"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27443
msgid ""
"@tindex matchnot With the Inverse flag [@code{matchnot}], this command "
"extracts all vector elements which do @emph{not} match the given pattern."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27452
msgid ""
"@tindex matches There is also a function @samp{matches(@var{x}, @var{p})} "
"which evaluates to 1 if expression @var{x} matches pattern @var{p}, or to 0 "
"otherwise.  This is sometimes useful for including into the conditional "
"clauses of other rewrite rules."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27462
msgid ""
"@tindex vmatches The function @code{vmatches} is just like @code{matches}, "
"except that if the match succeeds it returns a vector of assignments to the "
"meta-variables instead of the number 1.  For example, @samp{vmatches(f(1,2), "
"f(a,b))} returns @samp{[a := 1, b := 2]}.  If the match fails, the function "
"returns the number 0."
msgstr ""

#. type: node
#: ../../calc.texi:27463 ../../calc.texi:27637 ../../calc.texi:27638 ../../calc.texi:27657
#, no-wrap
msgid "Debugging Rewrites"
msgstr ""

#. type: cindex
#: ../../calc.texi:27467
#, no-wrap
msgid "@code{EvalRules} variable"
msgstr ""

#. type: vindex
#: ../../calc.texi:27468
#, no-wrap
msgid "EvalRules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27474
msgid ""
"It is possible to get Calc to apply a set of rewrite rules on all results, "
"effectively adding to the built-in set of default simplifications.  To do "
"this, simply store your rule set in the variable @code{EvalRules}.  There is "
"a convenient @kbd{s E} command for editing @code{EvalRules}; "
"@pxref{Operations on Variables}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27479
msgid ""
"For example, suppose you want @samp{sin(a + b)} to be expanded out to "
"@samp{sin(b) cos(a) + cos(b) sin(a)} wherever it appears, and similarly for "
"@samp{cos(a + b)}.  The corresponding rewrite rule set would be,"
msgstr ""

#. type: group
#: ../../calc.texi:27484
#, no-wrap
msgid ""
"[ sin(a + b)  :=  cos(a) sin(b) + sin(a) cos(b),\n"
"  cos(a + b)  :=  cos(a) cos(b) - sin(a) sin(b) ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27494
msgid ""
"To apply these manually, you could put them in a variable called "
"@code{trigexp} and then use @kbd{a r trigexp} every time you wanted to "
"expand trig functions.  But if instead you store them in the variable "
"@code{EvalRules}, they will automatically be applied to all sines and "
"cosines of sums.  Then, with @samp{2 x} and @samp{45} on the stack, typing "
"@kbd{+ S} will (assuming Degrees mode) result in @samp{0.7071 sin(2 x) + "
"0.7071 cos(2 x)} automatically."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27502
msgid ""
"As each level of a formula is evaluated, the rules from @code{EvalRules} are "
"applied before the default simplifications.  Rewriting continues until no "
"further @code{EvalRules} apply.  Note that this is different from the usual "
"order of application of rewrite rules: @code{EvalRules} works from the "
"bottom up, simplifying the arguments to a function before the function "
"itself, while @kbd{a r} applies rules from the top down."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27505
msgid ""
"Because the @code{EvalRules} are tried first, you can use them to override "
"the normal behavior of any built-in Calc function."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27517
msgid ""
"It is important not to write a rule that will get into an infinite loop.  "
"For example, the rule set @samp{[f(0) := 1, f(n) := n f(n-1)]} appears to be "
"a good definition of a factorial function, but it is unsafe.  Imagine what "
"happens if @samp{f(2.5)} is simplified.  Calc will continue to subtract 1 "
"from this argument forever without reaching zero.  A safer second rule would "
"be @samp{f(n) := n f(n-1) :: n>0}.  Another dangerous rule is @samp{g(x, y) "
":= g(y, x)}.  Rewriting @samp{g(2, 4)}, this would bounce back and forth "
"between that and @samp{g(4, 2)} forever.  If an infinite loop in "
"@code{EvalRules} occurs, Emacs will eventually stop with a ``Computation got "
"stuck or ran too long'' message."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27531
msgid ""
"Another subtle difference between @code{EvalRules} and regular rewrites "
"concerns rules that rewrite a formula into an identical formula.  For "
"example, @samp{f(n) := f(floor(n))} ``fails to match'' when @expr{n} is "
"already an integer.  But in @code{EvalRules} this case is detected only if "
"the righthand side literally becomes the original formula before any further "
"simplification.  This means that @samp{f(n) := f(floor(n))} will get into an "
"infinite loop if it occurs in @code{EvalRules}.  Calc will replace "
"@samp{f(6)} with @samp{f(floor(6))}, which is different from @samp{f(6)}, so "
"it will consider the rule to have matched and will continue simplifying that "
"formula; first the argument is simplified to get @samp{f(6)}, then the rule "
"matches again to get @samp{f(floor(6))} again, ad infinitum.  A much safer "
"rule would check its argument first, say, with @samp{f(n) := f(floor(n)) :: "
"!dint(n)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27545
msgid ""
"(What really happens is that the rewrite mechanism substitutes the "
"meta-variables in the righthand side of a rule, compares to see if the "
"result is the same as the original formula and fails if so, then uses the "
"default simplifications to simplify the result and compares again (and again "
"fails if the formula has simplified back to its original form).  The only "
"special wrinkle for the @code{EvalRules} is that the same rules will come "
"back into play when the default simplifications are used.  What Calc wants "
"to do is build @samp{f(floor(6))}, see that this is different from the "
"original formula, simplify to @samp{f(6)}, see that this is the same as the "
"original formula, and thus halt the rewriting.  But while simplifying, "
"@samp{f(6)} will again trigger the same @code{EvalRules} rule and Calc will "
"get into a loop inside the rewrite mechanism itself.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27550
msgid ""
"The @code{phase}, @code{schedule}, and @code{iterations} markers do not work "
"in @code{EvalRules}.  If the rule set is divided into phases, only the phase "
"1 rules are applied, and the schedule is ignored.  The rules are always "
"repeated as many times as possible."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27559
msgid ""
"The @code{EvalRules} are applied to all function calls in a formula, but not "
"to numbers (and other number-like objects like error forms), nor to vectors "
"or individual variable names.  (Though they will apply to @emph{components} "
"of vectors and error forms when appropriate.)  You might try to make a "
"variable @code{phihat} which automatically expands to its definition without "
"the need to press @kbd{=} by writing the rule @samp{quote(phihat) := "
"(1-sqrt(5))/2}, but unfortunately this rule will not work as part of "
"@code{EvalRules}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27574
msgid ""
"Finally, another limitation is that Calc sometimes calls its built-in "
"functions directly rather than going through the default simplifications.  "
"When it does this, @code{EvalRules} will not be able to override those "
"functions.  For example, when you take the absolute value of the complex "
"number @expr{(2, 3)}, Calc computes @samp{sqrt(2*2 + 3*3)} by calling the "
"multiplication, addition, and square root functions directly rather than "
"applying the default simplifications to this formula.  So an "
"@code{EvalRules} rule that (perversely) rewrites @samp{sqrt(13) := 6} would "
"not apply.  (However, if you put Calc into Symbolic mode so that "
"@samp{sqrt(13)} will be left in symbolic form by the built-in square root "
"function, your rule will be able to apply.  But if the complex number were "
"@expr{(3,4)}, so that @samp{sqrt(25)} must be calculated, then Symbolic mode "
"will not help because @samp{sqrt(25)} can be evaluated exactly to 5.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27588
msgid ""
"One subtle restriction that normally only manifests itself with "
"@code{EvalRules} is that while a given rewrite rule is in the process of "
"being checked, that same rule cannot be recursively applied.  Calc "
"effectively removes the rule from its rule set while checking the rule, then "
"puts it back once the match succeeds or fails.  (The technical reason for "
"this is that compiled pattern programs are not reentrant.)  For example, "
"consider the rule @samp{foo(x) := x :: foo(x/2) > 0} attempting to match "
"@samp{foo(8)}.  This rule will be inactive while the condition @samp{foo(4) "
"> 0} is checked, even though it might be an integral part of evaluating that "
"condition.  Note that this is not a problem for the more usual recursive "
"type of rule, such as @samp{foo(x) := foo(x/2)}, because there the rule has "
"succeeded and been reactivated by the time the righthand side is evaluated."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27591
msgid ""
"If @code{EvalRules} has no stored value (its default state), or if anything "
"but a vector is stored in it, then it is ignored."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27599
msgid ""
"Even though Calc's rewrite mechanism is designed to compare rewrite rules to "
"formulas as quickly as possible, storing rules in @code{EvalRules} may make "
"Calc run substantially slower.  This is particularly true of rules where the "
"top-level call is a commonly used function, or is not fixed.  The rule "
"@samp{f(n) := n f(n-1) :: n>0} will only activate the rewrite mechanism for "
"calls to the function @code{f}, but @samp{lg(n) + lg(m) := lg(n m)} will "
"check every @samp{+} operator."
msgstr ""

#. type: smallexample
#: ../../calc.texi:27602
#, no-wrap
msgid "apply(f, [a*b]) := apply(f, [a]) + apply(f, [b]) :: in(f, [ln, log10])\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27609
msgid ""
"may seem more ``efficient'' than two separate rules for @code{ln} and "
"@code{log10}, but actually it is vastly less efficient because rules with "
"@code{apply} as the top-level pattern must be tested against @emph{every} "
"function call that is simplified."
msgstr ""

#. type: cindex
#: ../../calc.texi:27610
#, no-wrap
msgid "@code{AlgSimpRules} variable"
msgstr ""

#. type: vindex
#: ../../calc.texi:27611
#, no-wrap
msgid "AlgSimpRules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27618
msgid ""
"Suppose you want @samp{sin(a + b)} to be expanded out not all the time, but "
"only when algebraic simplifications are used to simplify the formula.  The "
"variable @code{AlgSimpRules} holds rules for this purpose.  The @kbd{a s} "
"command will apply @code{EvalRules} and @code{AlgSimpRules} to the formula, "
"as well as all of its built-in simplifications."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27626
msgid ""
"Most of the special limitations for @code{EvalRules} don't apply to "
"@code{AlgSimpRules}.  Calc simply does an @kbd{a r AlgSimpRules} command "
"with an infinite repeat count as the first step of algebraic "
"simplifications. It then applies its own built-in simplifications throughout "
"the formula, and then repeats these two steps (along with applying the "
"default simplifications) until no further changes are possible."
msgstr ""

#. type: cindex
#: ../../calc.texi:27627
#, no-wrap
msgid "@code{ExtSimpRules} variable"
msgstr ""

#. type: cindex
#: ../../calc.texi:27628
#, no-wrap
msgid "@code{UnitSimpRules} variable"
msgstr ""

#. type: vindex
#: ../../calc.texi:27629
#, no-wrap
msgid "ExtSimpRules"
msgstr ""

#. type: vindex
#: ../../calc.texi:27630
#, no-wrap
msgid "UnitSimpRules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27636
msgid ""
"There are also @code{ExtSimpRules} and @code{UnitSimpRules} variables that "
"are used by @kbd{a e} and @kbd{u s}, respectively; these commands also apply "
"@code{EvalRules} and @code{AlgSimpRules}.  The variable "
"@code{IntegSimpRules} contains simplification rules that are used only "
"during integration by @kbd{a i}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27646
msgid ""
"If a buffer named @file{*Trace*} exists, the rewrite mechanism will record "
"some useful information there as it operates.  The original formula is "
"written there, as is the result of each successful rewrite, and the final "
"result of the rewriting.  All phase changes are also noted."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27649
msgid ""
"Calc always appends to @file{*Trace*}.  You must empty this buffer yourself "
"periodically if it is in danger of growing unwieldy."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27656
msgid ""
"Note that the rewriting mechanism is substantially slower when the "
"@file{*Trace*} buffer exists, even if the buffer is not visible on the "
"screen.  Once you are done, you will probably want to kill this buffer (with "
"@kbd{C-x k *Trace* @key{RET}}).  If you leave it in existence and forget "
"about it, all your future rewrite commands will be needlessly slow."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27668
msgid ""
"Returning to the example of substituting the pattern @samp{sin(x)^2 + "
"cos(x)^2} with 1, we saw that the rule @samp{opt(a) sin(x)^2 + opt(a) "
"cos(x)^2 := a} does a good job of finding suitable cases.  Another solution "
"would be to use the rule @samp{cos(x)^2 := 1 - sin(x)^2}, followed by "
"algebraic simplification if necessary.  This rule will be the most effective "
"way to do the job, but at the expense of making some changes that you might "
"not desire."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27676
msgid ""
"Another algebraic rewrite rule is @samp{exp(x+y) := exp(x) exp(y)}.  To make "
"this work with the @w{@kbd{j r}} command so that it can be easily targeted "
"to a particular exponential in a large formula, you might wish to write the "
"rule as @samp{select(exp(x+y)) := select(exp(x) exp(y))}.  The @samp{select} "
"markers will be ignored by the regular @kbd{a r} command (@pxref{Selections "
"with Rewrite Rules})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27685
msgid ""
"A surprisingly useful rewrite rule is @samp{a/(b-c) := a*(b+c)/(b^2-c^2)}.  "
"This will simplify the formula whenever @expr{b} and/or @expr{c} can be made "
"simpler by squaring.  For example, applying this rule to @samp{2 / (sqrt(2) "
"+ 3)} yields @samp{6:7 - 2:7 sqrt(2)} (assuming Symbolic mode has been "
"enabled to keep the square root from being evaluated to a floating-point "
"approximation).  This rule is also useful when working with symbolic complex "
"numbers, e.g., @samp{(a + b i) / (c + d i)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27696
msgid ""
"As another example, we could define our own ``triangular numbers'' function "
"with the rules @samp{[tri(0) := 0, tri(n) := n + tri(n-1) :: n>0]}.  Enter "
"this vector and store it in a variable: @kbd{@w{s t} trirules}.  Now, given "
"a suitable formula like @samp{tri(5)} on the stack, type @samp{a r trirules} "
"to apply these rules repeatedly.  After six applications, @kbd{a r} will "
"stop with 15 on the stack.  Once these rules are debugged, it would probably "
"be most useful to add them to @code{EvalRules} so that Calc will evaluate "
"the new @code{tri} function automatically.  We could then use @kbd{Z K} on "
"the keyboard macro @kbd{' tri($) @key{RET}} to make a command that applies "
"@code{tri} to the value on the top of the stack.  @xref{Programming}."
msgstr ""

#. type: cindex
#: ../../calc.texi:27697
#, no-wrap
msgid "Quaternions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27709
msgid ""
"The following rule set, contributed by François Pinard, implements "
"@dfn{quaternions}, a generalization of the concept of complex numbers.  "
"Quaternions have four components, and are here represented by function calls "
"@samp{quat(@var{w}, [@var{x}, @var{y}, @var{z}])} with ``real part'' @var{w} "
"and the three ``imaginary'' parts collected into a vector.  Various "
"arithmetical operations on quaternions are supported.  To use these rules, "
"either add them to @code{EvalRules}, or create a command based on @kbd{a r} "
"for simplifying quaternion formulas.  A convenient way to enter quaternions "
"would be a command defined by a keyboard macro containing: @kbd{' quat($$$$, "
"[$$$, $$, $])  @key{RET}}."
msgstr ""

#. type: smallexample
#: ../../calc.texi:27730
#, no-wrap
msgid ""
"[ quat(w, x, y, z) := quat(w, [x, y, z]),\n"
"  quat(w, [0, 0, 0]) := w,\n"
"  abs(quat(w, v)) := hypot(w, v),\n"
"  -quat(w, v) := quat(-w, -v),\n"
"  r + quat(w, v) := quat(r + w, v) :: real(r),\n"
"  r - quat(w, v) := quat(r - w, -v) :: real(r),\n"
"  quat(w1, v1) + quat(w2, v2) := quat(w1 + w2, v1 + v2),\n"
"  r * quat(w, v) := quat(r * w, r * v) :: real(r),\n"
"  plain(quat(w1, v1) * quat(w2, v2))\n"
"     := quat(w1 * w2 - v1 * v2, w1 * v2 + w2 * v1 + cross(v1, v2)),\n"
"  quat(w1, v1) / r := quat(w1 / r, v1 / r) :: real(r),\n"
"  z / quat(w, v) := z * quatinv(quat(w, v)),\n"
"  quatinv(quat(w, v)) := quat(w, -v) / (w^2 + v^2),\n"
"  quatsqr(quat(w, v)) := quat(w^2 - v^2, 2 * w * v),\n"
"  quat(w, v)^k := quatsqr(quat(w, v)^(k / 2))\n"
"               :: integer(k) :: k > 0 :: k % 2 = 0,\n"
"  quat(w, v)^k := quatsqr(quat(w, v)^((k - 1) / 2)) * quat(w, v)\n"
"               :: integer(k) :: k > 2,\n"
"  quat(w, v)^-k := quatinv(quat(w, v)^k) :: integer(k) :: k > 0 ]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27739
msgid ""
"Quaternions, like matrices, have non-commutative multiplication.  In other "
"words, @expr{q1 * q2 = q2 * q1} is not necessarily true if @expr{q1} and "
"@expr{q2} are @code{quat} forms.  The @samp{quat*quat} rule above uses "
"@code{plain} to prevent Calc from rearranging the product.  It may also be "
"wise to add the line @samp{[quat(), matrix]} to the @code{Decls} matrix, to "
"ensure that Calc's other algebraic operations will not rearrange a "
"quaternion product.  @xref{Declarations}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27746
msgid ""
"These rules also accept a four-argument @code{quat} form, converting it to "
"the preferred form in the first rule.  If you would rather see results in "
"the four-argument form, just append the two items @samp{phase(2), quat(w, "
"[x, y, z]) := quat(w, x, y, z)} to the end of the rule set.  (But remember "
"that multi-phase rule sets don't work in @code{EvalRules}.)"
msgstr ""

#. type: chapter
#: ../../calc.texi:27748
#, no-wrap
msgid "Operating on Units"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27756
msgid ""
"One special interpretation of algebraic formulas is as numbers with units.  "
"For example, the formula @samp{5 m / s^2} can be read ``five meters per "
"second squared.'' The commands in this chapter help you manipulate units "
"expressions in this form.  Units-related commands begin with the @kbd{u} "
"prefix key."
msgstr ""

#. type: menuentry
#: ../../calc.texi:27764
msgid "Basic Operations on Units::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:27764
msgid "The Units Table::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:27764
msgid "Predefined Units::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:27764
msgid "User-Defined Units::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:27764
msgid "Logarithmic Units::"
msgstr ""

#. type: section
#: ../../calc.texi:27764 ../../calc.texi:28215 ../../calc.texi:28454 ../../calc.texi:28455
#, no-wrap
msgid "Musical Notes"
msgstr ""

#. type: node
#: ../../calc.texi:27766 ../../calc.texi:27767 ../../calc.texi:27971
#, no-wrap
msgid "Basic Operations on Units"
msgstr ""

#. type: node
#: ../../calc.texi:27766 ../../calc.texi:27971 ../../calc.texi:27972 ../../calc.texi:28028
#, no-wrap
msgid "The Units Table"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27777
msgid ""
"A @dfn{units expression} is a formula which is basically a number multiplied "
"and/or divided by one or more @dfn{unit names}, which may optionally be "
"raised to integer powers.  Actually, the value part need not be a number; "
"any product or quotient involving unit names is a units expression.  Many of "
"the units commands will also accept any formula, where the command applies "
"to all units expressions which appear in the formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27784
msgid ""
"A unit name is a variable whose name appears in the @dfn{unit table}, or a "
"variable whose name is a prefix character like @samp{k} (for ``kilo'')  or "
"@samp{u} (for ``micro'') followed by a name in the unit table.  A "
"substantial table of built-in units is provided with Calc; @pxref{Predefined "
"Units}.  You can also define your own unit names; @pxref{User-Defined "
"Units}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27790
msgid ""
"Note that if the value part of a units expression is exactly @samp{1}, it "
"will be removed by the Calculator's automatic algebra routines: The formula "
"@samp{1 mm} is ``simplified'' to @samp{mm}.  This is only a display anomaly, "
"however; @samp{mm} will work just fine as a representation of one "
"millimeter."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27794
msgid ""
"You may find that Algebraic mode (@pxref{Algebraic Entry}) makes working "
"with units expressions easier.  Otherwise, you will have to remember to hit "
"the apostrophe key every time you wish to enter units."
msgstr ""

#. type: kindex
#: ../../calc.texi:27795
#, no-wrap
msgid "u s"
msgstr ""

#. type: pindex
#: ../../calc.texi:27796
#, no-wrap
msgid "calc-simplify-units"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27811
msgid ""
"@tindex usimplify The @kbd{u s} (@code{calc-simplify-units}) "
"[@code{usimplify}] command simplifies a units expression.  It uses Calc's "
"algebraic simplifications to simplify the expression first as a regular "
"algebraic formula; it then looks for features that can be further simplified "
"by converting one object's units to be compatible with another's.  For "
"example, @samp{5 m + 23 mm} will simplify to @samp{5.023 m}.  When different "
"but compatible units are added, the righthand term's units are converted to "
"match those of the lefthand term.  @xref{Simplification Modes}, for a way to "
"have this done automatically at all times."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27822
msgid ""
"Units simplification also handles quotients of two units with the same "
"dimensionality, as in @w{@samp{2 in s/L cm}} to @samp{5.08 s/L}; fractional "
"powers of unit expressions, as in @samp{sqrt(9 mm^2)} to @samp{3 mm} and "
"@samp{sqrt(9 acre)} to a quantity in meters; and @code{floor}, @code{ceil}, "
"@code{round}, @code{rounde}, @code{roundu}, @code{trunc}, @code{float}, "
"@code{frac}, @code{abs}, and @code{clean} applied to units expressions, in "
"which case the operation in question is applied only to the numeric part of "
"the expression.  Finally, trigonometric functions of quantities with units "
"of angle are evaluated, regardless of the current angular mode."
msgstr ""

#. type: kindex
#: ../../calc.texi:27823
#, no-wrap
msgid "u c"
msgstr ""

#. type: pindex
#: ../../calc.texi:27824
#, no-wrap
msgid "calc-convert-units"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27834
msgid ""
"The @kbd{u c} (@code{calc-convert-units}) command converts a units "
"expression to new, compatible units.  For example, given the units "
"expression @samp{55 mph}, typing @kbd{u c m/s @key{RET}} produces "
"@samp{24.5872 m/s}.  If you have previously converted a units expression "
"with the same type of units (in this case, distance over time), you will be "
"offered the previous choice of new units as a default.  Continuing the above "
"example, entering the units expression @samp{100 km/hr} and typing @kbd{u c "
"@key{RET}} (without specifying new units) produces @samp{27.7777777778 m/s}."
msgstr ""

#. type: kindex
#: ../../calc.texi:27835
#, no-wrap
msgid "u t"
msgstr ""

#. type: pindex
#: ../../calc.texi:27836
#, no-wrap
msgid "calc-convert-temperature"
msgstr ""

#. type: cindex
#: ../../calc.texi:27837
#, no-wrap
msgid "Temperature conversion"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27847
msgid ""
"The @kbd{u c} command treats temperature units (like @samp{degC} and "
"@samp{K}) as relative temperatures.  For example, @kbd{u c} converts "
"@samp{10 degC} to @samp{18 degF}: A change of 10 degrees Celsius corresponds "
"to a change of 18 degrees Fahrenheit.  To convert absolute temperatures, you "
"can use the @kbd{u t} (@code{calc-convert-temperature}) command.  The value "
"on the stack must be a simple units expression with units of temperature "
"only.  This command would convert @samp{10 degC} to @samp{50 degF}, the "
"equivalent temperature on the Fahrenheit scale."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27855
msgid ""
"While many of Calc's conversion factors are exact, some are necessarily "
"approximate.  If Calc is in fraction mode (@pxref{Fraction Mode}), then unit "
"conversions will try to give exact, rational conversions, but it isn't "
"always possible.  Given @samp{55 mph} in fraction mode, typing @kbd{u c m/s "
"@key{RET}} produces @samp{15367:625 m/s}, for example, while typing @kbd{u c "
"au/yr @key{RET}} produces @samp{5.18665819999e-3 au/yr}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27862
msgid ""
"If the units you request are inconsistent with the original units, the "
"number will be converted into your units times whatever ``remainder'' units "
"are left over.  For example, converting @samp{55 mph} into acres produces "
"@samp{6.08e-3 acre / (m s)}. Remainder units are expressed in terms of "
"``fundamental'' units like @samp{m} and @samp{s}, regardless of the input "
"units."
msgstr ""

#. type: kindex
#: ../../calc.texi:27863
#, no-wrap
msgid "u n"
msgstr ""

#. type: pindex
#: ../../calc.texi:27864
#, no-wrap
msgid "calc-convert-exact-units"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27871
msgid ""
"If you intend that your new units be consistent with the original units, the "
"@kbd{u n} (@code{calc-convert-exact-units}) command will check the units "
"before the conversion.  For example, to change @samp{mi/hr} to @samp{km/hr}, "
"you could type @kbd{u c km @key{RET}}, but @kbd{u n km @key{RET}} would "
"signal an error.  You would need to type @kbd{u n km/hr @key{RET}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27880
msgid ""
"One special exception is that if you specify a single unit name, and a "
"compatible unit appears somewhere in the units expression, then that "
"compatible unit will be converted to the new unit and the remaining units in "
"the expression will be left alone.  For example, given the input @samp{980 "
"cm/s^2}, the command @kbd{u c ms} will change the @samp{s} to @samp{ms} to "
"get @samp{9.8e-4 cm/ms^2}.  The ``remainder unit'' @samp{cm} is left alone "
"rather than being changed to the base unit @samp{m}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27887
msgid ""
"You can use explicit unit conversion instead of the @kbd{u s} command to "
"gain more control over the units of the result of an expression.  For "
"example, given @samp{5 m + 23 mm}, you can type @kbd{u c m} or @kbd{u c mm} "
"to express the result in either meters or millimeters.  (For that matter, "
"you could type @kbd{u c fath} to express the result in fathoms, if you "
"preferred!)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27895
msgid ""
"In place of a specific set of units, you can also enter one of the units "
"system names @code{si}, @code{mks} (equivalent), or @code{cgs}.  For "
"example, @kbd{u c si @key{RET}} converts the expression into International "
"System of Units (SI) base units.  Also, @kbd{u c base} converts to Calc's "
"base units, which are the same as @code{si} units except that @code{base} "
"uses @samp{g} as the fundamental unit of mass whereas @code{si} uses "
"@samp{kg}."
msgstr ""

#. type: cindex
#: ../../calc.texi:27896
#, no-wrap
msgid "Composite units"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27910
msgid ""
"The @kbd{u c} command also accepts @dfn{composite units}, which are "
"expressed as the sum of several compatible unit names.  For example, "
"converting @samp{30.5 in} to units @samp{mi+ft+in} (miles, feet, and inches) "
"produces @samp{2 ft + 6.5 in}.  Calc first sorts the unit names into order "
"of decreasing relative size.  It then accounts for as much of the input "
"quantity as it can using an integer number times the largest unit, then "
"moves on to the next smaller unit, and so on.  Only the smallest unit may "
"have a non-integer amount attached in the result.  A few standard unit names "
"exist for common combinations, such as @code{mfi} for @samp{mi+ft+in}, and "
"@code{tpo} for @samp{ton+lb+oz}.  Composite units are expanded as if by "
"@kbd{a x}, so that @samp{(ft+in)/hr} is first converted to "
"@samp{ft/hr+in/hr}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27920
msgid ""
"If the value on the stack does not contain any units, @kbd{u c} will prompt "
"first for the old units which this value should be considered to have, then "
"for the new units.  (If the value on the stack can be simplified so that it "
"doesn't contain any units, like @samp{ft/in} can be simplified to 12, then "
"@kbd{u c} will still prompt for both old units and new units.  Assuming the "
"old and new units you give are consistent with each other, the result also "
"will not contain any units.  For example, @kbd{@w{u c} cm @key{RET} in "
"@key{RET}} converts the number 2 on the stack to 5.08."
msgstr ""

#. type: kindex
#: ../../calc.texi:27921
#, no-wrap
msgid "u b"
msgstr ""

#. type: pindex
#: ../../calc.texi:27922
#, no-wrap
msgid "calc-base-units"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27927
msgid ""
"The @kbd{u b} (@code{calc-base-units}) command is shorthand for @kbd{u c "
"base}; it converts the units expression on the top of the stack into "
"@code{base} units.  If @kbd{u s} does not simplify a units expression as far "
"as you would like, try @kbd{u b}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27930
msgid ""
"Like the @kbd{u c} command, the @kbd{u b} command treats temperature units "
"as relative temperatures."
msgstr ""

#. type: kindex
#: ../../calc.texi:27931
#, no-wrap
msgid "u r"
msgstr ""

#. type: pindex
#: ../../calc.texi:27932
#, no-wrap
msgid "calc-remove-units"
msgstr ""

#. type: kindex
#: ../../calc.texi:27933
#, no-wrap
msgid "u x"
msgstr ""

#. type: pindex
#: ../../calc.texi:27934
#, no-wrap
msgid "calc-extract-units"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27941
msgid ""
"The @kbd{u r} (@code{calc-remove-units}) command removes units from the "
"formula at the top of the stack.  The @kbd{u x} (@code{calc-extract-units}) "
"command extracts only the units portion of a formula.  These commands "
"essentially replace every term of the formula that does or doesn't "
"(respectively) look like a unit name by the constant 1, then resimplify the "
"formula."
msgstr ""

#. type: kindex
#: ../../calc.texi:27942
#, no-wrap
msgid "u a"
msgstr ""

#. type: pindex
#: ../../calc.texi:27943
#, no-wrap
msgid "calc-autorange-units"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27953
msgid ""
"The @kbd{u a} (@code{calc-autorange-units}) command turns on and off a mode "
"in which unit prefixes like @code{k} (``kilo'') are automatically applied to "
"keep the numeric part of a units expression in a reasonable range.  This "
"mode affects @kbd{u s} and all units conversion commands except @kbd{u b}.  "
"For example, with autoranging on, @samp{12345 Hz} will be simplified to "
"@samp{12.345 kHz}.  Autoranging is useful for some kinds of units (like "
"@code{Hz} and @code{m}), but is probably undesirable for non-metric units "
"like @code{ft} and @code{tbsp}.  (Composite units are more appropriate for "
"those; see above.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27970
msgid ""
"Autoranging always applies the prefix to the leftmost unit name.  Calc "
"chooses the largest prefix that causes the number to be greater than or "
"equal to 1.0.  Thus an increasing sequence of adjusted times would be "
"@samp{1 ms, 10 ms, 100 ms, 1 s, 10 s, 100 s, 1 ks}.  Generally the rule of "
"thumb is that the number will be adjusted to be in the interval @samp{[1 "
".. 1000)}, although there are several exceptions to this rule.  First, if "
"the unit has a power then this is not possible; @samp{0.1 s^2} simplifies to "
"@samp{100000 ms^2}.  Second, the ``centi-'' prefix is allowed to form "
"@code{cm} (centimeters), but will not apply to other units.  The ``deci-,'' "
"``deka-,'' and ``hecto-'' prefixes are never used.  Thus the allowable "
"interval is @samp{[1 .. 10)} for millimeters and @samp{[1 .. 100)} for "
"centimeters.  Finally, a prefix will not be added to a unit if the resulting "
"name is also the actual name of another unit; @samp{1e-15 t} would normally "
"be considered a ``femto-ton,'' but it is written as @samp{1000 at} (1000 "
"atto-tons) instead because @code{ft} would be confused with feet."
msgstr ""

#. type: node
#: ../../calc.texi:27971 ../../calc.texi:28028 ../../calc.texi:28029 ../../calc.texi:28131
#, no-wrap
msgid "Predefined Units"
msgstr ""

#. type: kindex
#: ../../calc.texi:27975
#, no-wrap
msgid "u v"
msgstr ""

#. type: pindex
#: ../../calc.texi:27976
#, no-wrap
msgid "calc-enter-units-table"
msgstr ""

#. type: Plain text
#: ../../calc.texi:27985
msgid ""
"The @kbd{u v} (@code{calc-enter-units-table}) command displays the units "
"table in another buffer called @file{*Units Table*}.  Each entry in this "
"table gives the unit name as it would appear in an expression, the "
"definition of the unit in terms of simpler units, and a full name or "
"description of the unit.  Fundamental units are defined as themselves; these "
"are the units produced by the @kbd{u b} command.  The fundamental units are "
"meters, seconds, grams, kelvins, amperes, candelas, moles, radians, and "
"steradians."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27992
msgid ""
"The Units Table buffer also displays the Unit Prefix Table.  Note that two "
"prefixes, ``kilo'' and ``hecto,'' accept either upper- or lower-case prefix "
"letters.  @samp{Meg} is also accepted as a synonym for the @samp{M} prefix.  "
"Whenever a unit name can be interpreted as either a built-in name or a "
"prefix followed by another built-in name, the former interpretation wins.  "
"For example, @samp{2 pt} means two pints, not two pico-tons."
msgstr ""

#. type: Plain text
#: ../../calc.texi:27996
msgid ""
"The Units Table buffer, once created, is not rebuilt unless you define new "
"units.  To force the buffer to be rebuilt, give any numeric prefix argument "
"to @kbd{u v}."
msgstr ""

#. type: kindex
#: ../../calc.texi:27997
#, no-wrap
msgid "u V"
msgstr ""

#. type: pindex
#: ../../calc.texi:27998
#, no-wrap
msgid "calc-view-units-table"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28006
msgid ""
"The @kbd{u V} (@code{calc-view-units-table}) command is like @kbd{u v} "
"except that the cursor is not moved into the Units Table buffer.  You can "
"type @kbd{u V} again to remove the Units Table from the display.  To return "
"from the Units Table buffer after a @kbd{u v}, type @kbd{C-x * c} again or "
"use the regular Emacs @w{@kbd{C-x o}} (@code{other-window})  command.  You "
"can also kill the buffer with @kbd{C-x k} if you wish; the actual units "
"table is safely stored inside the Calculator."
msgstr ""

#. type: kindex
#: ../../calc.texi:28007
#, no-wrap
msgid "u g"
msgstr ""

#. type: pindex
#: ../../calc.texi:28008
#, no-wrap
msgid "calc-get-unit-definition"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28018
msgid ""
"The @kbd{u g} (@code{calc-get-unit-definition}) command retrieves a unit's "
"defining expression and pushes it onto the Calculator stack.  For example, "
"@kbd{u g in} will produce the expression @samp{2.54 cm}.  This is the same "
"definition for the unit that would appear in the Units Table buffer.  Note "
"that this command works only for actual unit names; @kbd{u g km} will report "
"that no such unit exists, for example, because @code{km} is really the unit "
"@code{m} with a @code{k} (``kilo'') prefix.  To see a definition of a unit "
"in terms of base units, it is easier to push the unit name on the stack and "
"then reduce it to base units with @kbd{u b}."
msgstr ""

#. type: kindex
#: ../../calc.texi:28019
#, no-wrap
msgid "u e"
msgstr ""

#. type: pindex
#: ../../calc.texi:28020
#, no-wrap
msgid "calc-explain-units"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28027
msgid ""
"The @kbd{u e} (@code{calc-explain-units}) command displays an English "
"description of the units of the expression on the stack.  For example, for "
"the expression @samp{62 km^2 g / s^2 mol K}, the description is "
"``Square-Kilometer Gram per (Second-squared Mole Degree-Kelvin).'' This "
"command uses the English descriptions that appear in the righthand column of "
"the Units Table."
msgstr ""

#. type: node
#: ../../calc.texi:28028 ../../calc.texi:28131 ../../calc.texi:28132 ../../calc.texi:28215
#, no-wrap
msgid "User-Defined Units"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28054
msgid ""
"The definitions of many units have changed over the years.  For example, the "
"meter was originally defined in 1791 as one ten-millionth of the distance "
"from the Equator to the North Pole.  In order to be more precise, the "
"definition was adjusted several times, and now a meter is defined as the "
"distance that light will travel in a vacuum in 1/299792458 of a second; "
"consequently, the speed of light in a vacuum is exactly 299792458 m/s.  Many "
"other units have been redefined in terms of fundamental physical processes; "
"a second, for example, is currently defined as 9192631770 periods of a "
"certain radiation related to the cesium-133 atom.  The only SI unit that is "
"not based on a fundamental physical process (although there are efforts to "
"change this) is the kilogram, which was originally defined as the mass of "
"one liter of water, but is now defined as the mass of the international "
"prototype of the kilogram (IPK), a cylinder of platinum-iridium kept at the "
"Bureau international des poids et mesures in Sèvres, France.  (There are "
"several copies of the IPK throughout the world.)  The British imperial "
"units, once defined in terms of physical objects, were redefined in 1963 in "
"terms of SI units.  The US customary units, which were the same as British "
"units until the British imperial system was created in 1824, were also "
"defined in terms of the SI units in 1893.  Because of these redefinitions, "
"conversions between metric, British Imperial, and US customary units can "
"often be done precisely."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28063
msgid ""
"Since the exact definitions of many kinds of units have evolved over the "
"years, and since certain countries sometimes have local differences in their "
"definitions, it is a good idea to examine Calc's definition of a unit before "
"depending on its exact value.  For example, there are three different units "
"for gallons, corresponding to the US (@code{gal}), Canadian (@code{galC}), "
"and British (@code{galUK}) definitions.  Also, note that @code{oz} is a "
"standard ounce of mass, @code{ozt} is a Troy ounce, and @code{ozfl} is a "
"fluid ounce."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28069
msgid ""
"The temperature units corresponding to degrees Kelvin and Centigrade "
"(Celsius) are the same in this table, since most units commands treat "
"temperatures as being relative.  The @code{calc-convert-temperature} command "
"has special rules for handling the different absolute magnitudes of the "
"various temperature scales."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28072
msgid ""
"The unit of volume ``liters'' can be referred to by either the lower-case "
"@code{l} or the upper-case @code{L}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28075
msgid ""
"The unit @code{A} stands for amperes; the name @code{Ang} is used for "
"angstroms."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28088
msgid ""
"The unit @code{pt} stands for pints; the name @code{point} stands for a "
"typographical point, defined by @samp{72 point = 1 in}.  This is slightly "
"different from the point defined by the American Typefounder's Association "
"in 1886, but the point used by Calc has become standard largely due to its "
"use by the PostScript page description language.  There is also "
"@code{texpt}, which stands for a printer's point as defined by the @TeX{} "
"typesetting system: @samp{72.27 texpt = 1 in}.  Other units used by @TeX{} "
"are available; they are @code{texpc} (a pica), @code{texbp} (a ``big "
"point'', equal to a standard point which is larger than the point used by "
"@TeX{}), @code{texdd} (a Didot point), @code{texcc} (a Cicero) and "
"@code{texsp} (a scaled @TeX{} point, all dimensions representable in @TeX{} "
"are multiples of this value)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28095
msgid ""
"When Calc is using the @TeX{} or @LaTeX{} language mode (@pxref{TeX and "
"LaTeX Language Modes}), the @TeX{} specific unit names will not use the "
"@samp{tex} prefix; the unit name for a @TeX{} point will be @samp{pt} "
"instead of @samp{texpt}, for example.  To avoid conflicts, the unit names "
"for pint and parsec will simply be @samp{pint} and @samp{parsec} instead of "
"@samp{pt} and @samp{pc}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28100
msgid ""
"The unit @code{e} stands for the elementary (electron) unit of charge; "
"because algebra command could mistake this for the special constant "
"@expr{e}, Calc provides the alternate unit name @code{ech} which is "
"preferable to @code{e}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28104
msgid ""
"The name @code{g} stands for one gram of mass; there is also @code{gf}, one "
"gram of force.  (Likewise for @kbd{lb}, pounds, and @kbd{lbf}.)  Meanwhile, "
"one ``@expr{g}'' of acceleration is denoted @code{ga}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28107
msgid ""
"The unit @code{ton} is a U.S. ton of @samp{2000 lb}, and @code{t} is a "
"metric ton of @samp{1000 kg}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28110
msgid ""
"The names @code{s} (or @code{sec}) and @code{min} refer to units of time; "
"@code{arcsec} and @code{arcmin} are units of angle."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28119
msgid ""
"Some ``units'' are really physical constants; for example, @code{c} "
"represents the speed of light, and @code{h} represents Planck's constant.  "
"You can use these just like other units: converting @samp{.5 c} to "
"@samp{m/s} expresses one-half the speed of light in meters per second.  You "
"can also use this merely as a handy reference; the @kbd{u g} command gets "
"the definition of one of these constants in its normal terms, and @kbd{u b} "
"expresses the definition in base units."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28128
msgid ""
"Two units, @code{pi} and @code{alpha} (the fine structure constant, "
"approximately @mathit{1/137}) are dimensionless.  The units simplification "
"commands simply treat these names as equivalent to their corresponding "
"values.  However you can, for example, use @kbd{u c} to convert a pure "
"number into multiples of the fine structure constant, or @kbd{u b} to "
"convert this back into a pure number.  (When @kbd{u c} prompts for the ``old "
"units,'' just enter a blank line to signify that the value really is "
"unitless.)"
msgstr ""

#. type: node
#: ../../calc.texi:28131 ../../calc.texi:28215 ../../calc.texi:28216 ../../calc.texi:28454
#, no-wrap
msgid "Logarithmic Units"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28137
msgid ""
"Calc provides ways to get quick access to your selected ``favorite'' units, "
"as well as ways to define your own new units."
msgstr ""

#. type: kindex
#: ../../calc.texi:28138
#, no-wrap
msgid "u 0-9"
msgstr ""

#. type: pindex
#: ../../calc.texi:28139
#, no-wrap
msgid "calc-quick-units"
msgstr ""

#. type: cindex
#: ../../calc.texi:28141
#, no-wrap
msgid "@code{Units} variable"
msgstr ""

#. type: cindex
#: ../../calc.texi:28142
#, no-wrap
msgid "Quick units"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28155
msgid ""
"To select your favorite units, store a vector of unit names or expressions "
"in the Calc variable @code{Units}.  The @kbd{u 1} through @kbd{u 9} commands "
"(@code{calc-quick-units}) provide access to these units.  If the value on "
"the top of the stack is a plain number (with no units attached), then @kbd{u "
"1} gives it the specified units.  (Basically, it multiplies the number by "
"the first item in the @code{Units} vector.)  If the number on the stack "
"@emph{does} have units, then @kbd{u 1} converts that number to the new "
"units.  For example, suppose the vector @samp{[in, ft]} is stored in "
"@code{Units}.  Then @kbd{30 u 1} will create the expression @samp{30 in}, "
"and @kbd{u 2} will convert that expression to @samp{2.5 ft}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28162
msgid ""
"The @kbd{u 0} command accesses the tenth element of @code{Units}.  Only ten "
"quick units may be defined at a time.  If the @code{Units} variable has no "
"stored value (the default), or if its value is not a vector, then the "
"quick-units commands will not function.  The @kbd{s U} command is a "
"convenient way to edit the @code{Units} variable; @pxref{Operations on "
"Variables}."
msgstr ""

#. type: kindex
#: ../../calc.texi:28163
#, no-wrap
msgid "u d"
msgstr ""

#. type: pindex
#: ../../calc.texi:28164
#, no-wrap
msgid "calc-define-unit"
msgstr ""

#. type: cindex
#: ../../calc.texi:28165
#, no-wrap
msgid "User-defined units"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28178
msgid ""
"The @kbd{u d} (@code{calc-define-unit}) command records the units expression "
"on the top of the stack as the definition for a new, user-defined unit.  For "
"example, putting @samp{16.5 ft} on the stack and typing @kbd{u d rod} "
"defines the new unit @samp{rod} to be equivalent to 16.5 feet.  The unit "
"conversion and simplification commands will now treat @code{rod} just like "
"any other unit of length.  You will also be prompted for an optional English "
"description of the unit, which will appear in the Units Table.  If you wish "
"the definition of this unit to be displayed in a special way in the Units "
"Table buffer (such as with an asterisk to indicate an approximate value), "
"then you can call this command with an argument, @kbd{C-u u d}; you will "
"then also be prompted for a string that will be used to display the "
"definition."
msgstr ""

#. type: kindex
#: ../../calc.texi:28179
#, no-wrap
msgid "u u"
msgstr ""

#. type: pindex
#: ../../calc.texi:28180
#, no-wrap
msgid "calc-undefine-unit"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28184
msgid ""
"The @kbd{u u} (@code{calc-undefine-unit}) command removes a user-defined "
"unit.  It is not possible to remove one of the predefined units, however."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28190
msgid ""
"If you define a unit with an existing unit name, your new definition will "
"replace the original definition of that unit.  If the unit was a predefined "
"unit, the old definition will not be replaced, only ``shadowed.'' The "
"built-in definition will reappear if you later use @kbd{u u} to remove the "
"shadowing definition."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28200
msgid ""
"To create a new fundamental unit, use either 1 or the unit name itself as "
"the defining expression.  Otherwise the expression can involve any other "
"units that you like (except for composite units like @samp{mfi}).  You can "
"create a new composite unit with a sum of other units as the defining "
"expression.  The next unit operation like @kbd{u c} or @kbd{u v} will "
"rebuild the internal unit table incorporating your modifications.  Note that "
"erroneous definitions (such as two units defined in terms of each other) "
"will not be detected until the unit table is next rebuilt; @kbd{u v} is a "
"convenient way to force this to happen."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28203
msgid ""
"Temperature units are treated specially inside the Calculator; it is not "
"possible to create user-defined temperature units."
msgstr ""

#. type: kindex
#: ../../calc.texi:28204
#, no-wrap
msgid "u p"
msgstr ""

#. type: pindex
#: ../../calc.texi:28205
#, no-wrap
msgid "calc-permanent-units"
msgstr ""

#. type: cindex
#: ../../calc.texi:28206
#, no-wrap
msgid "Calc init file, user-defined units"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28214
msgid ""
"The @kbd{u p} (@code{calc-permanent-units}) command stores the user-defined "
"units in your Calc init file (the file given by the variable "
"@code{calc-settings-file}, typically @file{~/.emacs.d/calc.el}), so that the "
"units will still be available in subsequent Emacs sessions.  If there was "
"already a set of user-defined units in your Calc init file, it is replaced "
"by the new set.  (@xref{General Mode Commands}, for a way to tell Calc to "
"use a different file for the Calc init file.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28221
msgid ""
"The units @code{dB} (decibels) and @code{Np} (nepers) are logarithmic units "
"which are manipulated differently than standard units.  Calc provides "
"commands to work with these logarithmic units."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28228
msgid ""
"Decibels and nepers are used to measure power quantities as well as field "
"quantities (quantities whose squares are proportional to power); these two "
"types of quantities are handled slightly different from each other.  By "
"default the Calc commands work as if power quantities are being used; with "
"the @kbd{H} prefix the Calc commands work as if field quantities are being "
"used."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28252
msgid ""
"The decibel level of a power @infoline @math{P1}, @texline @math{P_1}, "
"relative to a reference power @infoline @math{P0}, @texline @math{P_0}, is "
"defined to be @infoline @math{10 log10(P1/P0) dB}.  @texline @math{10 "
"\\log_{10}(P_{1}/P_{0}) {\\rm dB}}.  (The factor of 10 is because a decibel, "
"as its name implies, is one-tenth of a bel. The bel, named after Alexander "
"Graham Bell, was considered to be too large of a unit and was effectively "
"replaced by the decibel.)  If @math{F} is a field quantity with power "
"@math{P=k F^2}, then a reference quantity of @infoline @math{F0} @texline "
"@math{F_0} would correspond to a power of @infoline @math{P0=k F0^2}.  "
"@texline @math{P_{0}=kF_{0}^2}.  If @infoline @math{P1=k F1^2}, @texline "
"@math{P_{1}=kF_{1}^2}, then"
msgstr ""

#. type: example
#: ../../calc.texi:28256
#, no-wrap
msgid "10 log10(P1/P0) = 10 log10(F1^2/F0^2) = 20 log10(F1/F0).\n"
msgstr ""

#. type: tex
#: ../../calc.texi:28261
#, no-wrap
msgid ""
"$$ 10 \\log_{10}(P_1/P_0) = 10 \\log_{10}(F_1^2/F_0^2) = 20\n"
"\\log_{10}(F_1/F_0)$$\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28289
msgid ""
"In order to get the same decibel level regardless of whether a field "
"quantity or the corresponding power quantity is used, the decibel level of a "
"field quantity @infoline @math{F1}, @texline @math{F_1}, relative to a "
"reference @infoline @math{F0}, @texline @math{F_0}, is defined as @infoline "
"@math{20 log10(F1/F0) dB}.  @texline @math{20 \\log_{10}(F_{1}/F_{0}) {\\rm "
"dB}}.  For example, the decibel value of a sound pressure level of @infoline "
"@math{60 uPa} @texline @math{60 \\mu{\\rm Pa}} relative to @infoline "
"@math{20 uPa} @texline @math{20 \\mu{\\rm Pa}} (the threshold of human "
"hearing) is @infoline @math{20 log10(60 uPa/ 20 uPa) dB = 20 log10(3) dB}, "
"@texline @math{20 \\log_{10}(60 \\mu{\\rm Pa}/20 \\mu{\\rm Pa}) {\\rm dB} = "
"20 \\log_{10}(3) {\\rm dB}}, which is about @infoline @math{9.54 dB}.  "
"@texline @math{9.54 {\\rm dB}}.  Note that in taking the ratio, the original "
"units cancel and so these logarithmic units are dimensionless."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28310
msgid ""
"Nepers (named after John Napier, who is credited with inventing the "
"logarithm) are similar to bels except they use natural logarithms instead of "
"common logarithms.  The neper level of a power @infoline @math{P1}, @texline "
"@math{P_1}, relative to a reference power @infoline @math{P0}, @texline "
"@math{P_0}, is @infoline @math{(1/2) ln(P1/P0) Np}.  @texline @math{(1/2) "
"\\ln(P_1/P_0) {\\rm Np}}.  The neper level of a field @infoline @math{F1}, "
"@texline @math{F_1}, relative to a reference field @infoline @math{F0}, "
"@texline @math{F_0}, is @infoline @math{ln(F1/F0) Np}.  @texline "
"@math{\\ln(F_1/F_0) {\\rm Np}}."
msgstr ""

#. type: defvar
#: ../../calc.texi:28311 ../../calc.texi:35638
#, no-wrap
msgid "calc-lu-power-reference"
msgstr ""

#. type: defvarx
#: ../../calc.texi:28312 ../../calc.texi:35639
#, no-wrap
msgid "calc-lu-field-reference"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28328
msgid ""
"For power quantities, Calc uses @infoline @math{1 mW} @texline @math{1 {\\rm "
"mW}} as the default reference quantity; this default can be changed by "
"changing the value of the customizable variable "
"@code{calc-lu-power-reference} (@pxref{Customizing Calc}).  For field "
"quantities, Calc uses @infoline @math{20 uPa} @texline @math{20 \\mu{\\rm "
"Pa}} as the default reference quantity; this is the value used in acoustics "
"which is where decibels are commonly encountered.  This default can be "
"changed by changing the value of the customizable variable "
"@code{calc-lu-field-reference} (@pxref{Customizing Calc}).  A non-default "
"reference quantity will be read from the stack if the capital @kbd{O} prefix "
"is used."
msgstr ""

#. type: kindex
#: ../../calc.texi:28329
#, no-wrap
msgid "l q"
msgstr ""

#. type: pindex
#: ../../calc.texi:28330
#, no-wrap
msgid "calc-lu-quant"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28343
msgid ""
"@tindex lupquant @tindex lufquant The @kbd{l q} (@code{calc-lu-quant}) "
"[@code{lupquant}] command computes the power quantity corresponding to a "
"given number of logarithmic units. With the capital @kbd{O} prefix, @kbd{O l "
"q}, the reference level will be read from the top of the stack. (In an "
"algebraic formula, @code{lupquant} can be given an optional second argument "
"which will be used for the reference level.) For example, @code{20 dB "
"@key{RET} l q} will return @code{100 mW}; @code{20 dB @key{RET} 4 W "
"@key{RET} O l q} will return @code{400 W}.  The @kbd{H l q} "
"[@code{lufquant}] command behaves like @kbd{l q} but computes field "
"quantities instead of power quantities."
msgstr ""

#. type: kindex
#: ../../calc.texi:28344
#, no-wrap
msgid "l d"
msgstr ""

#. type: pindex
#: ../../calc.texi:28345
#, no-wrap
msgid "calc-db"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28348
msgid "@tindex dbpower @tindex dbfield"
msgstr ""

#. type: kindex
#: ../../calc.texi:28348
#, no-wrap
msgid "l n"
msgstr ""

#. type: pindex
#: ../../calc.texi:28349
#, no-wrap
msgid "calc-np"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28360
msgid ""
"@tindex nppower @tindex npfield The @kbd{l d} (@code{calc-db}) "
"[@code{dbpower}] command will compute the decibel level of a power quantity "
"using the default reference level; @kbd{H l d} [@code{dbfield}] will compute "
"the decibel level of a field quantity.  The commands @kbd{l n} "
"(@code{calc-np})  [@code{nppower}] and @kbd{H l n} [@code{npfield}] will "
"similarly compute neper levels.  With the capital @kbd{O} prefix these "
"commands will read a reference level from the stack; in an algebraic formula "
"the reference level can be given as an optional second argument."
msgstr ""

#. type: kindex
#: ../../calc.texi:28361
#, no-wrap
msgid "l +"
msgstr ""

#. type: pindex
#: ../../calc.texi:28362
#, no-wrap
msgid "calc-lu-plus"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28365
msgid "@tindex lupadd @tindex lufadd"
msgstr ""

#. type: kindex
#: ../../calc.texi:28365
#, no-wrap
msgid "l -"
msgstr ""

#. type: pindex
#: ../../calc.texi:28366
#, no-wrap
msgid "calc-lu-minus"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28369
msgid "@tindex lupsub @tindex lufsub"
msgstr ""

#. type: kindex
#: ../../calc.texi:28369
#, no-wrap
msgid "l *"
msgstr ""

#. type: pindex
#: ../../calc.texi:28370
#, no-wrap
msgid "calc-lu-times"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28373
msgid "@tindex lupmul @tindex lufmul"
msgstr ""

#. type: kindex
#: ../../calc.texi:28373
#, no-wrap
msgid "l /"
msgstr ""

#. type: pindex
#: ../../calc.texi:28374
#, no-wrap
msgid "calc-lu-divide"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28386
msgid ""
"@tindex lupdiv @tindex lufdiv The sum of two power or field quantities "
"doesn't correspond to the sum of the corresponding decibel or neper levels.  "
"If the powers corresponding to decibel levels @infoline @math{D1} @texline "
"@math{D_1} and @infoline @math{D2} @texline @math{D_2} are added, the "
"corresponding decibel level ``sum'' will be"
msgstr ""

#. type: example
#: ../../calc.texi:28390
#, no-wrap
msgid "  10 log10(10^(D1/10) + 10^(D2/10)) dB.\n"
msgstr ""

#. type: tex
#: ../../calc.texi:28394
#, no-wrap
msgid "$$ 10 \\log_{10}(10^{D_1/10} + 10^{D_2/10}) {\\rm dB}.$$\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28404
msgid ""
"When field quantities are combined, it often means the corresponding powers "
"are added and so the above formula might be used.  In acoustics, for "
"example, the sound pressure level is a field quantity and so the decibels "
"are often defined using the field formula, but the sound pressure levels are "
"combined as the sound power levels, and so the above formula should be "
"used.  If two field quantities themselves are added, the new decibel level "
"will be"
msgstr ""

#. type: example
#: ../../calc.texi:28408
#, no-wrap
msgid "  20 log10(10^(D1/20) + 10^(D2/20)) dB.\n"
msgstr ""

#. type: tex
#: ../../calc.texi:28412
#, no-wrap
msgid "$$ 20 \\log_{10}(10^{D_1/20} + 10^{D_2/20}) {\\rm dB}.$$\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28417
msgid ""
"If the power corresponding to @math{D} dB is multiplied by a number "
"@math{N}, then the corresponding decibel level will be"
msgstr ""

#. type: example
#: ../../calc.texi:28421
#, no-wrap
msgid "  D + 10 log10(N) dB,\n"
msgstr ""

#. type: tex
#: ../../calc.texi:28425
#, no-wrap
msgid "$$ D + 10 \\log_{10}(N) {\\rm dB},$$\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28430
msgid ""
"if a field quantity is multiplied by @math{N} the corresponding decibel "
"level will be"
msgstr ""

#. type: example
#: ../../calc.texi:28434
#, no-wrap
msgid "  D + 20 log10(N) dB.\n"
msgstr ""

#. type: tex
#: ../../calc.texi:28438
#, no-wrap
msgid "$$ D + 20 \\log_{10}(N) {\\rm dB}.$$\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28453
msgid ""
"There are similar formulas for combining nepers.  The @kbd{l +} "
"(@code{calc-lu-plus}) [@code{lupadd}] command will ``add'' two logarithmic "
"unit power levels this way; with the @kbd{H} prefix, @kbd{H l +} "
"[@code{lufadd}] will add logarithmic unit field levels.  Similarly, "
"logarithmic units can be ``subtracted'' with @kbd{l -} "
"(@code{calc-lu-minus}) [@code{lupsub}] or @kbd{H l -} [@code{lufsub}].  The "
"@kbd{l *} (@code{calc-lu-times}) [@code{lupmul}] and @kbd{H l *} "
"[@code{lufmul}] commands will ``multiply'' a logarithmic unit by a number; "
"the @kbd{l /} (@code{calc-lu-divide}) [@code{lupdiv}] and @kbd{H l /} "
"[@code{lufdiv}] commands will ``divide'' a logarithmic unit by a "
"number. Note that the reference quantities don't play a role in this "
"arithmetic."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28462
msgid ""
"Calc can convert between musical notes and their associated frequencies.  "
"Notes can be given using either scientific pitch notation or midi numbers.  "
"Since these note systems are basically logarithmic scales, Calc uses the "
"@kbd{l} prefix for functions operating on notes."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28477
msgid ""
"Scientific pitch notation refers to a note by giving a letter A through G, "
"possibly followed by a flat or sharp) with a subscript indicating an octave "
"number.  Each octave starts with C and ends with B and the octave numbered 0 "
"was chosen to correspond to the lowest audible frequency.  Using this "
"system, middle C (about 261.625 Hz)  corresponds to the note @expr{C} in "
"octave 4 and is denoted @expr{C_4}.  Any frequency can be described by "
"giving a note plus an offset in cents (where a cent is a ratio of "
"frequencies so that a semitone consists of 100 cents)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28483
msgid ""
"The midi note number system assigns numbers to notes so that @expr{C_(-1)} "
"corresponds to the midi note number 0 and @expr{G_9} corresponds to the midi "
"note number 127.  A midi controller can have up to 128 keys and each midi "
"note number from 0 to 127 corresponds to a possible key."
msgstr ""

#. type: kindex
#: ../../calc.texi:28484
#, no-wrap
msgid "l s"
msgstr ""

#. type: pindex
#: ../../calc.texi:28485
#, no-wrap
msgid "calc-spn"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28491
msgid ""
"@tindex spn The @kbd{l s} (@code{calc-spn}) [@code{spn}] command converts "
"either a frequency or a midi number to scientific pitch notation.  For "
"example, @code{500 Hz} gets converted to @code{B_4 + 21.3094853649 cents} "
"and @code{84} to @code{C_6}."
msgstr ""

#. type: kindex
#: ../../calc.texi:28492
#, no-wrap
msgid "l m"
msgstr ""

#. type: pindex
#: ../../calc.texi:28493
#, no-wrap
msgid "calc-midi"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28499
msgid ""
"@tindex midi The @kbd{l m} (@code{calc-midi}) [@code{midi}] command converts "
"either a frequency or a note given in scientific pitch notation to the "
"corresponding midi number. For example, @code{C_6} gets converted to 84 and "
"@code{440 Hz} to 69."
msgstr ""

#. type: kindex
#: ../../calc.texi:28500
#, no-wrap
msgid "l f"
msgstr ""

#. type: pindex
#: ../../calc.texi:28501
#, no-wrap
msgid "calc-freq"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28508
msgid ""
"@tindex freq The @kbd{l f} (@code{calc-freq}) [@code{freq}] command converts "
"either either a midi number or a note given in scientific pitch notation to "
"the corresponding frequency. For example, @code{Asharp_2 + 30 cents} gets "
"converted to @code{118.578040134 Hz} and @code{55} to @code{195.99771799 "
"Hz}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28520
msgid ""
"Since the frequencies of notes are not usually given exactly (and are "
"typically irrational), the customizable variable @code{calc-note-threshold} "
"determines how close (in cents) a frequency needs to be to a note to be "
"recognized as that note (@pxref{Customizing Calc}).  This variable has a "
"default value of @code{1}.  For example, middle @var{C} is approximately "
"@expr{261.625565302 Hz}; this frequency is often shortened to @expr{261.625 "
"Hz}.  Without @code{calc-note-threshold} (or a value of @expr{0}), Calc "
"would convert @code{261.625 Hz} to scientific pitch notation @code{B_3 + "
"99.9962592773 cents}; with the default value of @code{1}, Calc converts "
"@code{261.625 Hz} to @code{C_4}."
msgstr ""

#. type: chapter
#: ../../calc.texi:28523
#, no-wrap
msgid "Storing and Recalling"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28530
msgid ""
"Calculator variables are really just Lisp variables that contain numbers or "
"formulas in a form that Calc can understand.  The commands in this section "
"allow you to manipulate variables conveniently.  Commands related to "
"variables use the @kbd{s} prefix key."
msgstr ""

#. type: menuentry
#: ../../calc.texi:28537
msgid "Storing Variables::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:28537
msgid "Recalling Variables::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:28537
msgid "Operations on Variables::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:28537
msgid "Let Command::"
msgstr ""

#. type: node
#: ../../calc.texi:28537 ../../calc.texi:28947 ../../calc.texi:28985
#, no-wrap
msgid "Evaluates-To Operator"
msgstr ""

#. type: node
#: ../../calc.texi:28539 ../../calc.texi:28540 ../../calc.texi:28767
#, no-wrap
msgid "Storing Variables"
msgstr ""

#. type: node
#: ../../calc.texi:28539 ../../calc.texi:28767 ../../calc.texi:28768 ../../calc.texi:28790
#, no-wrap
msgid "Recalling Variables"
msgstr ""

#. type: kindex
#: ../../calc.texi:28543
#, no-wrap
msgid "s s"
msgstr ""

#. type: pindex
#: ../../calc.texi:28544
#, no-wrap
msgid "calc-store"
msgstr ""

#. type: cindex
#: ../../calc.texi:28545 ../../calc.texi:28912
#, no-wrap
msgid "Storing variables"
msgstr ""

#. type: cindex
#: ../../calc.texi:28546
#, no-wrap
msgid "Quick variables"
msgstr ""

#. type: vindex
#: ../../calc.texi:28547
#, no-wrap
msgid "q0"
msgstr ""

#. type: vindex
#: ../../calc.texi:28548
#, no-wrap
msgid "q9"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28554
msgid ""
"The @kbd{s s} (@code{calc-store}) command stores the value at the top of the "
"stack into a specified variable.  It prompts you to enter the name of the "
"variable.  If you press a single digit, the value is stored immediately in "
"one of the ``quick'' variables @code{q0} through @code{q9}.  Or you can "
"enter any variable name."
msgstr ""

#. type: kindex
#: ../../calc.texi:28555
#, no-wrap
msgid "s t"
msgstr ""

#. type: pindex
#: ../../calc.texi:28556
#, no-wrap
msgid "calc-store-into"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28560
msgid ""
"The @kbd{s s} command leaves the stored value on the stack.  There is also "
"an @kbd{s t} (@code{calc-store-into}) command, which removes a value from "
"the stack and stores it in a variable."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28569
msgid ""
"If the top of stack value is an equation @samp{a = 7} or assignment @samp{a "
":= 7} with a variable on the lefthand side, then Calc will assign that "
"variable with that value by default, i.e., if you type @kbd{s s @key{RET}} "
"or @kbd{s t @key{RET}}.  In this example, the value 7 would be stored in the "
"variable @samp{a}.  (If you do type a variable name at the prompt, the "
"top-of-stack value is stored in its entirety, even if it is an equation: "
"@samp{s s b @key{RET}} with @samp{a := 7} on the stack stores @samp{a := 7} "
"in @code{b}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28574
msgid ""
"In fact, the top of stack value can be a vector of equations or assignments "
"with different variables on their lefthand sides; the default will be to "
"store all the variables with their corresponding righthand sides "
"simultaneously."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28581
msgid ""
"It is also possible to type an equation or assignment directly at the prompt "
"for the @kbd{s s} or @kbd{s t} command: @kbd{s s foo = 7}.  In this case the "
"expression to the right of the @kbd{=} or @kbd{:=} symbol is evaluated as if "
"by the @kbd{=} command, and that value is stored in the variable.  No value "
"is taken from the stack; @kbd{s s} and @kbd{s t} are equivalent when used in "
"this way."
msgstr ""

#. type: kindex
#: ../../calc.texi:28582
#, no-wrap
msgid "s 0-9"
msgstr ""

#. type: kindex
#: ../../calc.texi:28583
#, no-wrap
msgid "t 0-9"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28588
msgid ""
"The prefix keys @kbd{s} and @kbd{t} may be followed immediately by a digit; "
"@kbd{s 9} is equivalent to @kbd{s s 9}, and @kbd{t 9} is equivalent to "
"@kbd{s t 9}.  (The @kbd{t} prefix is otherwise used for trail and time/date "
"commands.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:28589
#, no-wrap
msgid "s +"
msgstr ""

#. type: kindex
#: ../../calc.texi:28590
#, no-wrap
msgid "s -"
msgstr ""

#. type: kindex
#: ../../calc.texi:28594
#, no-wrap
msgid "s *"
msgstr ""

#. type: kindex
#: ../../calc.texi:28598
#, no-wrap
msgid "s /"
msgstr ""

#. type: kindex
#: ../../calc.texi:28602
#, no-wrap
msgid "s ^"
msgstr ""

#. type: kindex
#: ../../calc.texi:28606
#, no-wrap
msgid "s |"
msgstr ""

#. type: kindex
#: ../../calc.texi:28610
#, no-wrap
msgid "s n"
msgstr ""

#. type: kindex
#: ../../calc.texi:28614
#, no-wrap
msgid "s &"
msgstr ""

#. type: kindex
#: ../../calc.texi:28618
#, no-wrap
msgid "s ["
msgstr ""

#. type: kindex
#: ../../calc.texi:28622
#, no-wrap
msgid "s ]"
msgstr ""

#. type: pindex
#: ../../calc.texi:28623
#, no-wrap
msgid "calc-store-plus"
msgstr ""

#. type: pindex
#: ../../calc.texi:28624
#, no-wrap
msgid "calc-store-minus"
msgstr ""

#. type: pindex
#: ../../calc.texi:28625
#, no-wrap
msgid "calc-store-times"
msgstr ""

#. type: pindex
#: ../../calc.texi:28626
#, no-wrap
msgid "calc-store-div"
msgstr ""

#. type: pindex
#: ../../calc.texi:28627
#, no-wrap
msgid "calc-store-power"
msgstr ""

#. type: pindex
#: ../../calc.texi:28628
#, no-wrap
msgid "calc-store-concat"
msgstr ""

#. type: pindex
#: ../../calc.texi:28629
#, no-wrap
msgid "calc-store-neg"
msgstr ""

#. type: pindex
#: ../../calc.texi:28630
#, no-wrap
msgid "calc-store-inv"
msgstr ""

#. type: pindex
#: ../../calc.texi:28631
#, no-wrap
msgid "calc-store-decr"
msgstr ""

#. type: pindex
#: ../../calc.texi:28632
#, no-wrap
msgid "calc-store-incr"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28639
msgid ""
"There are also several ``arithmetic store'' commands.  For example, @kbd{s "
"+} removes a value from the stack and adds it to the specified variable.  "
"The other arithmetic stores are @kbd{s -}, @kbd{s *}, @kbd{s /}, @kbd{s ^}, "
"and @w{@kbd{s |}} (vector concatenation), plus @kbd{s n} and @kbd{s &} which "
"negate or invert the value in a variable, and @w{@kbd{s [}} and @kbd{s ]} "
"which decrease or increase a variable by one."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28653
msgid ""
"All the arithmetic stores accept the Inverse prefix to reverse the order of "
"the operands.  If @expr{v} represents the contents of the variable, and "
"@expr{a} is the value drawn from the stack, then regular @w{@kbd{s -}} "
"assigns @texline @math{v \\coloneq v - a}, @infoline @expr{v := v - a}, but "
"@kbd{I s -} assigns @texline @math{v \\coloneq a - v}.  @infoline @expr{v := "
"a - v}.  While @kbd{I s *} might seem pointless, it is useful if matrix "
"multiplication is involved.  Actually, all the arithmetic stores use "
"formulas designed to behave usefully both forwards and backwards:"
msgstr ""

#. type: group
#: ../../calc.texi:28666
#, no-wrap
msgid ""
"s +        v := v + a          v := a + v\n"
"s -        v := v - a          v := a - v\n"
"s *        v := v * a          v := a * v\n"
"s /        v := v / a          v := a / v\n"
"s ^        v := v ^ a          v := a ^ v\n"
"s |        v := v | a          v := a | v\n"
"s n        v := v / (-1)       v := (-1) / v\n"
"s &        v := v ^ (-1)       v := (-1) ^ v\n"
"s [        v := v - 1          v := 1 - v\n"
"s ]        v := v - (-1)       v := (-1) - v\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28673
msgid ""
"In the last four cases, a numeric prefix argument will be used in place of "
"the number one.  (For example, @kbd{M-2 s ]} increases a variable by 2, and "
"@kbd{M-2 I s ]} replaces a variable by minus-two minus the variable."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28677
msgid ""
"The first six arithmetic stores can also be typed @kbd{s t +}, @kbd{s t -}, "
"etc.  The commands @kbd{s s +}, @kbd{s s -}, and so on are analogous "
"arithmetic stores that don't remove the value @expr{a} from the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28685
msgid ""
"All arithmetic stores report the new value of the variable in the Trail for "
"your information.  They signal an error if the variable previously had no "
"stored value.  If default simplifications have been turned off, the "
"arithmetic stores temporarily turn them on for numeric arguments only (i.e., "
"they temporarily do an @kbd{m N} command).  @xref{Simplification Modes}.  "
"Large vectors put in the trail by these commands always use abbreviated "
"(@kbd{t .}) mode."
msgstr ""

#. type: kindex
#: ../../calc.texi:28686
#, no-wrap
msgid "s m"
msgstr ""

#. type: pindex
#: ../../calc.texi:28687
#, no-wrap
msgid "calc-store-map"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28699
msgid ""
"The @kbd{s m} command is a general way to adjust a variable's value using "
"any Calc function.  It is a ``mapping'' command analogous to @kbd{V M}, "
"@kbd{V R}, etc.  @xref{Reducing and Mapping}, to see how to specify a "
"function for a mapping command.  Basically, all you do is type the Calc "
"command key that would invoke that function normally.  For example, @kbd{s m "
"n} applies the @kbd{n} key to negate the contents of the variable, so @kbd{s "
"m n} is equivalent to @kbd{s n}.  Also, @kbd{s m Q} takes the square root of "
"the value stored in a variable, @kbd{s m v v} uses @kbd{v v} to reverse the "
"vector stored in the variable, and @kbd{s m H I S} takes the hyperbolic "
"arcsine of the variable contents."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28707
msgid ""
"If the mapping function takes two or more arguments, the additional "
"arguments are taken from the stack; the old value of the variable is "
"provided as the first argument.  Thus @kbd{s m -} with @expr{a} on the stack "
"computes @expr{v - a}, just like @kbd{s -}.  With the Inverse prefix, the "
"variable's original value becomes the @emph{last} argument instead of the "
"first.  Thus @kbd{I s m -} is also equivalent to @kbd{I s -}."
msgstr ""

#. type: kindex
#: ../../calc.texi:28708
#, no-wrap
msgid "s x"
msgstr ""

#. type: pindex
#: ../../calc.texi:28709
#, no-wrap
msgid "calc-store-exchange"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28713
msgid ""
"The @kbd{s x} (@code{calc-store-exchange}) command exchanges the value of a "
"variable with the value on the top of the stack.  Naturally, the variable "
"must already have a stored value for this to work."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28717
msgid ""
"You can type an equation or assignment at the @kbd{s x} prompt.  The command "
"@kbd{s x a=6} takes no values from the stack; instead, it pushes the old "
"value of @samp{a} on the stack and stores @samp{a = 6}."
msgstr ""

#. type: kindex
#: ../../calc.texi:28718
#, no-wrap
msgid "s u"
msgstr ""

#. type: pindex
#: ../../calc.texi:28719
#, no-wrap
msgid "calc-unstore"
msgstr ""

#. type: cindex
#: ../../calc.texi:28720
#, no-wrap
msgid "Void variables"
msgstr ""

#. type: cindex
#: ../../calc.texi:28721
#, no-wrap
msgid "Un-storing variables"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28727
msgid ""
"Until you store something in them, most variables are ``void,'' that is, "
"they contain no value at all.  If they appear in an algebraic formula they "
"will be left alone even if you press @kbd{=} (@code{calc-evaluate}).  The "
"@kbd{s u} (@code{calc-unstore}) command returns a variable to the void "
"state."
msgstr ""

#. type: kindex
#: ../../calc.texi:28728
#, no-wrap
msgid "s c"
msgstr ""

#. type: pindex
#: ../../calc.texi:28729
#, no-wrap
msgid "calc-copy-variable"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28736
msgid ""
"The @kbd{s c} (@code{calc-copy-variable}) command copies the stored value of "
"one variable to another.  One way it differs from a simple @kbd{s r} "
"followed by an @kbd{s t} (aside from saving keystrokes) is that the value "
"never goes on the stack and thus is never rounded, evaluated, or simplified "
"in any way; it is not even rounded down to the current precision."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28745
msgid ""
"The only variables with predefined values are the ``special constants'' "
"@code{pi}, @code{e}, @code{i}, @code{phi}, and @code{gamma}.  You are free "
"to unstore these variables or to store new values into them if you like, "
"although some of the algebraic-manipulation functions may assume these "
"variables represent their standard values.  Calc displays a warning if you "
"change the value of one of these variables, or of one of the other special "
"variables @code{inf}, @code{uinf}, and @code{nan} (which are normally void)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28753
msgid ""
"Note that @code{pi} doesn't actually have 3.14159265359 stored in it, but "
"rather a special magic value that evaluates to @cpi{} at the current "
"precision.  Likewise @code{e}, @code{i}, and @code{phi} evaluate according "
"to the current precision or polar mode.  If you recall a value from "
"@code{pi} and store it back, this magic property will be lost.  The magic "
"property is preserved, however, when a variable is copied with @kbd{s c}."
msgstr ""

#. type: kindex
#: ../../calc.texi:28754
#, no-wrap
msgid "s k"
msgstr ""

#. type: pindex
#: ../../calc.texi:28755
#, no-wrap
msgid "calc-copy-special-constant"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28766
msgid ""
"If one of the ``special constants'' is redefined (or undefined) so that it "
"no longer has its magic property, the property can be restored with @kbd{s "
"k} (@code{calc-copy-special-constant}).  This command will prompt for a "
"special constant and a variable to store it in, and so a special constant "
"can be stored in any variable.  Here, the special constant that you enter "
"doesn't depend on the value of the corresponding variable; @code{pi} will "
"represent 3.14159@dots{} regardless of what is currently stored in the Calc "
"variable @code{pi}.  If one of the other special variables, @code{inf}, "
"@code{uinf} or @code{nan}, is given a value, its original behavior can be "
"restored by voiding it with @kbd{s u}."
msgstr ""

#. type: node
#: ../../calc.texi:28767 ../../calc.texi:28790 ../../calc.texi:28947
#, no-wrap
msgid "Operations on Variables"
msgstr ""

#. type: kindex
#: ../../calc.texi:28771
#, no-wrap
msgid "s r"
msgstr ""

#. type: pindex
#: ../../calc.texi:28772
#, no-wrap
msgid "calc-recall"
msgstr ""

#. type: cindex
#: ../../calc.texi:28773
#, no-wrap
msgid "Recalling variables"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28779
msgid ""
"The most straightforward way to extract the stored value from a variable is "
"to use the @kbd{s r} (@code{calc-recall}) command.  This command prompts for "
"a variable name (similarly to @code{calc-store}), looks up the value of the "
"specified variable, and pushes that value onto the stack.  It is an error to "
"try to recall a void variable."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28785
msgid ""
"It is also possible to recall the value from a variable by evaluating a "
"formula containing that variable.  For example, @kbd{' a @key{RET} =} is the "
"same as @kbd{s r a @key{RET}} except that if the variable is void, the "
"former will simply leave the formula @samp{a} on the stack whereas the "
"latter will produce an error message."
msgstr ""

#. type: kindex
#: ../../calc.texi:28786
#, no-wrap
msgid "r 0-9"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28789
msgid ""
"The @kbd{r} prefix may be followed by a digit, so that @kbd{r 9} is "
"equivalent to @kbd{s r 9}."
msgstr ""

#. type: node
#: ../../calc.texi:28790 ../../calc.texi:28947 ../../calc.texi:28985
#, no-wrap
msgid "Let Command"
msgstr ""

#. type: section
#: ../../calc.texi:28791
#, no-wrap
msgid "Other Operations on Variables"
msgstr ""

#. type: kindex
#: ../../calc.texi:28794
#, no-wrap
msgid "s e"
msgstr ""

#. type: pindex
#: ../../calc.texi:28795
#, no-wrap
msgid "calc-edit-variable"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28804
msgid ""
"The @kbd{s e} (@code{calc-edit-variable}) command edits the stored value of "
"a variable without ever putting that value on the stack or simplifying or "
"evaluating the value.  It prompts for the name of the variable to edit.  If "
"the variable has no stored value, the editing buffer will start out empty.  "
"If the editing buffer is empty when you press @kbd{C-c C-c} to finish, the "
"variable will be made void.  @xref{Editing Stack Entries}, for a general "
"description of editing."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28815
msgid ""
"The @kbd{s e} command is especially useful for creating and editing rewrite "
"rules which are stored in variables.  Sometimes these rules contain formulas "
"which must not be evaluated until the rules are actually used.  (For "
"example, they may refer to @samp{deriv(x,y)}, where @code{x} will someday "
"become some expression involving @code{y}; if you let Calc evaluate the rule "
"while you are defining it, Calc will replace @samp{deriv(x,y)} with 0 "
"because the formula @code{x} does not itself refer to @code{y}.)  By "
"contrast, recalling the variable, editing with @kbd{`}, and storing will "
"evaluate the variable's value as a side effect of putting the value on the "
"stack."
msgstr ""

#. type: item
#: ../../calc.texi:28816 ../../calc.texi:28879
#, no-wrap
msgid "s A"
msgstr ""

#. type: item
#: ../../calc.texi:28817 ../../calc.texi:28881
#, no-wrap
msgid "s D"
msgstr ""

#. type: item
#: ../../calc.texi:28821 ../../calc.texi:28883
#, no-wrap
msgid "s E"
msgstr ""

#. type: item
#: ../../calc.texi:28825 ../../calc.texi:28885
#, no-wrap
msgid "s F"
msgstr ""

#. type: item
#: ../../calc.texi:28829 ../../calc.texi:28887
#, no-wrap
msgid "s G"
msgstr ""

#. type: item
#: ../../calc.texi:28833 ../../calc.texi:28889
#, no-wrap
msgid "s H"
msgstr ""

#. type: item
#: ../../calc.texi:28837 ../../calc.texi:28891
#, no-wrap
msgid "s I"
msgstr ""

#. type: item
#: ../../calc.texi:28841 ../../calc.texi:28893
#, no-wrap
msgid "s L"
msgstr ""

#. type: item
#: ../../calc.texi:28845 ../../calc.texi:28895
#, no-wrap
msgid "s P"
msgstr ""

#. type: item
#: ../../calc.texi:28849 ../../calc.texi:28897
#, no-wrap
msgid "s R"
msgstr ""

#. type: item
#: ../../calc.texi:28853 ../../calc.texi:28899
#, no-wrap
msgid "s T"
msgstr ""

#. type: item
#: ../../calc.texi:28857 ../../calc.texi:28901
#, no-wrap
msgid "s U"
msgstr ""

#. type: item
#: ../../calc.texi:28861 ../../calc.texi:28903
#, no-wrap
msgid "s X"
msgstr ""

#. type: pindex
#: ../../calc.texi:28862
#, no-wrap
msgid "calc-store-AlgSimpRules"
msgstr ""

#. type: pindex
#: ../../calc.texi:28863
#, no-wrap
msgid "calc-store-Decls"
msgstr ""

#. type: pindex
#: ../../calc.texi:28864
#, no-wrap
msgid "calc-store-EvalRules"
msgstr ""

#. type: pindex
#: ../../calc.texi:28865
#, no-wrap
msgid "calc-store-FitRules"
msgstr ""

#. type: pindex
#: ../../calc.texi:28866
#, no-wrap
msgid "calc-store-GenCount"
msgstr ""

#. type: pindex
#: ../../calc.texi:28867
#, no-wrap
msgid "calc-store-Holidays"
msgstr ""

#. type: pindex
#: ../../calc.texi:28868
#, no-wrap
msgid "calc-store-IntegLimit"
msgstr ""

#. type: pindex
#: ../../calc.texi:28869
#, no-wrap
msgid "calc-store-LineStyles"
msgstr ""

#. type: pindex
#: ../../calc.texi:28870
#, no-wrap
msgid "calc-store-PointStyles"
msgstr ""

#. type: pindex
#: ../../calc.texi:28871
#, no-wrap
msgid "calc-store-PlotRejects"
msgstr ""

#. type: pindex
#: ../../calc.texi:28872
#, no-wrap
msgid "calc-store-TimeZone"
msgstr ""

#. type: pindex
#: ../../calc.texi:28873
#, no-wrap
msgid "calc-store-Units"
msgstr ""

#. type: pindex
#: ../../calc.texi:28874
#, no-wrap
msgid "calc-store-ExtSimpRules"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28877
msgid ""
"There are several special-purpose variable-editing commands that use the "
"@kbd{s} prefix followed by a shifted letter:"
msgstr ""

#. type: table
#: ../../calc.texi:28881
msgid "Edit @code{AlgSimpRules}.  @xref{Algebraic Simplifications}."
msgstr ""

#. type: table
#: ../../calc.texi:28883
msgid "Edit @code{Decls}.  @xref{Declarations}."
msgstr ""

#. type: table
#: ../../calc.texi:28885
msgid "Edit @code{EvalRules}.  @xref{Basic Simplifications}."
msgstr ""

#. type: table
#: ../../calc.texi:28887
msgid "Edit @code{FitRules}.  @xref{Curve Fitting}."
msgstr ""

#. type: table
#: ../../calc.texi:28889
msgid "Edit @code{GenCount}.  @xref{Solving Equations}."
msgstr ""

#. type: table
#: ../../calc.texi:28891
msgid "Edit @code{Holidays}.  @xref{Business Days}."
msgstr ""

#. type: table
#: ../../calc.texi:28893
msgid "Edit @code{IntegLimit}.  @xref{Calculus}."
msgstr ""

#. type: table
#: ../../calc.texi:28895
msgid "Edit @code{LineStyles}.  @xref{Graphics}."
msgstr ""

#. type: table
#: ../../calc.texi:28897
msgid "Edit @code{PointStyles}.  @xref{Graphics}."
msgstr ""

#. type: table
#: ../../calc.texi:28899
msgid "Edit @code{PlotRejects}.  @xref{Graphics}."
msgstr ""

#. type: table
#: ../../calc.texi:28901
msgid "Edit @code{TimeZone}.  @xref{Time Zones}."
msgstr ""

#. type: table
#: ../../calc.texi:28903
msgid "Edit @code{Units}.  @xref{User-Defined Units}."
msgstr ""

#. type: table
#: ../../calc.texi:28905
msgid "Edit @code{ExtSimpRules}.  @xref{Unsafe Simplifications}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28909
msgid ""
"These commands are just versions of @kbd{s e} that use fixed variable names "
"rather than prompting for the variable name."
msgstr ""

#. type: kindex
#: ../../calc.texi:28910
#, no-wrap
msgid "s p"
msgstr ""

#. type: pindex
#: ../../calc.texi:28911
#, no-wrap
msgid "calc-permanent-variable"
msgstr ""

#. type: cindex
#: ../../calc.texi:28913
#, no-wrap
msgid "Permanent variables"
msgstr ""

#. type: cindex
#: ../../calc.texi:28914
#, no-wrap
msgid "Calc init file, variables"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28923
msgid ""
"The @kbd{s p} (@code{calc-permanent-variable}) command saves a variable's "
"value permanently in your Calc init file (the file given by the variable "
"@code{calc-settings-file}, typically @file{~/.emacs.d/calc.el}), so that its "
"value will still be available in future Emacs sessions.  You can re-execute "
"@w{@kbd{s p}} later on to update the saved value, but the only way to remove "
"a saved variable is to edit your calc init file by hand.  (@xref{General "
"Mode Commands}, for a way to tell Calc to use a different file for the Calc "
"init file.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28933
msgid ""
"If you do not specify the name of a variable to save (i.e., @kbd{s p "
"@key{RET}}), all Calc variables with defined values are saved except for the "
"special constants @code{pi}, @code{e}, @code{i}, @code{phi}, and "
"@code{gamma}; the variables @code{TimeZone} and @code{PlotRejects}; "
"@code{FitRules}, @code{DistribRules}, and other built-in rewrite rules; and "
"@code{PlotData@var{n}} variables generated by the graphics commands.  (You "
"can still save these variables by explicitly naming them in an @kbd{s p} "
"command.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:28934
#, no-wrap
msgid "s i"
msgstr ""

#. type: pindex
#: ../../calc.texi:28935
#, no-wrap
msgid "calc-insert-variables"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28946
msgid ""
"The @kbd{s i} (@code{calc-insert-variables}) command writes the values of "
"all Calc variables into a specified buffer.  The variables are written with "
"the prefix @code{var-} in the form of Lisp @code{setq} commands which store "
"the values in string form.  You can place these commands in your Calc init "
"file (or @file{.emacs}) if you wish, though in this case it would be easier "
"to use @kbd{s p @key{RET}}.  (Note that @kbd{s i} omits the same set of "
"variables as @w{@kbd{s p @key{RET}}}; the difference is that @kbd{s i} will "
"store the variables in any buffer, and it also stores in a more "
"human-readable format.)"
msgstr ""

#. type: section
#: ../../calc.texi:28948
#, no-wrap
msgid "The Let Command"
msgstr ""

#. type: kindex
#: ../../calc.texi:28951
#, no-wrap
msgid "s l"
msgstr ""

#. type: pindex
#: ../../calc.texi:28952
#, no-wrap
msgid "calc-let"
msgstr ""

#. type: cindex
#: ../../calc.texi:28953
#, no-wrap
msgid "Variables, temporary assignment"
msgstr ""

#. type: cindex
#: ../../calc.texi:28954
#, no-wrap
msgid "Temporary assignment to variables"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28959
msgid ""
"If you have an expression like @samp{a+b^2} on the stack and you wish to "
"compute its value where @expr{b=3}, you can simply store 3 in @expr{b} and "
"then press @kbd{=} to reevaluate the formula.  This has the side-effect of "
"leaving the stored value of 3 in @expr{b} for future operations."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28969
msgid ""
"The @kbd{s l} (@code{calc-let}) command evaluates a formula under a "
"@emph{temporary} assignment of a variable.  It stores the value on the top "
"of the stack into the specified variable, then evaluates the second-to-top "
"stack entry, then restores the original value (or lack of one)  in the "
"variable.  Thus after @kbd{'@w{ }a+b^2 @key{RET} 3 s l b @key{RET}}, the "
"stack will contain the formula @samp{a + 9}.  The subsequent command "
"@kbd{@w{5 s l a} @key{RET}} will replace this formula with the number 14.  "
"The variables @samp{a} and @samp{b} are not permanently affected in any way "
"by these commands."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28973
msgid ""
"The value on the top of the stack may be an equation or assignment, or a "
"vector of equations or assignments, in which case the default will be "
"analogous to the case of @kbd{s t @key{RET}}.  @xref{Storing Variables}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28977
msgid ""
"Also, you can answer the variable-name prompt with an equation or "
"assignment: @kbd{s l b=3 @key{RET}} is the same as storing 3 on the stack "
"and typing @kbd{s l b @key{RET}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:28984
msgid ""
"The @kbd{a b} (@code{calc-substitute}) command is another way to substitute "
"a variable with a value in a formula.  It does an actual substitution rather "
"than temporarily assigning the variable and evaluating.  For example, "
"letting @expr{n=2} in @samp{f(n pi)} with @kbd{a b} will produce @samp{f(2 "
"pi)}, whereas @kbd{s l} would give @samp{f(6.28)} since the evaluation step "
"will also evaluate @code{pi}."
msgstr ""

#. type: section
#: ../../calc.texi:28986
#, no-wrap
msgid "The Evaluates-To Operator"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28991
msgid "@tindex evalto @tindex =>"
msgstr ""

#. type: cindex
#: ../../calc.texi:28991
#, no-wrap
msgid "Evaluates-to operator"
msgstr ""

#. type: cindex
#: ../../calc.texi:28992
#, no-wrap
msgid "@samp{=>} operator"
msgstr ""

#. type: Plain text
#: ../../calc.texi:28998
msgid ""
"The special algebraic symbol @samp{=>} is known as the @dfn{evaluates-to "
"operator}.  (It will show up as an @code{evalto} function call in other "
"language modes like Pascal and @LaTeX{}.)  This is a binary operator, that "
"is, it has a lefthand and a righthand argument, although it can be entered "
"with the righthand argument omitted."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29005
msgid ""
"A formula like @samp{@var{a} => @var{b}} is evaluated by Calc as follows: "
"First, @var{a} is not simplified or modified in any way.  The previous value "
"of argument @var{b} is thrown away; the formula @var{a} is then copied and "
"evaluated as if by the @kbd{=} command according to all current modes and "
"stored variable values, and the result is installed as the new value of "
"@var{b}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29009
msgid ""
"For example, suppose you enter the algebraic formula @samp{2 + 3 => 17}.  "
"The number 17 is ignored, and the lefthand argument is left in its "
"unevaluated form; the result is the formula @samp{2 + 3 => 5}."
msgstr ""

#. type: kindex
#: ../../calc.texi:29010
#, no-wrap
msgid "s ="
msgstr ""

#. type: pindex
#: ../../calc.texi:29011
#, no-wrap
msgid "calc-evalto"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29017
msgid ""
"You can enter an @samp{=>} formula either directly using algebraic entry (in "
"which case the righthand side may be omitted since it is going to be "
"replaced right away anyhow), or by using the @kbd{s =} (@code{calc-evalto}) "
"command, which takes @var{a} from the stack and replaces it with "
"@samp{@var{a} => @var{b}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29033
msgid ""
"Calc keeps track of all @samp{=>} operators on the stack, and recomputes "
"them whenever anything changes that might affect their values, i.e., a mode "
"setting or variable value.  This occurs only if the @samp{=>} operator is at "
"the top level of the formula, or if it is part of a top-level vector.  In "
"other words, pushing @samp{2 + (a => 17)} will change the 17 to the actual "
"value of @samp{a} when you enter the formula, but the result will not be "
"dynamically updated when @samp{a} is changed later because the @samp{=>} "
"operator is buried inside a sum.  However, a vector of @samp{=>} operators "
"will be recomputed, since it is convenient to push a vector like @samp{[a "
"=>, b =>, c =>]} on the stack to make a concise display of all the variables "
"in your problem.  (Another way to do this would be to use @samp{[a, b, c] "
"=>}, which provides a slightly different format of display.  You can use "
"whichever you find easiest to read.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29043
msgid ""
"The @kbd{m C} (@code{calc-auto-recompute}) command allows you to turn this "
"automatic recomputation on or off.  If you turn recomputation off, you must "
"explicitly recompute an @samp{=>} operator on the stack in one of the usual "
"ways, such as by pressing @kbd{=}.  Turning recomputation off temporarily "
"can save a lot of time if you will be changing several modes or variables "
"before you look at the @samp{=>} entries again."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29051
msgid ""
"Most commands are not especially useful with @samp{=>} operators as "
"arguments.  For example, given @samp{x + 2 => 17}, it won't work to type "
"@kbd{1 +} to get @samp{x + 3 => 18}.  If you want to operate on the lefthand "
"side of the @samp{=>} operator on the top of the stack, type @kbd{j 1} "
"(that's the digit ``one'')  to select the lefthand side, execute your "
"commands, then type @kbd{j u} to unselect."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29064
msgid ""
"All current modes apply when an @samp{=>} operator is computed, including "
"the current simplification mode.  Recall that the formula "
"@samp{arcsin(sin(x))} will not be handled by Calc's algebraic "
"simplifications, but Calc's unsafe simplifications will reduce it to "
"@samp{x}.  If you enter @samp{arcsin(sin(x)) =>} normally, the result will "
"be @samp{arcsin(sin(x)) => arcsin(sin(x))}.  If you change to Extended "
"Simplification mode, the result will be @samp{arcsin(sin(x)) => x}.  "
"However, just pressing @kbd{a e} once will have no effect on "
"@samp{arcsin(sin(x)) => arcsin(sin(x))}, because the righthand side depends "
"only on the lefthand side and the current mode settings, and the lefthand "
"side is not affected by commands like @kbd{a e}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29075
msgid ""
"The ``let'' command (@kbd{s l}) has an interesting interaction with the "
"@samp{=>} operator.  The @kbd{s l} command evaluates the second-to-top stack "
"entry with the top stack entry supplying a temporary value for a given "
"variable.  As you might expect, if that stack entry is an @samp{=>} operator "
"its righthand side will temporarily show this value for the variable.  In "
"fact, all @samp{=>}s on the stack will be updated if they refer to that "
"variable.  But this change is temporary in the sense that the next command "
"that causes Calc to look at those stack entries will make them revert to the "
"old variable value."
msgstr ""

#. type: group
#: ../../calc.texi:29081
#, no-wrap
msgid ""
"2:  a => a             2:  a => 17         2:  a => a\n"
"1:  a + 1 => a + 1     1:  a + 1 => 18     1:  a + 1 => a + 1\n"
"    .                      .                   .\n"
"\n"
msgstr ""

#. type: group
#: ../../calc.texi:29083
#, no-wrap
msgid "                           17 s l a @key{RET}        p 8 @key{RET}\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29092
msgid ""
"Here the @kbd{p 8} command changes the current precision, thus causing the "
"@samp{=>} forms to be recomputed after the influence of the ``let'' is "
"gone.  The @kbd{d @key{SPC}} command (@code{calc-refresh}) is a handy way to "
"force the @samp{=>} operators on the stack to be recomputed without any "
"other side effects."
msgstr ""

#. type: kindex
#: ../../calc.texi:29093
#, no-wrap
msgid "s :"
msgstr ""

#. type: pindex
#: ../../calc.texi:29094
#, no-wrap
msgid "calc-assign"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29106
msgid ""
"@tindex assign @tindex := Embedded mode also uses @samp{=>} operators.  In "
"Embedded mode, the lefthand side of an @samp{=>} operator can refer to "
"variables assigned elsewhere in the file by @samp{:=} operators.  The "
"assignment operator @samp{a := 17} does not actually do anything by itself.  "
"But Embedded mode recognizes it and marks it as a sort of file-local "
"definition of the variable.  You can enter @samp{:=} operators in Algebraic "
"mode, or by using the @kbd{s :} (@code{calc-assign}) [@code{assign}] command "
"which takes a variable and value from the stack and replaces them with an "
"assignment."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29110
msgid ""
"@xref{TeX and LaTeX Language Modes}, for the way @samp{=>} appears in @TeX{} "
"language output.  The @dfn{eqn} mode gives similar treatment to @samp{=>}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29121
msgid ""
"The commands for graphing data begin with the @kbd{g} prefix key.  Calc uses "
"GNUPLOT 2.0 or later to do graphics.  These commands will only work if "
"GNUPLOT is available on your system.  (While GNUPLOT sounds like a relative "
"of GNU Emacs, it is actually completely unrelated.  However, it is free "
"software.  It can be obtained from @samp{http://www.gnuplot.info}.)"
msgstr ""

#. type: defvar
#: ../../calc.texi:29122 ../../calc.texi:35380
#, no-wrap
msgid "calc-gnuplot-name"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29133
msgid ""
"If you have GNUPLOT installed on your system but Calc is unable to find it, "
"you may need to set the @code{calc-gnuplot-name} variable in your Calc init "
"file or @file{.emacs}.  You may also need to set some Lisp variables to show "
"Calc how to run GNUPLOT on your system; these are described under @kbd{g D} "
"and @kbd{g O} below.  If you are using the X window system or MS-Windows, "
"Calc will configure GNUPLOT for you automatically.  If you have GNUPLOT 3.0 "
"or later and you are using a Unix or GNU system without X, Calc will "
"configure GNUPLOT to display graphs using simple character graphics that "
"will work on any POSIX-compatible terminal."
msgstr ""

#. type: menuentry
#: ../../calc.texi:29140
msgid "Basic Graphics::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:29140
msgid "Three Dimensional Graphics::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:29140
msgid "Managing Curves::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:29140
msgid "Graphics Options::"
msgstr ""

#. type: node
#: ../../calc.texi:29140 ../../calc.texi:29455 ../../calc.texi:29621
#, no-wrap
msgid "Devices"
msgstr ""

#. type: node
#: ../../calc.texi:29142 ../../calc.texi:29143 ../../calc.texi:29228
#, no-wrap
msgid "Basic Graphics"
msgstr ""

#. type: node
#: ../../calc.texi:29142 ../../calc.texi:29228 ../../calc.texi:29296
#, no-wrap
msgid "Three Dimensional Graphics"
msgstr ""

#. type: kindex
#: ../../calc.texi:29146
#, no-wrap
msgid "g f"
msgstr ""

#. type: pindex
#: ../../calc.texi:29147
#, no-wrap
msgid "calc-graph-fast"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29157
msgid ""
"The easiest graphics command is @kbd{g f} (@code{calc-graph-fast}).  This "
"command takes two vectors of equal length from the stack.  The vector at the "
"top of the stack represents the ``y'' values of the various data points.  "
"The vector in the second-to-top position represents the corresponding ``x'' "
"values.  This command runs GNUPLOT (if it has not already been started by "
"previous graphing commands) and displays the set of data points.  The points "
"will be connected by lines, and there will also be some kind of symbol to "
"indicate the points themselves."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29161
msgid ""
"The ``x'' entry may instead be an interval form, in which case suitable "
"``x'' values are interpolated between the minimum and maximum values of the "
"interval (whether the interval is open or closed is ignored)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29165
msgid ""
"The ``x'' entry may also be a number, in which case Calc uses the sequence "
"of ``x'' values @expr{x}, @expr{x+1}, @expr{x+2}, etc.  (Generally the "
"number 0 or 1 would be used for @expr{x} in this case.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29175
msgid ""
"The ``y'' entry may be any formula instead of a vector.  Calc effectively "
"uses @kbd{N} (@code{calc-eval-num}) to evaluate variables in the formula; "
"the result of this must be a formula in a single (unassigned) variable.  The "
"formula is plotted with this variable taking on the various ``x'' values.  "
"Graphs of formulas by default use lines without symbols at the computed data "
"points.  Note that if neither ``x'' nor ``y'' is a vector, Calc guesses at a "
"reasonable number of data points to use.  See the @kbd{g N} command below.  "
"(The ``x'' values must be either a vector or an interval if ``y'' is a "
"formula.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29188
msgid ""
"@tindex xy If ``y'' is (or evaluates to) a formula of the form "
"@samp{xy(@var{x}, @var{y})} then the result is a parametric plot.  The two "
"arguments of the fictitious @code{xy} function are used as the ``x'' and "
"``y'' coordinates of the curve, respectively.  In this case the ``x'' vector "
"or interval you specified is not directly visible in the graph.  For "
"example, if ``x'' is the interval @samp{[0..360]} and ``y'' is the formula "
"@samp{xy(sin(t), cos(t))}, the resulting graph will be a circle."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29192
msgid ""
"Also, ``x'' and ``y'' may each be variable names, in which case Calc looks "
"for suitable vectors, intervals, or formulas stored in those variables."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29202
msgid ""
"The ``x'' and ``y'' values for the data points (as pulled from the vectors, "
"calculated from the formulas, or interpolated from the intervals) should be "
"real numbers (integers, fractions, or floats).  One exception to this is "
"that the ``y'' entry can consist of a vector of numbers combined with error "
"forms, in which case the points will be plotted with the appropriate error "
"bars.  Other than this, if either the ``x'' value or the ``y'' value of a "
"given data point is not a real number, that data point will be omitted from "
"the graph.  The points on either side of the invalid point will @emph{not} "
"be connected by a line."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29205
msgid ""
"See the documentation for @kbd{g a} below for a description of the way "
"numeric prefix arguments affect @kbd{g f}."
msgstr ""

#. type: cindex
#: ../../calc.texi:29206
#, no-wrap
msgid "@code{PlotRejects} variable"
msgstr ""

#. type: vindex
#: ../../calc.texi:29207
#, no-wrap
msgid "PlotRejects"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29218
msgid ""
"If you store an empty vector in the variable @code{PlotRejects} (i.e., "
"@kbd{[ ] s t PlotRejects}), Calc will append information to this vector for "
"every data point which was rejected because its ``x'' or ``y'' values were "
"not real numbers.  The result will be a matrix where each row holds the "
"curve number, data point number, ``x'' value, and ``y'' value for a rejected "
"data point.  @xref{Evaluates-To Operator}, for a handy way to keep tabs on "
"the current value of @code{PlotRejects}.  @xref{Operations on Variables}, "
"for the @kbd{s R} command which is another easy way to examine "
"@code{PlotRejects}."
msgstr ""

#. type: kindex
#: ../../calc.texi:29219
#, no-wrap
msgid "g c"
msgstr ""

#. type: pindex
#: ../../calc.texi:29220
#, no-wrap
msgid "calc-graph-clear"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29227
msgid ""
"To clear the graphics display, type @kbd{g c} (@code{calc-graph-clear}).  If "
"the GNUPLOT output device is an X window, the window will go away.  Effects "
"on other kinds of output devices will vary.  You don't need to use @kbd{g c} "
"if you don't want to---if you give another @kbd{g f} or @kbd{g p} command "
"later on, it will reuse the existing graphics window if there is one."
msgstr ""

#. type: node
#: ../../calc.texi:29228 ../../calc.texi:29296 ../../calc.texi:29297 ../../calc.texi:29455
#, no-wrap
msgid "Managing Curves"
msgstr ""

#. type: section
#: ../../calc.texi:29229
#, no-wrap
msgid "Three-Dimensional Graphics"
msgstr ""

#. type: kindex
#: ../../calc.texi:29231
#, no-wrap
msgid "g F"
msgstr ""

#. type: pindex
#: ../../calc.texi:29232
#, no-wrap
msgid "calc-graph-fast-3d"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29236
msgid ""
"The @kbd{g F} (@code{calc-graph-fast-3d}) command makes a three-dimensional "
"graph.  It works only if you have GNUPLOT 3.0 or later; with GNUPLOT 2.0, "
"you will see a GNUPLOT error message if you try this command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29240
msgid ""
"The @kbd{g F} command takes three values from the stack, called ``x'', "
"``y'', and ``z'', respectively.  As was the case for 2D graphs, there are "
"several options for these values."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29254
msgid ""
"In the first case, ``x'' and ``y'' are each vectors (not necessarily of the "
"same length); either or both may instead be interval forms.  The ``z'' value "
"must be a matrix with the same number of rows as elements in ``x'', and the "
"same number of columns as elements in ``y''.  The result is a surface plot "
"where @texline @math{z_{ij}} @infoline @expr{z_ij} is the height of the "
"point at coordinate @expr{(x_i, y_j)} on the surface.  The 3D graph will be "
"displayed from a certain default viewpoint; you can change this viewpoint by "
"adding a @samp{set view} to the @file{*Gnuplot Commands*} buffer as "
"described later.  See the GNUPLOT documentation for a description of the "
"@samp{set view} command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29257
msgid ""
"Each point in the matrix will be displayed as a dot in the graph, and these "
"points will be connected by a grid of lines (@dfn{isolines})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29262
msgid ""
"In the second case, ``x'', ``y'', and ``z'' are all vectors of equal "
"length.  The resulting graph displays a 3D line instead of a surface, where "
"the coordinates of points along the line are successive triplets of values "
"from the input vectors."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29269
msgid ""
"In the third case, ``x'' and ``y'' are vectors or interval forms, and ``z'' "
"is any formula involving two variables (not counting variables with assigned "
"values).  These variables are sorted into alphabetical order; the first "
"takes on values from ``x'' and the second takes on values from ``y'' to form "
"a matrix of results that are graphed as a 3D surface."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29286
msgid ""
"@tindex xyz If the ``z'' formula evaluates to a call to the fictitious "
"function @samp{xyz(@var{x}, @var{y}, @var{z})}, then the result is a "
"``parametric surface.'' In this case, the axes of the graph are taken from "
"the @var{x} and @var{y} values in these calls, and the ``x'' and ``y'' "
"values from the input vectors or intervals are used only to specify the "
"range of inputs to the formula.  For example, plotting @samp{[0..360], "
"[0..180], xyz(sin(x)*sin(y), cos(x)*sin(y), cos(y))} will draw a sphere.  "
"(Since the default resolution for 3D plots is 5 steps in each of ``x'' and "
"``y'', this will draw a very crude sphere.  You could use the @kbd{g N} "
"command, described below, to increase this resolution, or specify the ``x'' "
"and ``y'' values as vectors with more than 5 elements."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29292
msgid ""
"It is also possible to have a function in a regular @kbd{g f} plot evaluate "
"to an @code{xyz} call.  Since @kbd{g f} plots a line, not a surface, the "
"result will be a 3D parametric line.  For example, @samp{[[0..720], "
"xyz(sin(x), cos(x), x)]} will plot two turns of a helix (a three-dimensional "
"spiral)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29295
msgid ""
"As for @kbd{g f}, each of ``x'', ``y'', and ``z'' may instead be variables "
"containing the relevant data."
msgstr ""

#. type: node
#: ../../calc.texi:29296 ../../calc.texi:29455 ../../calc.texi:29456 ../../calc.texi:29621
#, no-wrap
msgid "Graphics Options"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29304
msgid ""
"The @kbd{g f} command is really shorthand for the following commands: "
"@kbd{C-u g d g a g p}.  Likewise, @w{@kbd{g F}} is shorthand for @kbd{C-u g "
"d g A g p}.  You can gain more control over your graph by using these "
"commands directly."
msgstr ""

#. type: kindex
#: ../../calc.texi:29305
#, no-wrap
msgid "g a"
msgstr ""

#. type: pindex
#: ../../calc.texi:29306
#, no-wrap
msgid "calc-graph-add"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29312
msgid ""
"The @kbd{g a} (@code{calc-graph-add}) command adds the ``curve'' represented "
"by the two values on the top of the stack to the current graph.  You can "
"have any number of curves in the same graph.  When you give the @kbd{g p} "
"command, all the curves will be drawn superimposed on the same axes."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29326
msgid ""
"The @kbd{g a} command (and many others that affect the current graph)  will "
"cause a special buffer, @file{*Gnuplot Commands*}, to be displayed in "
"another window.  This buffer is a template of the commands that will be sent "
"to GNUPLOT when it is time to draw the graph.  The first @kbd{g a} command "
"adds a @code{plot} command to this buffer.  Succeeding @kbd{g a} commands "
"add extra curves onto that @code{plot} command.  Other graph-related "
"commands put other GNUPLOT commands into this buffer.  In normal usage you "
"never need to work with this buffer directly, but you can if you wish.  The "
"only constraint is that there must be only one @code{plot} command, and it "
"must be the last command in the buffer.  If you want to save and later "
"restore a complete graph configuration, you can use regular Emacs commands "
"to save and restore the contents of the @file{*Gnuplot Commands*} buffer."
msgstr ""

#. type: vindex
#: ../../calc.texi:29327
#, no-wrap
msgid "PlotData1"
msgstr ""

#. type: vindex
#: ../../calc.texi:29328
#, no-wrap
msgid "PlotData2"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29337
msgid ""
"If the values on the stack are not variable names, @kbd{g a} will invent "
"variable names for them (of the form @samp{PlotData@var{n}}) and store the "
"values in those variables.  The ``x'' and ``y'' variables are what go into "
"the @code{plot} command in the template.  If you add a curve that uses a "
"certain variable and then later change that variable, you can replot the "
"graph without having to delete and re-add the curve.  That's because the "
"variable name, not the vector, interval or formula itself, is what was added "
"by @kbd{g a}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29344
msgid ""
"A numeric prefix argument on @kbd{g a} or @kbd{g f} changes the way stack "
"entries are interpreted as curves.  With a positive prefix argument "
"@expr{n}, the top @expr{n} stack entries are ``y'' values for @expr{n} "
"different curves which share a common ``x'' value in the @expr{n+1}st stack "
"entry.  (Thus @kbd{g a} with no prefix argument is equivalent to @kbd{C-u 1 "
"g a}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29348
msgid ""
"A prefix of zero or plain @kbd{C-u} means to take two stack entries, ``x'' "
"and ``y'' as usual, but to interpret ``y'' as a vector of ``y'' values for "
"several curves that share a common ``x''."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29355
msgid ""
"A negative prefix argument tells Calc to read @expr{n} vectors from the "
"stack; each vector @expr{[x, y]} describes an independent curve.  This is "
"the only form of @kbd{g a} that creates several curves at once that don't "
"have common ``x'' values.  (Of course, the range of ``x'' values covered by "
"all the curves ought to be roughly the same if they are to look nice on the "
"same graph.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29365
msgid ""
"For example, to plot @texline @math{\\sin n x} @infoline @expr{sin(n x)} for "
"integers @expr{n} from 1 to 5, you could use @kbd{v x} to create a vector of "
"integers (@expr{n}), then @kbd{V M '} or @kbd{V M $} to map @samp{sin(n x)} "
"across this vector.  The resulting vector of formulas is suitable for use as "
"the ``y'' argument to a @kbd{C-u g a} or @kbd{C-u g f} command."
msgstr ""

#. type: kindex
#: ../../calc.texi:29366
#, no-wrap
msgid "g A"
msgstr ""

#. type: pindex
#: ../../calc.texi:29367
#, no-wrap
msgid "calc-graph-add-3d"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29378
msgid ""
"The @kbd{g A} (@code{calc-graph-add-3d}) command adds a 3D curve to the "
"graph.  It is not valid to intermix 2D and 3D curves in a single graph.  "
"This command takes three arguments, ``x'', ``y'', and ``z'', from the "
"stack.  With a positive prefix @expr{n}, it takes @expr{n+2} arguments "
"(common ``x'' and ``y'', plus @expr{n} separate ``z''s).  With a zero "
"prefix, it takes three stack entries but the ``z'' entry is a vector of "
"curve values.  With a negative prefix @expr{-n}, it takes @expr{n} vectors "
"of the form @expr{[x, y, z]}.  The @kbd{g A} command works by adding a "
"@code{splot} (surface-plot)  command to the @file{*Gnuplot Commands*} "
"buffer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29385
msgid ""
"(Although @kbd{g a} adds a 2D @code{plot} command to the @file{*Gnuplot "
"Commands*} buffer, Calc changes this to @code{splot} before sending it to "
"GNUPLOT if it notices that the data points are evaluating to @code{xyz} "
"calls.  It will not work to mix 2D and 3D @kbd{g a} curves in a single "
"graph, although Calc does not currently check for this.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:29386
#, no-wrap
msgid "g d"
msgstr ""

#. type: pindex
#: ../../calc.texi:29387
#, no-wrap
msgid "calc-graph-delete"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29392
msgid ""
"The @kbd{g d} (@code{calc-graph-delete}) command deletes the most recently "
"added curve from the graph.  It has no effect if there are no curves in the "
"graph.  With a numeric prefix argument of any kind, it deletes all of the "
"curves from the graph."
msgstr ""

#. type: kindex
#: ../../calc.texi:29393
#, no-wrap
msgid "g H"
msgstr ""

#. type: pindex
#: ../../calc.texi:29394
#, no-wrap
msgid "calc-graph-hide"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29399
msgid ""
"The @kbd{g H} (@code{calc-graph-hide}) command ``hides'' or ``unhides'' the "
"most recently added curve.  A hidden curve will not appear in the actual "
"plot, but information about it such as its name and line and point styles "
"will be retained."
msgstr ""

#. type: kindex
#: ../../calc.texi:29400
#, no-wrap
msgid "g j"
msgstr ""

#. type: pindex
#: ../../calc.texi:29401
#, no-wrap
msgid "calc-graph-juggle"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29408
msgid ""
"The @kbd{g j} (@code{calc-graph-juggle}) command moves the curve at the end "
"of the list (the ``most recently added curve'') to the front of the list.  "
"The next-most-recent curve is thus exposed for @w{@kbd{g d}} or similar "
"commands to use.  With @kbd{g j} you can work with any curve in the graph "
"even though curve-related commands only affect the last curve in the list."
msgstr ""

#. type: kindex
#: ../../calc.texi:29409
#, no-wrap
msgid "g p"
msgstr ""

#. type: pindex
#: ../../calc.texi:29410
#, no-wrap
msgid "calc-graph-plot"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29420
msgid ""
"The @kbd{g p} (@code{calc-graph-plot}) command uses GNUPLOT to draw the "
"graph described in the @file{*Gnuplot Commands*} buffer.  Any GNUPLOT "
"parameters which are not defined by commands in this buffer are reset to "
"their default values.  The variables named in the @code{plot} command are "
"written to a temporary data file and the variable names are then replaced by "
"the file name in the template.  The resulting plotting commands are fed to "
"the GNUPLOT program.  See the documentation for the GNUPLOT program for more "
"specific information.  All temporary files are removed when Emacs or GNUPLOT "
"exits."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29428
msgid ""
"If you give a formula for ``y'', Calc will remember all the values that it "
"calculates for the formula so that later plots can reuse these values.  Calc "
"throws out these saved values when you change any circumstances that may "
"affect the data, such as switching from Degrees to Radians mode, or changing "
"the value of a parameter in the formula.  You can force Calc to recompute "
"the data from scratch by giving a negative numeric prefix argument to @kbd{g "
"p}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29436
msgid ""
"Calc uses a fairly rough step size when graphing formulas over intervals.  "
"This is to ensure quick response.  You can ``refine'' a plot by giving a "
"positive numeric prefix argument to @kbd{g p}.  Calc goes through the data "
"points it has computed and saved from previous plots of the function, and "
"computes and inserts a new data point midway between each of the existing "
"points.  You can refine a plot any number of times, but beware that the "
"amount of calculation involved doubles each time."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29440
msgid ""
"Calc does not remember computed values for 3D graphs.  This means the "
"numerix prefix argument, if any, to @kbd{g p} is effectively ignored if the "
"current graph is three-dimensional."
msgstr ""

#. type: kindex
#: ../../calc.texi:29441
#, no-wrap
msgid "g P"
msgstr ""

#. type: pindex
#: ../../calc.texi:29442
#, no-wrap
msgid "calc-graph-print"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29454
msgid ""
"The @kbd{g P} (@code{calc-graph-print}) command is like @kbd{g p}, except "
"that it sends the output to a printer instead of to the screen.  More "
"precisely, @kbd{g p} looks for @samp{set terminal} or @samp{set output} "
"commands in the @file{*Gnuplot Commands*} buffer; lacking these it uses the "
"default settings.  However, @kbd{g P} ignores @samp{set terminal} and "
"@samp{set output} commands and uses a different set of default values.  All "
"of these values are controlled by the @kbd{g D} and @kbd{g O} commands "
"discussed below.  Provided everything is set up properly, @kbd{g p} will "
"plot to the screen unless you have specified otherwise and @kbd{g P} will "
"always plot to the printer."
msgstr ""

#. type: kindex
#: ../../calc.texi:29459
#, no-wrap
msgid "g g"
msgstr ""

#. type: pindex
#: ../../calc.texi:29460
#, no-wrap
msgid "calc-graph-grid"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29467
msgid ""
"The @kbd{g g} (@code{calc-graph-grid}) command turns the ``grid'' on and "
"off.  It is off by default; tick marks appear only at the edges of the "
"graph.  With the grid turned on, dotted lines appear across the graph at "
"each tick mark.  Note that this command only changes the setting in "
"@file{*Gnuplot Commands*}; to see the effects of the change you must give "
"another @kbd{g p} command."
msgstr ""

#. type: kindex
#: ../../calc.texi:29468
#, no-wrap
msgid "g b"
msgstr ""

#. type: pindex
#: ../../calc.texi:29469
#, no-wrap
msgid "calc-graph-border"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29473
msgid ""
"The @kbd{g b} (@code{calc-graph-border}) command turns the border (the box "
"that surrounds the graph) on and off.  It is on by default.  This command "
"will only work with GNUPLOT 3.0 and later versions."
msgstr ""

#. type: kindex
#: ../../calc.texi:29474
#, no-wrap
msgid "g k"
msgstr ""

#. type: pindex
#: ../../calc.texi:29475
#, no-wrap
msgid "calc-graph-key"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29481
msgid ""
"The @kbd{g k} (@code{calc-graph-key}) command turns the ``key'' on and off.  "
"The key is a chart in the corner of the graph that shows the correspondence "
"between curves and line styles.  It is off by default, and is only really "
"useful if you have several curves on the same graph."
msgstr ""

#. type: kindex
#: ../../calc.texi:29482
#, no-wrap
msgid "g N"
msgstr ""

#. type: pindex
#: ../../calc.texi:29483
#, no-wrap
msgid "calc-graph-num-points"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29496
msgid ""
"The @kbd{g N} (@code{calc-graph-num-points}) command allows you to select "
"the number of data points in the graph.  This only affects curves where "
"neither ``x'' nor ``y'' is specified as a vector.  Enter a blank line to "
"revert to the default value (initially 15).  With no prefix argument, this "
"command affects only the current graph.  With a positive prefix argument "
"this command changes or, if you enter a blank line, displays the default "
"number of points used for all graphs created by @kbd{g a} that don't specify "
"the resolution explicitly.  With a negative prefix argument, this command "
"changes or displays the default value (initially 5) used for 3D graphs "
"created by @kbd{g A}.  Note that a 3D setting of 5 means that a total of "
"@expr{5^2 = 25} points will be computed for the surface."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29506
msgid ""
"Data values in the graph of a function are normally computed to a precision "
"of five digits, regardless of the current precision at the time. This is "
"usually more than adequate, but there are cases where it will not be.  For "
"example, plotting @expr{1 + x} with @expr{x} in the interval @samp{[0 ..@: "
"1e-6]} will round all the data points down to 1.0! Putting the command "
"@samp{set precision @var{n}} in the @file{*Gnuplot Commands*} buffer will "
"cause the data to be computed at precision @var{n} instead of 5.  Since this "
"is such a rare case, there is no keystroke-based command to set the "
"precision."
msgstr ""

#. type: kindex
#: ../../calc.texi:29507
#, no-wrap
msgid "g h"
msgstr ""

#. type: pindex
#: ../../calc.texi:29508
#, no-wrap
msgid "calc-graph-header"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29512
msgid ""
"The @kbd{g h} (@code{calc-graph-header}) command sets the title for the "
"graph.  This will show up centered above the graph.  The default title is "
"blank (no title)."
msgstr ""

#. type: kindex
#: ../../calc.texi:29513
#, no-wrap
msgid "g n"
msgstr ""

#. type: pindex
#: ../../calc.texi:29514
#, no-wrap
msgid "calc-graph-name"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29523
msgid ""
"The @kbd{g n} (@code{calc-graph-name}) command sets the title of an "
"individual curve.  Like the other curve-manipulating commands, it affects "
"the most recently added curve, i.e., the last curve on the list in the "
"@file{*Gnuplot Commands*} buffer.  To set the title of the other curves you "
"must first juggle them to the end of the list with @kbd{g j}, or edit the "
"@file{*Gnuplot Commands*} buffer by hand.  Curve titles appear in the key; "
"if the key is turned off they are not used."
msgstr ""

#. type: kindex
#: ../../calc.texi:29524
#, no-wrap
msgid "g t"
msgstr ""

#. type: kindex
#: ../../calc.texi:29525
#, no-wrap
msgid "g T"
msgstr ""

#. type: pindex
#: ../../calc.texi:29526
#, no-wrap
msgid "calc-graph-title-x"
msgstr ""

#. type: pindex
#: ../../calc.texi:29527
#, no-wrap
msgid "calc-graph-title-y"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29535
msgid ""
"The @kbd{g t} (@code{calc-graph-title-x}) and @kbd{g T} "
"(@code{calc-graph-title-y}) commands set the titles on the ``x'' and ``y'' "
"axes, respectively.  These titles appear next to the tick marks on the left "
"and bottom edges of the graph, respectively.  Calc does not have commands to "
"control the tick marks themselves, but you can edit them into the "
"@file{*Gnuplot Commands*} buffer if you wish.  See the GNUPLOT documentation "
"for details."
msgstr ""

#. type: kindex
#: ../../calc.texi:29536
#, no-wrap
msgid "g r"
msgstr ""

#. type: kindex
#: ../../calc.texi:29537
#, no-wrap
msgid "g R"
msgstr ""

#. type: pindex
#: ../../calc.texi:29538
#, no-wrap
msgid "calc-graph-range-x"
msgstr ""

#. type: pindex
#: ../../calc.texi:29539
#, no-wrap
msgid "calc-graph-range-y"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29549
msgid ""
"The @kbd{g r} (@code{calc-graph-range-x}) and @kbd{g R} "
"(@code{calc-graph-range-y}) commands set the range of values on the ``x'' "
"and ``y'' axes, respectively.  You are prompted to enter a suitable range.  "
"This should be either a pair of numbers of the form, "
"@samp{@var{min}:@var{max}}, or a blank line to revert to the default "
"behavior of setting the range based on the range of values in the data, or "
"@samp{$} to take the range from the top of the stack.  Ranges on the stack "
"can be represented as either interval forms or vectors: @samp{[@var{min} "
"..@: @var{max}]} or @samp{[@var{min}, @var{max}]}."
msgstr ""

#. type: kindex
#: ../../calc.texi:29550
#, no-wrap
msgid "g l"
msgstr ""

#. type: kindex
#: ../../calc.texi:29551
#, no-wrap
msgid "g L"
msgstr ""

#. type: pindex
#: ../../calc.texi:29552
#, no-wrap
msgid "calc-graph-log-x"
msgstr ""

#. type: pindex
#: ../../calc.texi:29553
#, no-wrap
msgid "calc-graph-log-y"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29557
msgid ""
"The @kbd{g l} (@code{calc-graph-log-x}) and @kbd{g L} "
"(@code{calc-graph-log-y})  commands allow you to set either or both of the "
"axes of the graph to be logarithmic instead of linear."
msgstr ""

#. type: kindex
#: ../../calc.texi:29558
#, no-wrap
msgid "g C-l"
msgstr ""

#. type: kindex
#: ../../calc.texi:29559
#, no-wrap
msgid "g C-r"
msgstr ""

#. type: kindex
#: ../../calc.texi:29560
#, no-wrap
msgid "g C-t"
msgstr ""

#. type: pindex
#: ../../calc.texi:29561
#, no-wrap
msgid "calc-graph-log-z"
msgstr ""

#. type: pindex
#: ../../calc.texi:29562
#, no-wrap
msgid "calc-graph-range-z"
msgstr ""

#. type: pindex
#: ../../calc.texi:29563
#, no-wrap
msgid "calc-graph-title-z"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29567
msgid ""
"For 3D plots, @kbd{g C-t}, @kbd{g C-r}, and @kbd{g C-l} (those are letters "
"with the Control key held down) are the corresponding commands for the ``z'' "
"axis."
msgstr ""

#. type: kindex
#: ../../calc.texi:29568
#, no-wrap
msgid "g z"
msgstr ""

#. type: kindex
#: ../../calc.texi:29569
#, no-wrap
msgid "g Z"
msgstr ""

#. type: pindex
#: ../../calc.texi:29570
#, no-wrap
msgid "calc-graph-zero-x"
msgstr ""

#. type: pindex
#: ../../calc.texi:29571
#, no-wrap
msgid "calc-graph-zero-y"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29579
msgid ""
"The @kbd{g z} (@code{calc-graph-zero-x}) and @kbd{g Z} "
"(@code{calc-graph-zero-y}) commands control whether a dotted line is drawn "
"to indicate the ``x'' and/or ``y'' zero axes.  (These are the same dotted "
"lines that would be drawn there anyway if you used @kbd{g g} to turn the "
"``grid'' feature on.)  Zero-axis lines are on by default, and may be turned "
"off only in GNUPLOT 3.0 and later versions.  They are not available for 3D "
"plots."
msgstr ""

#. type: kindex
#: ../../calc.texi:29580
#, no-wrap
msgid "g s"
msgstr ""

#. type: pindex
#: ../../calc.texi:29581
#, no-wrap
msgid "calc-graph-line-style"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29590
msgid ""
"The @kbd{g s} (@code{calc-graph-line-style}) command turns the connecting "
"lines on or off for the most recently added curve, and optionally selects "
"the style of lines to be used for that curve.  Plain @kbd{g s} simply "
"toggles the lines on and off.  With a numeric prefix argument, @kbd{g s} "
"turns lines on and sets a particular line style.  Line style numbers start "
"at one and their meanings vary depending on the output device.  GNUPLOT "
"guarantees that there will be at least six different line styles available "
"for any device."
msgstr ""

#. type: kindex
#: ../../calc.texi:29591
#, no-wrap
msgid "g S"
msgstr ""

#. type: pindex
#: ../../calc.texi:29592
#, no-wrap
msgid "calc-graph-point-style"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29599
msgid ""
"The @kbd{g S} (@code{calc-graph-point-style}) command similarly turns the "
"symbols at the data points on or off, or sets the point style.  If you turn "
"both lines and points off, the data points will show as tiny dots.  If the "
"``y'' values being plotted contain error forms and the connecting lines are "
"turned off, then this command will also turn the error bars on or off."
msgstr ""

#. type: cindex
#: ../../calc.texi:29600
#, no-wrap
msgid "@code{LineStyles} variable"
msgstr ""

#. type: cindex
#: ../../calc.texi:29601
#, no-wrap
msgid "@code{PointStyles} variable"
msgstr ""

#. type: vindex
#: ../../calc.texi:29602
#, no-wrap
msgid "LineStyles"
msgstr ""

#. type: vindex
#: ../../calc.texi:29603
#, no-wrap
msgid "PointStyles"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29614
msgid ""
"Another way to specify curve styles is with the @code{LineStyles} and "
"@code{PointStyles} variables.  These variables initially have no stored "
"values, but if you store a vector of integers in one of these variables, the "
"@kbd{g a} and @kbd{g f} commands will use those style numbers instead of the "
"defaults for new curves that are added to the graph.  An entry should be a "
"positive integer for a specific style, or 0 to let the style be chosen "
"automatically, or @mathit{-1} to turn off lines or points altogether.  If "
"there are more curves than elements in the vector, the last few curves will "
"continue to have the default styles.  Of course, you can later use @kbd{g s} "
"and @kbd{g S} to change any of these styles."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29620
msgid ""
"For example, @kbd{'[2 -1 3] @key{RET} s t LineStyles} causes the first curve "
"to have lines in style number 2, the second curve to have no connecting "
"lines, and the third curve to have lines in style 3.  Point styles will "
"still be assigned automatically, but you could store another vector in "
"@code{PointStyles} to define them, too."
msgstr ""

#. type: section
#: ../../calc.texi:29622
#, no-wrap
msgid "Graphical Devices"
msgstr ""

#. type: kindex
#: ../../calc.texi:29625
#, no-wrap
msgid "g D"
msgstr ""

#. type: pindex
#: ../../calc.texi:29626
#, no-wrap
msgid "calc-graph-device"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29632
msgid ""
"The @kbd{g D} (@code{calc-graph-device}) command sets the device name (or "
"``terminal name'' in GNUPLOT lingo) to be used by @kbd{g p} commands on this "
"graph.  It does not affect the permanent default device name.  If you enter "
"a blank name, the device name reverts to the default.  Enter @samp{?} to see "
"a list of supported devices."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29643
msgid ""
"With a positive numeric prefix argument, @kbd{g D} instead sets the default "
"device name, used by all plots in the future which do not override it with a "
"plain @kbd{g D} command.  If you enter a blank line this command shows you "
"the current default.  The special name @code{default} signifies that Calc "
"should choose @code{x11} if the X window system is in use (as indicated by "
"the presence of a @code{DISPLAY} environment variable), @code{windows} on "
"MS-Windows, or otherwise @code{dumb} under GNUPLOT 3.0 and later, or "
"@code{postscript} under GNUPLOT 2.0.  This is the initial default value."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29656
msgid ""
"The @code{dumb} device is an interface to ``dumb terminals,'' i.e., "
"terminals with no special graphics facilities.  It writes a crude picture of "
"the graph composed of characters like @code{-} and @code{|} to a buffer "
"called @file{*Gnuplot Trail*}, which Calc then displays.  The graph is made "
"the same size as the Emacs screen, which on most dumb terminals will be "
"@texline @math{80\\times24} @infoline 80x24 characters.  The graph is "
"displayed in an Emacs ``recursive edit''; type @kbd{q} or @kbd{C-c C-c} to "
"exit the recursive edit and return to Calc.  Note that the @code{dumb} "
"device is present only in GNUPLOT 3.0 and later versions."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29665
msgid ""
"The word @code{dumb} may be followed by two numbers separated by spaces.  "
"These are the desired width and height of the graph in characters.  Also, "
"the device name @code{big} is like @code{dumb} but creates a graph four "
"times the width and height of the Emacs screen.  You will then have to "
"scroll around to view the entire graph.  In the @file{*Gnuplot Trail*} "
"buffer, @key{SPC}, @key{DEL}, @kbd{<}, and @kbd{>} are defined to scroll by "
"one screenful in each of the four directions."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29671
msgid ""
"With a negative numeric prefix argument, @kbd{g D} sets or displays the "
"device name used by @kbd{g P} (@code{calc-graph-print}).  This is initially "
"@code{postscript}.  If you don't have a PostScript printer, you may decide "
"once again to use @code{dumb} to create a plot on any text-only printer."
msgstr ""

#. type: kindex
#: ../../calc.texi:29672
#, no-wrap
msgid "g O"
msgstr ""

#. type: pindex
#: ../../calc.texi:29673
#, no-wrap
msgid "calc-graph-output"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29682
msgid ""
"The @kbd{g O} (@code{calc-graph-output}) command sets the name of the output "
"file used by GNUPLOT@.  For some devices, notably @code{x11} and "
"@code{windows}, there is no output file and this information is not used.  "
"Many other ``devices'' are really file formats like @code{postscript}; in "
"these cases the output in the desired format goes into the file you name "
"with @kbd{g O}.  Type @kbd{g O stdout @key{RET}} to set GNUPLOT to write to "
"its standard output stream, i.e., to @file{*Gnuplot Trail*}.  This is the "
"default setting."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29692
msgid ""
"Another special output name is @code{tty}, which means that GNUPLOT is going "
"to write graphics commands directly to its standard output, which you wish "
"Emacs to pass through to your terminal.  Tektronix graphics terminals, among "
"other devices, operate this way.  Calc does this by telling GNUPLOT to write "
"to a temporary file, then running a sub-shell executing the command "
"@samp{cat tempfile >/dev/tty}.  On typical Unix systems, this will copy the "
"temporary file directly to the terminal, bypassing Emacs entirely.  You will "
"have to type @kbd{C-l} to Emacs afterwards to refresh the screen."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29699
msgid ""
"Once again, @kbd{g O} with a positive or negative prefix argument sets the "
"default or printer output file names, respectively.  In each case you can "
"specify @code{auto}, which causes Calc to invent a temporary file name for "
"each @kbd{g p} (or @kbd{g P}) command.  This temporary file will be deleted "
"once it has been displayed or printed.  If the output file name is not "
"@code{auto}, the file is not automatically deleted."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29706
msgid ""
"The default and printer devices and output files can be saved permanently by "
"the @kbd{m m} (@code{calc-save-modes}) command.  The default number of data "
"points (see @kbd{g N}) and the X geometry (see @kbd{g X}) are also saved.  "
"Other graph information is @emph{not} saved; you can save a graph's "
"configuration simply by saving the contents of the @file{*Gnuplot Commands*} "
"buffer."
msgstr ""

#. type: defvar
#: ../../calc.texi:29707 ../../calc.texi:35390
#, no-wrap
msgid "calc-gnuplot-plot-command"
msgstr ""

#. type: vindex
#: ../../calc.texi:29708
#, no-wrap
msgid "calc-gnuplot-default-device"
msgstr ""

#. type: vindex
#: ../../calc.texi:29709
#, no-wrap
msgid "calc-gnuplot-default-output"
msgstr ""

#. type: defvarx
#: ../../calc.texi:29710 ../../calc.texi:35391
#, no-wrap
msgid "calc-gnuplot-print-command"
msgstr ""

#. type: vindex
#: ../../calc.texi:29711
#, no-wrap
msgid "calc-gnuplot-print-device"
msgstr ""

#. type: vindex
#: ../../calc.texi:29712
#, no-wrap
msgid "calc-gnuplot-print-output"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29719
msgid ""
"You may wish to configure the default and printer devices and output files "
"for the whole system.  The relevant Lisp variables are "
"@code{calc-gnuplot-default-device} and @code{-output}, and "
"@code{calc-gnuplot-print-device} and @code{-output}.  The output file names "
"must be either strings as described above, or Lisp expressions which are "
"evaluated on the fly to get the output file names."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29728
msgid ""
"Other important Lisp variables are @code{calc-gnuplot-plot-command} and "
"@code{calc-gnuplot-print-command}, which give the system commands to display "
"or print the output of GNUPLOT, respectively.  These may be @code{nil} if no "
"command is necessary, or strings which can include @samp{%s} to signify the "
"name of the file to be displayed or printed.  Or, these variables may "
"contain Lisp expressions which are evaluated to display or print the "
"output.  These variables are customizable (@pxref{Customizing Calc})."
msgstr ""

#. type: kindex
#: ../../calc.texi:29729
#, no-wrap
msgid "g x"
msgstr ""

#. type: pindex
#: ../../calc.texi:29730
#, no-wrap
msgid "calc-graph-display"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29735
msgid ""
"The @kbd{g x} (@code{calc-graph-display}) command lets you specify on which "
"X window system display your graphs should be drawn.  Enter a blank line to "
"see the current display name.  This command has no effect unless the current "
"device is @code{x11}."
msgstr ""

#. type: kindex
#: ../../calc.texi:29736
#, no-wrap
msgid "g X"
msgstr ""

#. type: pindex
#: ../../calc.texi:29737
#, no-wrap
msgid "calc-graph-geometry"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29745
msgid ""
"The @kbd{g X} (@code{calc-graph-geometry}) command is a similar command for "
"specifying the position and size of the X window.  The normal value is "
"@code{default}, which generally means your window manager will let you place "
"the window interactively.  Entering @samp{800x500+0+0} would create an "
"800-by-500 pixel window in the upper-left corner of the screen.  This "
"command has no effect if the current device is @code{windows}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29758
msgid ""
"The buffer called @file{*Gnuplot Trail*} holds a transcript of the session "
"with GNUPLOT@.  This shows the commands Calc has ``typed'' to GNUPLOT and "
"the responses it has received.  Calc tries to notice when an error message "
"has appeared here and display the buffer for you when this happens.  You can "
"check this buffer yourself if you suspect something has gone wrong@footnote{ "
"On MS-Windows, due to the peculiarities of how the Windows version of "
"GNUPLOT (called @command{wgnuplot}) works, the GNUPLOT responses are not "
"communicated back to Calc.  Instead, you need to look them up in the GNUPLOT "
"command window that is displayed as in normal interactive usage of GNUPLOT.  "
"}."
msgstr ""

#. type: kindex
#: ../../calc.texi:29759
#, no-wrap
msgid "g C"
msgstr ""

#. type: pindex
#: ../../calc.texi:29760
#, no-wrap
msgid "calc-graph-command"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29766
msgid ""
"The @kbd{g C} (@code{calc-graph-command}) command prompts you to enter any "
"line of text, then simply sends that line to the current GNUPLOT process.  "
"The @file{*Gnuplot Trail*} buffer looks deceptively like a Shell buffer but "
"you can't type commands in it yourself.  Instead, you must use @kbd{g C} for "
"this purpose."
msgstr ""

#. type: kindex
#: ../../calc.texi:29767
#, no-wrap
msgid "g v"
msgstr ""

#. type: kindex
#: ../../calc.texi:29768
#, no-wrap
msgid "g V"
msgstr ""

#. type: pindex
#: ../../calc.texi:29769
#, no-wrap
msgid "calc-graph-view-commands"
msgstr ""

#. type: pindex
#: ../../calc.texi:29770
#, no-wrap
msgid "calc-graph-view-trail"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29780
msgid ""
"The @kbd{g v} (@code{calc-graph-view-commands}) and @kbd{g V} "
"(@code{calc-graph-view-trail}) commands display the @file{*Gnuplot "
"Commands*} and @file{*Gnuplot Trail*} buffers, respectively, in another "
"window.  This happens automatically when Calc thinks there is something you "
"will want to see in either of these buffers.  If you type @kbd{g v} or "
"@kbd{g V} when the relevant buffer is already displayed, the buffer is "
"hidden again.  (Note that on MS-Windows, the @file{*Gnuplot Trail*} buffer "
"will usually show nothing of interest, because GNUPLOT's responses are not "
"communicated back to Calc.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29797
msgid ""
"One reason to use @kbd{g v} is to add your own commands to the "
"@file{*Gnuplot Commands*} buffer.  Press @kbd{g v}, then use @kbd{C-x o} to "
"switch into that window.  For example, GNUPLOT has @samp{set label} and "
"@samp{set arrow} commands that allow you to annotate your plots.  Since Calc "
"doesn't understand these commands, you have to add them to the "
"@file{*Gnuplot Commands*} buffer yourself, then use @w{@kbd{g p}} to replot "
"using these new commands.  Note that your commands must appear @emph{before} "
"the @code{plot} command.  To get help on any GNUPLOT feature, type, e.g., "
"@kbd{g C help set label}.  You may have to type @kbd{g C @key{RET}} a few "
"times to clear the ``press return for more'' or ``subtopic of @dots{}'' "
"requests.  Note that Calc always sends commands (like @samp{set nolabel}) to "
"reset all plotting parameters to the defaults before each plot, so to delete "
"a label all you need to do is delete the @samp{set label} line you added (or "
"comment it out with @samp{#}) and then replot with @kbd{g p}."
msgstr ""

#. type: kindex
#: ../../calc.texi:29798
#, no-wrap
msgid "g q"
msgstr ""

#. type: pindex
#: ../../calc.texi:29799
#, no-wrap
msgid "calc-graph-quit"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29806
msgid ""
"You can use @kbd{g q} (@code{calc-graph-quit}) to kill the GNUPLOT process "
"that is running.  The next graphing command you give will start a fresh "
"GNUPLOT process.  The word @samp{Graph} appears in the Calc window's mode "
"line whenever a GNUPLOT process is currently running.  The GNUPLOT process "
"is automatically killed when you exit Emacs if you haven't killed it "
"manually by then."
msgstr ""

#. type: kindex
#: ../../calc.texi:29807
#, no-wrap
msgid "g K"
msgstr ""

#. type: pindex
#: ../../calc.texi:29808
#, no-wrap
msgid "calc-graph-kill"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29813
msgid ""
"The @kbd{g K} (@code{calc-graph-kill}) command is like @kbd{g q} except that "
"it also views the @file{*Gnuplot Trail*} buffer so that you can see the "
"process being killed.  This is better if you are killing GNUPLOT because you "
"think it has gotten stuck."
msgstr ""

#. type: chapter
#: ../../calc.texi:29815
#, no-wrap
msgid "Kill and Yank Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29820
msgid ""
"The commands in this chapter move information between the Calculator and "
"other Emacs editing buffers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29823
msgid ""
"In many cases Embedded mode is an easier and more natural way to work with "
"Calc from a regular editing buffer.  @xref{Embedded Mode}."
msgstr ""

#. type: menuentry
#: ../../calc.texi:29832
msgid "Killing From Stack::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:29832
msgid "Yanking Into Stack::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:29832
msgid "Saving Into Registers::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:29832
msgid "Inserting From Registers::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:29832
msgid "Grabbing From Buffers::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:29832
msgid "Yanking Into Buffers::"
msgstr ""

#. type: section
#: ../../calc.texi:29832 ../../calc.texi:30073 ../../calc.texi:30127 ../../calc.texi:30128
#, no-wrap
msgid "X Cut and Paste"
msgstr ""

#. type: node
#: ../../calc.texi:29834 ../../calc.texi:29878
#, no-wrap
msgid "Killing From Stack"
msgstr ""

#. type: node
#: ../../calc.texi:29834 ../../calc.texi:29878 ../../calc.texi:29910
#, no-wrap
msgid "Yanking Into Stack"
msgstr ""

#. type: section
#: ../../calc.texi:29835
#, no-wrap
msgid "Killing from the Stack"
msgstr ""

#. type: kindex
#: ../../calc.texi:29838
#, no-wrap
msgid "C-k"
msgstr ""

#. type: pindex
#: ../../calc.texi:29839
#, no-wrap
msgid "calc-kill"
msgstr ""

#. type: kindex
#: ../../calc.texi:29840
#, no-wrap
msgid "M-k"
msgstr ""

#. type: pindex
#: ../../calc.texi:29841
#, no-wrap
msgid "calc-copy-as-kill"
msgstr ""

#. type: kindex
#: ../../calc.texi:29842
#, no-wrap
msgid "C-w"
msgstr ""

#. type: pindex
#: ../../calc.texi:29843
#, no-wrap
msgid "calc-kill-region"
msgstr ""

#. type: kindex
#: ../../calc.texi:29844
#, no-wrap
msgid "M-w"
msgstr ""

#. type: pindex
#: ../../calc.texi:29845
#, no-wrap
msgid "calc-copy-region-as-kill"
msgstr ""

#. type: kindex
#: ../../calc.texi:29846
#, no-wrap
msgid "M-C-w"
msgstr ""

#. type: cindex
#: ../../calc.texi:29847
#, no-wrap
msgid "Kill ring"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29861
msgid ""
"@dfn{Kill} commands are Emacs commands that insert text into the ``kill "
"ring,'' from which it can later be ``yanked'' by a @kbd{C-y} command.  Three "
"common kill commands in normal Emacs are @kbd{C-k}, which kills one line, "
"@kbd{C-w}, which kills the region between mark and point, and @kbd{M-w}, "
"which puts the region into the kill ring without actually deleting it.  All "
"of these commands work in the Calculator, too, although in the Calculator "
"they operate on whole stack entries, so they ``round up'' the specified "
"region to encompass full lines.  (To copy only parts of lines, the "
"@kbd{M-C-w} command in the Calculator will copy the region to the kill ring "
"without any ``rounding up'', just like the @kbd{M-w} command in normal "
"Emacs.)  Also, @kbd{M-k} has been provided to complete the set; it puts the "
"current line into the kill ring without deleting anything."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29868
msgid ""
"The kill commands are unusual in that they pay attention to the location of "
"the cursor in the Calculator buffer.  If the cursor is on or below the "
"bottom line, the kill commands operate on the top of the stack.  Otherwise, "
"they operate on whatever stack element the cursor is on.  The text is copied "
"into the kill ring exactly as it appears on the screen, including line "
"numbers if they are enabled."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29877
msgid ""
"A numeric prefix argument to @kbd{C-k} or @kbd{M-k} affects the number of "
"lines killed.  A positive argument kills the current line and @expr{n-1} "
"lines below it.  A negative argument kills the @expr{-n} lines above the "
"current line.  Again this mirrors the behavior of the standard Emacs "
"@kbd{C-k} command.  Although a whole line is always deleted, @kbd{C-k} with "
"no argument copies only the number itself into the kill ring, whereas "
"@kbd{C-k} with a prefix argument of 1 copies the number with its trailing "
"newline."
msgstr ""

#. type: node
#: ../../calc.texi:29878 ../../calc.texi:29910 ../../calc.texi:29944
#, no-wrap
msgid "Saving Into Registers"
msgstr ""

#. type: section
#: ../../calc.texi:29879
#, no-wrap
msgid "Yanking into the Stack"
msgstr ""

#. type: kindex
#: ../../calc.texi:29882
#, no-wrap
msgid "C-y"
msgstr ""

#. type: pindex
#: ../../calc.texi:29883
#, no-wrap
msgid "calc-yank"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29896
msgid ""
"The @kbd{C-y} command yanks the most recently killed text back into the "
"Calculator.  It pushes this value onto the top of the stack regardless of "
"the cursor position.  In general it re-parses the killed text as a number or "
"formula (or a list of these separated by commas or newlines).  However if "
"the thing being yanked is something that was just killed from the Calculator "
"itself, its full internal structure is yanked.  For example, if you have set "
"the floating-point display mode to show only four significant digits, then "
"killing and re-yanking 3.14159 (which displays as 3.142) will yank the full "
"3.14159, even though yanking it into any other buffer would yank the number "
"in its displayed form, 3.142.  (Since the default display modes show all "
"objects to their full precision, this feature normally makes no difference.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29909
msgid ""
"The @kbd{C-y} command can be given a prefix, which will interpret the text "
"being yanked with a different radix.  If the text being yanked can be "
"interpreted as a binary, octal, hexadecimal, or decimal number, then a "
"prefix of @kbd{2}, @kbd{8}, @kbd{6} or @kbd{0} will have Calc interpret the "
"yanked text as a number in the appropriate base.  For example, if @samp{111} "
"has just been killed and is yanked into Calc with a command of @kbd{C-2 "
"C-y}, then the number @samp{7} will be put on the stack.  If you use the "
"plain prefix @kbd{C-u}, then you will be prompted for a base to use, which "
"can be any integer from 2 to 36.  If Calc doesn't allow the text being "
"yanked to be read in a different base (such as if the text is an algebraic "
"expression), then the prefix will have no effect."
msgstr ""

#. type: node
#: ../../calc.texi:29910 ../../calc.texi:29944 ../../calc.texi:29956
#, no-wrap
msgid "Inserting From Registers"
msgstr ""

#. type: section
#: ../../calc.texi:29911
#, no-wrap
msgid "Saving into Registers"
msgstr ""

#. type: kindex
#: ../../calc.texi:29914
#, no-wrap
msgid "r s"
msgstr ""

#. type: pindex
#: ../../calc.texi:29915
#, no-wrap
msgid "calc-copy-to-register"
msgstr ""

#. type: pindex
#: ../../calc.texi:29916
#, no-wrap
msgid "calc-prepend-to-register"
msgstr ""

#. type: pindex
#: ../../calc.texi:29917
#, no-wrap
msgid "calc-append-to-register"
msgstr ""

#. type: cindex
#: ../../calc.texi:29918
#, no-wrap
msgid "Registers"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29924
msgid ""
"An alternative to killing and yanking stack entries is using registers in "
"Calc.  Saving stack entries in registers is like saving text in normal Emacs "
"registers; although, like Calc's kill commands, register commands always "
"operate on whole stack entries."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29934
msgid ""
"Registers in Calc are places to store stack entries for later use; each "
"register is indexed by a single character.  To store the current region "
"(rounded up, of course, to include full stack entries) into a register, use "
"the command @kbd{r s} (@code{calc-copy-to-register}).  You will then be "
"prompted for a register to use, the next character you type will be the "
"index for the register.  To store the region in register @var{r}, the full "
"command will be @kbd{r s @var{r}}.  With an argument, @kbd{C-u r s @var{r}}, "
"the region being copied to the register will be deleted from the Calc "
"buffer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29943
msgid ""
"It is possible to add additional stack entries to a register.  The command "
"@kbd{M-x calc-append-to-register} will prompt for a register, then add the "
"stack entries in the region to the end of the register contents. The command "
"@kbd{M-x calc-prepend-to-register} will similarly prompt for a register and "
"add the stack entries in the region to the beginning of the register "
"contents.  Both commands take @kbd{C-u} arguments, which will cause the "
"region to be deleted after being added to the register."
msgstr ""

#. type: node
#: ../../calc.texi:29944 ../../calc.texi:29956 ../../calc.texi:30073
#, no-wrap
msgid "Grabbing From Buffers"
msgstr ""

#. type: section
#: ../../calc.texi:29945
#, no-wrap
msgid "Inserting from Registers"
msgstr ""

#. type: kindex
#: ../../calc.texi:29947
#, no-wrap
msgid "r i"
msgstr ""

#. type: pindex
#: ../../calc.texi:29948
#, no-wrap
msgid "calc-insert-register"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29955
msgid ""
"The command @kbd{r i} (@code{calc-insert-register}) will prompt for a "
"register, then insert the contents of that register into the Calculator.  If "
"the contents of the register were placed there from within Calc, then the "
"full internal structure of the contents will be inserted into the "
"Calculator, otherwise whatever text is in the register is reparsed and then "
"inserted into the Calculator."
msgstr ""

#. type: node
#: ../../calc.texi:29956 ../../calc.texi:30073 ../../calc.texi:30127
#, no-wrap
msgid "Yanking Into Buffers"
msgstr ""

#. type: section
#: ../../calc.texi:29957
#, no-wrap
msgid "Grabbing from Other Buffers"
msgstr ""

#. type: kindex
#: ../../calc.texi:29960
#, no-wrap
msgid "C-x * g"
msgstr ""

#. type: pindex
#: ../../calc.texi:29961
#, no-wrap
msgid "calc-grab-region"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29970
msgid ""
"The @kbd{C-x * g} (@code{calc-grab-region}) command takes the text between "
"point and mark in the current buffer and attempts to parse it as a vector of "
"values.  Basically, it wraps the text in vector brackets @samp{[ ]} unless "
"the text already is enclosed in vector brackets, then reads the text as if "
"it were an algebraic entry.  The contents of the vector may be numbers, "
"formulas, or any other Calc objects.  If the @kbd{C-x * g} command works "
"successfully, it does an automatic @kbd{C-x * c} to enter the Calculator "
"buffer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29978
msgid ""
"A numeric prefix argument grabs the specified number of lines around point, "
"ignoring the mark.  A positive prefix grabs from point to the @expr{n}th "
"following newline (so that @kbd{M-1 C-x * g} grabs from point to the end of "
"the current line); a negative prefix grabs from point back to the "
"@expr{n+1}st preceding newline.  In these cases the text that is grabbed is "
"exactly the same as the text that @kbd{C-k} would delete given that prefix "
"argument."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29981
msgid "A prefix of zero grabs the current line; point may be anywhere on the line."
msgstr ""

#. type: Plain text
#: ../../calc.texi:29990
msgid ""
"A plain @kbd{C-u} prefix interprets the region between point and mark as a "
"single number or formula rather than a vector.  For example, @kbd{C-x * g} "
"on the text @samp{2 a b} produces the vector of three values @samp{[2, a, "
"b]}, but @kbd{C-u C-x * g} on the same region reads a formula which is a "
"product of three things: @samp{2 a b}.  (The text @samp{a + b}, on the other "
"hand, will be grabbed as a vector of one element by plain @kbd{C-x * g} "
"because the interpretation @samp{[a, +, b]} would be a syntax error.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:29993
msgid ""
"If a different language has been specified (@pxref{Language Modes}), the "
"grabbed text will be interpreted according to that language."
msgstr ""

#. type: kindex
#: ../../calc.texi:29994
#, no-wrap
msgid "C-x * r"
msgstr ""

#. type: pindex
#: ../../calc.texi:29995
#, no-wrap
msgid "calc-grab-rectangle"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30001
msgid ""
"The @kbd{C-x * r} (@code{calc-grab-rectangle}) command takes the text "
"between point and mark and attempts to parse it as a matrix.  If point and "
"mark are both in the leftmost column, the lines in between are parsed in "
"their entirety.  Otherwise, point and mark define the corners of a rectangle "
"whose contents are parsed."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30005
msgid ""
"Each line of the grabbed area becomes a row of the matrix.  The result will "
"actually be a vector of vectors, which Calc will treat as a matrix only if "
"every row contains the same number of values."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30010
msgid ""
"If a line contains a portion surrounded by square brackets (or curly "
"braces), that portion is interpreted as a vector which becomes a row of the "
"matrix.  Any text surrounding the bracketed portion on the line is ignored."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30017
msgid ""
"Otherwise, the entire line is interpreted as a row vector as if it were "
"surrounded by square brackets.  Leading line numbers (in the format used in "
"the Calc stack buffer) are ignored.  If you wish to force this "
"interpretation (even if the line contains bracketed portions), give a "
"negative numeric prefix argument to the @kbd{C-x * r} command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30026
msgid ""
"If you give a numeric prefix argument of zero or plain @kbd{C-u}, each line "
"is instead interpreted as a single formula which is converted into a "
"one-element vector.  Thus the result of @kbd{C-u C-x * r} will be a "
"one-column matrix.  For example, suppose one line of the data is the "
"expression @samp{2 a}.  A plain @w{@kbd{C-x * r}} will interpret this as "
"@samp{[2 a]}, which in turn is read as a two-element vector that forms one "
"row of the matrix.  But a @kbd{C-u C-x * r} will interpret this row as "
"@samp{[2*a]}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30032
msgid ""
"If you give a positive numeric prefix argument @var{n}, then each line will "
"be split up into columns of width @var{n}; each column is parsed separately "
"as a matrix element.  If a line contained @w{@samp{2 +/- 3 4 +/- 5}}, then "
"grabbing with a prefix argument of 8 would correctly split the line into two "
"error forms."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30038
msgid ""
"@xref{Matrix Functions}, to see how to pull the matrix apart into its "
"constituent rows and columns.  (If it is a @texline @math{1\\times1} "
"@infoline 1x1 matrix, just hit @kbd{v u} (@code{calc-unpack}) twice.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:30039
#, no-wrap
msgid "C-x * :"
msgstr ""

#. type: kindex
#: ../../calc.texi:30040
#, no-wrap
msgid "C-x * _"
msgstr ""

#. type: pindex
#: ../../calc.texi:30041
#, no-wrap
msgid "calc-grab-sum-across"
msgstr ""

#. type: pindex
#: ../../calc.texi:30042
#, no-wrap
msgid "calc-grab-sum-down"
msgstr ""

#. type: cindex
#: ../../calc.texi:30043
#, no-wrap
msgid "Summing rows and columns of data"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30051
msgid ""
"The @kbd{C-x * :} (@code{calc-grab-sum-down}) command is a handy way to grab "
"a rectangle of data and sum its columns.  It is equivalent to typing "
"@kbd{C-x * r}, followed by @kbd{V R : +} (the vector reduction command that "
"sums the columns of a matrix; @pxref{Reducing}).  The result of the command "
"will be a vector of numbers, one for each column in the input data.  The "
"@kbd{C-x * _} (@code{calc-grab-sum-across}) command similarly grabs a "
"rectangle and sums its rows by executing @w{@kbd{V R _ +}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30057
msgid ""
"As well as being more convenient, @kbd{C-x * :} and @kbd{C-x * _} are also "
"much faster because they don't actually place the grabbed vector on the "
"stack.  In a @kbd{C-x * r V R : +} sequence, formatting the vector for "
"display on the stack takes a large fraction of the total time (unless you "
"have planned ahead and used @kbd{v .} and @kbd{t .} modes)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30064
msgid ""
"For example, suppose we have a column of numbers in a file which we wish to "
"sum.  Go to one corner of the column and press @kbd{C-@@} to set the mark; "
"go to the other corner and type @kbd{C-x * :}.  Since there is only one "
"column, the result will be a vector of one number, the sum.  (You can type "
"@kbd{v u} to unpack this vector into a plain number if you want to do "
"further arithmetic with it.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30072
msgid ""
"To compute the product of the column of numbers, we would have to do it ``by "
"hand'' since there's no special grab-and-multiply command.  Use @kbd{C-x * "
"r} to grab the column of numbers into the calculator in the form of a column "
"matrix.  The statistics command @kbd{u *} is a handy way to find the product "
"of a vector or matrix of numbers.  @xref{Statistical Operations}.  Another "
"approach would be to use an explicit column reduction command, @kbd{V R : "
"*}."
msgstr ""

#. type: section
#: ../../calc.texi:30074
#, no-wrap
msgid "Yanking into Other Buffers"
msgstr ""

#. type: kindex
#: ../../calc.texi:30077
#, no-wrap
msgid "y"
msgstr ""

#. type: pindex
#: ../../calc.texi:30078
#, no-wrap
msgid "calc-copy-to-buffer"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30087
msgid ""
"The plain @kbd{y} (@code{calc-copy-to-buffer}) command inserts the number at "
"the top of the stack into the most recently used normal editing buffer.  "
"(More specifically, this is the most recently used buffer which is displayed "
"in a window and whose name does not begin with @samp{*}.  If there is no "
"such buffer, this is the most recently used buffer except for Calculator and "
"Calc Trail buffers.)  The number is inserted exactly as it appears and "
"without a newline.  (If line-numbering is enabled, the line number is "
"normally not included.)  The number is @emph{not} removed from the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30095
msgid ""
"With a prefix argument, @kbd{y} inserts several numbers, one per line.  A "
"positive argument inserts the specified number of values from the top of the "
"stack.  A negative argument inserts the @expr{n}th value from the top of the "
"stack.  An argument of zero inserts the entire stack.  Note that @kbd{y} "
"with an argument of 1 is slightly different from @kbd{y} with no argument; "
"the former always copies full lines, whereas the latter strips off the "
"trailing newline."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30106
msgid ""
"With a lone @kbd{C-u} as a prefix argument, @kbd{y} @emph{replaces} the "
"region in the other buffer with the yanked text, then quits the Calculator, "
"leaving you in that buffer.  A typical use would be to use @kbd{C-x * g} to "
"read a region of data into the Calculator, operate on the data to produce a "
"new matrix, then type @kbd{C-u y} to replace the original data with the new "
"data.  One might wish to alter the matrix display style (@pxref{Vector and "
"Matrix Formats}) or change the current display language (@pxref{Language "
"Modes}) before doing this.  Also, note that this command replaces a linear "
"region of text (as grabbed by @kbd{C-x * g}), not a rectangle (as grabbed by "
"@kbd{C-x * r})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30121
msgid ""
"If the editing buffer is in overwrite (as opposed to insert) mode, and the "
"@kbd{C-u} prefix was not used, then the yanked number will overwrite the "
"characters following point rather than being inserted before those "
"characters.  The usual conventions of overwrite mode are observed; for "
"example, characters will be inserted at the end of a line rather than "
"overflowing onto the next line.  Yanking a multi-line object such as a "
"matrix in overwrite mode overwrites the next @var{n} lines in the buffer, "
"lengthening or shortening each line as necessary.  Finally, if the thing "
"being yanked is a simple integer or floating-point number (like "
"@samp{-1.2345e-3}) and the characters following point also make up such a "
"number, then Calc will replace that number with the new number, lengthening "
"or shortening as necessary.  The concept of ``overwrite mode'' has thus been "
"generalized from overwriting characters to overwriting one complete number "
"with another."
msgstr ""

#. type: kindex
#: ../../calc.texi:30122
#, no-wrap
msgid "C-x * y"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30126
msgid ""
"The @kbd{C-x * y} key sequence is equivalent to @kbd{y} except that it can "
"be typed anywhere, not just in Calc.  This provides an easy way to guarantee "
"that Calc knows which editing buffer you want to use!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30134
msgid ""
"If you are using Emacs with the X window system, there is an easier way to "
"move small amounts of data into and out of the calculator: Use the "
"mouse-oriented cut and paste facilities of X."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30146
msgid ""
"The default bindings for a three-button mouse cause the left button to move "
"the Emacs cursor to the given place, the right button to select the text "
"between the cursor and the clicked location, and the middle button to yank "
"the selection into the buffer at the clicked location.  So, if you have a "
"Calc window and an editing window on your Emacs screen, you can use "
"left-click/right-click to select a number, vector, or formula from one "
"window, then middle-click to paste that value into the other window.  When "
"you paste text into the Calc window, Calc interprets it as an algebraic "
"entry.  It doesn't matter where you click in the Calc window; the new value "
"is always pushed onto the top of the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30155
msgid ""
"The @code{xterm} program that is typically used for general-purpose shell "
"windows in X interprets the mouse buttons in the same way.  So you can use "
"the mouse to move data between Calc and any other Unix program.  One nice "
"feature of @code{xterm} is that a double left-click selects one word, and a "
"triple left-click selects a whole line.  So you can usually transfer a "
"single number into Calc just by double-clicking on it in the shell, then "
"middle-clicking in the Calc window."
msgstr ""

#. type: kindex
#: ../../calc.texi:30160
#, no-wrap
msgid "C-x * k"
msgstr ""

#. type: pindex
#: ../../calc.texi:30161
#, no-wrap
msgid "calc-keypad"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30169
msgid ""
"The @kbd{C-x * k} (@code{calc-keypad}) command starts the Calculator and "
"displays a picture of a calculator-style keypad.  If you are using the X "
"window system, you can click on any of the ``keys'' in the keypad using the "
"left mouse button to operate the calculator.  The original window remains "
"the selected window; in Keypad mode you can type in your file while "
"simultaneously performing calculations with the mouse."
msgstr ""

#. type: pindex
#: ../../calc.texi:30170
#, no-wrap
msgid "full-calc-keypad"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30176
msgid ""
"If you have used @kbd{C-x * b} first, @kbd{C-x * k} instead invokes the "
"@code{full-calc-keypad} command, which takes over the whole Emacs screen and "
"displays the keypad, the Calc stack, and the Calc trail all at once.  This "
"mode would normally be used when running Calc standalone (@pxref{Standalone "
"Operation})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30181
msgid ""
"If you aren't using the X window system, you must switch into the "
"@file{*Calc Keypad*} window, place the cursor on the desired ``key,'' and "
"type @key{SPC} or @key{RET}.  If you think this is easier than using Calc "
"normally, go right ahead."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30185
msgid ""
"Calc commands are more or less the same in Keypad mode.  Certain keypad keys "
"differ slightly from the corresponding normal Calc keystrokes; all such "
"deviations are described below."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30194
msgid ""
"Keypad mode includes many more commands than will fit on the keypad at "
"once.  Click the right mouse button [@code{calc-keypad-menu}] to switch to "
"the next menu.  The bottom five rows of the keypad stay the same; the top "
"three rows change to a new set of commands.  To return to earlier menus, "
"click the middle mouse button [@code{calc-keypad-menu-back}] or simply "
"advance through the menus until you wrap around.  Typing @key{TAB} inside "
"the keypad window is equivalent to clicking the right mouse button there."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30199
msgid ""
"You can always click the @key{EXEC} button and type any normal Calc key "
"sequence.  This is equivalent to switching into the Calc buffer, typing the "
"keys, then switching back to your original buffer."
msgstr ""

#. type: menuentry
#: ../../calc.texi:30206
msgid "Keypad Main Menu::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:30206
msgid "Keypad Functions Menu::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:30206
msgid "Keypad Binary Menu::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:30206
msgid "Keypad Vectors Menu::"
msgstr ""

#. type: node
#: ../../calc.texi:30206 ../../calc.texi:30415 ../../calc.texi:30497
#, no-wrap
msgid "Keypad Modes Menu"
msgstr ""

#. type: node
#: ../../calc.texi:30208 ../../calc.texi:30339
#, no-wrap
msgid "Keypad Main Menu"
msgstr ""

#. type: node
#: ../../calc.texi:30208 ../../calc.texi:30339 ../../calc.texi:30382
#, no-wrap
msgid "Keypad Functions Menu"
msgstr ""

#. type: section
#: ../../calc.texi:30209
#, no-wrap
msgid "Main Menu"
msgstr ""

#. type: group
#: ../../calc.texi:30230
#, no-wrap
msgid ""
"|----+----+--Calc---+----+----1\n"
"|FLR |CEIL|RND |TRNC|CLN2|FLT |\n"
"|----+----+----+----+----+----|\n"
"| LN |EXP |    |ABS |IDIV|MOD |\n"
"|----+----+----+----+----+----|\n"
"|SIN |COS |TAN |SQRT|y^x |1/x |\n"
"|----+----+----+----+----+----|\n"
"|  ENTER  |+/- |EEX |UNDO| <- |\n"
"|-----+---+-+--+--+-+---++----|\n"
"| INV |  7  |  8  |  9  |  /  |\n"
"|-----+-----+-----+-----+-----|\n"
"| HYP |  4  |  5  |  6  |  *  |\n"
"|-----+-----+-----+-----+-----|\n"
"|EXEC |  1  |  2  |  3  |  -  |\n"
"|-----+-----+-----+-----+-----|\n"
"| OFF |  0  |  .  | PI  |  +  |\n"
"|-----+-----+-----+-----+-----+\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30238
msgid ""
"This is the menu that appears the first time you start Keypad mode.  It will "
"show up in a vertical window on the right side of your screen.  Above this "
"menu is the traditional Calc stack display.  On a 24-line screen you will be "
"able to see the top three stack entries."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30244
msgid ""
"The ten digit keys, decimal point, and @key{EEX} key are used for entering "
"numbers in the obvious way.  @key{EEX} begins entry of an exponent in "
"scientific notation.  Just as with regular Calc, the number is pushed onto "
"the stack as soon as you press @key{ENTER} or any other function key."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30249
msgid ""
"The @key{+/-} key corresponds to normal Calc's @kbd{n} key.  During numeric "
"entry it changes the sign of the number or of the exponent.  At other times "
"it changes the sign of the number on the top of the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30254
msgid ""
"The @key{INV} and @key{HYP} keys modify other keys.  As well as having the "
"effects described elsewhere in this manual, Keypad mode defines several "
"other ``inverse'' operations.  These are described below and in the "
"following sections."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30257
msgid ""
"The @key{ENTER} key finishes the current numeric entry, or otherwise "
"duplicates the top entry on the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30261
msgid ""
"The @key{UNDO} key undoes the most recent Calc operation.  @kbd{INV UNDO} is "
"the ``redo'' command, and @kbd{HYP UNDO} is ``last arguments'' "
"(@kbd{M-@key{RET}})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30266
msgid ""
"The @key{<-} key acts as a ``backspace'' during numeric entry.  At other "
"times it removes the top stack entry.  @kbd{INV <-} clears the entire "
"stack.  @kbd{HYP <-} takes an integer from the stack, then removes that many "
"additional stack elements."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30272
msgid ""
"The @key{EXEC} key prompts you to enter any keystroke sequence that would "
"normally work in Calc mode.  This can include a numeric prefix if you wish.  "
"It is also possible simply to switch into the Calc window and type commands "
"in it; there is nothing ``magic'' about this window when Keypad mode is "
"active."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30277
msgid ""
"The other keys in this display perform their obvious calculator functions.  "
"@key{CLN2} rounds the top-of-stack by temporarily reducing the precision by "
"2 digits.  @key{FLT} converts an integer or fraction on the top of the stack "
"to floating-point."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30282
msgid ""
"The @key{INV} and @key{HYP} keys combined with several of these keys give "
"you access to some common functions even if the appropriate menu is not "
"displayed.  Obviously you don't need to learn these keys unless you find "
"yourself wasting time switching among the menus."
msgstr ""

#. type: item
#: ../../calc.texi:30284
#, no-wrap
msgid "INV +/-"
msgstr ""

#. type: table
#: ../../calc.texi:30286
msgid "is the same as @key{1/x}."
msgstr ""

#. type: item
#: ../../calc.texi:30286
#, no-wrap
msgid "INV +"
msgstr ""

#. type: table
#: ../../calc.texi:30288
msgid "is the same as @key{SQRT}."
msgstr ""

#. type: item
#: ../../calc.texi:30288
#, no-wrap
msgid "INV -"
msgstr ""

#. type: table
#: ../../calc.texi:30290
msgid "is the same as @key{CONJ}."
msgstr ""

#. type: item
#: ../../calc.texi:30290
#, no-wrap
msgid "INV *"
msgstr ""

#. type: table
#: ../../calc.texi:30292
msgid "is the same as @key{y^x}."
msgstr ""

#. type: item
#: ../../calc.texi:30292
#, no-wrap
msgid "INV /"
msgstr ""

#. type: table
#: ../../calc.texi:30294
msgid "is the same as @kbd{INV y^x} (the @expr{x}th root of @expr{y})."
msgstr ""

#. type: item
#: ../../calc.texi:30294
#, no-wrap
msgid "HYP/INV 1"
msgstr ""

#. type: table
#: ../../calc.texi:30296
msgid "are the same as @key{SIN} / @kbd{INV SIN}."
msgstr ""

#. type: item
#: ../../calc.texi:30296
#, no-wrap
msgid "HYP/INV 2"
msgstr ""

#. type: table
#: ../../calc.texi:30298
msgid "are the same as @key{COS} / @kbd{INV COS}."
msgstr ""

#. type: item
#: ../../calc.texi:30298
#, no-wrap
msgid "HYP/INV 3"
msgstr ""

#. type: table
#: ../../calc.texi:30300
msgid "are the same as @key{TAN} / @kbd{INV TAN}."
msgstr ""

#. type: item
#: ../../calc.texi:30300
#, no-wrap
msgid "INV/HYP 4"
msgstr ""

#. type: table
#: ../../calc.texi:30302
msgid "are the same as @key{LN} / @kbd{HYP LN}."
msgstr ""

#. type: item
#: ../../calc.texi:30302
#, no-wrap
msgid "INV/HYP 5"
msgstr ""

#. type: table
#: ../../calc.texi:30304
msgid "are the same as @key{EXP} / @kbd{HYP EXP}."
msgstr ""

#. type: item
#: ../../calc.texi:30304
#, no-wrap
msgid "INV 6"
msgstr ""

#. type: table
#: ../../calc.texi:30306
msgid "is the same as @key{ABS}."
msgstr ""

#. type: item
#: ../../calc.texi:30306
#, no-wrap
msgid "INV 7"
msgstr ""

#. type: table
#: ../../calc.texi:30308
msgid "is the same as @key{RND} (@code{calc-round})."
msgstr ""

#. type: item
#: ../../calc.texi:30308
#, no-wrap
msgid "INV 8"
msgstr ""

#. type: table
#: ../../calc.texi:30310
msgid "is the same as @key{CLN2}."
msgstr ""

#. type: item
#: ../../calc.texi:30310
#, no-wrap
msgid "INV 9"
msgstr ""

#. type: table
#: ../../calc.texi:30312
msgid "is the same as @key{FLT} (@code{calc-float})."
msgstr ""

#. type: item
#: ../../calc.texi:30312
#, no-wrap
msgid "INV 0"
msgstr ""

#. type: table
#: ../../calc.texi:30314
msgid "is the same as @key{IMAG}."
msgstr ""

#. type: item
#: ../../calc.texi:30314
#, no-wrap
msgid "INV ."
msgstr ""

#. type: table
#: ../../calc.texi:30316
msgid "is the same as @key{PREC}."
msgstr ""

#. type: item
#: ../../calc.texi:30316
#, no-wrap
msgid "INV ENTER"
msgstr ""

#. type: table
#: ../../calc.texi:30318
msgid "is the same as @key{SWAP}."
msgstr ""

#. type: item
#: ../../calc.texi:30318
#, no-wrap
msgid "HYP ENTER"
msgstr ""

#. type: table
#: ../../calc.texi:30320
msgid "is the same as @key{RLL3}."
msgstr ""

#. type: item
#: ../../calc.texi:30320
#, no-wrap
msgid "INV HYP ENTER"
msgstr ""

#. type: table
#: ../../calc.texi:30322
msgid "is the same as @key{OVER}."
msgstr ""

#. type: item
#: ../../calc.texi:30322
#, no-wrap
msgid "HYP +/-"
msgstr ""

#. type: table
#: ../../calc.texi:30324
msgid "packs the top two stack entries as an error form."
msgstr ""

#. type: item
#: ../../calc.texi:30324
#, no-wrap
msgid "HYP EEX"
msgstr ""

#. type: table
#: ../../calc.texi:30326
msgid "packs the top two stack entries as a modulo form."
msgstr ""

#. type: item
#: ../../calc.texi:30326
#, no-wrap
msgid "INV EEX"
msgstr ""

#. type: table
#: ../../calc.texi:30330
msgid ""
"creates an interval form; this removes an integer which is one of 0 "
"@samp{[]}, 1 @samp{[)}, 2 @samp{(]} or 3 @samp{()}, followed by the two "
"limits of the interval."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30338
msgid ""
"The @kbd{OFF} key turns Calc off; typing @kbd{C-x * k} or @kbd{C-x * *} "
"again has the same effect.  This is analogous to typing @kbd{q} or hitting "
"@kbd{C-x * c} again in the normal calculator.  If Calc is running standalone "
"(the @code{full-calc-keypad} command appeared in the command line that "
"started Emacs), then @kbd{OFF} is replaced with @kbd{EXIT}; clicking on this "
"actually exits Emacs itself."
msgstr ""

#. type: node
#: ../../calc.texi:30339 ../../calc.texi:30382 ../../calc.texi:30415
#, no-wrap
msgid "Keypad Binary Menu"
msgstr ""

#. type: section
#: ../../calc.texi:30340
#, no-wrap
msgid "Functions Menu"
msgstr ""

#. type: group
#: ../../calc.texi:30351
#, no-wrap
msgid ""
"|----+----+----+----+----+----2\n"
"|IGAM|BETA|IBET|ERF |BESJ|BESY|\n"
"|----+----+----+----+----+----|\n"
"|IMAG|CONJ| RE |ATN2|RAND|RAGN|\n"
"|----+----+----+----+----+----|\n"
"|GCD |FACT|DFCT|BNOM|PERM|NXTP|\n"
"|----+----+----+----+----+----|\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30357
msgid ""
"This menu provides various operations from the @kbd{f} and @kbd{k} prefix "
"keys."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30360
msgid ""
"@key{IMAG} multiplies the number on the stack by the imaginary number "
"@expr{i = (0, 1)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30363
msgid ""
"@key{RE} extracts the real part a complex number.  @kbd{INV RE} extracts the "
"imaginary part."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30369
msgid ""
"@key{RAND} takes a number from the top of the stack and computes a random "
"number greater than or equal to zero but less than that number.  "
"(@xref{Random Numbers}.)  @key{RAGN} is the ``random again'' command; it "
"computes another random number using the same limit as last time."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30371
msgid "@kbd{INV GCD} computes the LCM (least common multiple) function."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30375
msgid ""
"@kbd{INV FACT} is the gamma function.  @texline @math{\\Gamma(x) = (x-1)!}.  "
"@infoline @expr{gamma(x) = (x-1)!}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30378
msgid ""
"@key{PERM} is the number-of-permutations function, which is on the @kbd{H k "
"c} key in normal Calc."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30381
msgid ""
"@key{NXTP} finds the next prime after a number.  @kbd{INV NXTP} finds the "
"previous prime."
msgstr ""

#. type: node
#: ../../calc.texi:30382 ../../calc.texi:30415 ../../calc.texi:30497
#, no-wrap
msgid "Keypad Vectors Menu"
msgstr ""

#. type: section
#: ../../calc.texi:30383
#, no-wrap
msgid "Binary Menu"
msgstr ""

#. type: group
#: ../../calc.texi:30394
#, no-wrap
msgid ""
"|----+----+----+----+----+----3\n"
"|AND | OR |XOR |NOT |LSH |RSH |\n"
"|----+----+----+----+----+----|\n"
"|DEC |HEX |OCT |BIN |WSIZ|ARSH|\n"
"|----+----+----+----+----+----|\n"
"| A  | B  | C  | D  | E  | F  |\n"
"|----+----+----+----+----+----|\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30401
msgid ""
"The keys in this menu perform operations on binary integers.  Note that both "
"logical and arithmetic right-shifts are provided.  @kbd{INV LSH} rotates one "
"bit to the left."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30404
msgid ""
"The ``difference'' function (normally on @kbd{b d}) is on @kbd{INV AND}.  "
"The ``clip'' function (normally on @w{@kbd{b c}}) is on @kbd{INV NOT}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30409
msgid ""
"The @key{DEC}, @key{HEX}, @key{OCT}, and @key{BIN} keys select the current "
"radix for display and entry of numbers: Decimal, hexadecimal, octal, or "
"binary.  The six letter keys @kbd{A} through @kbd{F} are used for entering "
"hexadecimal numbers."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30414
msgid ""
"The @key{WSIZ} key displays the current word size for binary operations and "
"allows you to enter a new word size.  You can respond to the prompt using "
"either the keyboard or the digits and @key{ENTER} from the keypad.  The "
"initial word size is 32 bits."
msgstr ""

#. type: section
#: ../../calc.texi:30416
#, no-wrap
msgid "Vectors Menu"
msgstr ""

#. type: group
#: ../../calc.texi:30427
#, no-wrap
msgid ""
"|----+----+----+----+----+----4\n"
"|SUM |PROD|MAX |MAP*|MAP^|MAP$|\n"
"|----+----+----+----+----+----|\n"
"|MINV|MDET|MTRN|IDNT|CRSS|\"x\" |\n"
"|----+----+----+----+----+----|\n"
"|PACK|UNPK|INDX|BLD |LEN |... |\n"
"|----+----+----+----+----+----|\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30432
msgid "The keys in this menu operate on vectors and matrices."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30440
msgid ""
"@key{PACK} removes an integer @var{n} from the top of the stack; the next "
"@var{n} stack elements are removed and packed into a vector, which is "
"replaced onto the stack.  Thus the sequence @kbd{1 ENTER 3 ENTER 5 ENTER 3 "
"PACK} enters the vector @samp{[1, 3, 5]} onto the stack.  To enter a matrix, "
"build each row on the stack as a vector, then use a final @key{PACK} to "
"collect the rows into a matrix."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30443
msgid ""
"@key{UNPK} unpacks the vector on the stack, pushing each of its components "
"separately."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30449
msgid ""
"@key{INDX} removes an integer @var{n}, then builds a vector of integers from "
"1 to @var{n}.  @kbd{INV INDX} takes three numbers from the stack: The vector "
"size @var{n}, the starting number, and the increment.  @kbd{BLD} takes an "
"integer @var{n} and any value @var{x} and builds a vector of @var{n} copies "
"of @var{x}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30452
msgid ""
"@key{IDNT} removes an integer @var{n}, then builds an @var{n}-by-@var{n} "
"identity matrix."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30454
msgid "@key{LEN} replaces a vector by its length, an integer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30456
msgid "@key{...} turns on or off ``abbreviated'' display mode for large vectors."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30459
msgid ""
"@key{MINV}, @key{MDET}, @key{MTRN}, and @key{CROSS} are the matrix inverse, "
"determinant, and transpose, and vector cross product."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30464
msgid ""
"@key{SUM} replaces a vector by the sum of its elements.  It is equivalent to "
"@kbd{u +} in normal Calc (@pxref{Statistical Operations}).  @key{PROD} "
"computes the product of the elements of a vector, and @key{MAX} computes the "
"maximum of all the elements of a vector."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30468
msgid ""
"@kbd{INV SUM} computes the alternating sum of the first element minus the "
"second, plus the third, minus the fourth, and so on.  @kbd{INV MAX} computes "
"the minimum of the vector elements."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30472
msgid ""
"@kbd{HYP SUM} computes the mean of the vector elements.  @kbd{HYP PROD} "
"computes the sample standard deviation.  @kbd{HYP MAX} computes the median."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30478
msgid ""
"@key{MAP*} multiplies two vectors elementwise.  It is equivalent to the "
"@kbd{V M *} command.  @key{MAP^} computes powers elementwise.  The arguments "
"must be vectors of equal length, or one must be a vector and the other must "
"be a plain number.  For example, @kbd{2 MAP^} squares all the elements of a "
"vector."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30488
msgid ""
"@key{MAP$} maps the formula on the top of the stack across the vector in the "
"second-to-top position.  If the formula contains several variables, Calc "
"takes that many vectors starting at the second-to-top position and matches "
"them to the variables in alphabetical order.  The result is a vector of the "
"same size as the input vectors, whose elements are the formula evaluated "
"with the variables set to the various sets of numbers in those vectors.  For "
"example, you could simulate @key{MAP^} using @key{MAP$} with the formula "
"@samp{x^y}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30496
msgid ""
"The @kbd{\"x\"} key pushes the variable name @expr{x} onto the stack.  To "
"build the formula @expr{x^2 + 6}, you would use the key sequence @kbd{\"x\" "
"2 y^x 6 +}.  This formula would then be suitable for use with the @key{MAP$} "
"key described above.  With @key{INV}, @key{HYP}, or @key{INV} and @key{HYP}, "
"the @kbd{\"x\"} key pushes the variable names @expr{y}, @expr{z}, and "
"@expr{t}, respectively."
msgstr ""

#. type: section
#: ../../calc.texi:30498
#, no-wrap
msgid "Modes Menu"
msgstr ""

#. type: group
#: ../../calc.texi:30509
#, no-wrap
msgid ""
"|----+----+----+----+----+----5\n"
"|FLT |FIX |SCI |ENG |GRP |    |\n"
"|----+----+----+----+----+----|\n"
"|RAD |DEG |FRAC|POLR|SYMB|PREC|\n"
"|----+----+----+----+----+----|\n"
"|SWAP|RLL3|RLL4|OVER|STO |RCL |\n"
"|----+----+----+----+----+----|\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30514
msgid "The keys in this menu manipulate modes, variables, and the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30520
msgid ""
"The @key{FLT}, @key{FIX}, @key{SCI}, and @key{ENG} keys select "
"floating-point, fixed-point, scientific, or engineering notation.  @key{FIX} "
"displays two digits after the decimal by default; the others display full "
"precision.  With the @key{INV} prefix, these keys pop a number-of-digits "
"argument from the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30524
msgid ""
"The @key{GRP} key turns grouping of digits with commas on or off.  @kbd{INV "
"GRP} enables grouping to the right of the decimal point as well as to the "
"left."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30527
msgid ""
"The @key{RAD} and @key{DEG} keys switch between radians and degrees for "
"trigonometric functions."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30531
msgid ""
"The @key{FRAC} key turns Fraction mode on or off.  This affects whether "
"commands like @kbd{/} with integer arguments produce fractional or "
"floating-point results."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30534
msgid ""
"The @key{POLR} key turns Polar mode on or off, determining whether polar or "
"rectangular complex numbers are used by default."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30538
msgid ""
"The @key{SYMB} key turns Symbolic mode on or off, in which operations that "
"would produce inexact floating-point results are left unevaluated as "
"algebraic formulas."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30541
msgid ""
"The @key{PREC} key selects the current precision.  Answer with the keyboard "
"or with the keypad digit and @key{ENTER} keys."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30546
msgid ""
"The @key{SWAP} key exchanges the top two stack elements.  The @key{RLL3} key "
"rotates the top three stack elements upwards.  The @key{RLL4} key rotates "
"the top four stack elements upwards.  The @key{OVER} key duplicates the "
"second-to-top stack element."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30552
msgid ""
"The @key{STO} and @key{RCL} keys are analogous to @kbd{s t} and @kbd{s r} in "
"regular Calc.  @xref{Store and Recall}.  Click the @key{STO} or @key{RCL} "
"key, then one of the ten digits.  (Named variables are not available in "
"Keypad mode.)  You can also use, for example, @kbd{STO + 3} to add to "
"register 3."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30561
msgid ""
"Embedded mode in Calc provides an alternative to copying numbers and "
"formulas back and forth between editing buffers and the Calc stack.  In "
"Embedded mode, your editing buffer becomes temporarily linked to the stack "
"and this copying is taken care of automatically."
msgstr ""

#. type: menuentry
#: ../../calc.texi:30568
msgid "Basic Embedded Mode::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:30568
msgid "More About Embedded Mode::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:30568
msgid "Assignments in Embedded Mode::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:30568
msgid "Mode Settings in Embedded Mode::"
msgstr ""

#. type: section
#: ../../calc.texi:30568 ../../calc.texi:31144 ../../calc.texi:31289 ../../calc.texi:31290
#, no-wrap
msgid "Customizing Embedded Mode"
msgstr ""

#. type: node
#: ../../calc.texi:30570 ../../calc.texi:30571 ../../calc.texi:30734
#, no-wrap
msgid "Basic Embedded Mode"
msgstr ""

#. type: node
#: ../../calc.texi:30570 ../../calc.texi:30734 ../../calc.texi:30735 ../../calc.texi:30918
#, no-wrap
msgid "More About Embedded Mode"
msgstr ""

#. type: kindex
#: ../../calc.texi:30574
#, no-wrap
msgid "C-x * e"
msgstr ""

#. type: pindex
#: ../../calc.texi:30575
#, no-wrap
msgid "calc-embedded"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30581
msgid ""
"To enter Embedded mode, position the Emacs point (cursor) on a formula in "
"any buffer and press @kbd{C-x * e} (@code{calc-embedded}).  Note that "
"@kbd{C-x * e} is not to be used in the Calc stack buffer like most Calc "
"commands, but rather in regular editing buffers that are visiting your own "
"files."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30593
msgid ""
"Calc will try to guess an appropriate language based on the major mode of "
"the editing buffer. (@xref{Language Modes}.) If the current buffer is in "
"@code{latex-mode}, for example, Calc will set its language to @LaTeX{}.  "
"Similarly, Calc will use @TeX{} language for @code{tex-mode}, "
"@code{plain-tex-mode} and @code{context-mode}, C language for @code{c-mode} "
"and @code{c++-mode}, FORTRAN language for @code{fortran-mode} and "
"@code{f90-mode}, Pascal for @code{pascal-mode}, and eqn for "
"@code{nroff-mode} (@pxref{Customizing Calc}).  These can be overridden with "
"Calc's mode changing commands (@pxref{Mode Settings in Embedded Mode}).  If "
"no suitable language is available, Calc will continue with its current "
"language."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30598
msgid ""
"Calc normally scans backward and forward in the buffer for the nearest "
"opening and closing @dfn{formula delimiters}.  The simplest delimiters are "
"blank lines.  Other delimiters that Embedded mode understands are:"
msgstr ""

#. type: enumerate
#: ../../calc.texi:30603 ../../calc.texi:35489
msgid ""
"The @TeX{} and @LaTeX{} math delimiters @samp{$ $}, @samp{$$ $$}, @samp{\\[ "
"\\]}, and @samp{\\( \\)};"
msgstr ""

#. type: enumerate
#: ../../calc.texi:30605 ../../calc.texi:35491
msgid ""
"Lines beginning with @samp{\\begin} and @samp{\\end} (except matrix "
"delimiters);"
msgstr ""

#. type: enumerate
#: ../../calc.texi:30607 ../../calc.texi:35493
msgid "Lines beginning with @samp{@@} (Texinfo delimiters)."
msgstr ""

#. type: enumerate
#: ../../calc.texi:30609 ../../calc.texi:35495
msgid "Lines beginning with @samp{.EQ} and @samp{.EN} (@dfn{eqn} delimiters);"
msgstr ""

#. type: enumerate
#: ../../calc.texi:30611 ../../calc.texi:35497
msgid "Lines containing a single @samp{%} or @samp{.\\\"} symbol and nothing else."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30616
msgid ""
"@xref{Customizing Embedded Mode}, to see how to make Calc recognize your own "
"favorite delimiters.  Delimiters like @samp{$ $} can appear on their own "
"separate lines or in-line with the formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30621
msgid ""
"If you give a positive or negative numeric prefix argument, Calc instead "
"uses the current point as one end of the formula, and includes that many "
"lines forward or backward (respectively, including the current "
"line). Explicit delimiters are not necessary in this case."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30625
msgid ""
"With a prefix argument of zero, Calc uses the current region (delimited by "
"point and mark) instead of formula delimiters.  With a prefix argument of "
"@kbd{C-u} only, Calc uses the current line as the formula."
msgstr ""

#. type: kindex
#: ../../calc.texi:30626
#, no-wrap
msgid "C-x * w"
msgstr ""

#. type: pindex
#: ../../calc.texi:30627
#, no-wrap
msgid "calc-embedded-word"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30633
msgid ""
"The @kbd{C-x * w} (@code{calc-embedded-word}) command will start Embedded "
"mode on the current ``word''; in this case Calc will scan for the first "
"non-numeric character (i.e., the first character that is not a digit, sign, "
"decimal point, or upper- or lower-case @samp{e}) forward and backward to "
"delimit the formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30645
msgid ""
"When you enable Embedded mode for a formula, Calc reads the text between the "
"delimiters and tries to interpret it as a Calc formula.  Calc can generally "
"identify @TeX{} formulas and Big-style formulas even if the language mode is "
"wrong.  If Calc can't make sense of the formula, it beeps and refuses to "
"enter Embedded mode.  But if the current language is wrong, Calc can "
"sometimes parse the formula successfully (but incorrectly); for example, the "
"C expression @samp{atan(a[1])} can be parsed in Normal language mode, but "
"the @code{atan} won't correspond to the built-in @code{arctan} function, and "
"the @samp{a[1]} will be interpreted as @samp{a} times the vector @samp{[1]}!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30650
msgid ""
"If you press @kbd{C-x * e} or @kbd{C-x * w} to activate an embedded formula "
"which is blank, say with the cursor on the space between the two delimiters "
"@samp{$ $}, Calc will immediately prompt for an algebraic entry."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30656
msgid ""
"Only one formula in one buffer can be enabled at a time.  If you move to "
"another area of the current buffer and give Calc commands, Calc turns "
"Embedded mode off for the old formula and then tries to restart Embedded "
"mode at the new position.  Other buffers are not affected by Embedded mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30662
msgid ""
"When Embedded mode begins, Calc pushes the current formula onto the stack.  "
"No Calc stack window is created; however, Calc copies the top-of-stack "
"position into the original buffer at all times.  You can create a Calc "
"window by hand with @kbd{C-x * o} if you find you need to see the entire "
"stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30666
msgid ""
"For example, typing @kbd{C-x * e} while somewhere in the formula @samp{n>2} "
"in the following line enables Embedded mode on that inequality:"
msgstr ""

#. type: example
#: ../../calc.texi:30669
#, no-wrap
msgid "We define $F_n = F_(n-1)+F_(n-2)$ for all $n>2$.\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30676
msgid ""
"The formula @expr{n>2} will be pushed onto the Calc stack, and the top of "
"stack will be copied back into the editing buffer.  This means that spaces "
"will appear around the @samp{>} symbol to match Calc's usual display style:"
msgstr ""

#. type: example
#: ../../calc.texi:30679
#, no-wrap
msgid "We define $F_n = F_(n-1)+F_(n-2)$ for all $n > 2$.\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30685
msgid ""
"No spaces have appeared around the @samp{+} sign because it's in a different "
"formula, one which we have not yet touched with Embedded mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30692
msgid ""
"Now that Embedded mode is enabled, keys you type in this buffer are "
"interpreted as Calc commands.  At this point we might use the ``commute'' "
"command @kbd{j C} to reverse the inequality.  This is a selection-based "
"command for which we first need to move the cursor onto the operator "
"(@samp{>} in this case) that needs to be commuted."
msgstr ""

#. type: example
#: ../../calc.texi:30695
#, no-wrap
msgid "We define $F_n = F_(n-1)+F_(n-2)$ for all $2 < n$.\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30701
msgid ""
"The @kbd{C-x * o} command is a useful way to open a Calc window without "
"actually selecting that window.  Giving this command verifies that @samp{2 < "
"n} is also on the Calc stack.  Typing @kbd{17 @key{RET}} would produce:"
msgstr ""

#. type: example
#: ../../calc.texi:30704
#, no-wrap
msgid "We define $F_n = F_(n-1)+F_(n-2)$ for all $17$.\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30714
msgid ""
"with @samp{2 < n} and @samp{17} on the stack; typing @key{TAB} at this point "
"will exchange the two stack values and restore @samp{2 < n} to the embedded "
"formula.  Even though you can't normally see the stack in Embedded mode, it "
"is still there and it still operates in the same way.  But, as with "
"old-fashioned RPN calculators, you can only see the value at the top of the "
"stack at any given time (unless you use @kbd{C-x * o})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30722
msgid ""
"Typing @kbd{C-x * e} again turns Embedded mode off.  The Calc window reveals "
"that the formula @w{@samp{2 < n}} is automatically removed from the stack, "
"but the @samp{17} is not.  Entering Embedded mode always pushes one thing "
"onto the stack, and leaving Embedded mode always removes one thing.  "
"Anything else that happens on the stack is entirely your business as far as "
"Embedded mode is concerned."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30733
msgid ""
"If you press @kbd{C-x * e} in the wrong place by accident, it is possible "
"that Calc will be able to parse the nearby text as a formula and will mangle "
"that text in an attempt to redisplay it ``properly'' in the current language "
"mode.  If this happens, press @kbd{C-x * e} again to exit Embedded mode, "
"then give the regular Emacs ``undo'' command (@kbd{C-_} or @kbd{C-x u}) to "
"put the text back the way it was before Calc edited it.  Note that Calc's "
"own Undo command (typed before you turn Embedded mode back off)  will not do "
"you any good, because as far as Calc is concerned you haven't done anything "
"with this formula yet."
msgstr ""

#. type: node
#: ../../calc.texi:30734 ../../calc.texi:30918 ../../calc.texi:30919 ../../calc.texi:31144
#, no-wrap
msgid "Assignments in Embedded Mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30745
msgid ""
"When Embedded mode ``activates'' a formula, i.e., when it examines the "
"formula for the first time since the buffer was created or loaded, Calc "
"tries to sense the language in which the formula was written.  If the "
"formula contains any @LaTeX{}-like @samp{\\} sequences, it is parsed (i.e., "
"read) in @LaTeX{} mode.  If the formula appears to be written in multi-line "
"Big mode, it is parsed in Big mode.  Otherwise, it is parsed according to "
"the current language mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30750
msgid ""
"Note that Calc does not change the current language mode according the "
"formula it reads in.  Even though it can read a @LaTeX{} formula when not in "
"@LaTeX{} mode, it will immediately rewrite this formula using whatever "
"language mode is in effect."
msgstr ""

#. type: kindex
#: ../../calc.texi:30755
#, no-wrap
msgid "d p"
msgstr ""

#. type: pindex
#: ../../calc.texi:30756
#, no-wrap
msgid "calc-show-plain"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30766
msgid ""
"Calc's parser is unable to read certain kinds of formulas.  For example, "
"with @kbd{v ]} (@code{calc-matrix-brackets}) you can specify matrix display "
"styles which the parser is unable to recognize as matrices.  The @kbd{d p} "
"(@code{calc-show-plain})  command turns on a mode in which a ``plain'' "
"version of a formula is placed in front of the fully-formatted version.  "
"When Calc reads a formula that has such a plain version in front, it reads "
"the plain version and ignores the formatted version."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30776
msgid ""
"Plain formulas are preceded and followed by @samp{%%%} signs by default.  "
"This notation has the advantage that the @samp{%} character begins a comment "
"in @TeX{} and @LaTeX{}, so if your formula is embedded in a @TeX{} or "
"@LaTeX{} document its plain version will be invisible in the final printed "
"copy.  Certain major modes have different delimiters to ensure that the "
"``plain'' version will be in a comment for those modes, also.  See "
"@ref{Customizing Embedded Mode} to see how to change the ``plain'' formula "
"delimiters."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30785
msgid ""
"There are several notations which Calc's parser for ``big'' formatted "
"formulas can't yet recognize.  In particular, it can't read the large "
"symbols for @code{sum}, @code{prod}, and @code{integ}, and it can't handle "
"@samp{=>} with the righthand argument omitted.  Also, Calc won't recognize "
"special formats you have defined with the @kbd{Z C} command "
"(@pxref{User-Defined Compositions}).  In these cases it is important to use "
"``plain'' mode to make sure Calc will be able to read your formula later."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30792
msgid ""
"Another example where ``plain'' mode is important is if you have specified a "
"float mode with few digits of precision.  Normally any digits that are "
"computed but not displayed will simply be lost when you save and re-load "
"your embedded buffer, but ``plain'' mode allows you to make sure that the "
"complete number is present in the file as well as the rounded-down number."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30809
msgid ""
"Embedded buffers remember active formulas for as long as they exist in Emacs "
"memory.  Suppose you have an embedded formula which is @cpi{} to the normal "
"12 decimal places, and then type @w{@kbd{C-u 5 d n}} to display only five "
"decimal places.  If you then type @kbd{d n}, all 12 places reappear because "
"the full number is still there on the Calc stack.  More surprisingly, even "
"if you exit Embedded mode and later re-enter it for that formula, typing "
"@kbd{d n} will restore all 12 places because each buffer remembers all its "
"active formulas.  However, if you save the buffer in a file and reload it in "
"a new Emacs session, all non-displayed digits will have been lost unless you "
"used ``plain'' mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30819
msgid ""
"In some applications of Embedded mode, you will want to have a sequence of "
"copies of a formula that show its evolution as you work on it.  For example, "
"you might want to have a sequence like this in your file (elaborating here "
"on the example from the ``Getting Started'' chapter):"
msgstr ""

#. type: smallexample
#: ../../calc.texi:30824 ../../calc.texi:30862
#, no-wrap
msgid ""
"                              ln(ln(x))\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:30828
#, no-wrap
msgid ""
"                  @r{(the derivative of }ln(ln(x))@r{)}\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:30830
#, no-wrap
msgid ""
"whose value at x = 2 is\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:30832
#, no-wrap
msgid ""
"                            @r{(the value)}\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:30834
#, no-wrap
msgid ""
"and at x = 3 is\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:30836
#, no-wrap
msgid "                            @r{(the value)}\n"
msgstr ""

#. type: kindex
#: ../../calc.texi:30838
#, no-wrap
msgid "C-x * d"
msgstr ""

#. type: pindex
#: ../../calc.texi:30839
#, no-wrap
msgid "calc-embedded-duplicate"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30845
msgid ""
"The @kbd{C-x * d} (@code{calc-embedded-duplicate}) command is a handy way to "
"make sequences like this.  If you type @kbd{C-x * d}, the formula under the "
"cursor (which may or may not have Embedded mode enabled for it at the time) "
"is copied immediately below and Embedded mode is then enabled for that copy."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30847
msgid "For this example, you would start with just"
msgstr ""

#. type: smallexample
#: ../../calc.texi:30852 ../../calc.texi:30865
#, no-wrap
msgid "                              ln(ln(x))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30857
msgid "and press @kbd{C-x * d} with the cursor on this formula.  The result is"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30874
msgid ""
"with the second copy of the formula enabled in Embedded mode.  You can now "
"press @kbd{a d x @key{RET}} to take the derivative, and @kbd{C-x * d C-x * "
"d} to make two more copies of the derivative.  To complete the computations, "
"type @kbd{3 s l x @key{RET}} to evaluate the last formula, then move up to "
"the second-to-last formula and type @kbd{2 s l x @key{RET}}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30878
msgid ""
"Finally, you would want to press @kbd{C-x * e} to exit Embedded mode, then "
"go up and insert the necessary text in between the various formulas and "
"numbers."
msgstr ""

#. type: kindex
#: ../../calc.texi:30883
#, no-wrap
msgid "C-x * f"
msgstr ""

#. type: kindex
#: ../../calc.texi:30884
#, no-wrap
msgid "C-x * '"
msgstr ""

#. type: pindex
#: ../../calc.texi:30885
#, no-wrap
msgid "calc-embedded-new-formula"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30894
msgid ""
"The @kbd{C-x * f} (@code{calc-embedded-new-formula}) command creates a new "
"embedded formula at the current point.  It inserts some default delimiters, "
"which are usually just blank lines, and then does an algebraic entry to get "
"the formula (which is then enabled for Embedded mode).  This is just "
"shorthand for typing the delimiters yourself, positioning the cursor between "
"the new delimiters, and pressing @kbd{C-x * e}.  The key sequence @kbd{C-x * "
"'} is equivalent to @kbd{C-x * f}."
msgstr ""

#. type: kindex
#: ../../calc.texi:30895
#, no-wrap
msgid "C-x * n"
msgstr ""

#. type: kindex
#: ../../calc.texi:30896
#, no-wrap
msgid "C-x * p"
msgstr ""

#. type: pindex
#: ../../calc.texi:30897
#, no-wrap
msgid "calc-embedded-next"
msgstr ""

#. type: pindex
#: ../../calc.texi:30898
#, no-wrap
msgid "calc-embedded-previous"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30910
msgid ""
"The @kbd{C-x * n} (@code{calc-embedded-next}) and @kbd{C-x * p} "
"(@code{calc-embedded-previous}) commands move the cursor to the next or "
"previous active embedded formula in the buffer.  They can take positive or "
"negative prefix arguments to move by several formulas.  Note that these "
"commands do not actually examine the text of the buffer looking for "
"formulas; they only see formulas which have previously been activated in "
"Embedded mode.  In fact, @kbd{C-x * n} and @kbd{C-x * p} are a useful way to "
"tell which embedded formulas are currently active.  Also, note that these "
"commands do not enable Embedded mode on the next or previous formula, they "
"just move the cursor."
msgstr ""

#. type: kindex
#: ../../calc.texi:30911
#, no-wrap
msgid "C-x * `"
msgstr ""

#. type: pindex
#: ../../calc.texi:30912
#, no-wrap
msgid "calc-embedded-edit"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30917
msgid ""
"The @kbd{C-x * `} (@code{calc-embedded-edit}) command edits the embedded "
"formula at the current point as if by @kbd{`} (@code{calc-edit}).  Embedded "
"mode does not have to be enabled for this to work.  Press @kbd{C-c C-c} to "
"finish the edit, or @kbd{C-x k} to cancel."
msgstr ""

#. type: node
#: ../../calc.texi:30918 ../../calc.texi:31144 ../../calc.texi:31145 ../../calc.texi:31289
#, no-wrap
msgid "Mode Settings in Embedded Mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30926
msgid ""
"The @samp{:=} (assignment) and @samp{=>} (``evaluates-to'') operators are "
"especially useful in Embedded mode.  They allow you to make a definition in "
"one formula, then refer to that definition in other formulas embedded in the "
"same buffer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30928
msgid "An embedded formula which is an assignment to a variable, as in"
msgstr ""

#. type: example
#: ../../calc.texi:30931
#, no-wrap
msgid "foo := 5\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30939
msgid ""
"records @expr{5} as the stored value of @code{foo} for the purposes of "
"Embedded mode operations in the current buffer.  It does @emph{not} actually "
"store @expr{5} as the ``global'' value of @code{foo}, however.  Regular Calc "
"operations, and Embedded formulas in other buffers, will not see this "
"assignment."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30945
msgid ""
"One way to use this assigned value is simply to create an Embedded formula "
"elsewhere that refers to @code{foo}, and to press @kbd{=} in that formula.  "
"However, this permanently replaces the @code{foo} in the formula with its "
"current value.  More interesting is to use @samp{=>} elsewhere:"
msgstr ""

#. type: example
#: ../../calc.texi:30948
#, no-wrap
msgid "foo + 7 => 12\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30951
msgid "@xref{Evaluates-To Operator}, for a general discussion of @samp{=>}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30954
msgid ""
"If you move back and change the assignment to @code{foo}, any @samp{=>} "
"formulas which refer to it are automatically updated."
msgstr ""

#. type: example
#: ../../calc.texi:30957
#, no-wrap
msgid ""
"foo := 17\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:30959
#, no-wrap
msgid "foo + 7 => 24\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30966
msgid ""
"The obvious question then is, @emph{how} can one easily change the "
"assignment to @code{foo}? If you simply select the formula in Embedded mode "
"and type 17, the assignment itself will be replaced by the 17.  The effect "
"on the other formula will be that the variable @code{foo} becomes "
"unassigned:"
msgstr ""

#. type: example
#: ../../calc.texi:30969
#, no-wrap
msgid ""
"17\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:30971
#, no-wrap
msgid "foo + 7 => foo + 7\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30977
msgid ""
"The right thing to do is first to use a selection command (@kbd{j 2} will do "
"the trick) to select the righthand side of the assignment.  Then, @kbd{17 "
"@key{TAB} @key{DEL}} will swap the 17 into place (@pxref{Selecting "
"Subformulas}, to see how this works)."
msgstr ""

#. type: kindex
#: ../../calc.texi:30978
#, no-wrap
msgid "C-x * j"
msgstr ""

#. type: pindex
#: ../../calc.texi:30979
#, no-wrap
msgid "calc-embedded-select"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30986
msgid ""
"The @kbd{C-x * j} (@code{calc-embedded-select}) command provides an easy way "
"to operate on assignments.  It is just like @kbd{C-x * e}, except that if "
"the enabled formula is an assignment, it uses @kbd{j 2} to select the "
"righthand side.  If the enabled formula is an evaluates-to, it uses @kbd{j "
"1} to select the lefthand side.  A formula can also be a combination of "
"both:"
msgstr ""

#. type: example
#: ../../calc.texi:30989
#, no-wrap
msgid "bar := foo + 3 => 20\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:30993
msgid "in which case @kbd{C-x * j} will select the middle part (@samp{foo + 3})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:30996
msgid "The formula is automatically deselected when you leave Embedded mode."
msgstr ""

#. type: kindex
#: ../../calc.texi:30997
#, no-wrap
msgid "C-x * u"
msgstr ""

#. type: pindex
#: ../../calc.texi:30998
#, no-wrap
msgid "calc-embedded-update-formula"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31004
msgid ""
"Another way to change the assignment to @code{foo} would simply be to edit "
"the number using regular Emacs editing rather than Embedded mode.  Then, we "
"have to find a way to get Embedded mode to notice the change.  The @kbd{C-x "
"* u} (@code{calc-embedded-update-formula})  command is a convenient way to "
"do this."
msgstr ""

#. type: example
#: ../../calc.texi:31007
#, no-wrap
msgid ""
"foo := 6\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:31009
#, no-wrap
msgid "foo + 7 => 13\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31017
msgid ""
"Pressing @kbd{C-x * u} is much like pressing @kbd{C-x * e = C-x * e}, that "
"is, temporarily enabling Embedded mode for the formula under the cursor and "
"then evaluating it with @kbd{=}.  But @kbd{C-x * u} does not actually use "
"@kbd{C-x * e}, and in fact another formula somewhere else can be enabled in "
"Embedded mode while you use @kbd{C-x * u} and that formula will not be "
"disturbed."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31023
msgid ""
"With a numeric prefix argument, @kbd{C-x * u} updates all active @samp{=>} "
"formulas in the buffer.  Formulas which have not yet been activated in "
"Embedded mode, and formulas which do not have @samp{=>} as their top-level "
"operator, are not affected by this.  (This is useful only if you have used "
"@kbd{m C}; see below.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31026
msgid ""
"With a plain @kbd{C-u} prefix, @kbd{C-u C-x * u} updates only in the region "
"between mark and point rather than in the whole buffer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31030
msgid ""
"@kbd{C-x * u} is also a handy way to activate a formula, such as an "
"@samp{=>} formula that has freshly been typed in or loaded from a file."
msgstr ""

#. type: kindex
#: ../../calc.texi:31031
#, no-wrap
msgid "C-x * a"
msgstr ""

#. type: pindex
#: ../../calc.texi:31032
#, no-wrap
msgid "calc-embedded-activate"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31040
msgid ""
"The @kbd{C-x * a} (@code{calc-embedded-activate}) command scans through the "
"current buffer and activates all embedded formulas that contain @samp{:=} or "
"@samp{=>} symbols.  This does not mean that Embedded mode is actually turned "
"on, but only that the formulas' positions are registered with Embedded mode "
"so that the @samp{=>} values can be properly updated as assignments are "
"changed."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31046
msgid ""
"It is a good idea to type @kbd{C-x * a} right after loading a file that uses "
"embedded @samp{=>} operators.  Emacs includes a nifty ``buffer-local "
"variables'' feature that you can use to do this automatically.  The idea is "
"to place near the end of your file a few lines that look like this:"
msgstr ""

#. type: example
#: ../../calc.texi:31051
#, no-wrap
msgid ""
"--- Local Variables: ---\n"
"--- eval:(calc-embedded-activate) ---\n"
"--- End: ---\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31060
msgid ""
"where the leading and trailing @samp{---} can be replaced by any suitable "
"strings (which must be the same on all three lines)  or omitted altogether; "
"in a @TeX{} or @LaTeX{} file, @samp{%} would be a good leading string and no "
"trailing string would be necessary.  In a C program, @samp{/*} and @samp{*/} "
"would be good leading and trailing strings."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31070
msgid ""
"When Emacs loads a file into memory, it checks for a Local Variables section "
"like this one at the end of the file.  If it finds this section, it does the "
"specified things (in this case, running @kbd{C-x * a} automatically) before "
"editing of the file begins.  The Local Variables section must be within 3000 "
"characters of the end of the file for Emacs to find it, and it must be in "
"the last page of the file if the file has any page separators.  @xref{File "
"Variables, , Local Variables in Files, emacs, the Emacs manual}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31076
msgid ""
"Note that @kbd{C-x * a} does not update the formulas it finds.  To do this, "
"type, say, @kbd{M-1 C-x * u} after @w{@kbd{C-x * a}}.  Generally this should "
"not be a problem, though, because the formulas will have been up-to-date "
"already when the file was saved."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31083
msgid ""
"Normally, @kbd{C-x * a} activates all the formulas it finds, but any "
"previous active formulas remain active as well.  With a positive numeric "
"prefix argument, @kbd{C-x * a} first deactivates all current active "
"formulas, then actives the ones it finds in its scan of the buffer.  With a "
"negative prefix argument, @kbd{C-x * a} simply deactivates all formulas."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31099
msgid ""
"Embedded mode has two symbols, @samp{Active} and @samp{~Active}, which it "
"puts next to the major mode name in a buffer's mode line.  It puts "
"@samp{Active} if it has reason to believe that all formulas in the buffer "
"are active, because you have typed @kbd{C-x * a} and Calc has not since had "
"to deactivate any formulas (which can happen if Calc goes to update an "
"@samp{=>} formula somewhere because a variable changed, and finds that the "
"formula is no longer there due to some kind of editing outside of Embedded "
"mode).  Calc puts @samp{~Active} in the mode line if some, but probably not "
"all, formulas in the buffer are active.  This happens if you activate a few "
"formulas one at a time but never use @kbd{C-x * a}, or if you used @kbd{C-x "
"* a} but then Calc had to deactivate a formula because it lost track of it.  "
"If neither of these symbols appears in the mode line, no embedded formulas "
"are active in the buffer (e.g., before Embedded mode has been used, or after "
"a @kbd{M-- C-x * a})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31104
msgid ""
"Embedded formulas can refer to assignments both before and after them in the "
"buffer.  If there are several assignments to a variable, the nearest "
"preceding assignment is used if there is one, otherwise the following "
"assignment is used."
msgstr ""

#. type: example
#: ../../calc.texi:31107 ../../calc.texi:31111
#, no-wrap
msgid ""
"x => 1\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:31109
#, no-wrap
msgid ""
"x := 1\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:31113
#, no-wrap
msgid ""
"x := 2\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:31115
#, no-wrap
msgid "x => 2\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31123
msgid ""
"As well as simple variables, you can also assign to subscript expressions of "
"the form @samp{@var{var}_@var{number}} (as in @code{x_0}), or "
"@samp{@var{var}_@var{var}} (as in @code{x_max}).  Assignments to other kinds "
"of objects can be represented by Calc, but the automatic linkage between "
"assignments and references works only for plain variables and these two "
"kinds of subscript expressions."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31131
msgid ""
"If there are no assignments to a given variable, the global stored value for "
"the variable is used (@pxref{Storing Variables}), or, if no value is stored, "
"the variable is left in symbolic form.  Note that global stored values will "
"be lost when the file is saved and loaded in a later Emacs session, unless "
"you have used the @kbd{s p} (@code{calc-permanent-variable}) command to save "
"them; @pxref{Operations on Variables}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31143
msgid ""
"The @kbd{m C} (@code{calc-auto-recompute}) command turns automatic "
"recomputation of @samp{=>} forms on and off.  If you turn automatic "
"recomputation off, you will have to use @kbd{C-x * u} to update these "
"formulas manually after an assignment has been changed.  If you plan to "
"change several assignments at once, it may be more efficient to type @kbd{m "
"C}, change all the assignments, then use @kbd{M-1 C-x * u} to update the "
"entire buffer afterwards.  The @kbd{m C} command also controls @samp{=>} "
"formulas on the stack; @pxref{Evaluates-To Operator}.  When you turn "
"automatic recomputation back on, the stack will be updated but the Embedded "
"buffer will not; you must use @kbd{C-x * u} to update the buffer by hand."
msgstr ""

#. type: kindex
#: ../../calc.texi:31147
#, no-wrap
msgid "m e"
msgstr ""

#. type: pindex
#: ../../calc.texi:31148
#, no-wrap
msgid "calc-embedded-preserve-modes"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31156
msgid ""
"The mode settings can be changed while Calc is in embedded mode, but by "
"default they will revert to their original values when embedded mode is "
"ended. However, the modes saved when the mode-recording mode is @code{Save} "
"(see below) and the modes in effect when the @kbd{m e} "
"(@code{calc-embedded-preserve-modes}) command is given will be preserved "
"when embedded mode is ended."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31163
msgid ""
"Embedded mode has a rather complicated mechanism for handling mode settings "
"in Embedded formulas.  It is possible to put annotations in the file that "
"specify mode settings either global to the entire file or local to a "
"particular formula or formulas.  In the latter case, different modes can be "
"specified for use when a formula is the enabled Embedded mode formula."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31168
msgid ""
"When you give any mode-setting command, like @kbd{m f} (for Fraction mode) "
"or @kbd{d s} (for scientific notation), Embedded mode adds a line like the "
"following one to the file just before the opening delimiter of the formula."
msgstr ""

#. type: example
#: ../../calc.texi:31172
#, no-wrap
msgid ""
"% [calc-mode: fractions: t]\n"
"% [calc-mode: float-format: (sci 0)]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31179
msgid ""
"When Calc interprets an embedded formula, it scans the text before the "
"formula for mode-setting annotations like these and sets the Calc buffer to "
"match these modes.  Modes not explicitly described in the file are not "
"changed.  Calc scans all the way to the top of the file, or up to a line of "
"the form"
msgstr ""

#. type: example
#: ../../calc.texi:31182
#, no-wrap
msgid "% [calc-defaults]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31188
msgid ""
"which you can insert at strategic places in the file if this backward scan "
"is getting too slow, or just to provide a barrier between one ``zone'' of "
"mode settings and another."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31193
msgid ""
"If the file contains several annotations for the same mode, the closest one "
"before the formula is used.  Annotations after the formula are never used "
"(except for global annotations, described below)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31203
msgid ""
"The scan does not look for the leading @samp{% }, only for the square "
"brackets and the text they enclose.  In fact, the leading characters are "
"different for different major modes.  You can edit the mode annotations to a "
"style that works better in context if you wish.  @xref{Customizing Embedded "
"Mode}, to see how to change the style that Calc uses when it generates the "
"annotations.  You can write mode annotations into the file yourself if you "
"know the syntax; the easiest way to find the syntax for a given mode is to "
"let Calc write the annotation for it once and see what it does."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31208
msgid ""
"If you give a mode-changing command for a mode that already has a suitable "
"annotation just above the current formula, Calc will modify that annotation "
"rather than generating a new, conflicting one."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31218
msgid ""
"Mode annotations have three parts, separated by colons.  (Spaces after the "
"colons are optional.)  The first identifies the kind of mode setting, the "
"second is a name for the mode itself, and the third is the value in the form "
"of a Lisp symbol, number, or list.  Annotations with unrecognizable text in "
"the first or second parts are ignored.  The third part is not checked to "
"make sure the value is of a valid type or range; if you write an annotation "
"by hand, be sure to give a proper value or results will be unpredictable.  "
"Mode-setting annotations are case-sensitive."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31225
msgid ""
"While Embedded mode is enabled, the word @code{Local} appears in the mode "
"line.  This is to show that mode setting commands generate annotations that "
"are ``local'' to the current formula or set of formulas.  The @kbd{m R} "
"(@code{calc-mode-record-mode}) command causes Calc to generate different "
"kinds of annotations.  Pressing @kbd{m R} repeatedly cycles through the "
"possible modes."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31228
msgid ""
"@code{LocEdit} and @code{LocPerm} modes generate annotations that look like "
"this, respectively:"
msgstr ""

#. type: example
#: ../../calc.texi:31232
#, no-wrap
msgid ""
"% [calc-edit-mode: float-format: (sci 0)]\n"
"% [calc-perm-mode: float-format: (sci 5)]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31239
msgid ""
"The first kind of annotation will be used only while a formula is enabled in "
"Embedded mode.  The second kind will be used only when the formula is "
"@emph{not} enabled.  (Whether the formula is ``active'' or not, i.e., "
"whether Calc has seen this formula yet, is not relevant here.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31242
msgid "@code{Global} mode generates an annotation like this at the end of the file:"
msgstr ""

#. type: example
#: ../../calc.texi:31245
#, no-wrap
msgid "% [calc-global-mode: fractions t]\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31252
msgid ""
"Global mode annotations affect all formulas throughout the file, and may "
"appear anywhere in the file.  This allows you to tuck your mode annotations "
"somewhere out of the way, say, on a new page of the file, as long as those "
"mode settings are suitable for all formulas in the file."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31258
msgid ""
"Enabling a formula with @kbd{C-x * e} causes a fresh scan for local mode "
"annotations; you will have to use this after adding annotations above a "
"formula by hand to get the formula to notice them.  Updating a formula with "
"@kbd{C-x * u} will also re-scan the local modes, but global modes are only "
"re-scanned by @kbd{C-x * a}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31265
msgid ""
"Another way that modes can get out of date is if you add a local mode "
"annotation to a formula that has another formula after it.  In this example, "
"we have used the @kbd{d s} command while the first of the two embedded "
"formulas is active.  But the second formula has not changed its style to "
"match, even though by the rules of reading annotations the @samp{(sci 0)} "
"applies to it, too."
msgstr ""

#. type: example
#: ../../calc.texi:31269
#, no-wrap
msgid ""
"% [calc-mode: float-format: (sci 0)]\n"
"1.23e2\n"
"\n"
msgstr ""

#. type: example
#: ../../calc.texi:31271
#, no-wrap
msgid "456.\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31275
msgid ""
"We would have to go down to the other formula and press @kbd{C-x * u} on it "
"in order to get it to notice the new annotation."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31285
msgid ""
"Two more mode-recording modes selectable by @kbd{m R} are available which "
"are also available outside of Embedded mode.  (@pxref{General Mode "
"Commands}.) They are @code{Save}, in which mode settings are recorded "
"permanently in your Calc init file (the file given by the variable "
"@code{calc-settings-file}, typically @file{~/.emacs.d/calc.el})  rather than "
"by annotating the current document, and no-recording mode (where there is no "
"symbol like @code{Save} or @code{Local} in the mode line), in which "
"mode-changing commands do not leave any annotations at all."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31288
msgid ""
"When Embedded mode is not enabled, mode-recording modes except for "
"@code{Save} have no effect."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31302
msgid ""
"You can modify Embedded mode's behavior by setting various Lisp variables "
"described here.  These variables are customizable (@pxref{Customizing "
"Calc}), or you can use @kbd{M-x set-variable} to adjust a variable on the "
"fly.  (Another possibility would be to use a file-local variable annotation "
"at the end of the file; @pxref{File Variables, , Local Variables in Files, "
"emacs, the Emacs manual}.)  Many of the variables given mentioned here can "
"be set to depend on the major mode of the editing buffer (@pxref{Customizing "
"Calc})."
msgstr ""

#. type: defvar
#: ../../calc.texi:31303 ../../calc.texi:35471
#, no-wrap
msgid "calc-embedded-open-formula"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31313
msgid ""
"The @code{calc-embedded-open-formula} variable holds a regular expression "
"for the opening delimiter of a formula.  @xref{Regexp Search, , Regular "
"Expression Search, emacs, the Emacs manual}, to see how regular expressions "
"work.  Basically, a regular expression is a pattern that Calc can search "
"for.  A regular expression that considers blank lines, @samp{$}, and "
"@samp{$$} to be opening delimiters is "
"@code{\"\\\\`\\\\|^\\n\\\\|\\\\$\\\\$?\"}.  Just in case the meaning of this "
"regular expression is not completely plain, let's go through it in detail."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31317
msgid ""
"The surrounding @samp{\" \"} marks quote the text between them as a Lisp "
"string.  If you left them off, @code{set-variable} (for example)  would try "
"to read the regular expression as a Lisp program."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31326
msgid ""
"The most obvious property of this regular expression is that it contains "
"indecently many backslashes.  There are actually two levels of backslash "
"usage going on here.  First, when Lisp reads a quoted string, all pairs of "
"characters beginning with a backslash are interpreted as special "
"characters.  Here, @code{\\n} changes to a new-line character, and "
"@code{\\\\} changes to a single backslash.  So the actual regular expression "
"seen by Calc is @samp{\\`\\|^ @r{(newline)} \\|\\$\\$?}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31333
msgid ""
"Regular expressions also consider pairs beginning with backslash to have "
"special meanings.  Sometimes the backslash is used to quote a character that "
"otherwise would have a special meaning in a regular expression, like "
"@samp{$}, which normally means ``end-of-line,'' or @samp{?}, which means "
"that the preceding item is optional.  So @samp{\\$\\$?} matches either one "
"or two dollar signs."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31340
msgid ""
"The other codes in this regular expression are @samp{^}, which matches "
"``beginning-of-line,'' @samp{\\|}, which means ``or,'' and @samp{\\`}, which "
"matches ``beginning-of-buffer.'' So the whole pattern means that a formula "
"begins at the beginning of the buffer, or on a newline that occurs at the "
"beginning of a line (i.e., a blank line), or at one or two dollar signs."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31344
msgid ""
"The default value of @code{calc-embedded-open-formula} looks just like this "
"example, with several more alternatives added on to recognize various other "
"common kinds of delimiters."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31352
msgid ""
"By the way, the reason to use @samp{^\\n} rather than @samp{^$} or "
"@samp{\\n\\n}, which also would appear to match blank lines, is that the "
"former expression actually ``consumes'' only one newline character as "
"@emph{part of} the delimiter, whereas the latter expressions consume zero or "
"two newlines, respectively.  The former choice gives the most natural "
"behavior when Calc must operate on a whole formula including its delimiters."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31360
msgid ""
"See the Emacs manual for complete details on regular expressions.  But just "
"for your convenience, here is a list of all characters which must be quoted "
"with backslash (like @samp{\\$}) to avoid some special interpretation: "
"@samp{. * + ? [ ] ^ $ \\}.  (Note the backslash in this list; for example, "
"to match @samp{\\[} you must use @code{\"\\\\\\\\\\\\[\"}.  An exercise for "
"the reader is to account for each of these six backslashes!)"
msgstr ""

#. type: defvarx
#: ../../calc.texi:31361 ../../calc.texi:35472
#, no-wrap
msgid "calc-embedded-close-formula"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31370
msgid ""
"The @code{calc-embedded-close-formula} variable holds a regular expression "
"for the closing delimiter of a formula.  A closing regular expression to "
"match the above example would be @code{\"\\\\'\\\\|\\n$\\\\|\\\\$\\\\$?\"}.  "
"This is almost the same as the other one, except it now uses @samp{\\'} "
"(``end-of-buffer'') and @samp{\\n$} (newline occurring at end of line, yet "
"another way of describing a blank line that is more appropriate for this "
"case)."
msgstr ""

#. type: defvar
#: ../../calc.texi:31371 ../../calc.texi:35509
#, no-wrap
msgid "calc-embedded-word-regexp"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31375
msgid ""
"The @code{calc-embedded-word-regexp} variable holds a regular expression "
"used to define an expression to look for (a ``word'') when you type @kbd{C-x "
"* w} to enable Embedded mode."
msgstr ""

#. type: defvar
#: ../../calc.texi:31376 ../../calc.texi:35527
#, no-wrap
msgid "calc-embedded-open-plain"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31384
msgid ""
"The @code{calc-embedded-open-plain} variable is a string which begins a "
"``plain'' formula written in front of the formatted formula when @kbd{d p} "
"mode is turned on.  Note that this is an actual string, not a regular "
"expression, because Calc must be able to write this string into a buffer as "
"well as to recognize it.  The default string is @code{\"%%% \"} (note the "
"trailing space), but may be different for certain major modes."
msgstr ""

#. type: defvarx
#: ../../calc.texi:31385 ../../calc.texi:35528
#, no-wrap
msgid "calc-embedded-close-plain"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31391
msgid ""
"The @code{calc-embedded-close-plain} variable is a string which ends a "
"``plain'' formula.  The default is @code{\" %%%\\n\"}, but may be different "
"for different major modes.  Without the trailing newline here, the first "
"line of a Big mode formula that followed might be shifted over with respect "
"to the other lines."
msgstr ""

#. type: defvar
#: ../../calc.texi:31392 ../../calc.texi:35568
#, no-wrap
msgid "calc-embedded-open-new-formula"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31400
msgid ""
"The @code{calc-embedded-open-new-formula} variable is a string which is "
"inserted at the front of a new formula when you type @kbd{C-x * f}.  Its "
"default value is @code{\"\\n\\n\"}.  If this string begins with a newline "
"character and the @kbd{C-x * f} is typed at the beginning of a line, "
"@kbd{C-x * f} will skip this first newline to avoid introducing unnecessary "
"blank lines in the file."
msgstr ""

#. type: defvarx
#: ../../calc.texi:31401 ../../calc.texi:35569
#, no-wrap
msgid "calc-embedded-close-new-formula"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31408
msgid ""
"The @code{calc-embedded-close-new-formula} variable is the corresponding "
"string which is inserted at the end of a new formula.  Its default value is "
"also @code{\"\\n\\n\"}.  The final newline is omitted by @w{@kbd{C-x * f}} "
"if typed at the end of a line.  (It follows that if @kbd{C-x * f} is typed "
"on a blank line, both a leading opening newline and a trailing closing "
"newline are omitted.)"
msgstr ""

#. type: defvar
#: ../../calc.texi:31409 ../../calc.texi:35434
#, no-wrap
msgid "calc-embedded-announce-formula"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31424
msgid ""
"The @code{calc-embedded-announce-formula} variable is a regular expression "
"which is sure to be followed by an embedded formula.  The @kbd{C-x * a} "
"command searches for this pattern as well as for @samp{=>} and @samp{:=} "
"operators.  Note that @kbd{C-x * a} will not activate just anything "
"surrounded by formula delimiters; after all, blank lines are considered "
"formula delimiters by default! But if your language includes a delimiter "
"which can only occur actually in front of a formula, you can take advantage "
"of it here.  The default pattern is @code{\"%Embed\\n\\\\(% .*\\n\\\\)*\"}, "
"but may be different for different major modes.  This pattern will check for "
"@samp{%Embed} followed by any number of lines beginning with @samp{%} and a "
"space.  This last is important to make Calc consider mode annotations part "
"of the pattern, so that the formula's opening delimiter really is sure to "
"follow the pattern."
msgstr ""

#. type: defvar
#: ../../calc.texi:31425 ../../calc.texi:35596
#, no-wrap
msgid "calc-embedded-open-mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31433
msgid ""
"The @code{calc-embedded-open-mode} variable is a string (not a regular "
"expression) which should precede a mode annotation.  Calc never scans for "
"this string; Calc always looks for the annotation itself.  But this is the "
"string that is inserted before the opening bracket when Calc adds an "
"annotation on its own.  The default is @code{\"% \"}, but may be different "
"for different major modes."
msgstr ""

#. type: defvarx
#: ../../calc.texi:31434 ../../calc.texi:35597
#, no-wrap
msgid "calc-embedded-close-mode"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31440
msgid ""
"The @code{calc-embedded-close-mode} variable is a string which follows a "
"mode annotation written by Calc.  Its default value is simply a newline, "
"@code{\"\\n\"}, but may be different for different major modes.  If you "
"change this, it is a good idea still to end with a newline so that mode "
"annotations will appear on lines by themselves."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31447
msgid ""
"There are several ways to ``program'' the Emacs Calculator, depending on the "
"nature of the problem you need to solve."
msgstr ""

#. type: enumerate
#: ../../calc.texi:31454
msgid ""
"@dfn{Keyboard macros} allow you to record a sequence of keystrokes and play "
"them back at a later time.  This is just the standard Emacs keyboard macro "
"mechanism, dressed up with a few more features such as loops and "
"conditionals."
msgstr ""

#. type: enumerate
#: ../../calc.texi:31459
msgid ""
"@dfn{Algebraic definitions} allow you to use any formula to define a new "
"function.  This function can then be used in algebraic formulas or as an "
"interactive command."
msgstr ""

#. type: enumerate
#: ../../calc.texi:31466
msgid ""
"@dfn{Rewrite rules} are discussed in the section on algebra commands.  "
"@xref{Rewrite Rules}.  If you put your rewrite rules in the variable "
"@code{EvalRules}, they will be applied automatically to all Calc results in "
"just the same way as an internal ``rule'' is applied to evaluate "
"@samp{sqrt(9)} to 3 and so on.  @xref{Automatic Rewrites}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:31473
msgid ""
"@dfn{Lisp} is the programming language that Calc (and most of Emacs)  is "
"written in.  If the above techniques aren't powerful enough, you can write "
"Lisp functions to do anything that built-in Calc commands can do.  Lisp code "
"is also somewhat faster than keyboard macros or rewrite rules."
msgstr ""

#. type: kindex
#: ../../calc.texi:31475
#, no-wrap
msgid "z"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31483
msgid ""
"Programming features are available through the @kbd{z} and @kbd{Z} prefix "
"keys.  New commands that you define are two-key sequences beginning with "
"@kbd{z}.  Commands for managing these definitions use the shift-@kbd{Z} "
"prefix.  (The @kbd{Z T} (@code{calc-timing})  command is described "
"elsewhere; @pxref{Troubleshooting Commands}.  The @kbd{Z C} "
"(@code{calc-user-define-composition}) command is also described elsewhere; "
"@pxref{User-Defined Compositions}.)"
msgstr ""

#. type: menuentry
#: ../../calc.texi:31490
msgid "Creating User Keys::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:31490
msgid "Keyboard Macros::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:31490
msgid "Invocation Macros::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:31490
msgid "Algebraic Definitions::"
msgstr ""

#. type: node
#: ../../calc.texi:31490 ../../calc.texi:31967 ../../calc.texi:32079 ../../calc.texi:32115 ../../calc.texi:32336 ../../calc.texi:32498 ../../calc.texi:32600 ../../calc.texi:32687 ../../calc.texi:32868 ../../calc.texi:33264
#, no-wrap
msgid "Lisp Definitions"
msgstr ""

#. type: node
#: ../../calc.texi:31492 ../../calc.texi:31493 ../../calc.texi:31567
#, no-wrap
msgid "Creating User Keys"
msgstr ""

#. type: subsubsection
#: ../../calc.texi:31492 ../../calc.texi:31567 ../../calc.texi:31610 ../../calc.texi:31660 ../../calc.texi:31736 ../../calc.texi:31829 ../../calc.texi:31894 ../../calc.texi:31934 ../../calc.texi:33159
#, no-wrap
msgid "Keyboard Macros"
msgstr ""

#. type: kindex
#: ../../calc.texi:31496
#, no-wrap
msgid "Z D"
msgstr ""

#. type: pindex
#: ../../calc.texi:31497
#, no-wrap
msgid "calc-user-define"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31501
msgid ""
"Any Calculator command may be bound to a key using the @kbd{Z D} "
"(@code{calc-user-define}) command.  Actually, it is bound to a two-key "
"sequence beginning with the lower-case @kbd{z} prefix."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31510
msgid ""
"The @kbd{Z D} command first prompts for the key to define.  For example, "
"press @kbd{Z D a} to define the new key sequence @kbd{z a}.  You are then "
"prompted for the name of the Calculator command that this key should run.  "
"For example, the @code{calc-sincos} command is not normally available on a "
"key.  Typing @kbd{Z D s sincos @key{RET}} programs the @kbd{z s} key "
"sequence to run @code{calc-sincos}.  This definition will remain in effect "
"for the rest of this Emacs session, or until you redefine @kbd{z s} to be "
"something else."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31513
msgid ""
"You can actually bind any Emacs command to a @kbd{z} key sequence by "
"backspacing over the @samp{calc-} when you are prompted for the command "
"name."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31517
msgid ""
"As with any other prefix key, you can type @kbd{z ?} to see a list of all "
"the two-key sequences you have defined that start with @kbd{z}.  Initially, "
"no @kbd{z} sequences (except @kbd{z ?} itself) are defined."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31523
msgid ""
"User keys are typically letters, but may in fact be any key.  "
"(@key{META}-keys are not permitted, nor are a terminal's special function "
"keys which generate multi-character sequences when pressed.)  You can define "
"different commands on the shifted and unshifted versions of a letter if you "
"wish."
msgstr ""

#. type: kindex
#: ../../calc.texi:31524
#, no-wrap
msgid "Z U"
msgstr ""

#. type: pindex
#: ../../calc.texi:31525
#, no-wrap
msgid "calc-user-undefine"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31529
msgid ""
"The @kbd{Z U} (@code{calc-user-undefine}) command unbinds a user key.  For "
"example, the key sequence @kbd{Z U s} will undefine the @code{sincos} key we "
"defined above."
msgstr ""

#. type: kindex
#: ../../calc.texi:31530
#, no-wrap
msgid "Z P"
msgstr ""

#. type: pindex
#: ../../calc.texi:31531
#, no-wrap
msgid "calc-user-define-permanent"
msgstr ""

#. type: cindex
#: ../../calc.texi:31532
#, no-wrap
msgid "Storing user definitions"
msgstr ""

#. type: cindex
#: ../../calc.texi:31533
#, no-wrap
msgid "Permanent user definitions"
msgstr ""

#. type: cindex
#: ../../calc.texi:31534
#, no-wrap
msgid "Calc init file, user-defined commands"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31544
msgid ""
"The @kbd{Z P} (@code{calc-user-define-permanent}) command makes a key "
"binding permanent so that it will remain in effect even in future Emacs "
"sessions.  (It does this by adding a suitable bit of Lisp code into your "
"Calc init file; that is, the file given by the variable "
"@code{calc-settings-file}, typically @file{~/.emacs.d/calc.el}.)  For "
"example, @kbd{Z P s} would register our @code{sincos} command permanently.  "
"If you later wish to unregister this command you must edit your Calc init "
"file by hand.  (@xref{General Mode Commands}, for a way to tell Calc to use "
"a different file for the Calc init file.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31558
msgid ""
"The @kbd{Z P} command also saves the user definition, if any, for the "
"command bound to the key.  After @kbd{Z F} and @kbd{Z C}, a given user key "
"could invoke a command, which in turn calls an algebraic function, which "
"might have one or more special display formats.  A single @kbd{Z P} command "
"will save all of these definitions.  To save an algebraic function, type "
"@kbd{'} (the apostrophe)  when prompted for a key, and type the function "
"name.  To save a command without its key binding, type @kbd{M-x} and enter a "
"function name.  (The @samp{calc-} prefix will automatically be inserted for "
"you.)  (If the command you give implies a function, the function will be "
"saved, and if the function has any display formats, those will be saved, but "
"not the other way around: Saving a function will not save any commands or "
"key bindings associated with the function.)"
msgstr ""

#. type: kindex
#: ../../calc.texi:31559
#, no-wrap
msgid "Z E"
msgstr ""

#. type: pindex
#: ../../calc.texi:31560
#, no-wrap
msgid "calc-user-define-edit"
msgstr ""

#. type: cindex
#: ../../calc.texi:31561
#, no-wrap
msgid "Editing user definitions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31566
msgid ""
"The @kbd{Z E} (@code{calc-user-define-edit}) command edits the definition of "
"a user key.  This works for keys that have been defined by either keyboard "
"macros or formulas; further details are contained in the relevant following "
"sections."
msgstr ""

#. type: node
#: ../../calc.texi:31567 ../../calc.texi:31934 ../../calc.texi:31935 ../../calc.texi:31967
#, no-wrap
msgid "Invocation Macros"
msgstr ""

#. type: section
#: ../../calc.texi:31568
#, no-wrap
msgid "Programming with Keyboard Macros"
msgstr ""

#. type: cindex
#: ../../calc.texi:31572
#, no-wrap
msgid "Programming with keyboard macros"
msgstr ""

#. type: cindex
#: ../../calc.texi:31573
#, no-wrap
msgid "Keyboard macros"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31582
msgid ""
"The easiest way to ``program'' the Emacs Calculator is to use standard "
"keyboard macros.  Press @w{@kbd{C-x (}} to begin recording a macro.  From "
"this point on, keystrokes you type will be saved away as well as performing "
"their usual functions.  Press @kbd{C-x )} to end recording.  Press "
"shift-@kbd{X} (or the standard Emacs key sequence @kbd{C-x e}) to execute "
"your keyboard macro by replaying the recorded keystrokes.  @xref{Keyboard "
"Macros, , , emacs, the Emacs Manual}, for further information."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31596
msgid ""
"When you use @kbd{X} to invoke a keyboard macro, the entire macro is treated "
"as a single command by the undo and trail features.  The stack display "
"buffer is not updated during macro execution, but is instead fixed up once "
"the macro completes.  Thus, commands defined with keyboard macros are "
"convenient and efficient.  The @kbd{C-x e} command, on the other hand, "
"invokes the keyboard macro with no special treatment: Each command in the "
"macro will record its own undo information and trail entry, and update the "
"stack buffer accordingly.  If your macro uses features outside of Calc's "
"control to operate on the contents of the Calc stack buffer, or if it "
"includes Undo, Redo, or last-arguments commands, you must use @kbd{C-x e} to "
"make sure the buffer and undo list are up-to-date at all times.  You could "
"also consider using @kbd{K} (@code{calc-keep-args})  instead of "
"@kbd{M-@key{RET}} (@code{calc-last-args})."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31601
msgid ""
"Calc extends the standard Emacs keyboard macros in several ways.  Keyboard "
"macros can be used to create user-defined commands.  Keyboard macros can "
"include conditional and iteration structures, somewhat analogous to those "
"provided by a traditional programmable calculator."
msgstr ""

#. type: menuentry
#: ../../calc.texi:31608
msgid "Naming Keyboard Macros::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:31608
msgid "Conditionals in Macros::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:31608
msgid "Loops in Macros::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:31608
msgid "Local Values in Macros::"
msgstr ""

#. type: node
#: ../../calc.texi:31608 ../../calc.texi:31829 ../../calc.texi:31894
#, no-wrap
msgid "Queries in Macros"
msgstr ""

#. type: node
#: ../../calc.texi:31610 ../../calc.texi:31611 ../../calc.texi:31660
#, no-wrap
msgid "Naming Keyboard Macros"
msgstr ""

#. type: node
#: ../../calc.texi:31610 ../../calc.texi:31660 ../../calc.texi:31736
#, no-wrap
msgid "Conditionals in Macros"
msgstr ""

#. type: kindex
#: ../../calc.texi:31614
#, no-wrap
msgid "Z K"
msgstr ""

#. type: pindex
#: ../../calc.texi:31615
#, no-wrap
msgid "calc-user-define-kbd-macro"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31628
msgid ""
"Once you have defined a keyboard macro, you can bind it to a @kbd{z} key "
"sequence with the @kbd{Z K} (@code{calc-user-define-kbd-macro}) command.  "
"This command prompts first for a key, then for a command name.  For example, "
"if you type @kbd{C-x ( n @key{TAB} n @key{TAB} C-x )} you will define a "
"keyboard macro which negates the top two numbers on the stack (@key{TAB} "
"swaps the top two stack elements).  Now you can type @kbd{Z K n @key{RET}} "
"to define this keyboard macro onto the @kbd{z n} key sequence.  The default "
"command name (if you answer the second prompt with just the @key{RET} key as "
"in this example) will be something like @samp{calc-User-n}.  The keyboard "
"macro will now be available as both @kbd{z n} and @kbd{M-x calc-User-n}.  "
"You can backspace and enter a more descriptive command name if you wish."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31633
msgid ""
"Macros defined by @kbd{Z K} act like single commands; they are executed in "
"the same way as by the @kbd{X} key.  If you wish to define the macro as a "
"standard no-frills Emacs macro (to be executed as if by @kbd{C-x e}), give a "
"negative prefix argument to @kbd{Z K}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31636
msgid ""
"Once you have bound your keyboard macro to a key, you can use @kbd{Z P} to "
"register it permanently with Emacs.  @xref{Creating User Keys}."
msgstr ""

#. type: cindex
#: ../../calc.texi:31637
#, no-wrap
msgid "Keyboard macros, editing"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31652
msgid ""
"The @kbd{Z E} (@code{calc-user-define-edit}) command on a key that has been "
"defined by a keyboard macro tries to use the @code{edmacro} package edit the "
"macro.  Type @kbd{C-c C-c} to finish editing and update the definition "
"stored on the key, or, to cancel the edit, kill the buffer with @kbd{C-x "
"k}.  The special characters @code{RET}, @code{LFD}, @code{TAB}, @code{SPC}, "
"@code{DEL}, and @code{NUL} must be entered as these three character "
"sequences, written in all uppercase, as must the prefixes @code{C-} and "
"@code{M-}.  Spaces and line breaks are ignored.  Other characters are copied "
"verbatim into the keyboard macro.  Basically, the notation is the same as is "
"used in all of this manual's examples, except that the manual takes some "
"liberties with spaces: When we say @kbd{' [1 2 3] @key{RET}}, we take it for "
"granted that it is clear we really mean @kbd{' [1 @key{SPC} 2 @key{SPC} 3] "
"@key{RET}}."
msgstr ""

#. type: kindex
#: ../../calc.texi:31653
#, no-wrap
msgid "C-x * m"
msgstr ""

#. type: pindex
#: ../../calc.texi:31654
#, no-wrap
msgid "read-kbd-macro"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31659
msgid ""
"The @kbd{C-x * m} (@code{read-kbd-macro}) command reads an Emacs ``region'' "
"of spelled-out keystrokes and defines it as the current keyboard macro.  It "
"is a convenient way to define a keyboard macro that has been stored in a "
"file, or to define a macro without executing it at the same time."
msgstr ""

#. type: node
#: ../../calc.texi:31660 ../../calc.texi:31736 ../../calc.texi:31829
#, no-wrap
msgid "Loops in Macros"
msgstr ""

#. type: subsection
#: ../../calc.texi:31661
#, no-wrap
msgid "Conditionals in Keyboard Macros"
msgstr ""

#. type: kindex
#: ../../calc.texi:31664
#, no-wrap
msgid "Z ["
msgstr ""

#. type: kindex
#: ../../calc.texi:31665
#, no-wrap
msgid "Z ]"
msgstr ""

#. type: pindex
#: ../../calc.texi:31666
#, no-wrap
msgid "calc-kbd-if"
msgstr ""

#. type: pindex
#: ../../calc.texi:31667
#, no-wrap
msgid "calc-kbd-else"
msgstr ""

#. type: pindex
#: ../../calc.texi:31668
#, no-wrap
msgid "calc-kbd-else-if"
msgstr ""

#. type: pindex
#: ../../calc.texi:31669
#, no-wrap
msgid "calc-kbd-end-if"
msgstr ""

#. type: cindex
#: ../../calc.texi:31670
#, no-wrap
msgid "Conditional structures"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31678
msgid ""
"The @kbd{Z [} (@code{calc-kbd-if}) and @kbd{Z ]} (@code{calc-kbd-end-if})  "
"commands allow you to put simple tests in a keyboard macro.  When Calc sees "
"the @kbd{Z [}, it pops an object from the stack and, if the object is a "
"non-zero value, continues executing keystrokes.  But if the object is zero, "
"or if it is not provably nonzero, Calc skips ahead to the matching @kbd{Z ]} "
"keystroke.  @xref{Logical Operations}, for a set of commands for performing "
"tests which conveniently produce 1 for true and 0 for false."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31685
msgid ""
"For example, @kbd{@key{RET} 0 a < Z [ n Z ]} implements an absolute-value "
"function in the form of a keyboard macro.  This macro duplicates the number "
"on the top of the stack, pushes zero and compares using @kbd{a <} "
"(@code{calc-less-than}), then, if the number was less than zero, executes "
"@kbd{n} (@code{calc-change-sign}).  Otherwise, the change-sign command is "
"skipped."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31692
msgid ""
"To program this macro, type @kbd{C-x (}, type the above sequence of "
"keystrokes, then type @kbd{C-x )}.  Note that the keystrokes will be "
"executed while you are making the definition as well as when you later "
"re-execute the macro by typing @kbd{X}.  Thus you should make sure a "
"suitable number is on the stack before defining the macro so that you don't "
"get a stack-underflow error during the definition process."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31695
msgid ""
"Conditionals can be nested arbitrarily.  However, there should be exactly "
"one @kbd{Z ]} for each @kbd{Z [} in a keyboard macro."
msgstr ""

#. type: kindex
#: ../../calc.texi:31696
#, no-wrap
msgid "Z :"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31704
msgid ""
"The @kbd{Z :} (@code{calc-kbd-else}) command allows you to choose between "
"two keystroke sequences.  The general format is @kbd{@var{cond} Z [ "
"@var{then-part} Z : @var{else-part} Z ]}.  If @var{cond} is true (i.e., if "
"the top of stack contains a non-zero number after @var{cond} has been "
"executed), the @var{then-part} will be executed and the @var{else-part} will "
"be skipped.  Otherwise, the @var{then-part} will be skipped and the "
"@var{else-part} will be executed."
msgstr ""

#. type: kindex
#: ../../calc.texi:31705
#, no-wrap
msgid "Z |"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31712
msgid ""
"The @kbd{Z |} (@code{calc-kbd-else-if}) command allows you to choose between "
"any number of alternatives.  For example, @kbd{@var{cond1} Z [ @var{part1} Z "
": @var{cond2} Z | @var{part2} Z : @var{part3} Z ]} will execute @var{part1} "
"if @var{cond1} is true, otherwise it will execute @var{part2} if @var{cond2} "
"is true, otherwise it will execute @var{part3}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31720
msgid ""
"More precisely, @kbd{Z [} pops a number and conditionally skips to the next "
"matching @kbd{Z :} or @kbd{Z ]} key.  @w{@kbd{Z ]}} has no effect when "
"actually executed.  @kbd{Z :} skips to the next matching @kbd{Z ]}.  @kbd{Z "
"|} pops a number and conditionally skips to the next matching @kbd{Z :} or "
"@kbd{Z ]}; thus, @kbd{Z [} and @kbd{Z |} are functionally equivalent except "
"that @kbd{Z [} participates in nesting but @kbd{Z |} does not."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31730
msgid ""
"Calc's conditional and looping constructs work by scanning the keyboard "
"macro for occurrences of character sequences like @samp{Z:} and @samp{Z]}.  "
"One side-effect of this is that if you use these constructs you must be "
"careful that these character pairs do not occur by accident in other parts "
"of the macros.  Since Calc rarely uses shift-@kbd{Z} for any purpose except "
"as a prefix character, this is not likely to be a problem.  Another "
"side-effect is that it will not work to define your own custom key bindings "
"for these commands.  Only the standard shift-@kbd{Z} bindings will work "
"correctly."
msgstr ""

#. type: kindex
#: ../../calc.texi:31731
#, no-wrap
msgid "Z C-g"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31735
msgid ""
"If Calc gets stuck while skipping characters during the definition of a "
"macro, type @kbd{Z C-g} to cancel the definition.  (Typing plain @kbd{C-g} "
"actually adds a @kbd{C-g} keystroke to the macro.)"
msgstr ""

#. type: node
#: ../../calc.texi:31736 ../../calc.texi:31829 ../../calc.texi:31830 ../../calc.texi:31894
#, no-wrap
msgid "Local Values in Macros"
msgstr ""

#. type: subsection
#: ../../calc.texi:31737
#, no-wrap
msgid "Loops in Keyboard Macros"
msgstr ""

#. type: kindex
#: ../../calc.texi:31740
#, no-wrap
msgid "Z <"
msgstr ""

#. type: kindex
#: ../../calc.texi:31741
#, no-wrap
msgid "Z >"
msgstr ""

#. type: pindex
#: ../../calc.texi:31742
#, no-wrap
msgid "calc-kbd-repeat"
msgstr ""

#. type: pindex
#: ../../calc.texi:31743
#, no-wrap
msgid "calc-kbd-end-repeat"
msgstr ""

#. type: cindex
#: ../../calc.texi:31744
#, no-wrap
msgid "Looping structures"
msgstr ""

#. type: cindex
#: ../../calc.texi:31745
#, no-wrap
msgid "Iterative structures"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31755
msgid ""
"The @kbd{Z <} (@code{calc-kbd-repeat}) and @kbd{Z >} "
"(@code{calc-kbd-end-repeat}) commands pop a number from the stack, which "
"must be an integer, then repeat the keystrokes between the brackets the "
"specified number of times.  If the integer is zero or negative, the body is "
"skipped altogether.  For example, @kbd{1 @key{TAB} Z < 2 * Z >} computes two "
"to a nonnegative integer power.  First, we push 1 on the stack and then swap "
"the integer argument back to the top.  The @kbd{Z <} pops that argument "
"leaving the 1 back on top of the stack.  Then, we repeat a multiply-by-two "
"step however many times."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31765
msgid ""
"Once again, the keyboard macro is executed as it is being entered.  In this "
"case it is especially important to set up reasonable initial conditions "
"before making the definition: Suppose the integer 1000 just happened to be "
"sitting on the stack before we typed the above definition! Another approach "
"is to enter a harmless dummy definition for the macro, then go back and edit "
"in the real one with a @kbd{Z E} command.  Yet another approach is to type "
"the macro as written-out keystroke names in a buffer, then use @kbd{C-x * m} "
"(@code{read-kbd-macro}) to read the macro."
msgstr ""

#. type: kindex
#: ../../calc.texi:31766
#, no-wrap
msgid "Z /"
msgstr ""

#. type: pindex
#: ../../calc.texi:31767
#, no-wrap
msgid "calc-break"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31775
msgid ""
"The @kbd{Z /} (@code{calc-kbd-break}) command allows you to break out of a "
"keyboard macro loop prematurely.  It pops an object from the stack; if that "
"object is true (a non-zero number), control jumps out of the innermost "
"enclosing @kbd{Z <} @dots{} @kbd{Z >} loop and continues after the @kbd{Z "
">}.  If the object is false, the @kbd{Z /} has no effect.  Thus "
"@kbd{@var{cond} Z /} is similar to @samp{if (@var{cond}) break;} in the C "
"language."
msgstr ""

#. type: kindex
#: ../../calc.texi:31776
#, no-wrap
msgid "Z ("
msgstr ""

#. type: kindex
#: ../../calc.texi:31777
#, no-wrap
msgid "Z )"
msgstr ""

#. type: pindex
#: ../../calc.texi:31778
#, no-wrap
msgid "calc-kbd-for"
msgstr ""

#. type: pindex
#: ../../calc.texi:31779
#, no-wrap
msgid "calc-kbd-end-for"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31789
msgid ""
"The @kbd{Z (} (@code{calc-kbd-for}) and @kbd{Z )} (@code{calc-kbd-end-for})  "
"commands are similar to @kbd{Z <} and @kbd{Z >}, except that they make the "
"value of the counter available inside the loop.  The general layout is "
"@kbd{@var{init} @var{final} Z ( @var{body} @var{step} Z )}.  The @kbd{Z (} "
"command pops initial and final values from the stack.  It then creates a "
"temporary internal counter and initializes it with the value @var{init}.  "
"The @kbd{Z (} command then repeatedly pushes the counter value onto the "
"stack and executes @var{body} and @var{step}, adding @var{step} to the "
"counter each time until the loop finishes."
msgstr ""

#. type: cindex
#: ../../calc.texi:31790
#, no-wrap
msgid "Summations (by keyboard macros)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31797
msgid ""
"By default, the loop finishes when the counter becomes greater than (or less "
"than) @var{final}, assuming @var{initial} is less than (greater than) "
"@var{final}.  If @var{initial} is equal to @var{final}, the body executes "
"exactly once.  The body of the loop always executes at least once.  For "
"example, @kbd{0 1 10 Z ( 2 ^ + 1 Z )} computes the sum of the squares of the "
"integers from 1 to 10, in steps of 1."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31804
msgid ""
"If you give a numeric prefix argument of 1 to @kbd{Z (}, the loop is forced "
"to use upward-counting conventions.  In this case, if @var{initial} is "
"greater than @var{final} the body will not be executed at all.  Note that "
"@var{step} may still be negative in this loop; the prefix argument merely "
"constrains the loop-finished test.  Likewise, a prefix argument of "
"@mathit{-1} forces downward-counting conventions."
msgstr ""

#. type: kindex
#: ../../calc.texi:31805
#, no-wrap
msgid "Z @{"
msgstr ""

#. type: kindex
#: ../../calc.texi:31806
#, no-wrap
msgid "Z @}"
msgstr ""

#. type: pindex
#: ../../calc.texi:31807
#, no-wrap
msgid "calc-kbd-loop"
msgstr ""

#. type: pindex
#: ../../calc.texi:31808
#, no-wrap
msgid "calc-kbd-end-loop"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31819
msgid ""
"The @kbd{Z @{} (@code{calc-kbd-loop}) and @kbd{Z @}} "
"(@code{calc-kbd-end-loop}) commands are similar to @kbd{Z <} and @kbd{Z >}, "
"except that they do not pop a count from the stack---they effectively create "
"an infinite loop.  Every @kbd{Z @{} @dots{} @kbd{Z @}} loop ought to include "
"at least one @kbd{Z /} to make sure the loop doesn't run forever.  (If any "
"error message occurs which causes Emacs to beep, the keyboard macro will "
"also be halted; this is a standard feature of Emacs.  You can also generally "
"press @kbd{C-g} to halt a running keyboard macro, although not all versions "
"of Unix support this feature.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31825
msgid ""
"The conditional and looping constructs are not actually tied to keyboard "
"macros, but they are most often used in that context.  For example, the "
"keystrokes @kbd{10 Z < 23 @key{RET} Z >} push ten copies of 23 onto the "
"stack.  This can be typed ``live'' just as easily as in a macro definition."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31828
msgid ""
"@xref{Conditionals in Macros}, for some additional notes about conditional "
"and looping commands."
msgstr ""

#. type: cindex
#: ../../calc.texi:31833
#, no-wrap
msgid "Local variables"
msgstr ""

#. type: cindex
#: ../../calc.texi:31834
#, no-wrap
msgid "Restoring saved modes"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31840
msgid ""
"Keyboard macros sometimes want to operate under known conditions without "
"affecting surrounding conditions.  For example, a keyboard macro may wish to "
"turn on Fraction mode, or set a particular precision, independent of the "
"user's normal setting for those modes."
msgstr ""

#. type: kindex
#: ../../calc.texi:31841
#, no-wrap
msgid "Z `"
msgstr ""

#. type: kindex
#: ../../calc.texi:31842
#, no-wrap
msgid "Z '"
msgstr ""

#. type: pindex
#: ../../calc.texi:31843
#, no-wrap
msgid "calc-kbd-push"
msgstr ""

#. type: pindex
#: ../../calc.texi:31844
#, no-wrap
msgid "calc-kbd-pop"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31849
msgid ""
"Macros also sometimes need to use local variables.  Assignments to local "
"variables inside the macro should not affect any variables outside the "
"macro.  The @kbd{Z `} (@code{calc-kbd-push}) and @kbd{Z '} "
"(@code{calc-kbd-pop}) commands give you both of these capabilities."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31855
msgid ""
"When you type @kbd{Z `} (with a grave accent), the values of various mode "
"settings are saved away.  The ten ``quick'' variables @code{q0} through "
"@code{q9} are also saved.  When you type @w{@kbd{Z '}} (with an apostrophe), "
"these values are restored.  Pairs of @kbd{Z `} and @kbd{Z '} commands may be "
"nested."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31861
msgid ""
"If a keyboard macro halts due to an error in between a @kbd{Z `} and a "
"@kbd{Z '}, the saved values will be restored correctly even though the macro "
"never reaches the @kbd{Z '} command.  Thus you can use @kbd{Z `} and @kbd{Z "
"'} without having to worry about what happens in exceptional conditions."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31869
msgid ""
"If you type @kbd{Z `} ``live'' (not in a keyboard macro), Calc puts you into "
"a ``recursive edit.'' You can tell you are in a recursive edit because there "
"will be extra square brackets in the mode line, as in "
"@samp{[(Calculator)]}.  These brackets will go away when you type the "
"matching @kbd{Z '} command.  The modes and quick variables will be saved and "
"restored in just the same way as if actual keyboard macros were involved."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31876
msgid ""
"The modes saved by @kbd{Z `} and @kbd{Z '} are the current precision and "
"binary word size, the angular mode (Deg, Rad, or HMS), the simplification "
"mode, Algebraic mode, Symbolic mode, Infinite mode, Matrix or Scalar mode, "
"Fraction mode, and the current complex mode (Polar or Rectangular).  The ten "
"``quick'' variables' values (or lack thereof) are also saved."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31882
msgid ""
"Most mode-setting commands act as toggles, but with a numeric prefix they "
"force the mode either on (positive prefix) or off (negative or zero "
"prefix).  Since you don't know what the environment might be when you invoke "
"your macro, it's best to use prefix arguments for all mode-setting commands "
"inside the macro."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31889
msgid ""
"In fact, @kbd{C-u Z `} is like @kbd{Z `} except that it sets the modes "
"listed above to their default values.  As usual, the matching @kbd{Z '} will "
"restore the modes to their settings from before the @kbd{C-u Z `}.  Also, "
"@w{@kbd{Z `}} with a negative prefix argument resets the algebraic mode to "
"its default (off) but leaves the other modes the same as they were outside "
"the construct."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31893
msgid ""
"The contents of the stack and trail, values of non-quick variables, and "
"other settings such as the language mode and the various display modes, are "
"@emph{not} affected by @kbd{Z `} and @kbd{Z '}."
msgstr ""

#. type: subsection
#: ../../calc.texi:31895
#, no-wrap
msgid "Queries in Keyboard Macros"
msgstr ""

#. type: kindex
#: ../../calc.texi:31907
#, no-wrap
msgid "Z #"
msgstr ""

#. type: pindex
#: ../../calc.texi:31908
#, no-wrap
msgid "calc-kbd-query"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31920
msgid ""
"The @kbd{Z #} (@code{calc-kbd-query}) command prompts for an algebraic entry "
"which takes its input from the keyboard, even during macro execution.  All "
"the normal conventions of algebraic input, including the use of @kbd{$} "
"characters, are supported.  The prompt message itself is taken from the top "
"of the stack, and so must be entered (as a string)  before the @kbd{Z #} "
"command.  (Recall, as a string it can be entered by pressing the @kbd{\"} "
"key and will appear as a vector when it is put on the stack.  The prompt "
"message is only put on the stack to provide a prompt for the @kbd{Z #} "
"command; it will not play any role in any subsequent calculations.)  This "
"command allows your keyboard macros to accept numbers or formulas as "
"interactive input."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31926
msgid ""
"As an example, @kbd{2 @key{RET} \"Power: \" @key{RET} Z # 3 @key{RET} ^} "
"will prompt for input with ``Power: '' in the minibuffer, then return 2 to "
"the provided power.  (The response to the prompt that's given, 3 in this "
"example, will not be part of the macro.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31933
msgid ""
"@xref{Keyboard Macro Query, , , emacs, the Emacs Manual}, for a description "
"of @kbd{C-x q} (@code{kbd-macro-query}), the standard Emacs way to accept "
"keyboard input during a keyboard macro.  In particular, you can use @kbd{C-x "
"q} to enter a recursive edit, which allows the user to perform any "
"Calculator operations interactively before pressing @kbd{C-M-c} to return "
"control to the keyboard macro."
msgstr ""

#. type: node
#: ../../calc.texi:31934 ../../calc.texi:31967 ../../calc.texi:32079
#, no-wrap
msgid "Algebraic Definitions"
msgstr ""

#. type: kindex
#: ../../calc.texi:31937
#, no-wrap
msgid "C-x * z"
msgstr ""

#. type: kindex
#: ../../calc.texi:31938
#, no-wrap
msgid "Z I"
msgstr ""

#. type: pindex
#: ../../calc.texi:31939
#, no-wrap
msgid "calc-user-invocation"
msgstr ""

#. type: pindex
#: ../../calc.texi:31940
#, no-wrap
msgid "calc-user-define-invocation"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31949
msgid ""
"Calc provides one special keyboard macro, called up by @kbd{C-x * z} "
"(@code{calc-user-invocation}), that is intended to allow you to define your "
"own special way of starting Calc.  To define this ``invocation macro,'' "
"create the macro in the usual way with @kbd{C-x (} and @kbd{C-x )}, then "
"type @kbd{Z I} (@code{calc-user-define-invocation}).  There is only one "
"invocation macro, so you don't need to type any additional letters after "
"@kbd{Z I}.  From now on, you can type @kbd{C-x * z} at any time to execute "
"your invocation macro."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31956
msgid ""
"For example, suppose you find yourself often grabbing rectangles of numbers "
"into Calc and multiplying their columns.  You can do this by typing @kbd{C-x "
"* r} to grab, and @kbd{V R : *} to multiply columns.  To make this into an "
"invocation macro, just type @kbd{C-x ( C-x * r V R : * C-x )}, then @kbd{Z "
"I}.  Then, to multiply a rectangle of data, just mark the data in its buffer "
"in the usual way and type @kbd{C-x * z}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31962
msgid ""
"Invocation macros are treated like regular Emacs keyboard macros; all the "
"special features described above for @kbd{Z K}-style macros do not apply.  "
"@kbd{C-x * z} is just like @kbd{C-x e}, except that it uses the macro that "
"was last stored by @kbd{Z I}.  (In fact, the macro does not even have to "
"have anything to do with Calc!)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31966
msgid ""
"The @kbd{m m} command saves the last invocation macro defined by @kbd{Z I} "
"along with all the other Calc mode settings.  @xref{General Mode Commands}."
msgstr ""

#. type: section
#: ../../calc.texi:31968
#, no-wrap
msgid "Programming with Formulas"
msgstr ""

#. type: kindex
#: ../../calc.texi:31971
#, no-wrap
msgid "Z F"
msgstr ""

#. type: pindex
#: ../../calc.texi:31972
#, no-wrap
msgid "calc-user-define-formula"
msgstr ""

#. type: cindex
#: ../../calc.texi:31973
#, no-wrap
msgid "Programming with algebraic formulas"
msgstr ""

#. type: Plain text
#: ../../calc.texi:31980
msgid ""
"Another way to create a new Calculator command uses algebraic formulas.  The "
"@kbd{Z F} (@code{calc-user-define-formula}) command stores the formula at "
"the top of the stack as the definition for a key.  This command prompts for "
"five things: The key, the command name, the function name, the argument "
"list, and the behavior of the command when given non-numeric arguments."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31988
msgid ""
"For example, suppose we type @kbd{' a+2b @key{RET}} to push the formula "
"@samp{a + 2*b} onto the stack.  We now type @kbd{Z F m} to define this "
"formula on the @kbd{z m} key sequence.  The next prompt is for a command "
"name, beginning with @samp{calc-}, which should be the long (@kbd{M-x}) form "
"for the new command.  If you simply press @key{RET}, a default name like "
"@code{calc-User-m} will be constructed.  In our example, suppose we enter "
"@kbd{spam @key{RET}} to define the new command as @code{calc-spam}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:31993
msgid ""
"If you want to give the formula a long-style name only, you can press "
"@key{SPC} or @key{RET} when asked which single key to use.  For example "
"@kbd{Z F @key{RET} spam @key{RET}} defines the new command as @kbd{M-x "
"calc-spam}, with no keyboard equivalent."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32003
msgid ""
"The third prompt is for an algebraic function name.  The default is to use "
"the same name as the command name but without the @samp{calc-} prefix.  (If "
"this is of the form @samp{User-m}, the hyphen is removed so it won't be "
"taken for a minus sign in algebraic formulas.)  This is the name you will "
"use if you want to enter your new function in an algebraic formula.  Suppose "
"we enter @kbd{yow @key{RET}}.  Then the new function can be invoked by "
"pushing two numbers on the stack and typing @kbd{z m} or @kbd{x spam}, or by "
"entering the algebraic formula @samp{yow(x,y)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32016
msgid ""
"The fourth prompt is for the function's argument list.  This is used to "
"associate values on the stack with the variables that appear in the "
"formula.  The default is a list of all variables which appear in the "
"formula, sorted into alphabetical order.  In our case, the default would be "
"@samp{(a b)}.  This means that, when the user types @kbd{z m}, the "
"Calculator will remove two numbers from the stack, substitute these numbers "
"for @samp{a} and @samp{b} (respectively) in the formula, then simplify the "
"formula and push the result on the stack.  In other words, @kbd{10 @key{RET} "
"100 z m} would replace the 10 and 100 on the stack with the number 210, "
"which is @expr{a + 2 b} with @expr{a=10} and @expr{b=100}.  Likewise, the "
"formula @samp{yow(10, 100)} will be evaluated by substituting @expr{a=10} "
"and @expr{b=100} in the definition."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32024
msgid ""
"You can rearrange the order of the names before pressing @key{RET} to "
"control which stack positions go to which variables in the formula.  If you "
"remove a variable from the argument list, that variable will be left in "
"symbolic form by the command.  Thus using an argument list of @samp{(b)} for "
"our function would cause @kbd{10 z m} to replace the 10 on the stack with "
"the formula @samp{a + 20}.  If we had used an argument list of @samp{(b a)}, "
"the result with inputs 10 and 100 would have been 120."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32029
msgid ""
"You can also put a nameless function on the stack instead of just a formula, "
"as in @samp{<a, b : a + 2 b>}.  @xref{Specifying Operators}.  In this "
"example, the command will be defined by the formula @samp{a + 2 b} using the "
"argument list @samp{(a b)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32039
msgid ""
"The final prompt is a y-or-n question concerning what to do if symbolic "
"arguments are given to your function.  If you answer @kbd{y}, then executing "
"@kbd{z m} (using the original argument list @samp{(a b)}) with arguments "
"@expr{10} and @expr{x} will leave the function in symbolic form, i.e., "
"@samp{yow(10,x)}.  On the other hand, if you answer @kbd{n}, then the "
"formula will always be expanded, even for non-constant arguments: @samp{10 + "
"2 x}.  If you never plan to feed algebraic formulas to your new function, it "
"doesn't matter how you answer this question."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32044
msgid ""
"If you answered @kbd{y} to this question you can still cause a function call "
"to be expanded by typing @kbd{a \"} (@code{calc-expand-formula}).  Also, "
"Calc will expand the function if necessary when you take a derivative or "
"integral or solve an equation involving the function."
msgstr ""

#. type: kindex
#: ../../calc.texi:32045
#, no-wrap
msgid "Z G"
msgstr ""

#. type: pindex
#: ../../calc.texi:32046
#, no-wrap
msgid "calc-get-user-defn"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32054
msgid ""
"Once you have defined a formula on a key, you can retrieve this formula with "
"the @kbd{Z G} (@code{calc-user-define-get-defn}) command.  Press a key, and "
"this command pushes the formula that was used to define that key onto the "
"stack.  Actually, it pushes a nameless function that specifies both the "
"argument list and the defining formula.  You will get an error message if "
"the key is undefined, or if the key was not defined by a @kbd{Z F} command."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32064
msgid ""
"The @kbd{Z E} (@code{calc-user-define-edit}) command on a key that has been "
"defined by a formula uses a variant of the @code{calc-edit} command to edit "
"the defining formula.  Press @kbd{C-c C-c} to finish editing and store the "
"new formula back in the definition, or kill the buffer with @kbd{C-x k} to "
"cancel the edit.  (The argument list and other properties of the definition "
"are unchanged; to adjust the argument list, you can use @kbd{Z G} to grab "
"the function onto the stack, edit with @kbd{`}, and then re-execute the "
"@kbd{Z F} command.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32068
msgid ""
"As usual, the @kbd{Z P} command records your definition permanently.  In "
"this case it will permanently record all three of the relevant definitions: "
"the key, the command, and the function."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32078
msgid ""
"You may find it useful to turn off the default simplifications with @kbd{m "
"O} (@code{calc-no-simplify-mode}) when entering a formula to be used as a "
"function definition.  For example, the formula @samp{deriv(a^2,v)} which "
"might be used to define a new function @samp{dsqr(a,v)} will be "
"``simplified'' to 0 immediately upon entry since @code{deriv} considers "
"@expr{a} to be constant with respect to @expr{v}.  Turning off default "
"simplifications cures this problem: The definition will be stored in "
"symbolic form without ever activating the @code{deriv} function.  Press "
"@kbd{m D} to turn the default simplifications back on afterwards."
msgstr ""

#. type: section
#: ../../calc.texi:32080
#, no-wrap
msgid "Programming with Lisp"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32092
msgid ""
"The Calculator can be programmed quite extensively in Lisp.  All you do is "
"write a normal Lisp function definition, but with @code{defmath} in place of "
"@code{defun}.  This has the same form as @code{defun}, but it automagically "
"replaces calls to standard Lisp functions like @code{+} and @code{zerop} "
"with calls to the corresponding functions in Calc's own library.  Thus you "
"can write natural-looking Lisp code which operates on all of the standard "
"Calculator data types.  You can then use @kbd{Z D} if you wish to bind your "
"new command to a @kbd{z}-prefix key sequence.  The @kbd{Z E} command will "
"not edit a Lisp-based definition."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32097
msgid ""
"Emacs Lisp is described in the GNU Emacs Lisp Reference Manual.  This "
"section assumes a familiarity with Lisp programming concepts; if you do not "
"know Lisp, you may find keyboard macros or rewrite rules to be an easier way "
"to program the Calculator."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32103
msgid ""
"This section first discusses ways to write commands, functions, or small "
"programs to be executed inside of Calc.  Then it discusses how your own "
"separate programs are able to call Calc from the outside.  Finally, there is "
"a list of internal Calc functions and data structures for the true Lisp "
"enthusiast."
msgstr ""

#. type: menuentry
#: ../../calc.texi:32110
msgid "Defining Functions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:32110
msgid "Defining Simple Commands::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:32110
msgid "Defining Stack Commands::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:32110
msgid "Argument Qualifiers::"
msgstr ""

#. type: node
#: ../../calc.texi:32110 ../../calc.texi:32600 ../../calc.texi:32687 ../../calc.texi:32688 ../../calc.texi:32700 ../../calc.texi:32784 ../../calc.texi:32868
#, no-wrap
msgid "Example Definitions"
msgstr ""

#. type: menuentry
#: ../../calc.texi:32113
msgid "Calling Calc from Your Programs::"
msgstr ""

#. type: node
#: ../../calc.texi:32113 ../../calc.texi:32868 ../../calc.texi:33264 ../../calc.texi:33304 ../../calc.texi:33444 ../../calc.texi:33505 ../../calc.texi:33692 ../../calc.texi:33960 ../../calc.texi:34304 ../../calc.texi:34441 ../../calc.texi:35012 ../../calc.texi:35158
#, no-wrap
msgid "Internals"
msgstr ""

#. type: node
#: ../../calc.texi:32115 ../../calc.texi:32336
#, no-wrap
msgid "Defining Functions"
msgstr ""

#. type: node
#: ../../calc.texi:32115 ../../calc.texi:32336 ../../calc.texi:32498
#, no-wrap
msgid "Defining Simple Commands"
msgstr ""

#. type: subsection
#: ../../calc.texi:32116
#, no-wrap
msgid "Defining New Functions"
msgstr ""

#. type: findex
#: ../../calc.texi:32119
#, no-wrap
msgid "defmath"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32125
msgid ""
"The @code{defmath} function (actually a Lisp macro) is like @code{defun} "
"except that code in the body of the definition can make use of the full "
"range of Calculator data types.  The prefix @samp{calcFunc-} is added to the "
"specified name to get the actual Lisp function name.  As a simple example,"
msgstr ""

#. type: example
#: ../../calc.texi:32131
#, no-wrap
msgid ""
"(defmath myfact (n)\n"
"  (if (> n 0)\n"
"      (* n (myfact (1- n)))\n"
"    1))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32135
msgid "This actually expands to the code,"
msgstr ""

#. type: example
#: ../../calc.texi:32141
#, no-wrap
msgid ""
"(defun calcFunc-myfact (n)\n"
"  (if (math-posp n)\n"
"      (math-mul n (calcFunc-myfact (math-add n -1)))\n"
"    1))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32145
msgid "This function can be used in algebraic expressions, e.g., @samp{myfact(5)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32150
msgid ""
"The @samp{myfact} function as it is defined above has the bug that an "
"expression @samp{myfact(a+b)} will be simplified to 1 because the formula "
"@samp{a+b} is not considered to be @code{posp}.  A robust factorial function "
"would be written along the following lines:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32158
#, no-wrap
msgid ""
"(defmath myfact (n)\n"
"  (if (> n 0)\n"
"      (* n (myfact (1- n)))\n"
"    (if (= n 0)\n"
"        1\n"
"      nil)))    ; this could be simplified as: (and (= n 0) 1)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32166
msgid ""
"If a function returns @code{nil}, it is left unsimplified by the Calculator "
"(except that its arguments will be simplified).  Thus, @samp{myfact(a+1+2)} "
"will be simplified to @samp{myfact(a+3)} but no further.  Beware that every "
"time the Calculator reexamines this formula it will attempt to resimplify "
"it, so your function ought to detect the returning-@code{nil} case as "
"efficiently as possible."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32173
msgid ""
"The following standard Lisp functions are treated by @code{defmath}: "
"@code{+}, @code{-}, @code{*}, @code{/}, @code{%}, @code{^} or @code{expt}, "
"@code{=}, @code{<}, @code{>}, @code{<=}, @code{>=}, @code{/=}, @code{1+}, "
"@code{1-}, @code{logand}, @code{logior}, @code{logxor}, @code{logandc2}, "
"@code{lognot}.  Also, @code{~=} is an abbreviation for "
"@code{math-nearly-equal}, which is useful in implementing Taylor series."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32181
msgid ""
"For other functions @var{func}, if a function by the name "
"@samp{calcFunc-@var{func}} exists it is used, otherwise if a function by the "
"name @samp{math-@var{func}} exists it is used, otherwise if @var{func} "
"itself is defined as a function it is used, otherwise "
"@samp{calcFunc-@var{func}} is used on the assumption that this is a "
"to-be-defined math function.  Also, if the function name is quoted as in "
"@samp{('integerp a)} the function name is always used exactly as written "
"(but not quoted)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32187
msgid ""
"Variable names have @samp{var-} prepended to them unless they appear in the "
"function's argument list or in an enclosing @code{let}, @code{let*}, "
"@code{for}, or @code{foreach} form, or their names already contain a "
"@samp{-} character.  Thus a reference to @samp{foo} is the same as a "
"reference to @samp{var-foo}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32189
msgid "A few other Lisp extensions are available in @code{defmath} definitions:"
msgstr ""

#. type: itemize
#: ../../calc.texi:32197
msgid ""
"The @code{elt} function accepts any number of index variables.  Note that "
"Calc vectors are stored as Lisp lists whose first element is the symbol "
"@code{vec}; thus, @samp{(elt v 2)} yields the second element of vector "
"@code{v}, and @samp{(elt m i j)} yields one element of a Calc matrix."
msgstr ""

#. type: itemize
#: ../../calc.texi:32206
msgid ""
"The @code{setq} function has been extended to act like the Common Lisp "
"@code{setf} function.  (The name @code{setf} is recognized as a synonym of "
"@code{setq}.)  Specifically, the first argument of @code{setq} can be an "
"@code{nth}, @code{elt}, @code{car}, or @code{cdr} form, in which case the "
"effect is to store into the specified element of a list.  Thus, @samp{(setq "
"(elt m i j) x)} stores @expr{x} into one element of a matrix."
msgstr ""

#. type: itemize
#: ../../calc.texi:32219
msgid ""
"A @code{for} looping construct is available.  For example, @samp{(for ((i 0 "
"10)) body)} executes @code{body} once for each binding of @expr{i} from zero "
"to 10.  This is like a @code{let} form in that @expr{i} is temporarily bound "
"to the loop count without disturbing its value outside the @code{for} "
"construct.  Nested loops, as in @samp{(for ((i 0 10) (j 0 (1- i) 2)) body)}, "
"are also available.  For each value of @expr{i} from zero to 10, @expr{j} "
"counts from 0 to @expr{i-1} in steps of two.  Note that @code{for} has the "
"same general outline as @code{let*}, except that each element of the header "
"is a list of three or four things, not just two."
msgstr ""

#. type: itemize
#: ../../calc.texi:32226
msgid ""
"The @code{foreach} construct loops over elements of a list.  For example, "
"@samp{(foreach ((x (cdr v))) body)} executes @code{body} with @expr{x} bound "
"to each element of Calc vector @expr{v} in turn.  The purpose of @code{cdr} "
"here is to skip over the initial @code{vec} symbol in the vector."
msgstr ""

#. type: itemize
#: ../../calc.texi:32232
msgid ""
"The @code{break} function breaks out of the innermost enclosing "
"@code{while}, @code{for}, or @code{foreach} loop.  If given a value, as in "
"@samp{(break x)}, this value is returned by the loop.  (Lisp loops otherwise "
"always return @code{nil}.)"
msgstr ""

#. type: itemize
#: ../../calc.texi:32238
msgid ""
"The @code{return} function prematurely returns from the enclosing function.  "
"For example, @samp{(return (+ x y))} returns @expr{x+y} as the value of a "
"function.  You can use @code{return} anywhere inside the body of the "
"function."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32245
msgid ""
"Non-integer numbers (and extremely large integers) cannot be included "
"directly into a @code{defmath} definition.  This is because the Lisp reader "
"will fail to parse them long before @code{defmath} ever gets control.  "
"Instead, use the notation, @samp{:\"3.1415\"}.  In fact, any algebraic "
"formula can go between the quotes.  For example,"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32250
#, no-wrap
msgid ""
"(defmath sqexp (x)     ; sqexp(x) == sqrt(exp(x)) == exp(x*0.5)\n"
"  (and (numberp x)\n"
"       (exp :\"x * 0.5\")))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32253 ../../calc.texi:32671
msgid "expands to"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32258
#, no-wrap
msgid ""
"(defun calcFunc-sqexp (x)\n"
"  (and (math-numberp x)\n"
"       (calcFunc-exp (math-mul x '(float 5 -1)))))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32265
msgid ""
"Note the use of @code{numberp} as a guard to ensure that the argument is a "
"number first, returning @code{nil} if not.  The exponential function could "
"itself have been included in the expression, if we had preferred: "
"@samp{:\"exp(x * 0.5)\"}.  As another example, the "
"multiplication-and-recursion step of @code{myfact} could have been written"
msgstr ""

#. type: example
#: ../../calc.texi:32268
#, no-wrap
msgid ":\"n * myfact(n-1)\"\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32281
msgid ""
"A good place to put your @code{defmath} commands is your Calc init file (the "
"file given by @code{calc-settings-file}, typically "
"@file{~/.emacs.d/calc.el}), which will not be loaded until Calc starts.  If "
"a file named @file{.emacs} exists in your home directory, Emacs reads and "
"executes the Lisp forms in this file as it starts up.  While it may seem "
"reasonable to put your favorite @code{defmath} commands there, this has the "
"unfortunate side-effect that parts of the Calculator must be loaded in to "
"process the @code{defmath} commands whether or not you will actually use the "
"Calculator! If you want to put the @code{defmath} commands there (for "
"example, if you redefine @code{calc-settings-file} to be @file{.emacs}), a "
"better effect can be had by writing"
msgstr ""

#. type: example
#: ../../calc.texi:32287
#, no-wrap
msgid ""
"(put 'calc-define 'thing '(progn\n"
" (defmath ... )\n"
" (defmath ... )\n"
"))\n"
msgstr ""

#. type: vindex
#: ../../calc.texi:32290
#, no-wrap
msgid "calc-define"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32300
msgid ""
"The @code{put} function adds a @dfn{property} to a symbol.  Each Lisp symbol "
"has a list of properties associated with it.  Here we add a property with a "
"name of @code{thing} and a @samp{(progn ...)} form as its value.  When Calc "
"starts up, and at the start of every Calc command, the property list for the "
"symbol @code{calc-define} is checked and the values of any properties found "
"are evaluated as Lisp forms.  The properties are removed as they are "
"evaluated.  The property names (like @code{thing}) are not used; you should "
"choose something like the name of your project so as not to conflict with "
"other properties."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32305
msgid ""
"The net effect is that you can put the above code in your @file{.emacs} file "
"and it will not be executed until Calc is loaded.  Or, you can put that same "
"code in another file which you load by hand either before or after Calc "
"itself is loaded."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32310
msgid ""
"The properties of @code{calc-define} are evaluated in the same order that "
"they were added.  They can assume that the Calc modules @file{calc.el}, "
"@file{calc-ext.el}, and @file{calc-macs.el} have been fully loaded, and that "
"the @file{*Calculator*} buffer will be the current buffer."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32319
msgid ""
"If your @code{calc-define} property only defines algebraic functions, you "
"can be sure that it will have been evaluated before Calc tries to call your "
"function, even if the file defining the property is loaded after Calc is "
"loaded.  But if the property defines commands or key sequences, it may not "
"be evaluated soon enough.  (Suppose it defines the new command "
"@code{tweak-calc}; the user can load your file, then type @kbd{M-x "
"tweak-calc} before Calc has had chance to do anything.)  To protect against "
"this situation, you can put"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32322 ../../calc.texi:32496
#, no-wrap
msgid "(run-hooks 'calc-check-defines)\n"
msgstr ""

#. type: findex
#: ../../calc.texi:32324
#, no-wrap
msgid "calc-check-defines"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32330
msgid ""
"at the end of your file.  The @code{calc-check-defines} function is what "
"looks for and evaluates properties on @code{calc-define}; @code{run-hooks} "
"has the advantage that it is quietly ignored if @code{calc-check-defines} is "
"not yet defined because Calc has not yet been loaded."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32335
msgid ""
"Examples of things that ought to be enclosed in a @code{calc-define} "
"property are @code{defmath} calls, @code{define-key} calls that modify the "
"Calc key map, and any calls that redefine things defined inside Calc.  "
"Ordinary @code{defun}s need not be enclosed with @code{calc-define}."
msgstr ""

#. type: node
#: ../../calc.texi:32336 ../../calc.texi:32498 ../../calc.texi:32600
#, no-wrap
msgid "Defining Stack Commands"
msgstr ""

#. type: subsection
#: ../../calc.texi:32337
#, no-wrap
msgid "Defining New Simple Commands"
msgstr ""

#. type: findex
#: ../../calc.texi:32340
#, no-wrap
msgid "interactive"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32347
msgid ""
"If a @code{defmath} form contains an @code{interactive} clause, it defines a "
"Calculator command.  Actually such a @code{defmath} results in @emph{two} "
"function definitions: One, a @samp{calcFunc-} function as was just "
"described, with the @code{interactive} clause removed.  Two, a @samp{calc-} "
"function with a suitable @code{interactive} clause and some sort of wrapper "
"to make the command work in the Calc environment."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32350
msgid ""
"In the simple case, the @code{interactive} clause has the same form as for "
"normal Emacs Lisp commands:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32356
#, no-wrap
msgid ""
"(defmath increase-precision (delta)\n"
"  \"Increase precision by DELTA.\"     ; This is the \"documentation "
"string\"\n"
"  (interactive \"p\")                  ; Register this as a M-x-able "
"command\n"
"  (setq calc-internal-prec (+ calc-internal-prec delta)))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32359
msgid "This expands to the pair of definitions,"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32366
#, no-wrap
msgid ""
"(defun calc-increase-precision (delta)\n"
"  \"Increase precision by DELTA.\"\n"
"  (interactive \"p\")\n"
"  (calc-wrapper\n"
"   (setq calc-internal-prec (math-add calc-internal-prec delta))))\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32370
#, no-wrap
msgid ""
"(defun calcFunc-increase-precision (delta)\n"
"  \"Increase precision by DELTA.\"\n"
"  (setq calc-internal-prec (math-add calc-internal-prec delta)))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32377
msgid ""
"where in this case the latter function would never really be used! Note that "
"since the Calculator stores small integers as plain Lisp integers, the "
"@code{math-add} function will work just as well as the native @code{+} even "
"when the intent is to operate on native Lisp integers."
msgstr ""

#. type: findex
#: ../../calc.texi:32378
#, no-wrap
msgid "calc-wrapper"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32381
msgid ""
"The @samp{calc-wrapper} call invokes a macro which surrounds the body of the "
"function with code that looks roughly like this:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32393
#, no-wrap
msgid ""
"(let ((calc-command-flags nil))\n"
"  (unwind-protect\n"
"      (save-current-buffer\n"
"        (calc-select-buffer)\n"
"        @emph{body of function}\n"
"        @emph{renumber stack}\n"
"        @emph{clear} Working @emph{message})\n"
"    @emph{realign cursor and window}\n"
"    @emph{clear Inverse, Hyperbolic, and Keep Args flags}\n"
"    @emph{update Emacs mode line}))\n"
msgstr ""

#. type: findex
#: ../../calc.texi:32395
#, no-wrap
msgid "calc-select-buffer"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32399
msgid ""
"The @code{calc-select-buffer} function selects the @file{*Calculator*} "
"buffer if necessary, say, because the command was invoked from inside the "
"@file{*Calc Trail*} window."
msgstr ""

#. type: findex
#: ../../calc.texi:32400
#, no-wrap
msgid "calc-set-command-flag"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32404
msgid ""
"You can call, for example, @code{(calc-set-command-flag 'no-align)} to set "
"the above-mentioned command flags.  Calc routines recognize the following "
"command flags:"
msgstr ""

#. type: item
#: ../../calc.texi:32406
#, no-wrap
msgid "renum-stack"
msgstr ""

#. type: table
#: ../../calc.texi:32410
msgid ""
"Stack line numbers @samp{1:}, @samp{2:}, and so on must be renumbered after "
"this command completes.  This is set by routines like @code{calc-push}."
msgstr ""

#. type: item
#: ../../calc.texi:32411
#, no-wrap
msgid "clear-message"
msgstr ""

#. type: table
#: ../../calc.texi:32414
msgid ""
"Calc should call @samp{(message \"\")} if this command completes normally "
"(to clear a ``Working@dots{}'' message out of the echo area)."
msgstr ""

#. type: item
#: ../../calc.texi:32415
#, no-wrap
msgid "no-align"
msgstr ""

#. type: table
#: ../../calc.texi:32417
msgid "Do not move the cursor back to the @samp{.} top-of-stack marker."
msgstr ""

#. type: item
#: ../../calc.texi:32418
#, no-wrap
msgid "position-point"
msgstr ""

#. type: table
#: ../../calc.texi:32422
msgid ""
"Use the variables @code{calc-position-point-line} and "
"@code{calc-position-point-column} to position the cursor after this command "
"finishes."
msgstr ""

#. type: item
#: ../../calc.texi:32423
#, no-wrap
msgid "keep-flags"
msgstr ""

#. type: table
#: ../../calc.texi:32426
msgid ""
"Do not clear @code{calc-inverse-flag}, @code{calc-hyperbolic-flag}, and "
"@code{calc-keep-args-flag} at the end of this command."
msgstr ""

#. type: item
#: ../../calc.texi:32427
#, no-wrap
msgid "do-edit"
msgstr ""

#. type: table
#: ../../calc.texi:32429
msgid "Switch to buffer @file{*Calc Edit*} after this command."
msgstr ""

#. type: item
#: ../../calc.texi:32430
#, no-wrap
msgid "hold-trail"
msgstr ""

#. type: table
#: ../../calc.texi:32433
msgid "Do not move trail pointer to end of trail when something is recorded there."
msgstr ""

#. type: kindex
#: ../../calc.texi:32436
#, no-wrap
msgid "Y ?"
msgstr ""

#. type: vindex
#: ../../calc.texi:32437
#, no-wrap
msgid "calc-Y-help-msgs"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32446
msgid ""
"Calc reserves a special prefix key, shift-@kbd{Y}, for user-written "
"extensions to Calc.  There are no built-in commands that work with this "
"prefix key; you must call @code{define-key} from Lisp (probably from inside "
"a @code{calc-define} property) to add to it.  Initially only @kbd{Y ?} is "
"defined; it takes help messages from a list of strings (initially "
"@code{nil}) in the variable @code{calc-Y-help-msgs}.  All other undefined "
"keys except for @kbd{Y} are reserved for use by future versions of Calc."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32453
msgid ""
"If you are writing a Calc enhancement which you expect to give to others, it "
"is best to minimize the number of @kbd{Y}-key sequences you use.  In fact, "
"if you have more than one key sequence you should consider defining "
"three-key sequences with a @kbd{Y}, then a key that stands for your package, "
"then a third key for the particular command within your package."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32460
msgid ""
"Users may wish to install several Calc enhancements, and it is possible that "
"several enhancements will choose to use the same key.  In the example below, "
"a variable @code{inc-prec-base-key} has been defined to contain the key that "
"identifies the @code{inc-prec} package.  Its value is initially "
"@code{\"P\"}, but a user can change this variable if necessary without "
"having to modify the file."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32464
msgid ""
"Here is a complete file, @file{inc-prec.el}, which makes a @kbd{Y P I} "
"command that increases the precision, and a @kbd{Y P D} command that "
"decreases the precision."
msgstr ""

#. type: smallexample
#: ../../calc.texi:32468
#, no-wrap
msgid ""
";;; Increase and decrease Calc precision.  Dave Gillespie, 5/31/91.\n"
";; (Include copyright or copyleft stuff here.)\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32471
#, no-wrap
msgid ""
"(defvar inc-prec-base-key \"P\"\n"
"  \"Base key for inc-prec.el commands.\")\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32473
#, no-wrap
msgid ""
"(put 'calc-define 'inc-prec '(progn\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32478
#, no-wrap
msgid ""
"(define-key calc-mode-map (format \"Y%sI\" inc-prec-base-key)\n"
"            'increase-precision)\n"
"(define-key calc-mode-map (format \"Y%sD\" inc-prec-base-key)\n"
"            'decrease-precision)\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32482
#, no-wrap
msgid ""
"(setq calc-Y-help-msgs\n"
"      (cons (format \"%s + Inc-prec, Dec-prec\" inc-prec-base-key)\n"
"            calc-Y-help-msgs))\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32487
#, no-wrap
msgid ""
"(defmath increase-precision (delta)\n"
"  \"Increase precision by DELTA.\"\n"
"  (interactive \"p\")\n"
"  (setq calc-internal-prec (+ calc-internal-prec delta)))\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32492
#, no-wrap
msgid ""
"(defmath decrease-precision (delta)\n"
"  \"Decrease precision by DELTA.\"\n"
"  (interactive \"p\")\n"
"  (setq calc-internal-prec (- calc-internal-prec delta)))\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32494
#, no-wrap
msgid ""
"))  ; end of calc-define property\n"
"\n"
msgstr ""

#. type: node
#: ../../calc.texi:32498 ../../calc.texi:32600 ../../calc.texi:32601 ../../calc.texi:32687
#, no-wrap
msgid "Argument Qualifiers"
msgstr ""

#. type: subsection
#: ../../calc.texi:32499
#, no-wrap
msgid "Defining New Stack-Based Commands"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32504
msgid ""
"To define a new computational command which takes and/or leaves arguments on "
"the stack, a special form of @code{interactive} clause is used."
msgstr ""

#. type: example
#: ../../calc.texi:32507
#, no-wrap
msgid "(interactive @var{num} @var{tag})\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32516
msgid ""
"where @var{num} is an integer, and @var{tag} is a string.  The effect is to "
"pop @var{num} values off the stack, resimplify them by calling "
"@code{calc-normalize}, and hand them to your function according to the "
"function's argument list.  Your function may include @code{&optional} and "
"@code{&rest} parameters, so long as calling the function with @var{num} "
"parameters is valid."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32523
msgid ""
"Your function must return either a number or a formula in a form acceptable "
"to Calc, or a list of such numbers or formulas.  These value(s)  are pushed "
"onto the stack when the function completes.  They are also recorded in the "
"Calc Trail buffer on a line beginning with @var{tag}, a string of (normally) "
"four characters or less.  If you omit @var{tag} or use @code{nil} as a tag, "
"the result is not recorded in the trail."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32525
msgid "As an example, the definition"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32533
#, no-wrap
msgid ""
"(defmath myfact (n)\n"
"  \"Compute the factorial of the integer at the top of the stack.\"\n"
"  (interactive 1 \"fact\")\n"
"  (if (> n 0)\n"
"      (* n (myfact (1- n)))\n"
"    (and (= n 0) 1)))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32538
msgid ""
"is a version of the factorial function shown previously which can be used as "
"a command as well as an algebraic function.  It expands to"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32546
#, no-wrap
msgid ""
"(defun calc-myfact ()\n"
"  \"Compute the factorial of the integer at the top of the stack.\"\n"
"  (interactive)\n"
"  (calc-slow-wrapper\n"
"   (calc-enter-result 1 \"fact\"\n"
"     (cons 'calcFunc-myfact (calc-top-list-n 1)))))\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32552
#, no-wrap
msgid ""
"(defun calcFunc-myfact (n)\n"
"  \"Compute the factorial of the integer at the top of the stack.\"\n"
"  (if (math-posp n)\n"
"      (math-mul n (calcFunc-myfact (math-add n -1)))\n"
"    (and (math-zerop n) 1)))\n"
msgstr ""

#. type: findex
#: ../../calc.texi:32554
#, no-wrap
msgid "calc-slow-wrapper"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32559
msgid ""
"The @code{calc-slow-wrapper} function is a version of @code{calc-wrapper} "
"that automatically puts up a @samp{Working...} message before the "
"computation begins.  (This message can be turned off by the user with an "
"@kbd{m w} (@code{calc-working}) command.)"
msgstr ""

#. type: findex
#: ../../calc.texi:32560
#, no-wrap
msgid "calc-top-list-n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32565
msgid ""
"The @code{calc-top-list-n} function returns a list of the specified number "
"of values from the top of the stack.  It resimplifies each value by calling "
"@code{calc-normalize}.  If its argument is zero it returns an empty list.  "
"It does not actually remove these values from the stack."
msgstr ""

#. type: findex
#: ../../calc.texi:32566
#, no-wrap
msgid "calc-enter-result"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32573
msgid ""
"The @code{calc-enter-result} function takes an integer @var{num} and string "
"@var{tag} as described above, plus a third argument which is either a "
"Calculator data object or a list of such objects.  These objects are "
"resimplified and pushed onto the stack after popping the specified number of "
"values from the stack.  If @var{tag} is non-@code{nil}, the values being "
"pushed are also recorded in the trail."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32579
msgid ""
"Note that if @code{calcFunc-myfact} returns @code{nil} this represents "
"``leave the function in symbolic form.'' To return an actual empty list, in "
"the sense that @code{calc-enter-result} will push zero elements back onto "
"the stack, you should return the special value @samp{'(nil)}, a list "
"containing the single symbol @code{nil}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32583
msgid ""
"The @code{interactive} declaration can actually contain a limited "
"Emacs-style code string as well which comes just before @var{num} and "
"@var{tag}.  Currently the only Emacs code supported is @samp{\"p\"}, as in"
msgstr ""

#. type: example
#: ../../calc.texi:32588
#, no-wrap
msgid ""
"(defmath foo (a b &optional c)\n"
"  (interactive \"p\" 2 \"foo\")\n"
"  @var{body})\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32593
msgid ""
"In this example, the command @code{calc-foo} will evaluate the expression "
"@samp{foo(a,b)} if executed with no argument, or @samp{foo(a,b,n)} if "
"executed with a numeric prefix argument of @expr{n}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32599
msgid ""
"The other code string allowed is @samp{\"m\"} (unrelated to the usual "
"@samp{\"m\"} code as used with @code{defun}).  It uses the numeric prefix "
"argument as the number of objects to remove from the stack and pass to the "
"function.  In this case, the integer @var{num} serves as a default number of "
"arguments to be used when no prefix is supplied."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32606
msgid ""
"Anywhere a parameter name can appear in the parameter list you can also use "
"an @dfn{argument qualifier}.  Thus the general form of a definition is:"
msgstr ""

#. type: example
#: ../../calc.texi:32612
#, no-wrap
msgid ""
"(defmath @var{name} (@var{param} @var{param...}\n"
"               &optional @var{param} @var{param...}\n"
"               &rest @var{param})\n"
"  @var{body})\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32616
msgid "where each @var{param} is either a symbol or a list of the form"
msgstr ""

#. type: example
#: ../../calc.texi:32619
#, no-wrap
msgid "(@var{qual} @var{param})\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32622
msgid "The following qualifiers are recognized:"
msgstr ""

#. type: findex
#: ../../calc.texi:32624 ../../calc.texi:32625
#, no-wrap
msgid "complete"
msgstr ""

#. type: table
#: ../../calc.texi:32630
msgid ""
"The argument must not be an incomplete vector, interval, or complex number.  "
"(This is rarely needed since the Calculator itself will never call your "
"function with an incomplete argument.  But there is nothing stopping your "
"own Lisp code from calling your function with an incomplete argument.)"
msgstr ""

#. type: findex
#: ../../calc.texi:32631 ../../calc.texi:32632
#, no-wrap
msgid "integer"
msgstr ""

#. type: table
#: ../../calc.texi:32636
msgid ""
"The argument must be an integer.  If it is an integer-valued float it will "
"be accepted but converted to integer form.  Non-integers and formulas are "
"rejected."
msgstr ""

#. type: findex
#: ../../calc.texi:32637 ../../calc.texi:32638
#, no-wrap
msgid "natnum"
msgstr ""

#. type: table
#: ../../calc.texi:32640
msgid "Like @samp{integer}, but the argument must be non-negative."
msgstr ""

#. type: findex
#: ../../calc.texi:32641 ../../calc.texi:32642
#, no-wrap
msgid "fixnum"
msgstr ""

#. type: table
#: ../../calc.texi:32646
msgid ""
"Like @samp{integer}, but the argument must fit into a native Lisp integer, "
"which on most systems means less than 2^23 in absolute value.  The argument "
"is converted into Lisp-integer form if necessary."
msgstr ""

#. type: table
#: ../../calc.texi:32652
msgid ""
"The argument is converted to floating-point format if it is a number or "
"vector.  If it is a formula it is left alone.  (The argument is never "
"actually rejected by this qualifier.)"
msgstr ""

#. type: var{#1}
#: ../../calc.texi:32653
#, no-wrap
msgid "pred"
msgstr ""

#. type: table
#: ../../calc.texi:32656
msgid ""
"The argument must satisfy predicate @var{pred}, which is one of the standard "
"Calculator predicates.  @xref{Predicates}."
msgstr ""

#. type: item
#: ../../calc.texi:32657
#, no-wrap
msgid "not-@var{pred}"
msgstr ""

#. type: table
#: ../../calc.texi:32659
msgid "The argument must @emph{not} satisfy predicate @var{pred}."
msgstr ""

#. type: example
#: ../../calc.texi:32667
#, no-wrap
msgid ""
"(defmath foo (a (constp (not-matrixp b)) &optional (float c)\n"
"              &rest (integer d))\n"
"  @var{body})\n"
msgstr ""

#. type: example
#: ../../calc.texi:32681
#, no-wrap
msgid ""
"(defun calcFunc-foo (a b &optional c &rest d)\n"
"  (and (math-matrixp b)\n"
"       (math-reject-arg b 'not-matrixp))\n"
"  (or (math-constp b)\n"
"      (math-reject-arg b 'constp))\n"
"  (and c (setq c (math-check-float c)))\n"
"  (setq d (mapcar 'math-check-integer d))\n"
"  @var{body})\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32686
msgid ""
"which performs the necessary checks and conversions before executing the "
"body of the function."
msgstr ""

#. type: node
#: ../../calc.texi:32687 ../../calc.texi:32868 ../../calc.texi:33264
#, no-wrap
msgid "Calling Calc from Your Programs"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32694
msgid ""
"This section includes some Lisp programming examples on a larger scale.  "
"These programs make use of some of the Calculator's internal functions; "
"@pxref{Internals}."
msgstr ""

#. type: menuentry
#: ../../calc.texi:32698
msgid "Bit Counting Example::"
msgstr ""

#. type: node
#: ../../calc.texi:32698 ../../calc.texi:32700 ../../calc.texi:32784
#, no-wrap
msgid "Sine Example"
msgstr ""

#. type: node
#: ../../calc.texi:32700 ../../calc.texi:32784
#, no-wrap
msgid "Bit Counting Example"
msgstr ""

#. type: subsubsection
#: ../../calc.texi:32701
#, no-wrap
msgid "Bit-Counting"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32713
msgid ""
"@tindex bcount Calc does not include a built-in function for counting the "
"number of ``one'' bits in a binary integer.  It's easy to invent one using "
"@kbd{b u} to convert the integer to a set, and @kbd{V #} to count the "
"elements of that set; let's write a function that counts the bits without "
"having to create an intermediate set."
msgstr ""

#. type: smallexample
#: ../../calc.texi:32723
#, no-wrap
msgid ""
"(defmath bcount ((natnum n))\n"
"  (interactive 1 \"bcnt\")\n"
"  (let ((count 0))\n"
"    (while (> n 0)\n"
"      (if (oddp n)\n"
"          (setq count (1+ count)))\n"
"      (setq n (ash n -1)))\n"
"    count))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32728
msgid ""
"When this is expanded by @code{defmath}, it will become the following Emacs "
"Lisp function:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32738
#, no-wrap
msgid ""
"(defun calcFunc-bcount (n)\n"
"  (setq n (math-check-natnum n))\n"
"  (let ((count 0))\n"
"    (while (math-posp n)\n"
"      (if (math-oddp n)\n"
"          (setq count (math-add count 1)))\n"
"      (setq n (calcFunc-lsh n -1)))\n"
"    count))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32744
msgid ""
"If the input numbers are large, this function involves a fair amount of "
"arithmetic.  A binary right shift is essentially a division by two; recall "
"that Calc stores integers in decimal form so bit shifts must involve actual "
"division."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32750
msgid ""
"To gain a bit more efficiency, we could divide the integer into @var{n}-bit "
"chunks, each of which can be handled quickly because they fit into Lisp "
"integers.  It turns out that Calc's arithmetic routines are especially fast "
"when dividing by an integer less than 1000, so we can set @var{n = 9} bits "
"and use repeated division by 512:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32760
#, no-wrap
msgid ""
"(defmath bcount ((natnum n))\n"
"  (interactive 1 \"bcnt\")\n"
"  (let ((count 0))\n"
"    (while (not (fixnump n))\n"
"      (let ((qr (idivmod n 512)))\n"
"        (setq count (+ count (bcount-fixnum (cdr qr)))\n"
"              n (car qr))))\n"
"    (+ count (bcount-fixnum n))))\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32767
#, no-wrap
msgid ""
"(defun bcount-fixnum (n)\n"
"  (let ((count 0))\n"
"    (while (> n 0)\n"
"      (setq count (+ count (logand n 1))\n"
"            n (ash n -1)))\n"
"    count))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32775
msgid ""
"Note that the second function uses @code{defun}, not @code{defmath}.  "
"Because this function deals only with native Lisp integers (``fixnums''), it "
"can use the actual Emacs @code{+} and related functions rather than the "
"slower but more general Calc equivalents which @code{defmath} uses."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32783
msgid ""
"The @code{idivmod} function does an integer division, returning both the "
"quotient and the remainder at once.  Again, note that while it might seem "
"that @samp{(logand n 511)} and @samp{(ash n -9)} are more efficient ways to "
"split off the bottom nine bits of @code{n}, actually they are less efficient "
"because each operation is really a division by 512 in disguise; "
"@code{idivmod} allows us to do the same thing with a single division by 512."
msgstr ""

#. type: subsubsection
#: ../../calc.texi:32785
#, no-wrap
msgid "The Sine Function"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32796
msgid ""
"@tindex mysin A somewhat limited sine function could be defined as follows, "
"using the well-known Taylor series expansion for @texline @math{\\sin x}: "
"@infoline @samp{sin(x)}:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32814
#, no-wrap
msgid ""
"(defmath mysin ((float (anglep x)))\n"
"  (interactive 1 \"mysn\")\n"
"  (setq x (to-radians x))    ; Convert from current angular mode.\n"
"  (let ((sum x)              ; Initial term of Taylor expansion of sin.\n"
"        newsum\n"
"        (nfact 1)            ; \"nfact\" equals \"n\" factorial at all "
"times.\n"
"        (xnegsqr :\"-(x^2)\")) ; \"xnegsqr\" equals -x^2.\n"
"    (for ((n 3 100 2))       ; Upper limit of 100 is a good precaution.\n"
"      (working \"mysin\" sum)  ; Display \"Working\" message, if enabled.\n"
"      (setq nfact (* nfact (1- n) n)\n"
"            x (* x xnegsqr)\n"
"            newsum (+ sum (/ x nfact)))\n"
"      (if (~= newsum sum)    ; If newsum is \"nearly equal to\" sum,\n"
"          (break))           ;  then we are done.\n"
"      (setq sum newsum))\n"
"    sum))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32822
msgid ""
"The actual @code{sin} function in Calc works by first reducing the problem "
"to a sine or cosine of a nonnegative number less than @cpiover{4}.  This "
"ensures that the Taylor series will converge quickly.  Also, the calculation "
"is carried out with two extra digits of precision to guard against "
"cumulative round-off in @samp{sum}.  Finally, complex arguments are allowed "
"and handled by a separate algorithm."
msgstr ""

#. type: smallexample
#: ../../calc.texi:32833
#, no-wrap
msgid ""
"(defmath mysin ((float (scalarp x)))\n"
"  (interactive 1 \"mysn\")\n"
"  (setq x (to-radians x))    ; Convert from current angular mode.\n"
"  (with-extra-prec 2         ; Evaluate with extra precision.\n"
"    (cond ((complexp x)\n"
"           (mysin-complex x))\n"
"          ((< x 0)\n"
"           (- (mysin-raw (- x)))    ; Always call mysin-raw with x >= 0.\n"
"          (t (mysin-raw x))))))\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:32844
#, no-wrap
msgid ""
"(defmath mysin-raw (x)\n"
"  (cond ((>= x 7)\n"
"         (mysin-raw (% x (two-pi))))     ; Now x < 7.\n"
"        ((> x (pi-over-2))\n"
"         (- (mysin-raw (- x (pi)))))     ; Now -pi/2 <= x <= pi/2.\n"
"        ((> x (pi-over-4))\n"
"         (mycos-raw (- x (pi-over-2))))  ; Now -pi/2 <= x <= pi/4.\n"
"        ((< x (- (pi-over-4)))\n"
"         (- (mycos-raw (+ x (pi-over-2)))))  ; Now -pi/4 <= x <= pi/4,\n"
"        (t (mysin-series x))))           ; so the series will be "
"efficient.\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32851
msgid ""
"where @code{mysin-complex} is an appropriate function to handle complex "
"numbers, @code{mysin-series} is the routine to compute the sine Taylor "
"series as before, and @code{mycos-raw} is a function analogous to "
"@code{mysin-raw} for cosines."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32862
msgid ""
"The strategy is to ensure that @expr{x} is nonnegative before calling "
"@code{mysin-raw}.  This function then recursively reduces its argument to a "
"suitable range, namely, plus-or-minus @cpiover{4}.  Note that each test, and "
"particularly the first comparison against 7, is designed so that small "
"roundoff errors cannot produce an infinite loop.  (Suppose we compared with "
"@samp{(two-pi)} instead; if due to roundoff problems the modulo operator "
"ever returned @samp{(two-pi)} exactly, an infinite recursion could result!)  "
"We use modulo only for arguments that will clearly get reduced, knowing that "
"the next rule will catch any reductions that this rule misses."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32867
msgid ""
"If a program is being written for general use, it is important to code it "
"carefully as shown in this second example.  For quick-and-dirty programs, "
"when you know that your own use of the sine function will never encounter a "
"large argument, a simpler program like the first one shown is fine."
msgstr ""

#. type: subsection
#: ../../calc.texi:32869
#, no-wrap
msgid "Calling Calc from Your Lisp Programs"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32879
msgid ""
"A later section (@pxref{Internals}) gives a full description of Calc's "
"internal Lisp functions.  It's not hard to call Calc from inside your "
"programs, but the number of these functions can be daunting.  So Calc "
"provides one special ``programmer-friendly'' function called "
"@code{calc-eval} that can be made to do just about everything you need.  "
"It's not as fast as the low-level Calc functions, but it's much simpler to "
"use!"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32882
msgid ""
"It may seem that @code{calc-eval} itself has a daunting number of options, "
"but they all stem from one simple operation."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32886
msgid ""
"In its simplest manifestation, @samp{(calc-eval \"1+2\")} parses the string "
"@code{\"1+2\"} as if it were a Calc algebraic entry and returns the result "
"formatted as a string: @code{\"3\"}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32891
msgid ""
"Since @code{calc-eval} is on the list of recommended @code{autoload} "
"functions, you don't need to make any special preparations to load Calc "
"before calling @code{calc-eval} the first time.  Calc will be loaded and "
"initialized for you."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32894
msgid ""
"All the Calc modes that are currently in effect will be used when evaluating "
"the expression and formatting the result."
msgstr ""

#. type: subsubsection
#: ../../calc.texi:32900
#, no-wrap
msgid "Additional Arguments to @code{calc-eval}"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32907
msgid ""
"If the input string parses to a list of expressions, Calc returns the "
"results separated by @code{\", \"}.  You can specify a different separator "
"by giving a second string argument to @code{calc-eval}: @samp{(calc-eval "
"\"1+2,3+4\" \";\")} returns @code{\"3;7\"}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32911
msgid ""
"The ``separator'' can also be any of several Lisp symbols which request "
"other behaviors from @code{calc-eval}.  These are discussed one by one "
"below."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32918
msgid ""
"You can give additional arguments to be substituted for @samp{$}, @samp{$$}, "
"and so on in the main expression.  For example, @samp{(calc-eval \"$/$$\" "
"nil \"7\" \"1+1\")} evaluates the expression @code{\"7/(1+1)\"} to yield the "
"result @code{\"3.5\"} (assuming Fraction mode is not in effect).  Note the "
"@code{nil} used as a placeholder for the item-separator argument."
msgstr ""

#. type: subsubsection
#: ../../calc.texi:32924
#, no-wrap
msgid "Error Handling"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32933
msgid ""
"If @code{calc-eval} encounters an error, it returns a list containing the "
"character position of the error, plus a suitable message as a string.  Note "
"that @samp{1 / 0} is @emph{not} an error by Calc's standards; it simply "
"returns the string @code{\"1 / 0\"} which is the division left in symbolic "
"form.  But @samp{(calc-eval \"1/\")} will return the list @samp{(2 "
"\"Expected a number\")}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32938
msgid ""
"If you bind the variable @code{calc-eval-error} to @code{t} using a "
"@code{let} form surrounding the call to @code{calc-eval}, errors instead "
"call the Emacs @code{error} function which aborts to the Emacs command loop "
"with a beep and an error message."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32942
msgid ""
"If you bind this variable to the symbol @code{string}, error messages are "
"returned as strings instead of lists.  The character position is ignored."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32946
msgid ""
"As a courtesy to other Lisp code which may be using Calc, be sure to bind "
"@code{calc-eval-error} using @code{let} rather than changing it permanently "
"with @code{setq}."
msgstr ""

#. type: subsubsection
#: ../../calc.texi:32952
#, no-wrap
msgid "Numbers Only"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32961
msgid ""
"Sometimes it is preferable to treat @samp{1 / 0} as an error rather than "
"returning a symbolic result.  If you pass the symbol @code{num} as the "
"second argument to @code{calc-eval}, results that are not constants are "
"treated as errors.  The error message reported is the first @code{calc-why} "
"message if there is one, or otherwise ``Number expected.''"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32965
msgid ""
"A result is ``constant'' if it is a number, vector, or other object that "
"does not include variables or function calls.  If it is a vector, the "
"components must themselves be constants."
msgstr ""

#. type: subsubsection
#: ../../calc.texi:32971
#, no-wrap
msgid "Default Modes"
msgstr ""

#. type: Plain text
#: ../../calc.texi:32980
msgid ""
"If the first argument to @code{calc-eval} is a list whose first element is a "
"formula string, then @code{calc-eval} sets all the various Calc modes to "
"their default values while the formula is evaluated and formatted.  For "
"example, the precision is set to 12 digits, digit grouping is turned off, "
"and the Normal language mode is used."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32984
msgid ""
"This same principle applies to the other options discussed below.  If the "
"first argument would normally be @var{x}, then it can also be the list "
"@samp{(@var{x})} to use the default mode settings."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32991
msgid ""
"If there are other elements in the list, they are taken as "
"variable-name/value pairs which override the default mode settings.  Look at "
"the documentation at the front of the @file{calc.el} file to find the names "
"of the Lisp variables for the various modes.  The mode settings are restored "
"to their original values when @code{calc-eval} is done."
msgstr ""

#. type: Plain text
#: ../../calc.texi:32996
msgid ""
"For example, @samp{(calc-eval '(\"$+$$\" calc-internal-prec 8) 'num a b)} "
"computes the sum of two numbers, requiring a numeric result, and using "
"default mode settings except that the precision is 8 instead of the default "
"of 12."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33002
msgid ""
"It's usually best to use this form of @code{calc-eval} unless your program "
"actually considers the interaction with Calc's mode settings to be a "
"feature.  This will avoid all sorts of potential ``gotchas''; consider what "
"happens with @samp{(calc-eval \"sqrt(2)\" 'num)} when the user has left Calc "
"in Symbolic mode or No-Simplify mode."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33009
msgid ""
"As another example, @samp{(equal (calc-eval '(\"$<$$\") nil a b) \"1\")} "
"checks if the number in string @expr{a} is less than the one in string "
"@expr{b}.  Without using a list, the integer 1 might come out in a variety "
"of formats which would be hard to test for conveniently: @code{\"1\"}, "
"@code{\"8#1\"}, @code{\"00001\"}.  (But see ``Predicates'' mode, below.)"
msgstr ""

#. type: subsubsection
#: ../../calc.texi:33015
#, no-wrap
msgid "Raw Numbers"
msgstr ""

#. type: Plain text
#: ../../calc.texi:33023
msgid ""
"Normally all input and output for @code{calc-eval} is done with strings.  "
"You can do arithmetic with, say, @samp{(calc-eval \"$+$$\" nil a b)} in "
"place of @samp{(+ a b)}, but this is very inefficient since the numbers must "
"be converted to and from string format as they are passed from one "
"@code{calc-eval} to the next."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33029
msgid ""
"If the separator is the symbol @code{raw}, the result will be returned as a "
"raw Calc data structure rather than a string.  You can read about how these "
"objects look in the following sections, but usually you can treat them as "
"``black box'' objects with no important internal structure."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33033
msgid ""
"There is also a @code{rawnum} symbol, which is a combination of @code{raw} "
"(returning a raw Calc object) and @code{num} (signaling an error if that "
"object is not a constant)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33040
msgid ""
"You can pass a raw Calc object to @code{calc-eval} in place of a string, "
"either as the formula itself or as one of the @samp{$} arguments.  Thus "
"@samp{(calc-eval \"$+$$\" 'raw a b)} is an addition function that operates "
"on raw Calc objects.  Of course in this case it would be easier to call the "
"low-level @code{math-add} function in Calc, if you can remember its name."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33045
msgid ""
"In particular, note that a plain Lisp integer is acceptable to Calc as a raw "
"object.  (All Lisp integers are accepted on input, but integers of more than "
"six decimal digits are converted to ``big-integer'' form for output.  "
"@xref{Data Type Formats}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:33048
msgid ""
"When it comes time to display the object, just use @samp{(calc-eval a)} to "
"format it as a string."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33052
msgid ""
"It is an error if the input expression evaluates to a list of values.  The "
"separator symbol @code{list} is like @code{raw} except that it returns a "
"list of one or more raw Calc objects."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33056
msgid ""
"Note that a Lisp string is not a valid Calc object, nor is a list containing "
"a string.  Thus you can still safely distinguish all the various kinds of "
"error returns discussed above."
msgstr ""

#. type: node
#: ../../calc.texi:33062 ../../calc.texi:33505 ../../calc.texi:33692 ../../calc.texi:33693 ../../calc.texi:33960
#, no-wrap
msgid "Predicates"
msgstr ""

#. type: Plain text
#: ../../calc.texi:33069
msgid ""
"If the separator symbol is @code{pred}, the result of the formula is treated "
"as a true/false value; @code{calc-eval} returns @code{t} or @code{nil}, "
"respectively.  A value is considered ``true'' if it is a non-zero number, or "
"false if it is zero or if it is not a number."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33072
msgid ""
"For example, @samp{(calc-eval \"$<$$\" 'pred a b)} tests whether one value "
"is less than another."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33078
msgid ""
"As usual, it is also possible for @code{calc-eval} to return one of the "
"error indicators described above.  Lisp will interpret such an indicator as "
"``true'' if you don't check for it explicitly.  If you wish to have an error "
"register as ``false'', use something like @samp{(eq (calc-eval ...) t)}."
msgstr ""

#. type: subsubsection
#: ../../calc.texi:33084
#, no-wrap
msgid "Variable Values"
msgstr ""

#. type: Plain text
#: ../../calc.texi:33094
msgid ""
"Variables in the formula passed to @code{calc-eval} are not normally "
"replaced by their values.  If you wish this, you can use the @code{evalv} "
"function (@pxref{Algebraic Manipulation}).  For example, if 4 is stored in "
"Calc variable @code{a} (i.e., in Lisp variable @code{var-a}), then "
"@samp{(calc-eval \"a+pi\")} will return the formula @code{\"a + pi\"}, but "
"@samp{(calc-eval \"evalv(a+pi)\")} will return @code{\"7.14159265359\"}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33101
msgid ""
"To store in a Calc variable, just use @code{setq} to store in the "
"corresponding Lisp variable.  (This is obtained by prepending @samp{var-} to "
"the Calc variable name.)  Calc routines will understand either string or raw "
"form values stored in variables, although raw data objects are much more "
"efficient.  For example, to increment the Calc variable @code{a}:"
msgstr ""

#. type: example
#: ../../calc.texi:33104
#, no-wrap
msgid "(setq var-a (calc-eval \"evalv(a+1)\" 'raw))\n"
msgstr ""

#. type: subsubsection
#: ../../calc.texi:33111
#, no-wrap
msgid "Stack Access"
msgstr ""

#. type: Plain text
#: ../../calc.texi:33120
msgid ""
"If the separator symbol is @code{push}, the formula argument is evaluated "
"(with possible @samp{$} expansions, as usual).  The result is pushed onto "
"the Calc stack.  The return value is @code{nil} (unless there is an error "
"from evaluating the formula, in which case the return value depends on "
"@code{calc-eval-error} in the usual way)."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33128
msgid ""
"If the separator symbol is @code{pop}, the first argument to "
"@code{calc-eval} must be an integer instead of a string.  That many values "
"are popped from the stack and thrown away.  A negative argument deletes the "
"entry at that stack level.  The return value is the number of elements "
"remaining in the stack after popping; @samp{(calc-eval 0 'pop)} is a good "
"way to measure the size of the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33134
msgid ""
"If the separator symbol is @code{top}, the first argument to "
"@code{calc-eval} must again be an integer.  The value at that stack level is "
"formatted as a string and returned.  Thus @samp{(calc-eval 1 'top)} returns "
"the top-of-stack value.  If the integer is out of range, @code{nil} is "
"returned."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33138
msgid ""
"The separator symbol @code{rawtop} is just like @code{top} except that the "
"stack entry is returned as a raw Calc object instead of as a string."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33145
msgid ""
"In all of these cases the first argument can be made a list in order to "
"force the default mode settings, as described above.  Thus @samp{(calc-eval "
"'(2 calc-number-radix 16) 'top)} returns the second-to-top stack entry, "
"formatted as a string using the default instead of current display modes, "
"except that the radix is hexadecimal instead of decimal."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33149
msgid ""
"It is, of course, polite to put the Calc stack back the way you found it "
"when you are done, unless the user of your program is actually expecting it "
"to affect the stack."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33153
msgid ""
"Note that you do not actually have to switch into the @file{*Calculator*} "
"buffer in order to use @code{calc-eval}; it temporarily switches into the "
"stack buffer if necessary."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33169
msgid ""
"If the separator symbol is @code{macro}, the first argument must be a string "
"of characters which Calc can execute as a sequence of keystrokes.  This "
"switches into the Calc buffer for the duration of the macro.  For example, "
"@samp{(calc-eval \"vx5\\rVR+\" 'macro)} pushes the vector @samp{[1,2,3,4,5]} "
"on the stack and then replaces it with the sum of those numbers.  Note that "
"@samp{\\r} is the Lisp notation for the carriage return, @key{RET}, "
"character."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33175
msgid ""
"If your keyboard macro wishes to pop the stack, @samp{\\C-d} is safer than "
"@samp{\\177} (the @key{DEL} character) because some installations may have "
"switched the meanings of @key{DEL} and @kbd{C-h}.  Calc always interprets "
"@kbd{C-d} as a synonym for ``pop-stack'' regardless of key mapping."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33179
msgid ""
"If you provide a third argument to @code{calc-eval}, evaluation of the "
"keyboard macro will leave a record in the Trail using that argument as a tag "
"string.  Normally the Trail is unaffected."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33181
msgid "The return value in this case is always @code{nil}."
msgstr ""

#. type: subsubsection
#: ../../calc.texi:33187
#, no-wrap
msgid "Lisp Evaluation"
msgstr ""

#. type: Plain text
#: ../../calc.texi:33195
msgid ""
"Finally, if the separator symbol is @code{eval}, then the Lisp @code{eval} "
"function is called on the first argument, which must be a Lisp expression "
"rather than a Calc formula.  Remember to quote the expression so that it is "
"not evaluated until inside @code{calc-eval}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33200
msgid ""
"The difference from plain @code{eval} is that @code{calc-eval} switches to "
"the Calc buffer before evaluating the expression.  For example, "
"@samp{(calc-eval '(setq calc-internal-prec 17) 'eval)} will correctly affect "
"the buffer-local Calc precision variable."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33210
msgid ""
"An alternative would be @samp{(calc-eval '(calc-precision 17) 'eval)}.  This "
"is evaluating a call to the function that is normally invoked by the @kbd{p} "
"key, giving it 17 as its ``numeric prefix argument.'' Note that this "
"function will leave a message in the echo area as a side effect.  Also, all "
"Calc functions switch to the Calc buffer automatically if not invoked from "
"there, so the above call is also equivalent to @samp{(calc-precision 17)} by "
"itself.  In all cases, Calc uses @code{save-excursion} to switch back to "
"your original buffer when it is done."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33213
msgid ""
"As usual the first argument can be a list that begins with a Lisp expression "
"to use default instead of current mode settings."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33216
msgid ""
"The result of @code{calc-eval} in this usage is just the result returned by "
"the evaluated Lisp expression."
msgstr ""

#. type: subsubsection
#: ../../calc.texi:33222
#, no-wrap
msgid "Example"
msgstr ""

#. type: findex
#: ../../calc.texi:33225
#, no-wrap
msgid "convert-temp"
msgstr ""

#. type: Plain text
#: ../../calc.texi:33233
msgid ""
"Here is a sample Emacs command that uses @code{calc-eval}.  Suppose you have "
"a document with lots of references to temperatures on the Fahrenheit scale, "
"say ``98.6 F'', and you wish to convert these references to Centigrade.  The "
"following command does this conversion.  Place the Emacs cursor right after "
"the letter ``F'' and invoke the command to change ``98.6 F'' to ``37 C''.  "
"Or, if the temperature is already in Centigrade form, the command changes it "
"back to Fahrenheit."
msgstr ""

#. type: example
#: ../../calc.texi:33258
#, no-wrap
msgid ""
"(defun convert-temp ()\n"
"  (interactive)\n"
"  (save-excursion\n"
"    (re-search-backward \"[^-.0-9]\\\\([-.0-9]+\\\\) *\\\\([FC]\\\\)\")\n"
"    (let* ((top1 (match-beginning 1))\n"
"           (bot1 (match-end 1))\n"
"           (number (buffer-substring top1 bot1))\n"
"           (top2 (match-beginning 2))\n"
"           (bot2 (match-end 2))\n"
"           (type (buffer-substring top2 bot2)))\n"
"      (if (equal type \"F\")\n"
"          (setq type \"C\"\n"
"                number (calc-eval \"($ - 32)*5/9\" nil number))\n"
"        (setq type \"F\"\n"
"              number (calc-eval \"$*9/5 + 32\" nil number)))\n"
"      (goto-char top2)\n"
"      (delete-region top2 bot2)\n"
"      (insert-before-markers type)\n"
"      (goto-char top1)\n"
"      (delete-region top1 bot1)\n"
"      (if (string-match \"\\\\.$\" number)   ; change \"37.\" to \"37\"\n"
"          (setq number (substring number 0 -1)))\n"
"      (insert number))))\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:33263
msgid ""
"Note the use of @code{insert-before-markers} when changing between ``F'' and "
"``C'', so that the character winds up before the cursor instead of after it."
msgstr ""

#. type: subsection
#: ../../calc.texi:33265
#, no-wrap
msgid "Calculator Internals"
msgstr ""

#. type: Plain text
#: ../../calc.texi:33276
msgid ""
"This section describes the Lisp functions defined by the Calculator that may "
"be of use to user-written Calculator programs (as described in the rest of "
"this chapter).  These functions are shown by their names as they "
"conventionally appear in @code{defmath}.  Their full Lisp names are "
"generally gotten by prepending @samp{calcFunc-} or @samp{math-} to their "
"apparent names.  (Names that begin with @samp{calc-} are already in their "
"full Lisp form.)  You can use the actual full names instead if you prefer "
"them, or if you are calling these functions from regular Lisp."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33282
msgid ""
"The functions described here are scattered throughout the various Calc "
"component files.  Note that @file{calc.el} includes @code{autoload}s for "
"only a few component files; to get autoloads of the more advanced function, "
"one needs to load @file{calc-ext.el}, which in turn autoloads all the "
"functions in the remaining component files."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33291
msgid ""
"Because @code{defmath} itself uses the extensions, user-written code "
"generally always executes with the extensions already loaded, so normally "
"you can use any Calc function and be confident that it will be autoloaded "
"for you when necessary.  If you are doing something special, check carefully "
"to make sure each function you are using is from @file{calc.el} or its "
"components, and use @w{@code{(require 'calc-ext)}} before using any function "
"based in @file{calc-ext.el} if you can't prove this file will already be "
"loaded."
msgstr ""

#. type: menuentry
#: ../../calc.texi:33302
msgid "Data Type Formats::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:33302
msgid "Interactive Lisp Functions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:33302
msgid "Stack Lisp Functions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:33302
msgid "Predicates::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:33302
msgid "Computational Lisp Functions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:33302
msgid "Vector Lisp Functions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:33302
msgid "Symbolic Lisp Functions::"
msgstr ""

#. type: menuentry
#: ../../calc.texi:33302
msgid "Formatting Lisp Functions::"
msgstr ""

#. type: subsubsection
#: ../../calc.texi:33302 ../../calc.texi:35012 ../../calc.texi:35158 ../../calc.texi:35159
#, no-wrap
msgid "Hooks"
msgstr ""

#. type: node
#: ../../calc.texi:33304 ../../calc.texi:33305 ../../calc.texi:33444
#, no-wrap
msgid "Data Type Formats"
msgstr ""

#. type: node
#: ../../calc.texi:33304 ../../calc.texi:33444 ../../calc.texi:33505
#, no-wrap
msgid "Interactive Lisp Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:33312
msgid ""
"Integers are stored in either of two ways, depending on their magnitude.  "
"Integers less than one million in absolute value are stored as standard Lisp "
"integers.  This is the only storage format for Calc data objects which is "
"not a Lisp list."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33323
msgid ""
"Large integers are stored as lists of the form @samp{(bigpos @var{d0} "
"@var{d1} @var{d2} @dots{})} for sufficiently large positive integers (where "
"``sufficiently large'' depends on the machine), or @samp{(bigneg @var{d0} "
"@var{d1} @var{d2} @dots{})} for negative integers.  Each @var{d} is a "
"base-@expr{10^n} ``digit'' (where again, @expr{n} depends on the machine), a "
"Lisp integer from 0 to 99@dots{}9.  The least significant digit is @var{d0}; "
"the last digit, @var{dn}, which is always nonzero, is the most significant "
"digit.  For example, the integer @mathit{-12345678} might be stored as "
"@samp{(bigneg 678 345 12)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33330
msgid ""
"The distinction between small and large integers is entirely hidden from the "
"user.  In @code{defmath} definitions, the Lisp predicate @code{integerp} "
"returns true for either kind of integer, and in general both big and small "
"integers are accepted anywhere the word ``integer'' is used in this manual.  "
"If the distinction must be made, native Lisp integers are called "
"@dfn{fixnums} and large integers are called @dfn{bignums}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33337
msgid ""
"Fractions are stored as a list of the form, @samp{(frac @var{n} @var{d})} "
"where @var{n} is an integer (big or small) numerator, @var{d} is an integer "
"denominator greater than one, and @var{n} and @var{d} are relatively prime.  "
"Note that fractions where @var{d} is one are automatically converted to "
"plain integers by all math routines; fractions where @var{d} is negative are "
"normalized by negating the numerator and denominator."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33348
msgid ""
"Floating-point numbers are stored in the form, @samp{(float @var{mant} "
"@var{exp})}, where @var{mant} (the ``mantissa'') is an integer less than "
"@samp{10^@var{p}} in absolute value (@var{p} represents the current "
"precision), and @var{exp} (the ``exponent'') is a fixnum.  The value of the "
"float is @samp{@var{mant} * 10^@var{exp}}.  For example, the number "
"@mathit{-3.14} is stored as @samp{(float -314 -2) = -314*10^-2}.  Other "
"constraints are that the number 0.0 is always stored as @samp{(float 0 0)}, "
"and, except for the 0.0 case, the rightmost base-10 digit of @var{mant} is "
"always nonzero.  (If the rightmost digit is zero, the number is rearranged "
"by dividing @var{mant} by ten and incrementing @var{exp}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:33354
msgid ""
"Rectangular complex numbers are stored in the form @samp{(cplx @var{re} "
"@var{im})}, where @var{re} and @var{im} are each real numbers, either "
"integers, fractions, or floats.  The value is @samp{@var{re} + @var{im}i}.  "
"The @var{im} part is nonzero; complex numbers with zero imaginary components "
"are converted to real numbers automatically."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33363
msgid ""
"Polar complex numbers are stored in the form @samp{(polar @var{r} "
"@var{theta})}, where @var{r} is a positive real value and @var{theta} is a "
"real value or HMS form representing an angle.  This angle is usually "
"normalized to lie in the interval @samp{(-180 ..@: 180)} degrees, or "
"@samp{(-pi ..@: pi)} radians, according to the current angular mode.  If the "
"angle is 0 the value is converted to a real number automatically.  (If the "
"angle is 180 degrees, the value is usually also converted to a negative real "
"number.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:33369
msgid ""
"Hours-minutes-seconds forms are stored as @samp{(hms @var{h} @var{m} "
"@var{s})}, where @var{h} is an integer or an integer-valued float (i.e., a "
"float with @samp{@var{exp} >= 0}), @var{m} is an integer or integer-valued "
"float in the range @w{@samp{[0 ..@: 60)}}, and @var{s} is any real number in "
"the range @samp{[0 ..@: 60)}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33374
msgid ""
"Date forms are stored as @samp{(date @var{n})}, where @var{n} is a real "
"number that counts days since midnight on the morning of January 1, 1 AD@.  "
"If @var{n} is an integer, this is a pure date form.  If @var{n} is a "
"fraction or float, this is a date/time form."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33378
msgid ""
"Modulo forms are stored as @samp{(mod @var{n} @var{m})}, where @var{m} is a "
"positive real number or HMS form, and @var{n} is a real number or HMS form "
"in the range @samp{[0 ..@: @var{m})}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33385
msgid ""
"Error forms are stored as @samp{(sdev @var{x} @var{sigma})}, where @var{x} "
"is the mean value and @var{sigma} is the standard deviation.  Each component "
"is either a number, an HMS form, or a symbolic object (a variable or "
"function call).  If @var{sigma} is zero, the value is converted to a plain "
"real number.  If @var{sigma} is negative or complex, it is automatically "
"normalized to be a positive real."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33396
msgid ""
"Interval forms are stored as @samp{(intv @var{mask} @var{lo} @var{hi})}, "
"where @var{mask} is one of the integers 0, 1, 2, or 3, and @var{lo} and "
"@var{hi} are real numbers, HMS forms, or symbolic objects.  The @var{mask} "
"is a binary integer where 1 represents the fact that the interval is closed "
"on the high end, and 2 represents the fact that it is closed on the low "
"end.  (Thus 3 represents a fully closed interval.)  The interval "
"@w{@samp{(intv 3 @var{x} @var{x})}} is converted to the plain number "
"@var{x}; intervals @samp{(intv @var{mask} @var{x} @var{x})} for any other "
"@var{mask} represent empty intervals.  If @var{hi} is less than @var{lo}, "
"the interval is converted to a standard empty interval by replacing @var{hi} "
"with @var{lo}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33403
msgid ""
"Vectors are stored as @samp{(vec @var{v1} @var{v2} @dots{})}, where @var{v1} "
"is the first element of the vector, @var{v2} is the second, and so on.  An "
"empty vector is stored as @samp{(vec)}.  A matrix is simply a vector where "
"all @var{v}'s are themselves vectors of equal lengths.  Note that Calc "
"vectors are unrelated to the Emacs Lisp ``vector'' type, which is generally "
"unused by Calc data structures."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33423
msgid ""
"Variables are stored as @samp{(var @var{name} @var{sym})}, where @var{name} "
"is a Lisp symbol whose print name is used as the visible name of the "
"variable, and @var{sym} is a Lisp symbol in which the variable's value is "
"actually stored.  Thus, @samp{(var pi var-pi)} represents the special "
"constant @samp{pi}.  Almost always, the form is @samp{(var @var{v} "
"var-@var{v})}.  If the variable name was entered with @code{#} signs (which "
"are converted to hyphens internally), the form is @samp{(var @var{u} "
"@var{v})}, where @var{u} is a symbol whose name contains @code{#} "
"characters, and @var{v} is a symbol that contains @code{-} characters "
"instead.  The value of a variable is the Calc object stored in its @var{sym} "
"symbol's value cell.  If the symbol's value cell is void or if it contains "
"@code{nil}, the variable has no value.  Special constants have the form "
"@samp{(special-const @var{value})} stored in their value cell, where "
"@var{value} is a formula which is evaluated when the constant's value is "
"requested.  Variables which represent units are not stored in any special "
"way; they are units only because their names appear in the units table.  If "
"the value cell contains a string, it is parsed to get the variable's value "
"when the variable is used."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33443
msgid ""
"A Lisp list with any other symbol as the first element is a function call.  "
"The symbols @code{+}, @code{-}, @code{*}, @code{/}, @code{%}, @code{^}, and "
"@code{|} represent special binary operators; these lists are always of the "
"form @samp{(@var{op} @var{lhs} @var{rhs})} where @var{lhs} is the "
"sub-formula on the lefthand side and @var{rhs} is the sub-formula on the "
"right.  The symbol @code{neg} represents unary negation; this list is always "
"of the form @samp{(neg @var{arg})}.  Any other symbol @var{func} represents "
"a function that would be displayed in function-call notation; the symbol "
"@var{func} is in general always of the form @samp{calcFunc-@var{name}}.  The "
"function cell of the symbol @var{func} should contain a Lisp function for "
"evaluating a call to @var{func}.  This function is passed the remaining "
"elements of the list (themselves already evaluated) as arguments; such "
"functions should return @code{nil} or call @code{reject-arg} to signify that "
"they should be left in symbolic form, or they should return a Calc object "
"which represents their value, or a list of such objects if they wish to "
"return multiple values.  (The latter case is allowed only for functions "
"which are the outer-level call in an expression whose value is about to be "
"pushed on the stack; this feature is considered obsolete and is not used by "
"any built-in Calc functions.)"
msgstr ""

#. type: node
#: ../../calc.texi:33444 ../../calc.texi:33505 ../../calc.texi:33692
#, no-wrap
msgid "Stack Lisp Functions"
msgstr ""

#. type: subsubsection
#: ../../calc.texi:33445
#, no-wrap
msgid "Interactive Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:33452
msgid ""
"The functions described here are used in implementing interactive Calc "
"commands.  Note that this list is not exhaustive! If there is an existing "
"command that behaves similarly to the one you want to define, you may find "
"helpful tricks by checking the source code for that command."
msgstr ""

#. type: defun
#: ../../calc.texi:33453
#, no-wrap
msgid "calc-set-command-flag flag"
msgstr ""

#. type: defun
#: ../../calc.texi:33458
msgid ""
"Set the command flag @var{flag}.  This is generally a Lisp symbol, but may "
"in fact be anything.  The effect is to add @var{flag} to the list stored in "
"the variable @code{calc-command-flags}, unless it is already there.  "
"@xref{Defining Simple Commands}."
msgstr ""

#. type: defun
#: ../../calc.texi:33460
#, no-wrap
msgid "calc-clear-command-flag flag"
msgstr ""

#. type: defun
#: ../../calc.texi:33463
msgid ""
"If @var{flag} appears among the list of currently-set command flags, remove "
"it from that list."
msgstr ""

#. type: defun
#: ../../calc.texi:33465
#, no-wrap
msgid "calc-record-undo rec"
msgstr ""

#. type: defun
#: ../../calc.texi:33479
msgid ""
"Add the ``undo record'' @var{rec} to the list of steps to take if the "
"current operation should need to be undone.  Stack push and pop functions "
"automatically call @code{calc-record-undo}, so the kinds of undo records you "
"might need to create take the form @samp{(set @var{sym} @var{value})}, which "
"says that the Lisp variable @var{sym} was changed and had previously "
"contained @var{value}; @samp{(store @var{var} @var{value})} which says that "
"the Calc variable @var{var} (a string which is the name of the symbol that "
"contains the variable's value) was stored and its previous value was "
"@var{value} (either a Calc data object, or @code{nil} if the variable was "
"previously void); or @samp{(eval @var{undo} @var{redo} @var{args} @dots{})}, "
"which means that to undo requires calling the function @samp{(@var{undo} "
"@var{args} @dots{})} and, if the undo is later redone, calling "
"@samp{(@var{redo} @var{args} @dots{})}."
msgstr ""

#. type: defun
#: ../../calc.texi:33481
#, no-wrap
msgid "calc-record-why msg args"
msgstr ""

#. type: defun
#: ../../calc.texi:33494
msgid ""
"Record the error or warning message @var{msg}, which is normally a string.  "
"This message will be replayed if the user types @kbd{w} (@code{calc-why}); "
"if the message string begins with a @samp{*}, it is considered important "
"enough to display even if the user doesn't type @kbd{w}.  If one or more "
"@var{args} are present, the displayed message will be of the form, "
"@samp{@var{msg}: @var{arg1}, @var{arg2}, @dots{}}, where the arguments are "
"formatted on the assumption that they are either strings or Calc objects of "
"some sort.  If @var{msg} is a symbol, it is the name of a Calc predicate "
"(such as @code{integerp} or @code{numvecp}) which the arguments did not "
"satisfy; it is expanded to a suitable string such as ``Expected an "
"integer.'' The @code{reject-arg} function calls @code{calc-record-why} "
"automatically; @pxref{Predicates}."
msgstr ""

#. type: defun
#: ../../calc.texi:33496
#, no-wrap
msgid "calc-is-inverse"
msgstr ""

#. type: defun
#: ../../calc.texi:33499
msgid ""
"This predicate returns true if the current command is inverse, i.e., if the "
"Inverse (@kbd{I} key) flag was set."
msgstr ""

#. type: defun
#: ../../calc.texi:33501
#, no-wrap
msgid "calc-is-hyperbolic"
msgstr ""

#. type: defun
#: ../../calc.texi:33503
msgid "This predicate is the analogous function for the @kbd{H} key."
msgstr ""

#. type: subsubsection
#: ../../calc.texi:33506
#, no-wrap
msgid "Stack-Oriented Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:33511
msgid ""
"The functions described here perform various operations on the Calc stack "
"and trail.  They are to be used in interactive Calc commands."
msgstr ""

#. type: defun
#: ../../calc.texi:33512
#, no-wrap
msgid "calc-push-list vals n"
msgstr ""

#. type: defun
#: ../../calc.texi:33521
msgid ""
"Push the Calc objects in list @var{vals} onto the stack at stack level "
"@var{n}.  If @var{n} is omitted it defaults to 1, so that the elements are "
"pushed at the top of the stack.  If @var{n} is greater than 1, the elements "
"will be inserted into the stack so that the last element will end up at "
"level @var{n}, the next-to-last at level @var{n}+1, etc.  The elements of "
"@var{vals} are assumed to be valid Calc objects, and are not evaluated, "
"rounded, or renormalized in any way.  If @var{vals} is an empty list, "
"nothing happens."
msgstr ""

#. type: defun
#: ../../calc.texi:33527
msgid ""
"The stack elements are pushed without any sub-formula selections.  You can "
"give an optional third argument to this function, which must be a list the "
"same size as @var{vals} of selections.  Each selection must be @code{eq} to "
"some sub-formula of the corresponding formula in @var{vals}, or @code{nil} "
"if that formula should have no selection."
msgstr ""

#. type: defun
#: ../../calc.texi:33529
#, no-wrap
msgid "calc-top-list n m"
msgstr ""

#. type: defun
#: ../../calc.texi:33540
msgid ""
"Return a list of the @var{n} objects starting at level @var{m} of the "
"stack.  If @var{m} is omitted it defaults to 1, so that the elements are "
"taken from the top of the stack.  If @var{n} is omitted, it also defaults to "
"1, so that the top stack element (in the form of a one-element list) is "
"returned.  If @var{m} is greater than 1, the @var{m}th stack element will be "
"at the end of the list, the @var{m}+1st element will be next-to-last, etc.  "
"If @var{n} or @var{m} are out of range, the command is aborted with a "
"suitable error message.  If @var{n} is zero, the function returns an empty "
"list.  The stack elements are not evaluated, rounded, or renormalized."
msgstr ""

#. type: defun
#: ../../calc.texi:33554
msgid ""
"If any stack elements contain selections, and selections have not been "
"disabled by the @kbd{j e} (@code{calc-enable-selections}) command, this "
"function returns the selected portions rather than the entire stack "
"elements.  It can be given a third ``selection-mode'' argument which selects "
"other behaviors.  If it is the symbol @code{t}, then a selection in any of "
"the requested stack elements produces an ``invalid operation on selections'' "
"error.  If it is the symbol @code{full}, the whole stack entry is always "
"returned regardless of selections.  If it is the symbol @code{sel}, the "
"selected portion is always returned, or @code{nil} if there is no "
"selection.  (This mode ignores the @kbd{j e} command.)  If the symbol is "
"@code{entry}, the complete stack entry in list form is returned; the first "
"element of this list will be the whole formula, and the third element will "
"be the selection (or @code{nil})."
msgstr ""

#. type: defun
#: ../../calc.texi:33556
#, no-wrap
msgid "calc-pop-stack n m"
msgstr ""

#. type: defun
#: ../../calc.texi:33560
msgid ""
"Remove the specified elements from the stack.  The parameters @var{n} and "
"@var{m} are defined the same as for @code{calc-top-list}.  The return value "
"of @code{calc-pop-stack} is uninteresting."
msgstr ""

#. type: defun
#: ../../calc.texi:33566
msgid ""
"If there are any selected sub-formulas among the popped elements, and @kbd{j "
"e} has not been used to disable selections, this produces an error without "
"changing the stack.  If you supply an optional third argument of @code{t}, "
"the stack elements are popped even if they contain selections."
msgstr ""

#. type: defun
#: ../../calc.texi:33568
#, no-wrap
msgid "calc-record-list vals tag"
msgstr ""

#. type: defun
#: ../../calc.texi:33573
msgid ""
"This function records one or more results in the trail.  The @var{vals} are "
"a list of strings or Calc objects.  The @var{tag} is the four-character tag "
"string to identify the values.  If @var{tag} is omitted, a blank tag will be "
"used."
msgstr ""

#. type: defun
#: ../../calc.texi:33575
#, no-wrap
msgid "calc-normalize n"
msgstr ""

#. type: defun
#: ../../calc.texi:33582
msgid ""
"This function takes a Calc object and ``normalizes'' it.  At the very least "
"this involves re-rounding floating-point values according to the current "
"precision and other similar jobs.  Also, unless the user has selected "
"No-Simplify mode (@pxref{Simplification Modes}), this involves actually "
"evaluating a formula object by executing the function calls it contains, and "
"possibly also doing algebraic simplification, etc."
msgstr ""

#. type: defun
#: ../../calc.texi:33584
#, no-wrap
msgid "calc-top-list-n n m"
msgstr ""

#. type: defun
#: ../../calc.texi:33594
msgid ""
"This function is identical to @code{calc-top-list}, except that it calls "
"@code{calc-normalize} on the values that it takes from the stack.  They are "
"also passed through @code{check-complete}, so that incomplete objects will "
"be rejected with an error message.  All computational commands should use "
"this in preference to @code{calc-top-list}; the only standard Calc commands "
"that operate on the stack without normalizing are stack management commands "
"like @code{calc-enter} and @code{calc-roll-up}.  This function accepts the "
"same optional selection-mode argument as @code{calc-top-list}."
msgstr ""

#. type: defun
#: ../../calc.texi:33596
#, no-wrap
msgid "calc-top-n m"
msgstr ""

#. type: defun
#: ../../calc.texi:33600
msgid ""
"This function is a convenient form of @code{calc-top-list-n} in which only a "
"single element of the stack is taken and returned, rather than a list of "
"elements.  This also accepts an optional selection-mode argument."
msgstr ""

#. type: defun
#: ../../calc.texi:33602
#, no-wrap
msgid "calc-enter-result n tag vals"
msgstr ""

#. type: defun
#: ../../calc.texi:33609
msgid ""
"This function is a convenient interface to most of the above functions.  The "
"@var{vals} argument should be either a single Calc object, or a list of Calc "
"objects; the object or objects are normalized, and the top @var{n} stack "
"entries are replaced by the normalized objects.  If @var{tag} is "
"non-@code{nil}, the normalized objects are also recorded in the trail.  A "
"typical stack-based computational command would take the form,"
msgstr ""

#. type: smallexample
#: ../../calc.texi:33613
#, no-wrap
msgid ""
"(calc-enter-result @var{n} @var{tag} (cons 'calcFunc-@var{func}\n"
"                               (calc-top-list-n @var{n})))\n"
msgstr ""

#. type: defun
#: ../../calc.texi:33628
msgid ""
"If any of the @var{n} stack elements replaced contain sub-formula "
"selections, and selections have not been disabled by @kbd{j e}, this "
"function takes one of two courses of action.  If @var{n} is equal to the "
"number of elements in @var{vals}, then each element of @var{vals} is spliced "
"into the corresponding selection; this is what happens when you use the "
"@key{TAB} key, or when you use a unary arithmetic operation like "
"@code{sqrt}.  If @var{vals} has only one element but @var{n} is greater than "
"one, there must be only one selection among the top @var{n} stack elements; "
"the element from @var{vals} is spliced into that selection.  This is what "
"happens when you use a binary arithmetic operation like @kbd{+}.  Any other "
"combination of @var{n} and @var{vals} is an error when selections are "
"present."
msgstr ""

#. type: defun
#: ../../calc.texi:33630
#, no-wrap
msgid "calc-unary-op tag func arg"
msgstr ""

#. type: defun
#: ../../calc.texi:33636
msgid ""
"This function implements a unary operator that allows a numeric prefix "
"argument to apply the operator over many stack entries.  If the prefix "
"argument @var{arg} is @code{nil}, this uses @code{calc-enter-result} as "
"outlined above.  Otherwise, it maps the function over several stack "
"elements; @pxref{Prefix Arguments}.  For example,"
msgstr ""

#. type: smallexample
#: ../../calc.texi:33641
#, no-wrap
msgid ""
"(defun calc-zeta (arg)\n"
"  (interactive \"P\")\n"
"  (calc-unary-op \"zeta\" 'calcFunc-zeta arg))\n"
msgstr ""

#. type: defun
#: ../../calc.texi:33644
#, no-wrap
msgid "calc-binary-op tag func arg ident unary"
msgstr ""

#. type: defun
#: ../../calc.texi:33657
msgid ""
"This function implements a binary operator, analogously to "
"@code{calc-unary-op}.  The optional @var{ident} and @var{unary} arguments "
"specify the behavior when the prefix argument is zero or one, respectively.  "
"If the prefix is zero, the value @var{ident} is pushed onto the stack, if "
"specified, otherwise an error message is displayed.  If the prefix is one, "
"the unary function @var{unary} is applied to the top stack element, or, if "
"@var{unary} is not specified, nothing happens.  When the argument is two or "
"more, the binary function @var{func} is reduced across the top @var{arg} "
"stack elements; when the argument is negative, the function is mapped "
"between the next-to-top @mathit{-@var{arg}} stack elements and the top "
"element."
msgstr ""

#. type: defun
#: ../../calc.texi:33659
#, no-wrap
msgid "calc-stack-size"
msgstr ""

#. type: defun
#: ../../calc.texi:33663
msgid ""
"Return the number of elements on the stack as an integer.  This count does "
"not include elements that have been temporarily hidden by stack truncation; "
"@pxref{Truncating the Stack}."
msgstr ""

#. type: defun
#: ../../calc.texi:33665
#, no-wrap
msgid "calc-cursor-stack-index n"
msgstr ""

#. type: defun
#: ../../calc.texi:33671
msgid ""
"Move the point to the @var{n}th stack entry.  If @var{n} is zero, this will "
"be the @samp{.} line.  If @var{n} is from 1 to the current stack size, this "
"will be the beginning of the first line of that stack entry's display.  If "
"line numbers are enabled, this will move to the first character of the line "
"number, not the stack entry itself."
msgstr ""

#. type: defun
#: ../../calc.texi:33673
#, no-wrap
msgid "calc-substack-height n"
msgstr ""

#. type: defun
#: ../../calc.texi:33681
msgid ""
"Return the number of lines between the beginning of the @var{n}th stack "
"entry and the bottom of the buffer.  If @var{n} is zero, this will be one "
"(assuming no stack truncation).  If all stack entries are one line long "
"(i.e., no matrices are displayed), the return value will be equal @var{n}+1 "
"as long as @var{n} is in range.  (Note that in Big mode, the return value "
"includes the blank lines that separate stack entries.)"
msgstr ""

#. type: defun
#: ../../calc.texi:33690
msgid ""
"Erase the @file{*Calculator*} buffer and reformat its contents from memory.  "
"This must be called after changing any parameter, such as the current "
"display radix, which might change the appearance of existing stack entries.  "
"(During a keyboard macro invoked by the @kbd{X} key, refreshing is "
"suppressed, but a flag is set so that the entire stack will be refreshed "
"rather than just the top few elements when the macro finishes.)"
msgstr ""

#. type: node
#: ../../calc.texi:33692 ../../calc.texi:33960 ../../calc.texi:34304
#, no-wrap
msgid "Computational Lisp Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:33702
msgid ""
"The functions described here are predicates, that is, they return a "
"true/false value where @code{nil} means false and anything else means true.  "
"These predicates are expanded by @code{defmath}, for example, from "
"@code{zerop} to @code{math-zerop}.  In many cases they correspond to native "
"Lisp functions by the same name, but are extended to cover the full range of "
"Calc data types."
msgstr ""

#. type: defun
#: ../../calc.texi:33703
#, no-wrap
msgid "zerop x"
msgstr ""

#. type: defun
#: ../../calc.texi:33709
msgid ""
"Returns true if @var{x} is numerically zero, in any of the Calc data types.  "
"(Note that for some types, such as error forms and intervals, it never makes "
"sense to return true.)  In @code{defmath}, the expression @samp{(= x 0)} "
"will automatically be converted to @samp{(math-zerop x)}, and @samp{(/= x "
"0)} will be converted to @samp{(not (math-zerop x))}."
msgstr ""

#. type: defun
#: ../../calc.texi:33711
#, no-wrap
msgid "negp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33717
msgid ""
"Returns true if @var{x} is negative.  This accepts negative real numbers of "
"various types, negative HMS and date forms, and intervals in which all "
"included values are negative.  In @code{defmath}, the expression @samp{(< x "
"0)} will automatically be converted to @samp{(math-negp x)}, and @samp{(>= x "
"0)} will be converted to @samp{(not (math-negp x))}."
msgstr ""

#. type: defun
#: ../../calc.texi:33719
#, no-wrap
msgid "posp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33722
msgid ""
"Returns true if @var{x} is positive (and non-zero).  For complex numbers, "
"none of these three predicates will return true."
msgstr ""

#. type: defun
#: ../../calc.texi:33724
#, no-wrap
msgid "looks-negp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33729
msgid ""
"Returns true if @var{x} is ``negative-looking.'' This returns true if "
"@var{x} is a negative number, or a formula with a leading minus sign such as "
"@samp{-a/b}.  In other words, this is an object which can be made simpler by "
"calling @code{(- @var{x})}."
msgstr ""

#. type: defun
#: ../../calc.texi:33731
#, no-wrap
msgid "integerp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33733
msgid "Returns true if @var{x} is an integer of any size."
msgstr ""

#. type: defun
#: ../../calc.texi:33735
#, no-wrap
msgid "fixnump x"
msgstr ""

#. type: defun
#: ../../calc.texi:33737
msgid "Returns true if @var{x} is a native Lisp integer."
msgstr ""

#. type: defun
#: ../../calc.texi:33739
#, no-wrap
msgid "natnump x"
msgstr ""

#. type: defun
#: ../../calc.texi:33741
msgid "Returns true if @var{x} is a nonnegative integer of any size."
msgstr ""

#. type: defun
#: ../../calc.texi:33743
#, no-wrap
msgid "fixnatnump x"
msgstr ""

#. type: defun
#: ../../calc.texi:33745
msgid "Returns true if @var{x} is a nonnegative Lisp integer."
msgstr ""

#. type: defun
#: ../../calc.texi:33747
#, no-wrap
msgid "num-integerp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33751
msgid ""
"Returns true if @var{x} is numerically an integer, i.e., either a true "
"integer or a float with no significant digits to the right of the decimal "
"point."
msgstr ""

#. type: defun
#: ../../calc.texi:33753
#, no-wrap
msgid "messy-integerp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33757
msgid ""
"Returns true if @var{x} is numerically, but not literally, an integer.  A "
"value is @code{num-integerp} if it is @code{integerp} or "
"@code{messy-integerp} (but it is never both at once)."
msgstr ""

#. type: defun
#: ../../calc.texi:33759
#, no-wrap
msgid "num-natnump x"
msgstr ""

#. type: defun
#: ../../calc.texi:33761
msgid "Returns true if @var{x} is numerically a nonnegative integer."
msgstr ""

#. type: defun
#: ../../calc.texi:33763
#, no-wrap
msgid "evenp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33765
msgid "Returns true if @var{x} is an even integer."
msgstr ""

#. type: defun
#: ../../calc.texi:33767
#, no-wrap
msgid "looks-evenp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33770
msgid ""
"Returns true if @var{x} is an even integer, or a formula with a leading "
"multiplicative coefficient which is an even integer."
msgstr ""

#. type: defun
#: ../../calc.texi:33772
#, no-wrap
msgid "oddp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33774
msgid "Returns true if @var{x} is an odd integer."
msgstr ""

#. type: defun
#: ../../calc.texi:33776
#, no-wrap
msgid "ratp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33779
msgid ""
"Returns true if @var{x} is a rational number, i.e., an integer or a "
"fraction."
msgstr ""

#. type: defun
#: ../../calc.texi:33781
#, no-wrap
msgid "realp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33784
msgid ""
"Returns true if @var{x} is a real number, i.e., an integer, fraction, or "
"floating-point number."
msgstr ""

#. type: defun
#: ../../calc.texi:33786
#, no-wrap
msgid "anglep x"
msgstr ""

#. type: defun
#: ../../calc.texi:33788
msgid "Returns true if @var{x} is a real number or HMS form."
msgstr ""

#. type: defun
#: ../../calc.texi:33790
#, no-wrap
msgid "floatp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33794
msgid ""
"Returns true if @var{x} is a float, or a complex number, error form, "
"interval, date form, or modulo form in which at least one component is a "
"float."
msgstr ""

#. type: defun
#: ../../calc.texi:33796
#, no-wrap
msgid "complexp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33799
msgid ""
"Returns true if @var{x} is a rectangular or polar complex number (but not a "
"real number)."
msgstr ""

#. type: defun
#: ../../calc.texi:33801
#, no-wrap
msgid "rect-complexp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33803
msgid "Returns true if @var{x} is a rectangular complex number."
msgstr ""

#. type: defun
#: ../../calc.texi:33805
#, no-wrap
msgid "polar-complexp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33807
msgid "Returns true if @var{x} is a polar complex number."
msgstr ""

#. type: defun
#: ../../calc.texi:33809
#, no-wrap
msgid "numberp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33811
msgid "Returns true if @var{x} is a real number or a complex number."
msgstr ""

#. type: defun
#: ../../calc.texi:33813
#, no-wrap
msgid "scalarp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33815
msgid "Returns true if @var{x} is a real or complex number or an HMS form."
msgstr ""

#. type: defun
#: ../../calc.texi:33817
#, no-wrap
msgid "vectorp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33820
msgid ""
"Returns true if @var{x} is a vector (this simply checks if its argument is a "
"list whose first element is the symbol @code{vec})."
msgstr ""

#. type: defun
#: ../../calc.texi:33822
#, no-wrap
msgid "numvecp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33824
msgid "Returns true if @var{x} is a number or vector."
msgstr ""

#. type: defun
#: ../../calc.texi:33826
#, no-wrap
msgid "matrixp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33829
msgid ""
"Returns true if @var{x} is a matrix, i.e., a vector of one or more vectors, "
"all of the same size."
msgstr ""

#. type: defun
#: ../../calc.texi:33831
#, no-wrap
msgid "square-matrixp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33833
msgid "Returns true if @var{x} is a square matrix."
msgstr ""

#. type: defun
#: ../../calc.texi:33835
#, no-wrap
msgid "objectp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33840
msgid ""
"Returns true if @var{x} is any numeric Calc object, including real and "
"complex numbers, HMS forms, date forms, error forms, intervals, and modulo "
"forms.  (Note that error forms and intervals may include formulas as their "
"components; see @code{constp} below.)"
msgstr ""

#. type: defun
#: ../../calc.texi:33842
#, no-wrap
msgid "objvecp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33846
msgid ""
"Returns true if @var{x} is an object or a vector.  This also accepts "
"incomplete objects, but it rejects variables and formulas (except as "
"mentioned above for @code{objectp})."
msgstr ""

#. type: defun
#: ../../calc.texi:33848
#, no-wrap
msgid "primp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33853
msgid ""
"Returns true if @var{x} is a ``primitive'' or ``atomic'' Calc object, i.e., "
"one whose components cannot be regarded as sub-formulas.  This includes "
"variables, and all @code{objectp} types except error forms and intervals."
msgstr ""

#. type: defun
#: ../../calc.texi:33855
#, no-wrap
msgid "constp x"
msgstr ""

#. type: defun
#: ../../calc.texi:33859
msgid ""
"Returns true if @var{x} is constant, i.e., a real or complex number, HMS "
"form, date form, or error form, interval, or vector all of whose components "
"are @code{constp}."
msgstr ""

#. type: defun
#: ../../calc.texi:33861
#, no-wrap
msgid "lessp x y"
msgstr ""

#. type: defun
#: ../../calc.texi:33869
msgid ""
"Returns true if @var{x} is numerically less than @var{y}.  Returns false if "
"@var{x} is greater than or equal to @var{y}, or if the order is undefined or "
"cannot be determined.  Generally speaking, this works by checking whether "
"@samp{@var{x} - @var{y}} is @code{negp}.  In @code{defmath}, the expression "
"@samp{(< x y)} will automatically be converted to @samp{(lessp x y)}; "
"expressions involving @code{>}, @code{<=}, and @code{>=} are similarly "
"converted in terms of @code{lessp}."
msgstr ""

#. type: defun
#: ../../calc.texi:33871
#, no-wrap
msgid "beforep x y"
msgstr ""

#. type: defun
#: ../../calc.texi:33881
msgid ""
"Returns true if @var{x} comes before @var{y} in a canonical ordering of Calc "
"objects.  If @var{x} and @var{y} are both real numbers, this will be the "
"same as @code{lessp}.  But whereas @code{lessp} considers other types of "
"objects to be unordered, @code{beforep} puts any two objects into a "
"definite, consistent order.  The @code{beforep} function is used by the "
"@kbd{V S} vector-sorting command, and also by Calc's algebraic "
"simplifications to put the terms of a product into canonical order: This "
"allows @samp{x y + y x} to be simplified easily to @samp{2 x y}."
msgstr ""

#. type: defun
#: ../../calc.texi:33883
#, no-wrap
msgid "equal x y"
msgstr ""

#. type: defun
#: ../../calc.texi:33888
msgid ""
"This is the standard Lisp @code{equal} predicate; it returns true if @var{x} "
"and @var{y} are structurally identical.  This is the usual way to compare "
"numbers for equality, but note that @code{equal} will treat 0 and 0.0 as "
"different."
msgstr ""

#. type: defun
#: ../../calc.texi:33890
#, no-wrap
msgid "math-equal x y"
msgstr ""

#. type: defun
#: ../../calc.texi:33895
msgid ""
"Returns true if @var{x} and @var{y} are numerically equal, either because "
"they are @code{equal}, or because their difference is @code{zerop}.  In "
"@code{defmath}, the expression @samp{(= x y)} will automatically be "
"converted to @samp{(math-equal x y)}."
msgstr ""

#. type: defun
#: ../../calc.texi:33897
#, no-wrap
msgid "equal-int x n"
msgstr ""

#. type: defun
#: ../../calc.texi:33902
msgid ""
"Returns true if @var{x} and @var{n} are numerically equal, where @var{n} is "
"a fixnum which is not a multiple of 10.  This will automatically be used by "
"@code{defmath} in place of the more general @code{math-equal} whenever "
"possible."
msgstr ""

#. type: defun
#: ../../calc.texi:33904
#, no-wrap
msgid "nearly-equal x y"
msgstr ""

#. type: defun
#: ../../calc.texi:33917
msgid ""
"Returns true if @var{x} and @var{y}, as floating-point numbers, are equal "
"except possibly in the last decimal place.  For example, 314.159 and 314.166 "
"are considered nearly equal if the current precision is 6 (since they differ "
"by 7 units), but not if the current precision is 7 (since they differ by 70 "
"units).  Most functions which use series expansions use "
"@code{with-extra-prec} to evaluate the series with 2 extra digits of "
"precision, then use @code{nearly-equal} to decide when the series has "
"converged; this guards against cumulative error in the series evaluation "
"without doing extra work which would be lost when the result is rounded back "
"down to the current precision.  In @code{defmath}, this can be written "
"@samp{(~= @var{x} @var{y})}.  The @var{x} and @var{y} can be numbers of any "
"kind, including complex."
msgstr ""

#. type: defun
#: ../../calc.texi:33919
#, no-wrap
msgid "nearly-zerop x y"
msgstr ""

#. type: defun
#: ../../calc.texi:33926
msgid ""
"Returns true if @var{x} is nearly zero, compared to @var{y}.  This checks "
"whether @var{x} plus @var{y} would by be @code{nearly-equal} to @var{y} "
"itself, to within the current precision, in other words, if adding @var{x} "
"to @var{y} would have a negligible effect on @var{y} due to roundoff error.  "
"@var{X} may be a real or complex number, but @var{y} must be real."
msgstr ""

#. type: defun
#: ../../calc.texi:33928
#, no-wrap
msgid "is-true x"
msgstr ""

#. type: defun
#: ../../calc.texi:33932
msgid ""
"Return true if the formula @var{x} represents a true value in Calc, not "
"Lisp, terms.  It tests if @var{x} is a non-zero number or a provably "
"non-zero formula."
msgstr ""

#. type: defun
#: ../../calc.texi:33934
#, no-wrap
msgid "reject-arg val pred"
msgstr ""

#. type: defun
#: ../../calc.texi:33939
msgid ""
"Abort the current function evaluation due to unacceptable argument values.  "
"This calls @samp{(calc-record-why @var{pred} @var{val})}, then signals a "
"Lisp error which @code{normalize} will trap.  The net effect is that the "
"function call which led here will be left in symbolic form."
msgstr ""

#. type: defun
#: ../../calc.texi:33941
#, no-wrap
msgid "inexact-value"
msgstr ""

#. type: defun
#: ../../calc.texi:33950
msgid ""
"If Symbolic mode is enabled, this will signal an error that causes "
"@code{normalize} to leave the formula in symbolic form, with the message "
"``Inexact result.'' (This function has no effect when not in Symbolic mode.)  "
"Note that if your function calls @samp{(sin 5)} in Symbolic mode, the "
"@code{sin} function will call @code{inexact-value}, which will cause your "
"function to be left unsimplified.  You may instead wish to call "
"@samp{(normalize (list 'calcFunc-sin 5))}, which in Symbolic mode will "
"return the formula @samp{sin(5)} to your function."
msgstr ""

#. type: defun
#: ../../calc.texi:33952
#, no-wrap
msgid "overflow"
msgstr ""

#. type: defun
#: ../../calc.texi:33954
msgid "This signals an error that will be reported as a floating-point overflow."
msgstr ""

#. type: defun
#: ../../calc.texi:33956
#, no-wrap
msgid "underflow"
msgstr ""

#. type: defun
#: ../../calc.texi:33958
msgid "This signals a floating-point underflow."
msgstr ""

#. type: node
#: ../../calc.texi:33960 ../../calc.texi:34304 ../../calc.texi:34441
#, no-wrap
msgid "Vector Lisp Functions"
msgstr ""

#. type: subsubsection
#: ../../calc.texi:33961
#, no-wrap
msgid "Computational Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:33971
msgid ""
"The functions described here do the actual computational work of the "
"Calculator.  In addition to these, note that any function described in the "
"main body of this manual may be called from Lisp; for example, if the "
"documentation refers to the @code{calc-sqrt} [@code{sqrt}] command, this "
"means @code{calc-sqrt} is an interactive stack-based square-root command and "
"@code{sqrt} (which @code{defmath} expands to @code{calcFunc-sqrt})  is the "
"actual Lisp function for taking square roots."
msgstr ""

#. type: Plain text
#: ../../calc.texi:33977
msgid ""
"The functions @code{math-add}, @code{math-sub}, @code{math-mul}, "
"@code{math-div}, @code{math-mod}, and @code{math-neg} are not included in "
"this list, since @code{defmath} allows you to write native Lisp @code{+}, "
"@code{-}, @code{*}, @code{/}, @code{%}, and unary @code{-}, respectively, "
"instead."
msgstr ""

#. type: defun
#: ../../calc.texi:33978
#, no-wrap
msgid "normalize val"
msgstr ""

#. type: defun
#: ../../calc.texi:33988
msgid ""
"(Full form: @code{math-normalize}.)  Reduce the value @var{val} to standard "
"form.  For example, if @var{val} is a fixnum, it will be converted to a "
"bignum if it is too large, and if @var{val} is a bignum it will be "
"normalized by clipping off trailing (i.e., most-significant) zero digits and "
"converting to a fixnum if it is small.  All the various data types are "
"similarly converted to their standard forms.  Variables are left alone, but "
"function calls are actually evaluated in formulas.  For example, normalizing "
"@samp{(+ 2 (calcFunc-abs -4))} will return 6."
msgstr ""

#. type: defun
#: ../../calc.texi:33993
msgid ""
"If a function call fails, because the function is void or has the wrong "
"number of parameters, or because it returns @code{nil} or calls "
"@code{reject-arg} or @code{inexact-result}, @code{normalize} returns the "
"formula still in symbolic form."
msgstr ""

#. type: defun
#: ../../calc.texi:34002
msgid ""
"If the current simplification mode is ``none'' or ``numeric arguments "
"only,'' @code{normalize} will act appropriately.  However, the more powerful "
"simplification modes (like Algebraic Simplification) are not handled by "
"@code{normalize}.  They are handled by @code{calc-normalize}, which calls "
"@code{normalize} and possibly some other routines, such as @code{simplify} "
"or @code{simplify-units}.  Programs generally will never call "
"@code{calc-normalize} except when popping or pushing values on the stack."
msgstr ""

#. type: defun
#: ../../calc.texi:34004
#, no-wrap
msgid "evaluate-expr expr"
msgstr ""

#. type: defun
#: ../../calc.texi:34008
msgid ""
"Replace all variables in @var{expr} that have values with their values, then "
"use @code{normalize} to simplify the result.  This is what happens when you "
"press the @kbd{=} key interactively."
msgstr ""

#. type: defmac
#: ../../calc.texi:34010
#, no-wrap
msgid "with-extra-prec n body"
msgstr ""

#. type: defmac
#: ../../calc.texi:34013
msgid ""
"Evaluate the Lisp forms in @var{body} with precision increased by @var{n} "
"digits.  This is a macro which expands to"
msgstr ""

#. type: smallexample
#: ../../calc.texi:34018
#, no-wrap
msgid ""
"(math-normalize\n"
"  (let ((calc-internal-prec (+ calc-internal-prec @var{n})))\n"
"    @var{body}))\n"
msgstr ""

#. type: defmac
#: ../../calc.texi:34024
msgid ""
"The surrounding call to @code{math-normalize} causes a floating-point result "
"to be rounded down to the original precision afterwards.  This is important "
"because some arithmetic operations assume a number's mantissa contains no "
"more digits than the current precision allows."
msgstr ""

#. type: defun
#: ../../calc.texi:34026
#, no-wrap
msgid "make-frac n d"
msgstr ""

#. type: defun
#: ../../calc.texi:34029
msgid ""
"Build a fraction @samp{@var{n}:@var{d}}.  This is equivalent to calling "
"@samp{(normalize (list 'frac @var{n} @var{d}))}, but more efficient."
msgstr ""

#. type: defun
#: ../../calc.texi:34031
#, no-wrap
msgid "make-float mant exp"
msgstr ""

#. type: defun
#: ../../calc.texi:34036
msgid ""
"Build a floating-point value out of @var{mant} and @var{exp}, both of which "
"are arbitrary integers.  This function will return a properly normalized "
"float value, or signal an overflow or underflow if @var{exp} is out of "
"range."
msgstr ""

#. type: defun
#: ../../calc.texi:34038
#, no-wrap
msgid "make-sdev x sigma"
msgstr ""

#. type: defun
#: ../../calc.texi:34044
msgid ""
"Build an error form out of @var{x} and the absolute value of @var{sigma}.  "
"If @var{sigma} is zero, the result is the number @var{x} directly.  If "
"@var{sigma} is negative or complex, its absolute value is used.  If @var{x} "
"or @var{sigma} is not a valid type of object for use in error forms, this "
"calls @code{reject-arg}."
msgstr ""

#. type: defun
#: ../../calc.texi:34046
#, no-wrap
msgid "make-intv mask lo hi"
msgstr ""

#. type: defun
#: ../../calc.texi:34051
msgid ""
"Build an interval form out of @var{mask} (which is assumed to be an integer "
"from 0 to 3), and the limits @var{lo} and @var{hi}.  If @var{lo} is greater "
"than @var{hi}, an empty interval form is returned.  This calls "
"@code{reject-arg} if @var{lo} or @var{hi} is unsuitable."
msgstr ""

#. type: defun
#: ../../calc.texi:34053
#, no-wrap
msgid "sort-intv mask lo hi"
msgstr ""

#. type: defun
#: ../../calc.texi:34057
msgid ""
"Build an interval form, similar to @code{make-intv}, except that if @var{lo} "
"is less than @var{hi} they are simply exchanged, and the bits of @var{mask} "
"are swapped accordingly."
msgstr ""

#. type: defun
#: ../../calc.texi:34059
#, no-wrap
msgid "make-mod n m"
msgstr ""

#. type: defun
#: ../../calc.texi:34064
msgid ""
"Build a modulo form out of @var{n} and the modulus @var{m}.  Since modulo "
"forms do not allow formulas as their components, if @var{n} or @var{m} is "
"not a real number or HMS form the result will be a formula which is a call "
"to @code{makemod}, the algebraic version of this function."
msgstr ""

#. type: defun
#: ../../calc.texi:34066
#, no-wrap
msgid "float x"
msgstr ""

#. type: defun
#: ../../calc.texi:34072
msgid ""
"Convert @var{x} to floating-point form.  Integers and fractions are "
"converted to numerically equivalent floats; components of complex numbers, "
"vectors, HMS forms, date forms, error forms, intervals, and modulo forms are "
"recursively floated.  If the argument is a variable or formula, this calls "
"@code{reject-arg}."
msgstr ""

#. type: defun
#: ../../calc.texi:34074
#, no-wrap
msgid "compare x y"
msgstr ""

#. type: defun
#: ../../calc.texi:34079
msgid ""
"Compare the numbers @var{x} and @var{y}, and return @mathit{-1} if "
"@samp{(lessp @var{x} @var{y})}, 1 if @samp{(lessp @var{y} @var{x})}, 0 if "
"@samp{(math-equal @var{x} @var{y})}, or 2 if the order is undefined or "
"cannot be determined."
msgstr ""

#. type: defun
#: ../../calc.texi:34081
#, no-wrap
msgid "numdigs n"
msgstr ""

#. type: defun
#: ../../calc.texi:34085
msgid ""
"Return the number of digits of integer @var{n}, effectively "
"@samp{ceil(log10(@var{n}))}, but much more efficient.  Zero is considered to "
"have zero digits."
msgstr ""

#. type: defun
#: ../../calc.texi:34087
#, no-wrap
msgid "scale-int x n"
msgstr ""

#. type: defun
#: ../../calc.texi:34090
msgid ""
"Shift integer @var{x} left @var{n} decimal digits, or right "
"@mathit{-@var{n}} digits with truncation toward zero."
msgstr ""

#. type: defun
#: ../../calc.texi:34092
#, no-wrap
msgid "scale-rounding x n"
msgstr ""

#. type: defun
#: ../../calc.texi:34095
msgid ""
"Like @code{scale-int}, except that a right shift rounds to the nearest "
"integer rather than truncating."
msgstr ""

#. type: defun
#: ../../calc.texi:34097
#, no-wrap
msgid "fixnum n"
msgstr ""

#. type: defun
#: ../../calc.texi:34101
msgid ""
"Return the integer @var{n} as a fixnum, i.e., a native Lisp integer.  If "
"@var{n} is outside the permissible range for Lisp integers (usually 24 "
"binary bits) the result is undefined."
msgstr ""

#. type: defun
#: ../../calc.texi:34103
#, no-wrap
msgid "sqr x"
msgstr ""

#. type: defun
#: ../../calc.texi:34105
msgid "Compute the square of @var{x}; short for @samp{(* @var{x} @var{x})}."
msgstr ""

#. type: defun
#: ../../calc.texi:34107
#, no-wrap
msgid "quotient x y"
msgstr ""

#. type: defun
#: ../../calc.texi:34111
msgid ""
"Divide integer @var{x} by integer @var{y}; return an integer quotient and "
"discard the remainder.  If @var{x} or @var{y} is negative, the direction of "
"rounding is undefined."
msgstr ""

#. type: defun
#: ../../calc.texi:34113
#, no-wrap
msgid "idiv x y"
msgstr ""

#. type: defun
#: ../../calc.texi:34118
msgid ""
"Perform an integer division; if @var{x} and @var{y} are both nonnegative "
"integers, this uses the @code{quotient} function, otherwise it computes "
"@samp{floor(@var{x}/@var{y})}.  Thus the result is well-defined but slower "
"than for @code{quotient}."
msgstr ""

#. type: defun
#: ../../calc.texi:34120
#, no-wrap
msgid "imod x y"
msgstr ""

#. type: defun
#: ../../calc.texi:34125
msgid ""
"Divide integer @var{x} by integer @var{y}; return the integer remainder and "
"discard the quotient.  Like @code{quotient}, this works only for integer "
"arguments and is not well-defined for negative arguments.  For a more "
"well-defined result, use @samp{(% @var{x} @var{y})}."
msgstr ""

#. type: defun
#: ../../calc.texi:34127
#, no-wrap
msgid "idivmod x y"
msgstr ""

#. type: defun
#: ../../calc.texi:34131
msgid ""
"Divide integer @var{x} by integer @var{y}; return a cons cell whose "
"@code{car} is @samp{(quotient @var{x} @var{y})} and whose @code{cdr} is "
"@samp{(imod @var{x} @var{y})}."
msgstr ""

#. type: defun
#: ../../calc.texi:34133
#, no-wrap
msgid "pow x y"
msgstr ""

#. type: defun
#: ../../calc.texi:34137
msgid ""
"Compute @var{x} to the power @var{y}.  In @code{defmath} code, this can also "
"be written @samp{(^ @var{x} @var{y})} or @w{@samp{(expt @var{x} @var{y})}}."
msgstr ""

#. type: defun
#: ../../calc.texi:34139
#, no-wrap
msgid "abs-approx x"
msgstr ""

#. type: defun
#: ../../calc.texi:34143
msgid ""
"Compute a fast approximation to the absolute value of @var{x}.  For example, "
"for a rectangular complex number the result is the sum of the absolute "
"values of the components."
msgstr ""

#. type: findex
#: ../../calc.texi:34146
#, no-wrap
msgid "gamma-const"
msgstr ""

#. type: findex
#: ../../calc.texi:34147
#, no-wrap
msgid "ln-2"
msgstr ""

#. type: findex
#: ../../calc.texi:34148
#, no-wrap
msgid "ln-10"
msgstr ""

#. type: findex
#: ../../calc.texi:34150
#, no-wrap
msgid "pi-over-2"
msgstr ""

#. type: findex
#: ../../calc.texi:34151
#, no-wrap
msgid "pi-over-4"
msgstr ""

#. type: findex
#: ../../calc.texi:34152
#, no-wrap
msgid "pi-over-180"
msgstr ""

#. type: findex
#: ../../calc.texi:34153
#, no-wrap
msgid "sqrt-two-pi"
msgstr ""

#. type: findex
#: ../../calc.texi:34154
#, no-wrap
msgid "sqrt-e"
msgstr ""

#. type: findex
#: ../../calc.texi:34155
#, no-wrap
msgid "two-pi"
msgstr ""

#. type: defun
#: ../../calc.texi:34164
msgid ""
"The function @samp{(pi)} computes @samp{pi} to the current precision.  Other "
"related constant-generating functions are @code{two-pi}, @code{pi-over-2}, "
"@code{pi-over-4}, @code{pi-over-180}, @code{sqrt-two-pi}, @code{e}, "
"@code{sqrt-e}, @code{ln-2}, @code{ln-10}, @code{phi} and "
"@code{gamma-const}.  Each function returns a floating-point value in the "
"current precision, and each uses caching so that all calls after the first "
"are essentially free."
msgstr ""

#. type: defmac
#: ../../calc.texi:34166
#, no-wrap
msgid "math-defcache @var{func} @var{initial} @var{form}"
msgstr ""

#. type: defmac
#: ../../calc.texi:34179
msgid ""
"This macro, usually used as a top-level call like @code{defun} or "
"@code{defvar}, defines a new cached constant analogous to @code{pi}, etc.  "
"It defines a function @code{func} which returns the requested value; if "
"@var{initial} is non-@code{nil} it must be a @samp{(float @dots{})} form "
"which serves as an initial value for the cache.  If @var{func} is called "
"when the cache is empty or does not have enough digits to satisfy the "
"current precision, the Lisp expression @var{form} is evaluated with the "
"current precision increased by four, and the result minus its two least "
"significant digits is stored in the cache.  For example, calling @samp{(pi)} "
"with a precision of 30 computes @samp{pi} to 34 digits, rounds it down to 32 "
"digits for future use, then rounds it again to 30 digits for use in the "
"present request."
msgstr ""

#. type: findex
#: ../../calc.texi:34181
#, no-wrap
msgid "half-circle"
msgstr ""

#. type: findex
#: ../../calc.texi:34182
#, no-wrap
msgid "quarter-circle"
msgstr ""

#. type: defun
#: ../../calc.texi:34183
#, no-wrap
msgid "full-circle symb"
msgstr ""

#. type: defun
#: ../../calc.texi:34189
msgid ""
"If the current angular mode is Degrees or HMS, this function returns the "
"integer 360.  In Radians mode, this function returns either the "
"corresponding value in radians to the current precision, or the formula "
"@samp{2*pi}, depending on the Symbolic mode.  There are also similar "
"function @code{half-circle} and @code{quarter-circle}."
msgstr ""

#. type: defun
#: ../../calc.texi:34191
#, no-wrap
msgid "power-of-2 n"
msgstr ""

#. type: defun
#: ../../calc.texi:34195
msgid ""
"Compute two to the integer power @var{n}, as a (potentially very large)  "
"integer.  Powers of two are cached, so only the first call for a particular "
"@var{n} is expensive."
msgstr ""

#. type: defun
#: ../../calc.texi:34197
#, no-wrap
msgid "integer-log2 n"
msgstr ""

#. type: defun
#: ../../calc.texi:34201
msgid ""
"Compute the base-2 logarithm of @var{n}, which must be an integer which is a "
"power of two.  If @var{n} is not a power of two, this function will return "
"@code{nil}."
msgstr ""

#. type: defun
#: ../../calc.texi:34203
#, no-wrap
msgid "div-mod a b m"
msgstr ""

#. type: defun
#: ../../calc.texi:34206
msgid ""
"Divide @var{a} by @var{b}, modulo @var{m}.  This returns @code{nil} if there "
"is no solution, or if any of the arguments are not integers."
msgstr ""

#. type: defun
#: ../../calc.texi:34208
#, no-wrap
msgid "pow-mod a b m"
msgstr ""

#. type: defun
#: ../../calc.texi:34212
msgid ""
"Compute @var{a} to the power @var{b}, modulo @var{m}.  If @var{a}, @var{b}, "
"and @var{m} are integers, this uses an especially efficient algorithm.  "
"Otherwise, it simply computes @samp{(% (^ a b) m)}."
msgstr ""

#. type: defun
#: ../../calc.texi:34214
#, no-wrap
msgid "isqrt n"
msgstr ""

#. type: defun
#: ../../calc.texi:34218
msgid ""
"Compute the integer square root of @var{n}.  This is the square root of "
"@var{n} rounded down toward zero, i.e., @samp{floor(sqrt(@var{n}))}.  If "
"@var{n} is itself an integer, the computation is especially efficient."
msgstr ""

#. type: defun
#: ../../calc.texi:34220
#, no-wrap
msgid "to-hms a ang"
msgstr ""

#. type: defun
#: ../../calc.texi:34225
msgid ""
"Convert the argument @var{a} into an HMS form.  If @var{ang} is specified, "
"it is the angular mode in which to interpret @var{a}, either @code{deg} or "
"@code{rad}.  Otherwise, the current angular mode is used.  If @var{a} is "
"already an HMS form it is returned as-is."
msgstr ""

#. type: defun
#: ../../calc.texi:34227
#, no-wrap
msgid "from-hms a ang"
msgstr ""

#. type: defun
#: ../../calc.texi:34232
msgid ""
"Convert the HMS form @var{a} into a real number.  If @var{ang} is specified, "
"it is the angular mode in which to express the result, otherwise the current "
"angular mode is used.  If @var{a} is already a real number, it is returned "
"as-is."
msgstr ""

#. type: defun
#: ../../calc.texi:34234
#, no-wrap
msgid "to-radians a"
msgstr ""

#. type: defun
#: ../../calc.texi:34237
msgid ""
"Convert the number or HMS form @var{a} to radians from the current angular "
"mode."
msgstr ""

#. type: defun
#: ../../calc.texi:34239
#, no-wrap
msgid "from-radians a"
msgstr ""

#. type: defun
#: ../../calc.texi:34242
msgid ""
"Convert the number @var{a} from radians to the current angular mode.  If "
"@var{a} is a formula, this returns the formula @samp{deg(@var{a})}."
msgstr ""

#. type: defun
#: ../../calc.texi:34244
#, no-wrap
msgid "to-radians-2 a"
msgstr ""

#. type: defun
#: ../../calc.texi:34247
msgid ""
"Like @code{to-radians}, except that in Symbolic mode a degrees to radians "
"conversion yields a formula like @samp{@var{a}*pi/180}."
msgstr ""

#. type: defun
#: ../../calc.texi:34249
#, no-wrap
msgid "from-radians-2 a"
msgstr ""

#. type: defun
#: ../../calc.texi:34252
msgid ""
"Like @code{from-radians}, except that in Symbolic mode a radians to degrees "
"conversion yields a formula like @samp{@var{a}*180/pi}."
msgstr ""

#. type: defun
#: ../../calc.texi:34254
#, no-wrap
msgid "random-digit"
msgstr ""

#. type: defun
#: ../../calc.texi:34256
msgid "Produce a random base-1000 digit in the range 0 to 999."
msgstr ""

#. type: defun
#: ../../calc.texi:34258
#, no-wrap
msgid "random-digits n"
msgstr ""

#. type: defun
#: ../../calc.texi:34261
msgid ""
"Produce a random @var{n}-digit integer; this will be an integer in the "
"interval @samp{[0, 10^@var{n})}."
msgstr ""

#. type: defun
#: ../../calc.texi:34263
#, no-wrap
msgid "random-float"
msgstr ""

#. type: defun
#: ../../calc.texi:34265
msgid "Produce a random float in the interval @samp{[0, 1)}."
msgstr ""

#. type: defun
#: ../../calc.texi:34267
#, no-wrap
msgid "prime-test n iters"
msgstr ""

#. type: defun
#: ../../calc.texi:34281
msgid ""
"Determine whether the integer @var{n} is prime.  Return a list which has one "
"of these forms: @samp{(nil @var{f})} means the number is non-prime because "
"it was found to be divisible by @var{f}; @samp{(nil)} means it was found to "
"be non-prime by table look-up (so no factors are known); @samp{(nil "
"unknown)} means it is definitely non-prime but no factors are known because "
"@var{n} was large enough that Fermat's probabilistic test had to be used; "
"@samp{(t)} means the number is definitely prime; and @samp{(maybe @var{i} "
"@var{p})} means that Fermat's test, after @var{i} iterations, is @var{p} "
"percent sure that the number is prime.  The @var{iters} parameter is the "
"number of Fermat iterations to use, in the case that this is necessary.  If "
"@code{prime-test} returns ``maybe,'' you can call it again with the same "
"@var{n} to get a greater certainty; @code{prime-test} remembers where it "
"left off."
msgstr ""

#. type: defun
#: ../../calc.texi:34283
#, no-wrap
msgid "to-simple-fraction f"
msgstr ""

#. type: defun
#: ../../calc.texi:34288
msgid ""
"If @var{f} is a floating-point number which can be represented exactly as a "
"small rational number, return that number, else return @var{f}.  For "
"example, 0.75 would be converted to 3:4.  This function is very fast."
msgstr ""

#. type: defun
#: ../../calc.texi:34290
#, no-wrap
msgid "to-fraction f tol"
msgstr ""

#. type: defun
#: ../../calc.texi:34294
msgid ""
"Find a rational approximation to floating-point number @var{f} to within a "
"specified tolerance @var{tol}; this corresponds to the algebraic function "
"@code{frac}, and can be rather slow."
msgstr ""

#. type: defun
#: ../../calc.texi:34296
#, no-wrap
msgid "quarter-integer n"
msgstr ""

#. type: defun
#: ../../calc.texi:34302
msgid ""
"If @var{n} is an integer or integer-valued float, this function returns "
"zero.  If @var{n} is a half-integer (i.e., an integer plus @mathit{1:2} or "
"0.5), it returns 2.  If @var{n} is a quarter-integer, it returns 1 or 3.  If "
"@var{n} is anything else, this function returns @code{nil}."
msgstr ""

#. type: node
#: ../../calc.texi:34304 ../../calc.texi:34441 ../../calc.texi:35012
#, no-wrap
msgid "Symbolic Lisp Functions"
msgstr ""

#. type: subsubsection
#: ../../calc.texi:34305
#, no-wrap
msgid "Vector Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:34310
msgid ""
"The functions described here perform various operations on vectors and "
"matrices."
msgstr ""

#. type: defun
#: ../../calc.texi:34311
#, no-wrap
msgid "math-concat x y"
msgstr ""

#. type: defun
#: ../../calc.texi:34314
msgid ""
"Do a vector concatenation; this operation is written @samp{@var{x} | "
"@var{y}} in a symbolic formula.  @xref{Building Vectors}."
msgstr ""

#. type: defun
#: ../../calc.texi:34316
#, no-wrap
msgid "vec-length v"
msgstr ""

#. type: defun
#: ../../calc.texi:34320
msgid ""
"Return the length of vector @var{v}.  If @var{v} is not a vector, the result "
"is zero.  If @var{v} is a matrix, this returns the number of rows in the "
"matrix."
msgstr ""

#. type: defun
#: ../../calc.texi:34322
#, no-wrap
msgid "mat-dimens m"
msgstr ""

#. type: defun
#: ../../calc.texi:34332
msgid ""
"Determine the dimensions of vector or matrix @var{m}.  If @var{m} is not a "
"vector, the result is an empty list.  If @var{m} is a plain vector but not a "
"matrix, the result is a one-element list containing the length of the "
"vector.  If @var{m} is a matrix with @var{r} rows and @var{c} columns, the "
"result is the list @samp{(@var{r} @var{c})}.  Higher-order tensors produce "
"lists of more than two dimensions.  Note that the object @samp{[[1, 2, 3], "
"[4, 5]]} is a vector of vectors not all the same size, and is treated by "
"this and other Calc routines as a plain vector of two elements."
msgstr ""

#. type: defun
#: ../../calc.texi:34334
#, no-wrap
msgid "dimension-error"
msgstr ""

#. type: defun
#: ../../calc.texi:34338
msgid ""
"Abort the current function with a message of ``Dimension error.'' The "
"Calculator will leave the function being evaluated in symbolic form; this is "
"really just a special case of @code{reject-arg}."
msgstr ""

#. type: defun
#: ../../calc.texi:34340
#, no-wrap
msgid "build-vector args"
msgstr ""

#. type: defun
#: ../../calc.texi:34344
msgid ""
"Return a Calc vector with @var{args} as elements.  For example, "
"@samp{(build-vector 1 2 3)} returns the Calc vector @samp{[1, 2, 3]}, stored "
"internally as the list @samp{(vec 1 2 3)}."
msgstr ""

#. type: defun
#: ../../calc.texi:34346
#, no-wrap
msgid "make-vec obj dims"
msgstr ""

#. type: defun
#: ../../calc.texi:34350
msgid ""
"Return a Calc vector or matrix all of whose elements are equal to "
"@var{obj}.  For example, @samp{(make-vec 27 3 4)} returns a 3x4 matrix "
"filled with 27's."
msgstr ""

#. type: defun
#: ../../calc.texi:34352
#, no-wrap
msgid "row-matrix v"
msgstr ""

#. type: defun
#: ../../calc.texi:34356
msgid ""
"If @var{v} is a plain vector, convert it into a row matrix, i.e., a matrix "
"whose single row is @var{v}.  If @var{v} is already a matrix, leave it "
"alone."
msgstr ""

#. type: defun
#: ../../calc.texi:34358
#, no-wrap
msgid "col-matrix v"
msgstr ""

#. type: defun
#: ../../calc.texi:34362
msgid ""
"If @var{v} is a plain vector, convert it into a column matrix, i.e., a "
"matrix with each element of @var{v} as a separate row.  If @var{v} is "
"already a matrix, leave it alone."
msgstr ""

#. type: defun
#: ../../calc.texi:34364
#, no-wrap
msgid "map-vec f v"
msgstr ""

#. type: defun
#: ../../calc.texi:34368
msgid ""
"Map the Lisp function @var{f} over the Calc vector @var{v}.  For example, "
"@samp{(map-vec 'math-floor v)} returns a vector of the floored components of "
"vector @var{v}."
msgstr ""

#. type: defun
#: ../../calc.texi:34370
#, no-wrap
msgid "map-vec-2 f a b"
msgstr ""

#. type: defun
#: ../../calc.texi:34380
msgid ""
"Map the Lisp function @var{f} over the two vectors @var{a} and @var{b}.  If "
"@var{a} and @var{b} are vectors of equal length, the result is a vector of "
"the results of calling @samp{(@var{f} @var{ai} @var{bi})} for each pair of "
"elements @var{ai} and @var{bi}.  If either @var{a} or @var{b} is a scalar, "
"it is matched with each value of the other vector.  For example, "
"@samp{(map-vec-2 'math-add v 1)} returns the vector @var{v} with each "
"element increased by one.  Note that using @samp{'+} would not work here, "
"since @code{defmath} does not expand function names everywhere, just where "
"they are in the function position of a Lisp expression."
msgstr ""

#. type: defun
#: ../../calc.texi:34382
#, no-wrap
msgid "reduce-vec f v"
msgstr ""

#. type: defun
#: ../../calc.texi:34386
msgid ""
"Reduce the function @var{f} over the vector @var{v}.  For example, if "
"@var{v} is @samp{[10, 20, 30, 40]}, this calls @samp{(f (f (f 10 20) 30) "
"40)}.  If @var{v} is a matrix, this reduces over the rows of @var{v}."
msgstr ""

#. type: defun
#: ../../calc.texi:34388
#, no-wrap
msgid "reduce-cols f m"
msgstr ""

#. type: defun
#: ../../calc.texi:34392
msgid ""
"Reduce the function @var{f} over the columns of matrix @var{m}.  For "
"example, if @var{m} is @samp{[[1, 2], [3, 4], [5, 6]]}, the result is a "
"vector of the two elements @samp{(f (f 1 3) 5)} and @samp{(f (f 2 4) 6)}."
msgstr ""

#. type: defun
#: ../../calc.texi:34394
#, no-wrap
msgid "mat-row m n"
msgstr ""

#. type: defun
#: ../../calc.texi:34398
msgid ""
"Return the @var{n}th row of matrix @var{m}.  This is equivalent to "
"@samp{(elt m n)}.  For a slower but safer version, use @code{mrow}.  "
"(@xref{Extracting Elements}.)"
msgstr ""

#. type: defun
#: ../../calc.texi:34400
#, no-wrap
msgid "mat-col m n"
msgstr ""

#. type: defun
#: ../../calc.texi:34403
msgid ""
"Return the @var{n}th column of matrix @var{m}, in the form of a vector.  The "
"arguments are not checked for correctness."
msgstr ""

#. type: defun
#: ../../calc.texi:34405
#, no-wrap
msgid "mat-less-row m n"
msgstr ""

#. type: defun
#: ../../calc.texi:34408
msgid ""
"Return a copy of matrix @var{m} with its @var{n}th row deleted.  The number "
"@var{n} must be in range from 1 to the number of rows in @var{m}."
msgstr ""

#. type: defun
#: ../../calc.texi:34410
#, no-wrap
msgid "mat-less-col m n"
msgstr ""

#. type: defun
#: ../../calc.texi:34412
msgid "Return a copy of matrix @var{m} with its @var{n}th column deleted."
msgstr ""

#. type: defun
#: ../../calc.texi:34414
#, no-wrap
msgid "transpose m"
msgstr ""

#. type: defun
#: ../../calc.texi:34416
msgid "Return the transpose of matrix @var{m}."
msgstr ""

#. type: defun
#: ../../calc.texi:34418
#, no-wrap
msgid "flatten-vector v"
msgstr ""

#. type: defun
#: ../../calc.texi:34421
msgid ""
"Flatten nested vector @var{v} into a vector of scalars.  For example, if "
"@var{v} is @samp{[[1, 2, 3], [4, 5]]} the result is @samp{[1, 2, 3, 4, 5]}."
msgstr ""

#. type: defun
#: ../../calc.texi:34423
#, no-wrap
msgid "copy-matrix m"
msgstr ""

#. type: defun
#: ../../calc.texi:34430
msgid ""
"If @var{m} is a matrix, return a copy of @var{m}.  This maps "
"@code{copy-sequence} over the rows of @var{m}; in Lisp terms, each element "
"of the result matrix will be @code{eq} to the corresponding element of "
"@var{m}, but none of the @code{cons} cells that make up the structure of the "
"matrix will be @code{eq}.  If @var{m} is a plain vector, this is the same as "
"@code{copy-sequence}."
msgstr ""

#. type: defun
#: ../../calc.texi:34432
#, no-wrap
msgid "swap-rows m r1 r2"
msgstr ""

#. type: defun
#: ../../calc.texi:34439
msgid ""
"Exchange rows @var{r1} and @var{r2} of matrix @var{m} in-place.  In other "
"words, unlike most of the other functions described here, this function "
"changes @var{m} itself rather than building up a new result matrix.  The "
"return value is @var{m}, i.e., @samp{(eq (swap-rows m 1 2) m)} is true, with "
"the side effect of exchanging the first two rows of @var{m}."
msgstr ""

#. type: node
#: ../../calc.texi:34441 ../../calc.texi:35012 ../../calc.texi:35158
#, no-wrap
msgid "Formatting Lisp Functions"
msgstr ""

#. type: subsubsection
#: ../../calc.texi:34442
#, no-wrap
msgid "Symbolic Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:34447
msgid "The functions described here operate on symbolic formulas in the Calculator."
msgstr ""

#. type: defun
#: ../../calc.texi:34448
#, no-wrap
msgid "calc-prepare-selection num"
msgstr ""

#. type: defun
#: ../../calc.texi:34461
msgid ""
"Prepare a stack entry for selection operations.  If @var{num} is omitted, "
"the stack entry containing the cursor is used; otherwise, it is the number "
"of the stack entry to use.  This function stores useful information about "
"the current stack entry into a set of variables.  "
"@code{calc-selection-cache-num} contains the number of the stack entry "
"involved (equal to @var{num} if you specified it); "
"@code{calc-selection-cache-entry} contains the stack entry as a list (such "
"as @code{calc-top-list} would return with @code{entry} as the selection "
"mode); and @code{calc-selection-cache-comp} contains a special ``tagged'' "
"composition (@pxref{Formatting Lisp Functions})  which allows Calc to relate "
"cursor positions in the buffer with their corresponding sub-formulas."
msgstr ""

#. type: defun
#: ../../calc.texi:34476
msgid ""
"A slight complication arises in the selection mechanism because formulas may "
"contain small integers.  For example, in the vector @samp{[1, 2, 1]} the "
"first and last elements are @code{eq} to each other; selections are recorded "
"as the actual Lisp object that appears somewhere in the tree of the whole "
"formula, but storing @code{1} would falsely select both @code{1}'s in the "
"vector.  So @code{calc-prepare-selection} also checks the stack entry and "
"replaces any plain integers with ``complex number'' lists of the form "
"@samp{(cplx @var{n} 0)}.  This list will be displayed the same as a plain "
"@var{n} and the change will be completely invisible to the user, but it will "
"guarantee that no two sub-formulas of the stack entry will be @code{eq} to "
"each other.  Next time the stack entry is involved in a computation, "
"@code{calc-normalize} will replace these lists with plain numbers again, "
"again invisibly to the user."
msgstr ""

#. type: defun
#: ../../calc.texi:34478
#, no-wrap
msgid "calc-encase-atoms x"
msgstr ""

#. type: defun
#: ../../calc.texi:34483
msgid ""
"This modifies the formula @var{x} to ensure that each part of the formula is "
"a unique atom, using the @samp{(cplx @var{n} 0)} trick described above.  "
"This function may use @code{setcar} to modify the formula in-place."
msgstr ""

#. type: defun
#: ../../calc.texi:34485
#, no-wrap
msgid "calc-find-selected-part"
msgstr ""

#. type: defun
#: ../../calc.texi:34490
msgid ""
"Find the smallest sub-formula of the current formula that contains the "
"cursor.  This assumes @code{calc-prepare-selection} has been called "
"already.  If the cursor is not actually on any part of the formula, this "
"returns @code{nil}."
msgstr ""

#. type: defun
#: ../../calc.texi:34492
#, no-wrap
msgid "calc-change-current-selection selection"
msgstr ""

#. type: defun
#: ../../calc.texi:34498
msgid ""
"Change the currently prepared stack element's selection to @var{selection}, "
"which should be @code{eq} to some sub-formula of the stack element, or "
"@code{nil} to unselect the formula.  The stack element's appearance in the "
"Calc buffer is adjusted to reflect the new selection."
msgstr ""

#. type: defun
#: ../../calc.texi:34500
#, no-wrap
msgid "calc-find-nth-part expr n"
msgstr ""

#. type: defun
#: ../../calc.texi:34506
msgid ""
"Return the @var{n}th sub-formula of @var{expr}.  This function is used by "
"the selection commands, and (unless @kbd{j b} has been used) treats sums and "
"products as flat many-element formulas.  Thus if @var{expr} is @samp{((a + "
"b) - c) + d}, calling @code{calc-find-nth-part} with @var{n} equal to four "
"will return @samp{d}."
msgstr ""

#. type: defun
#: ../../calc.texi:34508
#, no-wrap
msgid "calc-find-parent-formula expr part"
msgstr ""

#. type: defun
#: ../../calc.texi:34516
msgid ""
"Return the sub-formula of @var{expr} which immediately contains @var{part}.  "
"If @var{expr} is @samp{a*b + (c+1)*d} and @var{part} is @code{eq} to the "
"@samp{c+1} term of @var{expr}, then this function will return "
"@samp{(c+1)*d}.  If @var{part} turns out not to be a sub-formula of "
"@var{expr}, the function returns @code{nil}.  If @var{part} is @code{eq} to "
"@var{expr}, the function returns @code{t}.  This function does not take "
"associativity into account."
msgstr ""

#. type: defun
#: ../../calc.texi:34518
#, no-wrap
msgid "calc-find-assoc-parent-formula expr part"
msgstr ""

#. type: defun
#: ../../calc.texi:34525
msgid ""
"This is the same as @code{calc-find-parent-formula}, except that (unless "
"@kbd{j b} has been used) it continues widening the selection to contain a "
"complete level of the formula.  Given @samp{a} from @samp{((a + b) - c) + "
"d}, @code{calc-find-parent-formula} will return @samp{a + b} but "
"@code{calc-find-assoc-parent-formula} will return the whole expression."
msgstr ""

#. type: defun
#: ../../calc.texi:34527
#, no-wrap
msgid "calc-grow-assoc-formula expr part"
msgstr ""

#. type: defun
#: ../../calc.texi:34532
msgid ""
"This expands sub-formula @var{part} of @var{expr} to encompass a complete "
"level of the formula.  If @var{part} and its immediate parent are not "
"compatible associative operators, or if @kbd{j b} has been used, this simply "
"returns @var{part}."
msgstr ""

#. type: defun
#: ../../calc.texi:34534
#, no-wrap
msgid "calc-find-sub-formula expr part"
msgstr ""

#. type: defun
#: ../../calc.texi:34541
msgid ""
"This finds the immediate sub-formula of @var{expr} which contains "
"@var{part}.  It returns an index @var{n} such that @samp{(calc-find-nth-part "
"@var{expr} @var{n})} would return @var{part}.  If @var{part} is not a "
"sub-formula of @var{expr}, it returns @code{nil}.  If @var{part} is "
"@code{eq} to @var{expr}, it returns @code{t}.  This function does not take "
"associativity into account."
msgstr ""

#. type: defun
#: ../../calc.texi:34543
#, no-wrap
msgid "calc-replace-sub-formula expr old new"
msgstr ""

#. type: defun
#: ../../calc.texi:34546
msgid ""
"This function returns a copy of formula @var{expr}, with the sub-formula "
"that is @code{eq} to @var{old} replaced by @var{new}."
msgstr ""

#. type: defun
#: ../../calc.texi:34548
#, no-wrap
msgid "simplify expr"
msgstr ""

#. type: defun
#: ../../calc.texi:34552
msgid ""
"Simplify the expression @var{expr} by applying Calc's algebraic "
"simplifications.  This always returns a copy of the expression; the "
"structure @var{expr} points to remains unchanged in memory."
msgstr ""

#. type: defun
#: ../../calc.texi:34565
msgid ""
"More precisely, here is what @code{simplify} does: The expression is first "
"normalized and evaluated by calling @code{normalize}.  If any "
"@code{AlgSimpRules} have been defined, they are then applied.  Then the "
"expression is traversed in a depth-first, bottom-up fashion; at each level, "
"any simplifications that can be made are made until no further changes are "
"possible.  Once the entire formula has been traversed in this way, it is "
"compared with the original formula (from before the call to "
"@code{normalize}) and, if it has changed, the entire procedure is repeated "
"(starting with @code{normalize})  until no further changes occur.  Usually "
"only two iterations are needed: one to simplify the formula, and another to "
"verify that no further simplifications were possible."
msgstr ""

#. type: defun
#: ../../calc.texi:34567
#, no-wrap
msgid "simplify-extended expr"
msgstr ""

#. type: defun
#: ../../calc.texi:34576
msgid ""
"Simplify the expression @var{expr}, with additional rules enabled that help "
"do a more thorough job, while not being entirely ``safe'' in all "
"circumstances.  (For example, this mode will simplify @samp{sqrt(x^2)} to "
"@samp{x}, which is only valid when @var{x} is positive.)  This is "
"implemented by temporarily binding the variable "
"@code{math-living-dangerously} to @code{t} (using a @code{let} form) and "
"calling @code{simplify}.  Dangerous simplification rules are written to "
"check this variable before taking any action."
msgstr ""

#. type: defun
#: ../../calc.texi:34578
#, no-wrap
msgid "simplify-units expr"
msgstr ""

#. type: defun
#: ../../calc.texi:34582
msgid ""
"Simplify the expression @var{expr}, treating variable names as units "
"whenever possible.  This works by binding the variable "
"@code{math-simplifying-units} to @code{t} while calling @code{simplify}."
msgstr ""

#. type: defmac
#: ../../calc.texi:34584
#, no-wrap
msgid "math-defsimplify funcs body"
msgstr ""

#. type: defmac
#: ../../calc.texi:34598
msgid ""
"Register a new simplification rule; this is normally called as a top-level "
"form, like @code{defun} or @code{defmath}.  If @var{funcs} is a symbol (like "
"@code{+} or @code{calcFunc-sqrt}), this simplification rule is applied to "
"the formulas which are calls to the specified function.  Or, @var{funcs} can "
"be a list of such symbols; the rule applies to all functions on the list.  "
"The @var{body} is written like the body of a function with a single argument "
"called @code{expr}.  The body will be executed with @code{expr} bound to a "
"formula which is a call to one of the functions @var{funcs}.  If the "
"function body returns @code{nil}, or if it returns a result @code{equal} to "
"the original @code{expr}, it is ignored and Calc goes on to try the next "
"simplification rule that applies.  If the function body returns something "
"different, that new formula is substituted for @var{expr} in the original "
"formula."
msgstr ""

#. type: defmac
#: ../../calc.texi:34604
msgid ""
"At each point in the formula, rules are tried in the order of the original "
"calls to @code{math-defsimplify}; the search stops after the first rule that "
"makes a change.  Thus later rules for that same function will not have a "
"chance to trigger until the next iteration of the main @code{simplify} loop."
msgstr ""

#. type: defmac
#: ../../calc.texi:34609
msgid ""
"Note that, since @code{defmath} is not being used here, @var{body} must be "
"written in true Lisp code without the conveniences that @code{defmath} "
"provides.  If you prefer, you can have @var{body} simply call another "
"function (defined with @code{defmath}) which does the real work."
msgstr ""

#. type: defmac
#: ../../calc.texi:34615
msgid ""
"The arguments of a function call will already have been simplified before "
"any rules for the call itself are invoked.  Since a new argument list is "
"consed up when this happens, this means that the rule's body is allowed to "
"rearrange the function's arguments destructively if that is convenient.  "
"Here is a typical example of a simplification rule:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:34625
#, no-wrap
msgid ""
"(math-defsimplify calcFunc-arcsinh\n"
"  (or (and (math-looks-negp (nth 1 expr))\n"
"           (math-neg (list 'calcFunc-arcsinh\n"
"                           (math-neg (nth 1 expr)))))\n"
"      (and (eq (car-safe (nth 1 expr)) 'calcFunc-sinh)\n"
"           (or math-living-dangerously\n"
"               (math-known-realp (nth 1 (nth 1 expr))))\n"
"           (nth 1 (nth 1 expr)))))\n"
msgstr ""

#. type: defmac
#: ../../calc.texi:34631
msgid ""
"This is really a pair of rules written with one @code{math-defsimplify} for "
"convenience; the first replaces @samp{arcsinh(-x)} with @samp{-arcsinh(x)}, "
"and the second, which is safe only for real @samp{x}, replaces "
"@samp{arcsinh(sinh(x))} with @samp{x}."
msgstr ""

#. type: defun
#: ../../calc.texi:34633
#, no-wrap
msgid "common-constant-factor expr"
msgstr ""

#. type: defun
#: ../../calc.texi:34638
msgid ""
"Check @var{expr} to see if it is a sum of terms all multiplied by the same "
"rational value.  If so, return this value.  If not, return @code{nil}.  For "
"example, if called on @samp{6x + 9y + 12z}, it would return 3, since 3 is a "
"common factor of all the terms."
msgstr ""

#. type: defun
#: ../../calc.texi:34640
#, no-wrap
msgid "cancel-common-factor expr factor"
msgstr ""

#. type: defun
#: ../../calc.texi:34647
msgid ""
"Assuming @var{expr} is a sum with @var{factor} as a common factor, divide "
"each term of the sum by @var{factor}.  This is done by destructively "
"modifying parts of @var{expr}, on the assumption that it is being used by a "
"simplification rule (where such things are allowed; see above).  For "
"example, consider this built-in rule for square roots:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:34657
#, no-wrap
msgid ""
"(math-defsimplify calcFunc-sqrt\n"
"  (let ((fac (math-common-constant-factor (nth 1 expr))))\n"
"    (and fac (not (eq fac 1))\n"
"         (math-mul (math-normalize (list 'calcFunc-sqrt fac))\n"
"                   (math-normalize\n"
"                    (list 'calcFunc-sqrt\n"
"                          (math-cancel-common-factor\n"
"                           (nth 1 expr) fac)))))))\n"
msgstr ""

#. type: defun
#: ../../calc.texi:34660
#, no-wrap
msgid "frac-gcd a b"
msgstr ""

#. type: defun
#: ../../calc.texi:34666
msgid ""
"Compute a ``rational GCD'' of @var{a} and @var{b}, which must both be "
"rational numbers.  This is the fraction composed of the GCD of the "
"numerators of @var{a} and @var{b}, over the GCD of the denominators.  It is "
"used by @code{common-constant-factor}.  Note that the standard @code{gcd} "
"function uses the LCM to combine the denominators."
msgstr ""

#. type: defun
#: ../../calc.texi:34668
#, no-wrap
msgid "map-tree func expr many"
msgstr ""

#. type: defun
#: ../../calc.texi:34681
msgid ""
"Try applying Lisp function @var{func} to various sub-expressions of "
"@var{expr}.  Initially, call @var{func} with @var{expr} itself as an "
"argument.  If this returns an expression which is not @code{equal} to "
"@var{expr}, apply @var{func} again until eventually it does return "
"@var{expr} with no changes.  Then, if @var{expr} is a function call, "
"recursively apply @var{func} to each of the arguments.  This keeps going "
"until no changes occur anywhere in the expression; this final expression is "
"returned by @code{map-tree}.  Note that, unlike simplification rules, "
"@var{func} functions may @emph{not} make destructive changes to @var{expr}.  "
"If a third argument @var{many} is provided, it is an integer which says how "
"many times @var{func} may be applied; the default, as described above, is "
"infinitely many times."
msgstr ""

#. type: defun
#: ../../calc.texi:34683
#, no-wrap
msgid "compile-rewrites rules"
msgstr ""

#. type: defun
#: ../../calc.texi:34690
msgid ""
"Compile the rewrite rule set specified by @var{rules}, which should be a "
"formula that is either a vector or a variable name.  If the latter, the "
"compiled rules are saved so that later @code{compile-rules} calls for that "
"same variable can return immediately.  If there are problems with the rules, "
"this function calls @code{error} with a suitable message."
msgstr ""

#. type: defun
#: ../../calc.texi:34692
#, no-wrap
msgid "apply-rewrites expr crules heads"
msgstr ""

#. type: defun
#: ../../calc.texi:34703
msgid ""
"Apply the compiled rewrite rule set @var{crules} to the expression "
"@var{expr}.  This will make only one rewrite and only checks at the top "
"level of the expression.  The result @code{nil} if no rules matched, or if "
"the only rules that matched did not actually change the expression.  The "
"@var{heads} argument is optional; if is given, it should be a list of all "
"function names that (may) appear in @var{expr}.  The rewrite compiler tags "
"each rule with the rarest-looking function name in the rule; if you specify "
"@var{heads}, @code{apply-rewrites} can use this information to narrow its "
"search down to just a few rules in the rule set."
msgstr ""

#. type: defun
#: ../../calc.texi:34705
#, no-wrap
msgid "rewrite-heads expr"
msgstr ""

#. type: defun
#: ../../calc.texi:34708
msgid ""
"Compute a @var{heads} list for @var{expr} suitable for use with "
"@code{apply-rewrites}, as discussed above."
msgstr ""

#. type: defun
#: ../../calc.texi:34710
#, no-wrap
msgid "rewrite expr rules many"
msgstr ""

#. type: defun
#: ../../calc.texi:34715
msgid ""
"This is an all-in-one rewrite function.  It compiles the rule set specified "
"by @var{rules}, then uses @code{map-tree} to apply the rules throughout "
"@var{expr} up to @var{many} (default infinity)  times."
msgstr ""

#. type: defun
#: ../../calc.texi:34717
#, no-wrap
msgid "match-patterns pat vec not-flag"
msgstr ""

#. type: defun
#: ../../calc.texi:34722
msgid ""
"Given a Calc vector @var{vec} and an uncompiled pattern set or pattern set "
"variable @var{pat}, this function returns a new vector of all elements of "
"@var{vec} which do (or don't, if @var{not-flag} is non-@code{nil}) match any "
"of the patterns in @var{pat}."
msgstr ""

#. type: defun
#: ../../calc.texi:34724
#, no-wrap
msgid "deriv expr var value symb"
msgstr ""

#. type: defun
#: ../../calc.texi:34734
msgid ""
"Compute the derivative of @var{expr} with respect to variable @var{var} "
"(which may actually be any sub-expression).  If @var{value} is specified, "
"the derivative is evaluated at the value of @var{var}; otherwise, the "
"derivative is left in terms of @var{var}.  If the expression contains "
"functions for which no derivative formula is known, new derivative functions "
"are invented by adding primes to the names; @pxref{Calculus}.  However, if "
"@var{symb} is non-@code{nil}, the presence of nondifferentiable functions in "
"@var{expr} instead cancels the whole differentiation, and @code{deriv} "
"returns @code{nil} instead."
msgstr ""

#. type: defun
#: ../../calc.texi:34743
msgid ""
"Derivatives of an @var{n}-argument function can be defined by adding a "
"@code{math-derivative-@var{n}} property to the property list of the symbol "
"for the function's derivative, which will be the function name followed by "
"an apostrophe.  The value of the property should be a Lisp function; it is "
"called with the same arguments as the original function call that is being "
"differentiated.  It should return a formula for the derivative.  For "
"example, the derivative of @code{ln} is defined by"
msgstr ""

#. type: smallexample
#: ../../calc.texi:34747
#, no-wrap
msgid ""
"(put 'calcFunc-ln\\' 'math-derivative-1\n"
"     (function (lambda (u) (math-div 1 u))))\n"
msgstr ""

#. type: defun
#: ../../calc.texi:34750
msgid "The two-argument @code{log} function has two derivatives,"
msgstr ""

#. type: smallexample
#: ../../calc.texi:34755
#, no-wrap
msgid ""
"(put 'calcFunc-log\\' 'math-derivative-2     ; d(log(x,b)) / dx\n"
"     (function (lambda (x b) ... )))\n"
"(put 'calcFunc-log\\'2 'math-derivative-2    ; d(log(x,b)) / db\n"
"     (function (lambda (x b) ... )))\n"
msgstr ""

#. type: defun
#: ../../calc.texi:34758
#, no-wrap
msgid "tderiv expr var value symb"
msgstr ""

#. type: defun
#: ../../calc.texi:34762
msgid ""
"Compute the total derivative of @var{expr}.  This is the same as "
"@code{deriv}, except that variables other than @var{var} are not assumed to "
"be constant with respect to @var{var}."
msgstr ""

#. type: defun
#: ../../calc.texi:34764
#, no-wrap
msgid "integ expr var low high"
msgstr ""

#. type: defun
#: ../../calc.texi:34767
msgid ""
"Compute the integral of @var{expr} with respect to @var{var}.  "
"@xref{Calculus}, for further details."
msgstr ""

#. type: defmac
#: ../../calc.texi:34769
#, no-wrap
msgid "math-defintegral funcs body"
msgstr ""

#. type: defmac
#: ../../calc.texi:34780
msgid ""
"Define a rule for integrating a function or functions of one argument; this "
"macro is very similar in format to @code{math-defsimplify}.  The main "
"difference is that here @var{body} is the body of a function with a single "
"argument @code{u} which is bound to the argument to the function being "
"integrated, not the function call itself.  Also, the variable of integration "
"is available as @code{math-integ-var}.  If evaluation of the integral "
"requires doing further integrals, the body should call @samp{(math-integral "
"@var{x})} to find the integral of @var{x} with respect to "
"@code{math-integ-var}; this function returns @code{nil} if the integral "
"could not be done.  Some examples:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:34786
#, no-wrap
msgid ""
"(math-defintegral calcFunc-conj\n"
"  (let ((int (math-integral u)))\n"
"    (and int\n"
"         (list 'calcFunc-conj int))))\n"
"\n"
msgstr ""

#. type: smallexample
#: ../../calc.texi:34790
#, no-wrap
msgid ""
"(math-defintegral calcFunc-cos\n"
"  (and (equal u math-integ-var)\n"
"       (math-from-radians-2 (list 'calcFunc-sin u))))\n"
msgstr ""

#. type: defmac
#: ../../calc.texi:34798
msgid ""
"In the @code{cos} example, we define only the integral of @samp{cos(x) dx}, "
"relying on the general integration-by-substitution facility to handle "
"cosines of more complicated arguments.  An integration rule should return "
"@code{nil} if it can't do the integral; if several rules are defined for the "
"same function, they are tried in order until one returns a non-@code{nil} "
"result."
msgstr ""

#. type: defmac
#: ../../calc.texi:34800
#, no-wrap
msgid "math-defintegral-2 funcs body"
msgstr ""

#. type: defmac
#: ../../calc.texi:34805
msgid ""
"Define a rule for integrating a function or functions of two arguments.  "
"This is exactly analogous to @code{math-defintegral}, except that @var{body} "
"is written as the body of a function with two arguments, @var{u} and "
"@var{v}."
msgstr ""

#. type: defun
#: ../../calc.texi:34807
#, no-wrap
msgid "solve-for lhs rhs var full"
msgstr ""

#. type: defun
#: ../../calc.texi:34818
msgid ""
"Attempt to solve the equation @samp{@var{lhs} = @var{rhs}} by isolating the "
"variable @var{var} on the lefthand side; return the resulting righthand "
"side, or @code{nil} if the equation cannot be solved.  The variable "
"@var{var} must appear at least once in @var{lhs} or @var{rhs}.  Note that "
"the return value is a formula which does not contain @var{var}; this is "
"different from the user-level @code{solve} and @code{finv} functions, which "
"return a rearranged equation or a functional inverse, respectively.  If "
"@var{full} is non-@code{nil}, a full solution including dummy signs and "
"dummy integers will be produced.  User-defined inverses are provided as "
"properties in a manner similar to derivatives:"
msgstr ""

#. type: smallexample
#: ../../calc.texi:34822
#, no-wrap
msgid ""
"(put 'calcFunc-ln 'math-inverse\n"
"     (function (lambda (x) (list 'calcFunc-exp x))))\n"
msgstr ""

#. type: defun
#: ../../calc.texi:34829
msgid ""
"This function can call @samp{(math-solve-get-sign @var{x})} to create a new "
"arbitrary sign variable, returning @var{x} times that sign, and "
"@samp{(math-solve-get-int @var{x})} to create a new arbitrary integer "
"variable multiplied by @var{x}.  These functions simply return @var{x} if "
"the caller requested a non-``full'' solution."
msgstr ""

#. type: defun
#: ../../calc.texi:34831
#, no-wrap
msgid "solve-eqn expr var full"
msgstr ""

#. type: defun
#: ../../calc.texi:34836
msgid ""
"This version of @code{solve-for} takes an expression which will typically be "
"an equation or inequality.  (If it is not, it will be interpreted as the "
"equation @samp{@var{expr} = 0}.)  It returns an equation or inequality, or "
"@code{nil} if no solution could be found."
msgstr ""

#. type: defun
#: ../../calc.texi:34838
#, no-wrap
msgid "solve-system exprs vars full"
msgstr ""

#. type: defun
#: ../../calc.texi:34842
msgid ""
"This function solves a system of equations.  Generally, @var{exprs} and "
"@var{vars} will be vectors of equal length.  @xref{Solving Systems of "
"Equations}, for other options."
msgstr ""

#. type: defun
#: ../../calc.texi:34844
#, no-wrap
msgid "expr-contains expr var"
msgstr ""

#. type: defun
#: ../../calc.texi:34847
msgid ""
"Returns a non-@code{nil} value if @var{var} occurs as a subexpression of "
"@var{expr}."
msgstr ""

#. type: defun
#: ../../calc.texi:34854
msgid ""
"This function might seem at first to be identical to "
"@code{calc-find-sub-formula}.  The key difference is that "
"@code{expr-contains} uses @code{equal} to test for matches, whereas "
"@code{calc-find-sub-formula} uses @code{eq}.  In the formula @samp{f(a, a)}, "
"the two @samp{a}s will be @code{equal} but not @code{eq} to each other."
msgstr ""

#. type: defun
#: ../../calc.texi:34856
#, no-wrap
msgid "expr-contains-count expr var"
msgstr ""

#. type: defun
#: ../../calc.texi:34859
msgid ""
"Returns the number of occurrences of @var{var} as a subexpression of "
"@var{expr}, or @code{nil} if there are no occurrences."
msgstr ""

#. type: defun
#: ../../calc.texi:34861
#, no-wrap
msgid "expr-depends expr var"
msgstr ""

#. type: defun
#: ../../calc.texi:34865
msgid ""
"Returns true if @var{expr} refers to any variable the occurs in @var{var}.  "
"In other words, it checks if @var{expr} and @var{var} have any variables in "
"common."
msgstr ""

#. type: defun
#: ../../calc.texi:34867
#, no-wrap
msgid "expr-contains-vars expr"
msgstr ""

#. type: defun
#: ../../calc.texi:34870
msgid ""
"Return true if @var{expr} contains any variables, or @code{nil} if "
"@var{expr} contains only constants and functions with constant arguments."
msgstr ""

#. type: defun
#: ../../calc.texi:34872
#, no-wrap
msgid "expr-subst expr old new"
msgstr ""

#. type: defun
#: ../../calc.texi:34877
msgid ""
"Returns a copy of @var{expr}, with all occurrences of @var{old} replaced by "
"@var{new}.  This treats @code{lambda} forms specially with respect to the "
"dummy argument variables, so that the effect is always to return @var{expr} "
"evaluated at @var{old} = @var{new}."
msgstr ""

#. type: defun
#: ../../calc.texi:34879
#, no-wrap
msgid "multi-subst expr old new"
msgstr ""

#. type: defun
#: ../../calc.texi:34884
msgid ""
"This is like @code{expr-subst}, except that @var{old} and @var{new} are "
"lists of expressions to be substituted simultaneously.  If one list is "
"shorter than the other, trailing elements of the longer list are ignored."
msgstr ""

#. type: defun
#: ../../calc.texi:34886
#, no-wrap
msgid "expr-weight expr"
msgstr ""

#. type: defun
#: ../../calc.texi:34890
msgid ""
"Returns the ``weight'' of @var{expr}, basically a count of the total number "
"of objects and function calls that appear in @var{expr}.  For ``primitive'' "
"objects, this will be one."
msgstr ""

#. type: defun
#: ../../calc.texi:34892
#, no-wrap
msgid "expr-height expr"
msgstr ""

#. type: defun
#: ../../calc.texi:34896
msgid ""
"Returns the ``height'' of @var{expr}, which is the deepest level to which "
"function calls are nested.  (Note that @samp{@var{a} + @var{b}} counts as a "
"function call.)  For primitive objects, this returns zero."
msgstr ""

#. type: defun
#: ../../calc.texi:34898
#, no-wrap
msgid "polynomial-p expr var"
msgstr ""

#. type: defun
#: ../../calc.texi:34908
msgid ""
"Check if @var{expr} is a polynomial in variable (or sub-expression)  "
"@var{var}.  If so, return the degree of the polynomial, that is, the highest "
"power of @var{var} that appears in @var{expr}.  For example, for @samp{(x^2 "
"+ 3)^3 + 4} this would return 6.  This function returns @code{nil} unless "
"@var{expr}, when expanded out by @kbd{a x} (@code{calc-expand}), would "
"consist of a sum of terms in which @var{var} appears only raised to "
"nonnegative integer powers.  Note that if @var{var} does not occur in "
"@var{expr}, then @var{expr} is considered a polynomial of degree 0."
msgstr ""

#. type: defun
#: ../../calc.texi:34910
#, no-wrap
msgid "is-polynomial expr var degree loose"
msgstr ""

#. type: defun
#: ../../calc.texi:34930
msgid ""
"Check if @var{expr} is a polynomial in variable or sub-expression @var{var}, "
"and, if so, return a list representation of the polynomial where the "
"elements of the list are coefficients of successive powers of @var{var}: "
"@samp{@var{a} + @var{b} x + @var{c} x^3} would produce the list "
"@samp{(@var{a} @var{b} 0 @var{c})}, and @samp{(x + 1)^2} would produce the "
"list @samp{(1 2 1)}.  The highest element of the list will be non-zero, with "
"the special exception that if @var{expr} is the constant zero, the returned "
"value will be @samp{(0)}.  Return @code{nil} if @var{expr} is not a "
"polynomial in @var{var}.  If @var{degree} is specified, this will not "
"consider polynomials of degree higher than that value.  This is a good "
"precaution because otherwise an input of @samp{(x+1)^1000} will cause a huge "
"coefficient list to be built.  If @var{loose} is non-@code{nil}, then a "
"looser definition of a polynomial is used in which coefficients are no "
"longer required not to depend on @var{var}, but are only required not to "
"take the form of polynomials themselves.  For example, @samp{sin(x) x^2 + "
"cos(x)} is a loose polynomial with coefficients @samp{((calcFunc-cos x) 0 "
"(calcFunc-sin x))}.  The result will never be @code{nil} in loose mode, "
"since any expression can be interpreted as a ``constant'' loose polynomial."
msgstr ""

#. type: defun
#: ../../calc.texi:34932
#, no-wrap
msgid "polynomial-base expr pred"
msgstr ""

#. type: defun
#: ../../calc.texi:34943
msgid ""
"Check if @var{expr} is a polynomial in any variable that occurs in it; if "
"so, return that variable.  (If @var{expr} is a multivariate polynomial, this "
"chooses one variable arbitrarily.)  If @var{pred} is specified, it should be "
"a Lisp function which is called as @samp{(@var{pred} @var{subexpr})}, and "
"which should return true if @code{mpb-top-expr} (a global name for the "
"original @var{expr}) is a suitable polynomial in @var{subexpr}.  The default "
"predicate uses @samp{(polynomial-p mpb-top-expr @var{subexpr})}; you can use "
"@var{pred} to specify additional conditions.  Or, you could have @var{pred} "
"build up a list of every suitable @var{subexpr} that is found."
msgstr ""

#. type: defun
#: ../../calc.texi:34945
#, no-wrap
msgid "poly-simplify poly"
msgstr ""

#. type: defun
#: ../../calc.texi:34948
msgid ""
"Simplify polynomial coefficient list @var{poly} by (destructively)  clipping "
"off trailing zeros."
msgstr ""

#. type: defun
#: ../../calc.texi:34950
#, no-wrap
msgid "poly-mix a ac b bc"
msgstr ""

#. type: defun
#: ../../calc.texi:34955
msgid ""
"Mix two polynomial lists @var{a} and @var{b} (in the form returned by "
"@code{is-polynomial}) in a linear combination with coefficient expressions "
"@var{ac} and @var{bc}.  The result is a (not necessarily simplified)  "
"polynomial list representing @samp{@var{ac} @var{a} + @var{bc} @var{b}}."
msgstr ""

#. type: defun
#: ../../calc.texi:34957
#, no-wrap
msgid "poly-mul a b"
msgstr ""

#. type: defun
#: ../../calc.texi:34960
msgid ""
"Multiply two polynomial coefficient lists @var{a} and @var{b}.  The result "
"will be in simplified form if the inputs were simplified."
msgstr ""

#. type: defun
#: ../../calc.texi:34962
#, no-wrap
msgid "build-polynomial-expr poly var"
msgstr ""

#. type: defun
#: ../../calc.texi:34968
msgid ""
"Construct a Calc formula which represents the polynomial coefficient list "
"@var{poly} applied to variable @var{var}.  The @kbd{a c} "
"(@code{calc-collect}) command uses @code{is-polynomial} to turn an "
"expression into a coefficient list, then @code{build-polynomial-expr} to "
"turn the list back into an expression in regular form."
msgstr ""

#. type: defun
#: ../../calc.texi:34970
#, no-wrap
msgid "check-unit-name var"
msgstr ""

#. type: defun
#: ../../calc.texi:34978
msgid ""
"Check if @var{var} is a variable which can be interpreted as a unit name.  "
"If so, return the units table entry for that unit.  This will be a list "
"whose first element is the unit name (not counting prefix characters) as a "
"symbol and whose second element is the Calc expression which defines the "
"unit.  (Refer to the Calc sources for details on the remaining elements of "
"this list.)  If @var{var} is not a variable or is not a unit name, return "
"@code{nil}."
msgstr ""

#. type: defun
#: ../../calc.texi:34980
#, no-wrap
msgid "units-in-expr-p expr sub-exprs"
msgstr ""

#. type: defun
#: ../../calc.texi:34985
msgid ""
"Return true if @var{expr} contains any variables which can be interpreted as "
"units.  If @var{sub-exprs} is @code{t}, the entire expression is searched.  "
"If @var{sub-exprs} is @code{nil}, this checks whether @var{expr} is directly "
"a units expression."
msgstr ""

#. type: defun
#: ../../calc.texi:34987
#, no-wrap
msgid "single-units-in-expr-p expr"
msgstr ""

#. type: defun
#: ../../calc.texi:34992
msgid ""
"Check whether @var{expr} contains exactly one units variable.  If so, return "
"the units table entry for the variable.  If @var{expr} does not contain any "
"units, return @code{nil}.  If @var{expr} contains two or more units, return "
"the symbol @code{wrong}."
msgstr ""

#. type: defun
#: ../../calc.texi:34994
#, no-wrap
msgid "to-standard-units expr which"
msgstr ""

#. type: defun
#: ../../calc.texi:35000
msgid ""
"Convert units expression @var{expr} to base units.  If @var{which} is "
"@code{nil}, use Calc's native base units.  Otherwise, @var{which} can "
"specify a units system, which is a list of two-element lists, where the "
"first element is a Calc base symbol name and the second is an expression to "
"substitute for it."
msgstr ""

#. type: defun
#: ../../calc.texi:35002
#, no-wrap
msgid "remove-units expr"
msgstr ""

#. type: defun
#: ../../calc.texi:35005
msgid ""
"Return a copy of @var{expr} with all units variables replaced by ones.  This "
"expression is generally normalized before use."
msgstr ""

#. type: defun
#: ../../calc.texi:35007
#, no-wrap
msgid "extract-units expr"
msgstr ""

#. type: defun
#: ../../calc.texi:35010
msgid ""
"Return a copy of @var{expr} with everything but units variables replaced by "
"ones."
msgstr ""

#. type: subsubsection
#: ../../calc.texi:35013
#, no-wrap
msgid "I/O and Formatting Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:35018
msgid ""
"The functions described here are responsible for parsing and formatting Calc "
"numbers and formulas."
msgstr ""

#. type: defun
#: ../../calc.texi:35019
#, no-wrap
msgid "calc-eval str sep arg1 arg2 @dots{}"
msgstr ""

#. type: defun
#: ../../calc.texi:35022
msgid ""
"This is the simplest interface to the Calculator from another Lisp program.  "
"@xref{Calling Calc from Your Programs}."
msgstr ""

#. type: defun
#: ../../calc.texi:35024
#, no-wrap
msgid "read-number str"
msgstr ""

#. type: defun
#: ../../calc.texi:35028
msgid ""
"If string @var{str} contains a valid Calc number, either integer, fraction, "
"float, or HMS form, this function parses and returns that number.  "
"Otherwise, it returns @code{nil}."
msgstr ""

#. type: defun
#: ../../calc.texi:35030
#, no-wrap
msgid "read-expr str"
msgstr ""

#. type: defun
#: ../../calc.texi:35036
msgid ""
"Read an algebraic expression from string @var{str}.  If @var{str} does not "
"have the form of a valid expression, return a list of the form @samp{(error "
"@var{pos} @var{msg})} where @var{pos} is an integer index into @var{str} of "
"the general location of the error, and @var{msg} is a string describing the "
"problem."
msgstr ""

#. type: defun
#: ../../calc.texi:35038
#, no-wrap
msgid "read-exprs str"
msgstr ""

#. type: defun
#: ../../calc.texi:35042
msgid ""
"Read a list of expressions separated by commas, and return it as a Lisp "
"list.  If an error occurs in any expressions, an error list as shown above "
"is returned instead."
msgstr ""

#. type: defun
#: ../../calc.texi:35044
#, no-wrap
msgid "calc-do-alg-entry initial prompt no-norm"
msgstr ""

#. type: defun
#: ../../calc.texi:35055
msgid ""
"Read an algebraic formula or formulas using the minibuffer.  All conventions "
"of regular algebraic entry are observed.  The return value is a list of Calc "
"formulas; there will be more than one if the user entered a list of values "
"separated by commas.  The result is @code{nil} if the user presses Return "
"with a blank line.  If @var{initial} is given, it is a string which the "
"minibuffer will initially contain.  If @var{prompt} is given, it is the "
"prompt string to use; the default is ``Algebraic:''.  If @var{no-norm} is "
"@code{t}, the formulas will be returned exactly as parsed; otherwise, they "
"will be passed through @code{calc-normalize} first."
msgstr ""

#. type: defun
#: ../../calc.texi:35062
msgid ""
"To support the use of @kbd{$} characters in the algebraic entry, use "
"@code{let} to bind @code{calc-dollar-values} to a list of the values to be "
"substituted for @kbd{$}, @kbd{$$}, and so on, and bind "
"@code{calc-dollar-used} to 0.  Upon return, @code{calc-dollar-used} will "
"have been changed to the highest number of consecutive @kbd{$}s that "
"actually appeared in the input."
msgstr ""

#. type: defun
#: ../../calc.texi:35064
#, no-wrap
msgid "format-number a"
msgstr ""

#. type: defun
#: ../../calc.texi:35066
msgid "Convert the real or complex number or HMS form @var{a} to string form."
msgstr ""

#. type: defun
#: ../../calc.texi:35068
#, no-wrap
msgid "format-flat-expr a prec"
msgstr ""

#. type: defun
#: ../../calc.texi:35078
msgid ""
"Convert the arbitrary Calc number or formula @var{a} to string form, in the "
"style used by the trail buffer and the @code{calc-edit} command.  This is a "
"simple format designed mostly to guarantee the string is of a form that can "
"be re-parsed by @code{read-expr}.  Most formatting modes, such as digit "
"grouping, complex number format, and point character, are ignored to ensure "
"the result will be re-readable.  The @var{prec} parameter is normally 0; if "
"you pass a large integer like 1000 instead, the expression will be "
"surrounded by parentheses unless it is a plain number or variable name."
msgstr ""

#. type: defun
#: ../../calc.texi:35080
#, no-wrap
msgid "format-nice-expr a width"
msgstr ""

#. type: defun
#: ../../calc.texi:35086
msgid ""
"This is like @code{format-flat-expr} (with @var{prec} equal to 0), except "
"that newlines will be inserted to keep lines down to the specified "
"@var{width}, and vectors that look like matrices or rewrite rules are "
"written in a pseudo-matrix format.  The @code{calc-edit} command uses this "
"when only one stack entry is being edited."
msgstr ""

#. type: defun
#: ../../calc.texi:35088
#, no-wrap
msgid "format-value a width"
msgstr ""

#. type: defun
#: ../../calc.texi:35097
msgid ""
"Convert the Calc number or formula @var{a} to string form, using the format "
"seen in the stack buffer.  Beware the string returned may not be re-readable "
"by @code{read-expr}, for example, because of digit grouping.  Multi-line "
"objects like matrices produce strings that contain newline characters to "
"separate the lines.  The @var{w} parameter, if given, is the target window "
"size for which to format the expressions.  If @var{w} is omitted, the width "
"of the Calculator window is used."
msgstr ""

#. type: defun
#: ../../calc.texi:35099
#, no-wrap
msgid "compose-expr a prec"
msgstr ""

#. type: defun
#: ../../calc.texi:35113
msgid ""
"Format the Calc number or formula @var{a} according to the current language "
"mode, returning a ``composition.'' To learn about the structure of "
"compositions, see the comments in the Calc source code.  You can specify the "
"format of a given type of function call by putting a "
"@code{math-compose-@var{lang}} property on the function's symbol, whose "
"value is a Lisp function that takes @var{a} and @var{prec} as arguments and "
"returns a composition.  Here @var{lang} is a language mode name, one of "
"@code{normal}, @code{big}, @code{c}, @code{pascal}, @code{fortran}, "
"@code{tex}, @code{eqn}, @code{math}, or @code{maple}.  In Big mode, Calc "
"actually tries @code{math-compose-big} first, then tries "
"@code{math-compose-normal}.  If this property does not exist, or if the "
"function returns @code{nil}, the function is written in the normal "
"function-call notation for that language."
msgstr ""

#. type: defun
#: ../../calc.texi:35115
#, no-wrap
msgid "composition-to-string c w"
msgstr ""

#. type: defun
#: ../../calc.texi:35121
msgid ""
"Convert a composition structure returned by @code{compose-expr} into a "
"string.  Multi-line compositions convert to strings containing newline "
"characters.  The target window size is given by @var{w}.  The "
"@code{format-value} function basically calls @code{compose-expr} followed by "
"@code{composition-to-string}."
msgstr ""

#. type: defun
#: ../../calc.texi:35123
#, no-wrap
msgid "comp-width c"
msgstr ""

#. type: defun
#: ../../calc.texi:35125
msgid "Compute the width in characters of composition @var{c}."
msgstr ""

#. type: defun
#: ../../calc.texi:35127
#, no-wrap
msgid "comp-height c"
msgstr ""

#. type: defun
#: ../../calc.texi:35129
msgid "Compute the height in lines of composition @var{c}."
msgstr ""

#. type: defun
#: ../../calc.texi:35131
#, no-wrap
msgid "comp-ascent c"
msgstr ""

#. type: defun
#: ../../calc.texi:35134
msgid ""
"Compute the portion of the height of composition @var{c} which is on or "
"above the baseline.  For a one-line composition, this will be one."
msgstr ""

#. type: defun
#: ../../calc.texi:35136
#, no-wrap
msgid "comp-descent c"
msgstr ""

#. type: defun
#: ../../calc.texi:35139
msgid ""
"Compute the portion of the height of composition @var{c} which is below the "
"baseline.  For a one-line composition, this will be zero."
msgstr ""

#. type: defun
#: ../../calc.texi:35141
#, no-wrap
msgid "comp-first-char c"
msgstr ""

#. type: defun
#: ../../calc.texi:35145
msgid ""
"If composition @var{c} is a ``flat'' composition, return the first "
"(leftmost) character of the composition as an integer.  Otherwise, return "
"@code{nil}."
msgstr ""

#. type: defun
#: ../../calc.texi:35147
#, no-wrap
msgid "comp-last-char c"
msgstr ""

#. type: defun
#: ../../calc.texi:35150
msgid ""
"If composition @var{c} is a ``flat'' composition, return the last "
"(rightmost) character, otherwise return @code{nil}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:35167
msgid ""
"Hooks are variables which contain Lisp functions (or lists of functions)  "
"which are called at various times.  Calc defines a number of hooks that help "
"you to customize it in various ways.  Calc uses the Lisp function "
"@code{run-hooks} to invoke the hooks shown below.  Several other "
"customization-related variables are also described here."
msgstr ""

#. type: defvar
#: ../../calc.texi:35168
#, no-wrap
msgid "calc-load-hook"
msgstr ""

#. type: defvar
#: ../../calc.texi:35172
msgid ""
"This hook is called at the end of @file{calc.el}, after the file has been "
"loaded, before any functions in it have been called, but after "
"@code{calc-mode-map} and similar variables have been set up."
msgstr ""

#. type: defvar
#: ../../calc.texi:35174
#, no-wrap
msgid "calc-ext-load-hook"
msgstr ""

#. type: defvar
#: ../../calc.texi:35176
msgid "This hook is called at the end of @file{calc-ext.el}."
msgstr ""

#. type: defvar
#: ../../calc.texi:35178
#, no-wrap
msgid "calc-start-hook"
msgstr ""

#. type: defvar
#: ../../calc.texi:35183
msgid ""
"This hook is called as the last step in a @kbd{M-x calc} command.  At this "
"point, the Calc buffer has been created and initialized if necessary, the "
"Calc window and trail window have been created, and the ``Welcome to Calc'' "
"message has been displayed."
msgstr ""

#. type: defvar
#: ../../calc.texi:35185
#, no-wrap
msgid "calc-mode-hook"
msgstr ""

#. type: defvar
#: ../../calc.texi:35194
msgid ""
"This hook is called when the Calc buffer is being created.  Usually this "
"will only happen once per Emacs session.  The hook is called after Emacs has "
"switched to the new buffer, the mode-settings file has been read if "
"necessary, and all other buffer-local variables have been set up.  After "
"this hook returns, Calc will perform a @code{calc-refresh} operation, set up "
"the mode line display, then evaluate any deferred @code{calc-define} "
"properties that have not been evaluated yet."
msgstr ""

#. type: defvar
#: ../../calc.texi:35196
#, no-wrap
msgid "calc-trail-mode-hook"
msgstr ""

#. type: defvar
#: ../../calc.texi:35201
msgid ""
"This hook is called when the Calc Trail buffer is being created.  It is "
"called as the very last step of setting up the Trail buffer.  Like "
"@code{calc-mode-hook}, this will normally happen only once per Emacs "
"session."
msgstr ""

#. type: defvar
#: ../../calc.texi:35203
#, no-wrap
msgid "calc-end-hook"
msgstr ""

#. type: defvar
#: ../../calc.texi:35208
msgid ""
"This hook is called by @code{calc-quit}, generally because the user presses "
"@kbd{q} or @kbd{C-x * c} while in Calc.  The Calc buffer will be the current "
"buffer.  The hook is called as the very first step, before the Calc window "
"is destroyed."
msgstr ""

#. type: defvar
#: ../../calc.texi:35210
#, no-wrap
msgid "calc-window-hook"
msgstr ""

#. type: defvar
#: ../../calc.texi:35217
msgid ""
"If this hook is non-@code{nil}, it is called to create the Calc window.  "
"Upon return, this new Calc window should be the current window.  (The Calc "
"buffer will already be the current buffer when the hook is called.)  If the "
"hook is not defined, Calc will generally use @code{split-window}, "
"@code{set-window-buffer}, and @code{select-window} to create the Calc "
"window."
msgstr ""

#. type: defvar
#: ../../calc.texi:35219
#, no-wrap
msgid "calc-trail-window-hook"
msgstr ""

#. type: defvar
#: ../../calc.texi:35224
msgid ""
"If this hook is non-@code{nil}, it is called to create the Calc Trail "
"window.  The variable @code{calc-trail-buffer} will contain the buffer which "
"the window should use.  Unlike @code{calc-window-hook}, this hook must "
"@emph{not} switch into the new window."
msgstr ""

#. type: defvar
#: ../../calc.texi:35226
#, no-wrap
msgid "calc-embedded-mode-hook"
msgstr ""

#. type: defvar
#: ../../calc.texi:35228
msgid "This hook is called the first time that Embedded mode is entered."
msgstr ""

#. type: defvar
#: ../../calc.texi:35230
#, no-wrap
msgid "calc-embedded-new-buffer-hook"
msgstr ""

#. type: defvar
#: ../../calc.texi:35233
msgid "This hook is called each time that Embedded mode is entered in a new buffer."
msgstr ""

#. type: defvar
#: ../../calc.texi:35235
#, no-wrap
msgid "calc-embedded-new-formula-hook"
msgstr ""

#. type: defvar
#: ../../calc.texi:35238
msgid ""
"This hook is called each time that Embedded mode is enabled for a new "
"formula."
msgstr ""

#. type: defvar
#: ../../calc.texi:35240
#, no-wrap
msgid "calc-edit-mode-hook"
msgstr ""

#. type: defvar
#: ../../calc.texi:35247
msgid ""
"This hook is called by @code{calc-edit} (and the other ``edit'' commands) "
"when the temporary editing buffer is being created.  The buffer will have "
"been selected and set up to be in @code{calc-edit-mode}, but will not yet "
"have been filled with text.  (In fact it may still have leftover text from a "
"previous @code{calc-edit} command.)"
msgstr ""

#. type: defvar
#: ../../calc.texi:35249
#, no-wrap
msgid "calc-mode-save-hook"
msgstr ""

#. type: defvar
#: ../../calc.texi:35254
msgid ""
"This hook is called by the @code{calc-save-modes} command, after Calc's own "
"mode features have been inserted into the Calc init file and just before the "
"``End of mode settings'' message is inserted."
msgstr ""

#. type: defvar
#: ../../calc.texi:35256
#, no-wrap
msgid "calc-reset-hook"
msgstr ""

#. type: defvar
#: ../../calc.texi:35259
msgid ""
"This hook is called after @kbd{C-x * 0} (@code{calc-reset}) has reset all "
"modes.  The Calc buffer will be the current buffer."
msgstr ""

#. type: defvar
#: ../../calc.texi:35261
#, no-wrap
msgid "calc-other-modes"
msgstr ""

#. type: defvar
#: ../../calc.texi:35267
msgid ""
"This variable contains a list of strings.  The strings are concatenated at "
"the end of the modes portion of the Calc mode line (after standard modes "
"such as ``Deg'', ``Inv'' and ``Hyp'').  Each string should be a short, "
"single word followed by a space.  The variable is @code{nil} by default."
msgstr ""

#. type: defvar
#: ../../calc.texi:35269
#, no-wrap
msgid "calc-mode-map"
msgstr ""

#. type: defvar
#: ../../calc.texi:35278
msgid ""
"This is the keymap that is used by Calc mode.  The best time to adjust it is "
"probably in a @code{calc-mode-hook}.  If the Calc extensions package "
"(@file{calc-ext.el}) has not yet been loaded, many of these keys will be "
"bound to @code{calc-missing-key}, which is a command that loads the "
"extensions package and ``retypes'' the key.  If your @code{calc-mode-hook} "
"rebinds one of these keys, it will probably be overridden when the "
"extensions are loaded."
msgstr ""

#. type: defvar
#: ../../calc.texi:35280
#, no-wrap
msgid "calc-digit-map"
msgstr ""

#. type: defvar
#: ../../calc.texi:35285
msgid ""
"This is the keymap that is used during numeric entry.  Numeric entry uses "
"the minibuffer, but this map binds every non-numeric key to "
"@code{calcDigit-nondigit} which generally calls @code{exit-minibuffer} and "
"``retypes'' the key."
msgstr ""

#. type: defvar
#: ../../calc.texi:35287
#, no-wrap
msgid "calc-alg-ent-map"
msgstr ""

#. type: defvar
#: ../../calc.texi:35290
msgid ""
"This is the keymap that is used during algebraic entry.  This is mostly a "
"copy of @code{minibuffer-local-map}."
msgstr ""

#. type: defvar
#: ../../calc.texi:35292
#, no-wrap
msgid "calc-store-var-map"
msgstr ""

#. type: defvar
#: ../../calc.texi:35296
msgid ""
"This is the keymap that is used during entry of variable names for commands "
"like @code{calc-store} and @code{calc-recall}.  This is mostly a copy of "
"@code{minibuffer-local-completion-map}."
msgstr ""

#. type: defvar
#: ../../calc.texi:35298
#, no-wrap
msgid "calc-edit-mode-map"
msgstr ""

#. type: defvar
#: ../../calc.texi:35302
msgid ""
"This is the (sparse) keymap used by @code{calc-edit} and other temporary "
"editing commands.  It binds @key{RET}, @key{LFD}, and @kbd{C-c C-c} to "
"@code{calc-edit-finish}."
msgstr ""

#. type: defvar
#: ../../calc.texi:35304
#, no-wrap
msgid "calc-mode-var-list"
msgstr ""

#. type: defvar
#: ../../calc.texi:35310
msgid ""
"This is a list of variables which are saved by @code{calc-save-modes}.  Each "
"entry is a list of two items, the variable (as a Lisp symbol)  and its "
"default value.  When modes are being saved, each variable is compared with "
"its default value (using @code{equal}) and any non-default variables are "
"written out."
msgstr ""

#. type: defvar
#: ../../calc.texi:35312
#, no-wrap
msgid "calc-local-var-list"
msgstr ""

#. type: defvar
#: ../../calc.texi:35320
msgid ""
"This is a list of variables which should be buffer-local to the Calc "
"buffer.  Each entry is a variable name (as a Lisp symbol).  These variables "
"also have their default values manipulated by the @code{calc} and "
"@code{calc-quit} commands; @pxref{Multiple Calculators}.  Since "
"@code{calc-mode-hook} is called after this list has been used the first "
"time, your hook should add a variable to the list and also call "
"@code{make-local-variable} itself."
msgstr ""

#. type: appendix
#: ../../calc.texi:35323
#, no-wrap
msgid "GNU GENERAL PUBLIC LICENSE"
msgstr ""

#. type: include
#: ../../calc.texi:35324
#, no-wrap
msgid "gpl.texi"
msgstr ""

#. type: include
#: ../../calc.texi:35328
#, no-wrap
msgid "doclicense.texi"
msgstr ""

#. type: Plain text
#: ../../calc.texi:35335
msgid ""
"The usual prefix for Calc is the key sequence @kbd{C-x *}.  If you wish to "
"use a different prefix, you can put"
msgstr ""

#. type: example
#: ../../calc.texi:35338
#, no-wrap
msgid "(global-set-key \"NEWPREFIX\" 'calc-dispatch)\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:35349
msgid ""
"in your .emacs file.  (@xref{Key Bindings,,Customizing Key Bindings,emacs, "
"The GNU Emacs Manual}, for more information on binding keys.)  A convenient "
"way to start Calc is with @kbd{C-x * *}; to make it equally convenient for "
"users who use a different prefix, the prefix can be followed by @kbd{=}, "
"@kbd{&}, @kbd{#}, @kbd{\\}, @kbd{/}, @kbd{+} or @kbd{-} as well as @kbd{*} "
"to start Calc, and so in many cases the last character of the prefix can "
"simply be typed twice."
msgstr ""

#. type: Plain text
#: ../../calc.texi:35360
msgid ""
"Calc is controlled by many variables, most of which can be reset from within "
"Calc.  Some variables are less involved with actual calculation and can be "
"set outside of Calc using Emacs's customization facilities.  These variables "
"are listed below.  Typing @kbd{M-x customize-variable @key{RET} "
"@var{variable-name} @key{RET}} will bring up a buffer in which the "
"variable's value can be redefined.  Typing @kbd{M-x customize-group "
"@key{RET} calc @key{RET}} will bring up a buffer which contains all of "
"Calc's customizable variables.  (These variables can also be reset by "
"putting the appropriate lines in your .emacs file; @xref{Init File, ,Init "
"File, emacs, The GNU Emacs Manual}.)"
msgstr ""

#. type: Plain text
#: ../../calc.texi:35365
msgid ""
"Some of the customizable variables are regular expressions.  A regular "
"expression is basically a pattern that Calc can search for.  See @ref{Regexp "
"Search,, Regular Expression Search, emacs, The GNU Emacs Manual} to see how "
"regular expressions work."
msgstr ""

#. type: defvar
#: ../../calc.texi:35366
#, no-wrap
msgid "calc-settings-file"
msgstr ""

#. type: defvar
#: ../../calc.texi:35374
msgid ""
"The variable @code{calc-settings-file} holds the file name in which commands "
"like @kbd{m m} and @kbd{Z P} store ``permanent'' definitions.  If "
"@code{calc-settings-file} is not your user init file (typically "
"@file{~/.emacs}) and if the variable @code{calc-loaded-settings-file} is "
"@code{nil}, then Calc will automatically load your settings file (if it "
"exists) the first time Calc is invoked."
msgstr ""

#. type: defvar
#: ../../calc.texi:35378
msgid ""
"The default value for this variable is @code{\"~/.emacs.d/calc.el\"} unless "
"the file @file{~/.calc.el} exists, in which case the default value will be "
"@code{\"~/.calc.el\"}."
msgstr ""

#. type: defvar
#: ../../calc.texi:35388
msgid ""
"See @ref{Graphics}.@* The variable @code{calc-gnuplot-name} should be the "
"name of the GNUPLOT program (a string).  If you have GNUPLOT installed on "
"your system but Calc is unable to find it, you may need to set this "
"variable.  You may also need to set some Lisp variables to show Calc how to "
"run GNUPLOT on your system, see @ref{Devices, ,Graphical Devices} .  The "
"default value of @code{calc-gnuplot-name} is @code{\"gnuplot\"}."
msgstr ""

#. type: defvar
#: ../../calc.texi:35400
msgid ""
"See @ref{Devices, ,Graphical Devices}.@* The variables "
"@code{calc-gnuplot-plot-command} and @code{calc-gnuplot-print-command} "
"represent system commands to display and print the output of GNUPLOT, "
"respectively.  These may be @code{nil} if no command is necessary, or "
"strings which can include @samp{%s} to signify the name of the file to be "
"displayed or printed.  Or, these variables may contain Lisp expressions "
"which are evaluated to display or print the output."
msgstr ""

#. type: defvar
#: ../../calc.texi:35404
msgid ""
"The default value of @code{calc-gnuplot-plot-command} is @code{nil}, and the "
"default value of @code{calc-gnuplot-print-command} is @code{\"lp %s\"}."
msgstr ""

#. type: defvar
#: ../../calc.texi:35406
#, no-wrap
msgid "calc-language-alist"
msgstr ""

#. type: defvar
#: ../../calc.texi:35418
msgid ""
"See @ref{Basic Embedded Mode}.@* The variable @code{calc-language-alist} "
"controls the languages that Calc will associate with major modes.  When Calc "
"embedded mode is enabled, it will try to use the current major mode to "
"determine what language should be used.  (This can be overridden using "
"Calc's mode changing commands, @xref{Mode Settings in Embedded Mode}.)  The "
"variable @code{calc-language-alist} consists of a list of pairs of the form "
"@code{(@var{MAJOR-MODE} . @var{LANGUAGE})}; for example, @code{(latex-mode "
". latex)} is one such pair.  If Calc embedded is activated in a buffer whose "
"major mode is @var{MAJOR-MODE}, it will set itself to use the language "
"@var{LANGUAGE}."
msgstr ""

#. type: defvar
#: ../../calc.texi:35420
msgid "The default value of @code{calc-language-alist} is"
msgstr ""

#. type: example
#: ../../calc.texi:35431
#, no-wrap
msgid ""
"   ((latex-mode . latex)\n"
"    (tex-mode   . tex)\n"
"    (plain-tex-mode . tex)\n"
"    (context-mode . tex)\n"
"    (nroff-mode . eqn)\n"
"    (pascal-mode . pascal)\n"
"    (c-mode . c)\n"
"    (c++-mode . c)\n"
"    (fortran-mode . fortran)\n"
"    (f90-mode . fortran))\n"
msgstr ""

#. type: defvarx
#: ../../calc.texi:35435
#, no-wrap
msgid "calc-embedded-announce-formula-alist"
msgstr ""

#. type: defvar
#: ../../calc.texi:35443
msgid ""
"See @ref{Customizing Embedded Mode}.@* The variable "
"@code{calc-embedded-announce-formula} helps determine what formulas @kbd{C-x "
"* a} will activate in a buffer.  It is a regular expression, and when "
"activating embedded formulas with @kbd{C-x * a}, it will tell Calc that what "
"follows is a formula to be activated.  (Calc also uses other patterns to "
"find formulas, such as @samp{=>} and @samp{:=}.)"
msgstr ""

#. type: defvar
#: ../../calc.texi:35447
msgid ""
"The default pattern is @code{\"%Embed\\n\\\\(% .*\\n\\\\)*\"}, which checks "
"for @samp{%Embed} followed by any number of lines beginning with @samp{%} "
"and a space."
msgstr ""

#. type: defvar
#: ../../calc.texi:35453
msgid ""
"The variable @code{calc-embedded-announce-formula-alist} is used to set "
"@code{calc-embedded-announce-formula} to different regular expressions "
"depending on the major mode of the editing buffer.  It consists of a list of "
"pairs of the form @code{(@var{MAJOR-MODE} .  @var{REGEXP})}, and its default "
"value is"
msgstr ""

#. type: example
#: ../../calc.texi:35465
#, no-wrap
msgid ""
"   ((c++-mode     . \"//Embed\\n\\\\(// .*\\n\\\\)*\")\n"
"    (c-mode       . \"/\\\\*Embed\\\\*/\\n\\\\(/\\\\* .*\\\\*/\\n\\\\)*\")\n"
"    (f90-mode     . \"!Embed\\n\\\\(! .*\\n\\\\)*\")\n"
"    (fortran-mode . \"C Embed\\n\\\\(C .*\\n\\\\)*\")\n"
"    (html-helper-mode . \"<!-- Embed -->\\n\\\\(<!-- .* -->\\n\\\\)*\")\n"
"    (html-mode    . \"<!-- Embed -->\\n\\\\(<!-- .* -->\\n\\\\)*\")\n"
"    (nroff-mode   . \"\\\\\\\\\\\"Embed\\n\\\\(\\\\\\\\\\\" .*\\n\\\\)*\")\n"
"    (pascal-mode  . \"@{Embed@}\\n\\\\(@{.*@}\\n\\\\)*\")\n"
"    (sgml-mode    . \"<!-- Embed -->\\n\\\\(<!-- .* -->\\n\\\\)*\")\n"
"    (xml-mode     . \"<!-- Embed -->\\n\\\\(<!-- .* -->\\n\\\\)*\")\n"
"    (texinfo-mode . \"@@c Embed\\n\\\\(@@c .*\\n\\\\)*\"))\n"
msgstr ""

#. type: defvar
#: ../../calc.texi:35469
msgid ""
"Any major modes added to @code{calc-embedded-announce-formula-alist} should "
"also be added to @code{calc-embedded-open-close-plain-alist} and "
"@code{calc-embedded-open-close-mode-alist}."
msgstr ""

#. type: defvarx
#: ../../calc.texi:35473
#, no-wrap
msgid "calc-embedded-open-close-formula-alist"
msgstr ""

#. type: defvar
#: ../../calc.texi:35482
msgid ""
"See @ref{Customizing Embedded Mode}.@* The variables "
"@code{calc-embedded-open-formula} and @code{calc-embedded-close-formula} "
"control the region that Calc will activate as a formula when Embedded mode "
"is entered with @kbd{C-x * e}.  They are regular expressions; Calc normally "
"scans backward and forward in the buffer for the nearest text matching these "
"regular expressions to be the ``formula delimiters''."
msgstr ""

#. type: defvar
#: ../../calc.texi:35485
msgid ""
"The simplest delimiters are blank lines.  Other delimiters that Embedded "
"mode understands by default are:"
msgstr ""

#. type: defvar
#: ../../calc.texi:35507
msgid ""
"The variable @code{calc-embedded-open-close-formula-alist} is used to set "
"@code{calc-embedded-open-formula} and @code{calc-embedded-close-formula} to "
"different regular expressions depending on the major mode of the editing "
"buffer.  It consists of a list of lists of the form @code{(@var{MAJOR-MODE} "
"@var{OPEN-FORMULA-REGEXP} @var{CLOSE-FORMULA-REGEXP})}, and its default "
"value is @code{nil}."
msgstr ""

#. type: defvarx
#: ../../calc.texi:35510
#, no-wrap
msgid "calc-embedded-word-regexp-alist"
msgstr ""

#. type: defvar
#: ../../calc.texi:35515
msgid ""
"See @ref{Customizing Embedded Mode}.@* The variable "
"@code{calc-embedded-word-regexp} determines the expression that Calc will "
"activate when Embedded mode is entered with @kbd{C-x * w}.  It is a regular "
"expressions."
msgstr ""

#. type: defvar
#: ../../calc.texi:35518
msgid ""
"The default value of @code{calc-embedded-word-regexp} is "
"@code{\"[-+]?[0-9]+\\\\(\\\\.[0-9]+\\\\)?\\\\([eE][-+]?[0-9]+\\\\)?\"}."
msgstr ""

#. type: defvar
#: ../../calc.texi:35525
msgid ""
"The variable @code{calc-embedded-word-regexp-alist} is used to set "
"@code{calc-embedded-word-regexp} to a different regular expression depending "
"on the major mode of the editing buffer.  It consists of a list of lists of "
"the form @code{(@var{MAJOR-MODE} @var{WORD-REGEXP})}, and its default value "
"is @code{nil}."
msgstr ""

#. type: defvarx
#: ../../calc.texi:35529
#, no-wrap
msgid "calc-embedded-open-close-plain-alist"
msgstr ""

#. type: defvar
#: ../../calc.texi:35536
msgid ""
"See @ref{Customizing Embedded Mode}.@* The variables "
"@code{calc-embedded-open-plain} and @code{calc-embedded-open-plain} are used "
"to delimit ``plain'' formulas.  Note that these are actual strings, not "
"regular expressions, because Calc must be able to write these string into a "
"buffer as well as to recognize them."
msgstr ""

#. type: defvar
#: ../../calc.texi:35542
msgid ""
"The default string for @code{calc-embedded-open-plain} is @code{\"%%% \"}, "
"note the trailing space.  The default string for "
"@code{calc-embedded-close-plain} is @code{\" %%%\\n\"}, without the trailing "
"newline here, the first line of a Big mode formula that followed might be "
"shifted over with respect to the other lines."
msgstr ""

#. type: defvar
#: ../../calc.texi:35550
msgid ""
"The variable @code{calc-embedded-open-close-plain-alist} is used to set "
"@code{calc-embedded-open-plain} and @code{calc-embedded-close-plain} to "
"different strings depending on the major mode of the editing buffer.  It "
"consists of a list of lists of the form @code{(@var{MAJOR-MODE} "
"@var{OPEN-PLAIN-STRING} @var{CLOSE-PLAIN-STRING})}, and its default value is"
msgstr ""

#. type: example
#: ../../calc.texi:35562
#, no-wrap
msgid ""
"   ((c++-mode     \"// %% \"   \" %%\\n\")\n"
"    (c-mode       \"/* %% \"   \" %% */\\n\")\n"
"    (f90-mode     \"! %% \"    \" %%\\n\")\n"
"    (fortran-mode \"C %% \"    \" %%\\n\")\n"
"    (html-helper-mode \"<!-- %% \" \" %% -->\\n\")\n"
"    (html-mode \"<!-- %% \" \" %% -->\\n\")\n"
"    (nroff-mode   \"\\\\\\\" %% \" \" %%\\n\")\n"
"    (pascal-mode  \"@{%% \"    \" %%@}\\n\")\n"
"    (sgml-mode     \"<!-- %% \" \" %% -->\\n\")\n"
"    (xml-mode     \"<!-- %% \" \" %% -->\\n\")\n"
"    (texinfo-mode \"@@c %% \"   \" %%\\n\"))\n"
msgstr ""

#. type: defvar
#: ../../calc.texi:35566
msgid ""
"Any major modes added to @code{calc-embedded-open-close-plain-alist} should "
"also be added to @code{calc-embedded-announce-formula-alist} and "
"@code{calc-embedded-open-close-mode-alist}."
msgstr ""

#. type: defvarx
#: ../../calc.texi:35570
#, no-wrap
msgid "calc-embedded-open-close-new-formula-alist"
msgstr ""

#. type: defvar
#: ../../calc.texi:35575
msgid ""
"See @ref{Customizing Embedded Mode}.@* The variables "
"@code{calc-embedded-open-new-formula} and "
"@code{calc-embedded-close-new-formula} are strings which are inserted before "
"and after a new formula when you type @kbd{C-x * f}."
msgstr ""

#. type: defvar
#: ../../calc.texi:35585
msgid ""
"The default value of @code{calc-embedded-open-new-formula} is "
"@code{\"\\n\\n\"}.  If this string begins with a newline character and the "
"@kbd{C-x * f} is typed at the beginning of a line, @kbd{C-x * f} will skip "
"this first newline to avoid introducing unnecessary blank lines in the "
"file.  The default value of @code{calc-embedded-close-new-formula} is also "
"@code{\"\\n\\n\"}.  The final newline is omitted by @w{@kbd{C-x * f}} if "
"typed at the end of a line.  (It follows that if @kbd{C-x * f} is typed on a "
"blank line, both a leading opening newline and a trailing closing newline "
"are omitted.)"
msgstr ""

#. type: defvar
#: ../../calc.texi:35594
msgid ""
"The variable @code{calc-embedded-open-close-new-formula-alist} is used to "
"set @code{calc-embedded-open-new-formula} and "
"@code{calc-embedded-close-new-formula} to different strings depending on the "
"major mode of the editing buffer.  It consists of a list of lists of the "
"form @code{(@var{MAJOR-MODE} @var{OPEN-NEW-FORMULA-STRING} "
"@var{CLOSE-NEW-FORMULA-STRING})}, and its default value is @code{nil}."
msgstr ""

#. type: defvarx
#: ../../calc.texi:35598
#, no-wrap
msgid "calc-embedded-open-close-mode-alist"
msgstr ""

#. type: defvar
#: ../../calc.texi:35605
msgid ""
"See @ref{Customizing Embedded Mode}.@* The variables "
"@code{calc-embedded-open-mode} and @code{calc-embedded-close-mode} are "
"strings which Calc will place before and after any mode annotations that it "
"inserts.  Calc never scans for these strings; Calc always looks for the "
"annotation itself, so it is not necessary to add them to user-written "
"annotations."
msgstr ""

#. type: defvar
#: ../../calc.texi:35612
msgid ""
"The default value of @code{calc-embedded-open-mode} is @code{\"% \"} and the "
"default value of @code{calc-embedded-close-mode} is @code{\"\\n\"}.  If you "
"change the value of @code{calc-embedded-close-mode}, it is a good idea still "
"to end with a newline so that mode annotations will appear on lines by "
"themselves."
msgstr ""

#. type: defvar
#: ../../calc.texi:35620
msgid ""
"The variable @code{calc-embedded-open-close-mode-alist} is used to set "
"@code{calc-embedded-open-mode} and @code{calc-embedded-close-mode} to "
"different strings expressions depending on the major mode of the editing "
"buffer.  It consists of a list of lists of the form @code{(@var{MAJOR-MODE} "
"@var{OPEN-MODE-STRING} @var{CLOSE-MODE-STRING})}, and its default value is"
msgstr ""

#. type: example
#: ../../calc.texi:35632
#, no-wrap
msgid ""
"   ((c++-mode     \"// \"   \"\\n\")\n"
"    (c-mode       \"/* \"   \" */\\n\")\n"
"    (f90-mode     \"! \"    \"\\n\")\n"
"    (fortran-mode \"C \"    \"\\n\")\n"
"    (html-helper-mode \"<!-- \" \" -->\\n\")\n"
"    (html-mode    \"<!-- \" \" -->\\n\")\n"
"    (nroff-mode   \"\\\\\\\" \" \"\\n\")\n"
"    (pascal-mode  \"@{ \"    \" @}\\n\")\n"
"    (sgml-mode    \"<!-- \" \" -->\\n\")\n"
"    (xml-mode     \"<!-- \" \" -->\\n\")\n"
"    (texinfo-mode \"@@c \"   \"\\n\"))\n"
msgstr ""

#. type: defvar
#: ../../calc.texi:35636
msgid ""
"Any major modes added to @code{calc-embedded-open-close-mode-alist} should "
"also be added to @code{calc-embedded-announce-formula-alist} and "
"@code{calc-embedded-open-close-plain-alist}."
msgstr ""

#. type: defvar
#: ../../calc.texi:35645
msgid ""
"See @ref{Logarithmic Units}.@* The variables @code{calc-lu-power-reference} "
"and @code{calc-lu-field-reference} are unit expressions (written as strings) "
"which Calc will use as reference quantities for logarithmic units."
msgstr ""

#. type: defvar
#: ../../calc.texi:35649
msgid ""
"The default value of @code{calc-lu-power-reference} is @code{\"mW\"} and the "
"default value of @code{calc-lu-field-reference} is @code{\"20 uPa\"}."
msgstr ""

#. type: defvar
#: ../../calc.texi:35651
#, no-wrap
msgid "calc-note-threshold"
msgstr ""

#. type: defvar
#: ../../calc.texi:35656
msgid ""
"See @ref{Musical Notes}.@* The variable @code{calc-note-threshold} is a "
"number (written as a string) which determines how close (in cents) a "
"frequency needs to be to a note to be recognized as that note."
msgstr ""

#. type: defvar
#: ../../calc.texi:35658
msgid "The default value of @code{calc-note-threshold} is 1."
msgstr ""

#. type: defvar
#: ../../calc.texi:35675
msgid ""
"See @ref{Displaying Selections}.@* The variable "
"@code{calc-highlight-selections-with-faces} determines how selected "
"sub-formulas are distinguished.  If "
"@code{calc-highlight-selections-with-faces} is nil, then a selected "
"sub-formula is distinguished either by changing every character not part of "
"the sub-formula with a dot or by changing every character in the sub-formula "
"with a @samp{#} sign.  If @code{calc-highlight-selections-with-faces} is t, "
"then a selected sub-formula is distinguished either by displaying the "
"non-selected portion of the formula with @code{calc-nonselected-face} or by "
"displaying the selected sub-formula with @code{calc-nonselected-face}."
msgstr ""

#. type: defvar
#: ../../calc.texi:35677
#, no-wrap
msgid "calc-multiplication-has-precedence"
msgstr ""

#. type: defvar
#: ../../calc.texi:35689
msgid ""
"The variable @code{calc-multiplication-has-precedence} determines whether "
"multiplication has precedence over division in algebraic formulas in normal "
"language modes.  If @code{calc-multiplication-has-precedence} is "
"non-@code{nil}, then multiplication has precedence (and, for certain obscure "
"reasons, is right associative), and so for example @samp{a/b*c} will be "
"interpreted as @samp{a/(b*c)}. If @code{calc-multiplication-has-precedence} "
"is @code{nil}, then multiplication has the same precedence as division (and, "
"like division, is left associative), and so for example @samp{a/b*c} will be "
"interpreted as @samp{(a/b)*c}.  The default value of "
"@code{calc-multiplication-has-precedence} is @code{t}."
msgstr ""

#. type: defvar
#: ../../calc.texi:35691
#, no-wrap
msgid "calc-context-sensitive-enter"
msgstr ""

#. type: defvar
#: ../../calc.texi:35699
msgid ""
"The commands @code{calc-enter} and @code{calc-pop} will typically duplicate "
"the top of the stack.  If @code{calc-context-sensitive-enter} is "
"non-@code{nil}, then the @code{calc-enter} will copy the element at the "
"cursor to the top of the stack and @code{calc-pop} will delete the element "
"at the cursor.  The default value of @code{calc-context-sensitive-enter} is "
"@code{nil}."
msgstr ""

#. type: defvar
#: ../../calc.texi:35701
#, no-wrap
msgid "calc-undo-length"
msgstr ""

#. type: defvar
#: ../../calc.texi:35708
msgid ""
"The variable @code{calc-undo-length} determines the number of undo steps "
"that Calc will keep track of when @code{calc-quit} is called.  If "
"@code{calc-undo-length} is a non-negative integer, then this is the number "
"of undo steps that will be preserved; if @code{calc-undo-length} has any "
"other value, then all undo steps will be preserved.  The default value of "
"@code{calc-undo-length} is @expr{100}."
msgstr ""

#. type: defvar
#: ../../calc.texi:35710
#, no-wrap
msgid "calc-gregorian-switch"
msgstr ""

#. type: defvar
#: ../../calc.texi:35720
msgid ""
"See @ref{Date Forms}.@* The variable @code{calc-gregorian-switch} is either "
"a list of integers @code{(@var{YEAR} @var{MONTH} @var{DAY})} or @code{nil}.  "
"If it is @code{nil}, then Calc's date forms always represent Gregorian "
"dates.  Otherwise, @code{calc-gregorian-switch} represents the date that the "
"calendar switches from Julian dates to Gregorian dates; @code{(@var{YEAR} "
"@var{MONTH} @var{DAY})} will be the first Gregorian date.  The customization "
"buffer will offer several standard dates to choose from, or the user can "
"enter their own date."
msgstr ""

#. type: defvar
#: ../../calc.texi:35722
msgid "The default value of @code{calc-gregorian-switch} is @code{nil}."
msgstr ""

#. type: Plain text
#: ../../calc.texi:35734
msgid ""
"If you find a bug in Calc, send e-mail to @email{bug-gnu-emacs@@gnu.org}.  "
"There is an automatic command @kbd{M-x report-emacs-bug} which helps you to "
"report bugs.  This command prompts you for a brief subject line, then leaves "
"you in a mail editing buffer.  Type @kbd{C-c C-c} to send your mail.  Make "
"sure your subject line indicates that you are reporting a Calc bug."
msgstr ""

#. type: Plain text
#: ../../calc.texi:35739
msgid ""
"If you have suggestions for additional features for Calc, please send them.  "
"Some have dared to suggest that Calc is already top-heavy with features; "
"this obviously cannot be the case, so if you have ideas, send them right in."
msgstr ""

#. type: Plain text
#: ../../calc.texi:35744
msgid ""
"At the front of the source file, @file{calc.el}, is a list of ideas for "
"future work.  If any enthusiastic souls wish to take it upon themselves to "
"work on these, please send a message (using @kbd{M-x report-emacs-bug})  so "
"any efforts can be coordinated."
msgstr ""

#. type: Plain text
#: ../../calc.texi:35747
msgid ""
"The latest version of Calc is available from Savannah, in the Emacs "
"repository.  See @uref{https://savannah.gnu.org/projects/emacs}."
msgstr ""

#. type: appendix
#: ../../calc.texi:35750
#, no-wrap
msgid "Calc Summary"
msgstr ""

#. type: Plain text
#: ../../calc.texi:35761
msgid ""
"This section includes a complete list of Calc keystroke commands.  Each line "
"lists the stack entries used by the command (top-of-stack last), the "
"keystrokes themselves, the prompts asked by the command, and the result of "
"the command (also with top-of-stack last).  The result is expressed using "
"the equivalent algebraic function.  Commands which put no results on the "
"stack show the full @kbd{M-x} command name in that position.  Numbers "
"preceding the result or command name refer to notes at the end."
msgstr ""

#. type: Plain text
#: ../../calc.texi:35765
msgid ""
"Algebraic functions and @kbd{M-x} commands that don't have corresponding "
"keystrokes are not listed in this summary.  @xref{Command Index}.  "
"@xref{Function Index}."
msgstr ""

#. type: iftex
#: ../../calc.texi:35768
msgid "@begingroup"
msgstr ""

#. type: tex
#: ../../calc.texi:35788
#, no-wrap
msgid ""
"\\vskip-2\\baselineskip \\null\n"
"\\gdef\\sumrow#1{\\sumrowx#1\\relax}%\n"
"\\gdef\\sumrowx#1\\:#2\\:#3\\:#4\\:#5\\:#6\\relax{%\n"
"\\leavevmode%\n"
"{\\smallfonts\n"
"\\hbox to5em{\\sl\\hss#1}%\n"
"\\hbox to5em{\\tt#2\\hss}%\n"
"\\hbox to4em{\\sl#3\\hss}%\n"
"\\hbox to5em{\\rm\\hss#4}%\n"
"\\thinspace%\n"
"{\\tt#5}%\n"
"{\\sl#6}%\n"
"}}%\n"
"\\gdef\\sumlpar{{\\rm(}}%\n"
"\\gdef\\sumrpar{{\\rm)}}%\n"
"\\gdef\\sumcomma{{\\rm,\\thinspace}}%\n"
"\\gdef\\sumexcl{{\\rm!}}%\n"
"\\gdef\\sumbreak{\\vskip-2.5\\baselineskip\\goodbreak}%\n"
"\\gdef\\minus#1{{\\tt-}}%\n"
msgstr ""

#. type: iftex
#: ../../calc.texi:35795
msgid ""
"@let@:=@sumsep @let@r=@sumrow @catcode`@(=@active @let(=@sumlpar "
"@catcode`@)=@active @let)=@sumrpar @catcode`@,=@active @let,=@sumcomma "
"@catcode`@!=@active @let!=@sumexcl"
msgstr ""

#. type: iftex
#: ../../calc.texi:35800
#, no-wrap
msgid ""
"@advance@baselineskip-2.5pt\n"
"@let@c@sumbreak\n"
msgstr ""

#. type: format
#: ../../calc.texi:35829
#, no-wrap
msgid ""
"@r{       @:     C-x * a  @:             @:    33  "
"@:calc-embedded-activate@:}\n"
"@r{       @:     C-x * b  @:             @:        @:calc-big-or-small@:}\n"
"@r{       @:     C-x * c  @:             @:        @:calc@:}\n"
"@r{       @:     C-x * d  @:             @:        "
"@:calc-embedded-duplicate@:}\n"
"@r{       @:     C-x * e  @:             @:    34  @:calc-embedded@:}\n"
"@r{       @:     C-x * f  @:formula      @:        "
"@:calc-embedded-new-formula@:}\n"
"@r{       @:     C-x * g  @:             @:    35  @:calc-grab-region@:}\n"
"@r{       @:     C-x * i  @:             @:        @:calc-info@:}\n"
"@r{       @:     C-x * j  @:             @:        "
"@:calc-embedded-select@:}\n"
"@r{       @:     C-x * k  @:             @:        @:calc-keypad@:}\n"
"@r{       @:     C-x * l  @:             @:        "
"@:calc-load-everything@:}\n"
"@r{       @:     C-x * m  @:             @:        @:read-kbd-macro@:}\n"
"@r{       @:     C-x * n  @:             @:     4  @:calc-embedded-next@:}\n"
"@r{       @:     C-x * o  @:             @:        @:calc-other-window@:}\n"
"@r{       @:     C-x * p  @:             @:     4  "
"@:calc-embedded-previous@:}\n"
"@r{       @:     C-x * q  @:formula      @:        @:quick-calc@:}\n"
"@r{       @:     C-x * r  @:             @:    36  "
"@:calc-grab-rectangle@:}\n"
"@r{       @:     C-x * s  @:             @:        @:calc-info-summary@:}\n"
"@r{       @:     C-x * t  @:             @:        @:calc-tutorial@:}\n"
"@r{       @:     C-x * u  @:             @:        "
"@:calc-embedded-update-formula@:}\n"
"@r{       @:     C-x * w  @:             @:        @:calc-embedded-word@:}\n"
"@r{       @:     C-x * x  @:             @:        @:calc-quit@:}\n"
"@r{       @:     C-x * y  @:            @:1,28,49  "
"@:calc-copy-to-buffer@:}\n"
"@r{       @:     C-x * z  @:             @:        "
"@:calc-user-invocation@:}\n"
"@r{       @:     C-x * :  @:             @:    36  @:calc-grab-sum-down@:}\n"
"@r{       @:     C-x * _  @:             @:    36  "
"@:calc-grab-sum-across@:}\n"
"@r{       @:     C-x * `  @:editing      @:    30  @:calc-embedded-edit@:}\n"
"@r{       @:     C-x * 0  @:(zero)       @:        @:calc-reset@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:35840
#, no-wrap
msgid ""
"@r{       @:      0-9   @:number       @:        @:@:number}\n"
"@r{       @:      .     @:number       @:        @:@:0.number}\n"
"@r{       @:      _     @:number       @:        @:-@:number}\n"
"@r{       @:      e     @:number       @:        @:@:1e number}\n"
"@r{       @:      #     @:number       @:        "
"@:@:current-radix@tfn{#}number}\n"
"@r{       @:      p     @:(in number)  @:        @:+/-@:}\n"
"@r{       @:      M     @:(in number)  @:        @:mod@:}\n"
"@r{       @:      @@ ' \" @:  (in number)@:        @:@:HMS form}\n"
"@r{       @:      h m s @:  (in number)@:        @:@:HMS form}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:35845
#, no-wrap
msgid ""
"@r{       @:      '     @:formula      @: 37,46  @:@:formula}\n"
"@r{       @:      $     @:formula      @: 37,46  @:$@:formula}\n"
"@r{       @:      \"     @:string       @: 37,46  @:@:string}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:35864
#, no-wrap
msgid ""
"@r{    a b@:      +     @:             @:     2  @:add@:(a,b)  a+b}\n"
"@r{    a b@:      -     @:             @:     2  @:sub@:(a,b)  a@minus{}b}\n"
"@r{    a b@:      *     @:             @:     2  @:mul@:(a,b)  a b, a*b}\n"
"@r{    a b@:      /     @:             @:     2  @:div@:(a,b)  a/b}\n"
"@r{    a b@:      ^     @:             @:     2  @:pow@:(a,b)  a^b}\n"
"@r{    a b@:    I ^     @:             @:     2  @:nroot@:(a,b)  a^(1/b)}\n"
"@r{    a b@:      %     @:             @:     2  @:mod@:(a,b)  a%b}\n"
"@r{    a b@:      \\     @:             @:     2  @:idiv@:(a,b)  a\\b}\n"
"@r{    a b@:      :     @:             @:     2  @:fdiv@:(a,b)}\n"
"@r{    a b@:      |     @:             @:     2  @:vconcat@:(a,b)  a|b}\n"
"@r{    a b@:    I |     @:             @:        @:vconcat@:(b,a)  b|a}\n"
"@r{    a b@:    H |     @:             @:     2  @:append@:(a,b)}\n"
"@r{    a b@:  I H |     @:             @:        @:append@:(b,a)}\n"
"@r{      a@:      &     @:             @:     1  @:inv@:(a)  1/a}\n"
"@r{      a@:      !     @:             @:     1  @:fact@:(a)  a!}\n"
"@r{      a@:      =     @:             @:     1  @:evalv@:(a)}\n"
"@r{      a@:      M-%   @:             @:        @:percent@:(a)  a%}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:35875
#, no-wrap
msgid ""
"@r{  ... a@:      @summarykey{RET}   @:             @:     1  @:@:... a a}\n"
"@r{  ... a@:      @summarykey{SPC}   @:             @:     1  @:@:... a a}\n"
"@r{... a b@:      @summarykey{TAB}   @:             @:     3  @:@:... b a}\n"
"@r{. a b c@:      M-@summarykey{TAB} @:             @:     3  @:@:... b c "
"a}\n"
"@r{... a b@:      @summarykey{LFD}   @:             @:     1  @:@:... a b "
"a}\n"
"@r{  ... a@:      @summarykey{DEL}   @:             @:     1  @:@:...}\n"
"@r{... a b@:      M-@summarykey{DEL} @:             @:     1  @:@:... b}\n"
"@r{       @:      M-@summarykey{RET} @:             @:     4  "
"@:calc-last-args@:}\n"
"@r{      a@:      `     @:editing      @:  1,30  @:calc-edit@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:35884
#, no-wrap
msgid ""
"@r{  ... a@:      C-d   @:             @:     1  @:@:...}\n"
"@r{       @:      C-k   @:             @:    27  @:calc-kill@:}\n"
"@r{       @:      C-w   @:             @:    27  @:calc-kill-region@:}\n"
"@r{       @:      C-y   @:             @:        @:calc-yank@:}\n"
"@r{       @:      C-_   @:             @:     4  @:calc-undo@:}\n"
"@r{       @:      M-k   @:             @:    27  @:calc-copy-as-kill@:}\n"
"@r{       @:      M-w   @:             @:    27  "
"@:calc-copy-region-as-kill@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:35893
#, no-wrap
msgid ""
"@r{       @:      [     @:             @:        @:@:[...}\n"
"@r{[.. a b@:      ]     @:             @:        @:@:[a,b]}\n"
"@r{       @:      (     @:             @:        @:@:(...}\n"
"@r{(.. a b@:      )     @:             @:        @:@:(a,b)}\n"
"@r{       @:      ,     @:             @:        @:@:vector or rect "
"complex}\n"
"@r{       @:      ;     @:             @:        @:@:matrix or polar "
"complex}\n"
"@r{       @:      ..    @:             @:        @:@:interval}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:35901
#, no-wrap
msgid ""
"@r{       @:      ~     @:             @:        @:calc-num-prefix@:}\n"
"@r{       @:      <     @:             @:     4  @:calc-scroll-left@:}\n"
"@r{       @:      >     @:             @:     4  @:calc-scroll-right@:}\n"
"@r{       @:      @{     @:             @:     4  @:calc-scroll-down@:}\n"
"@r{       @:      @}     @:             @:     4  @:calc-scroll-up@:}\n"
"@r{       @:      ?     @:             @:        @:calc-help@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:35910
#, no-wrap
msgid ""
"@r{      a@:      n     @:             @:     1  @:neg@:(a)  @minus{}a}\n"
"@r{       @:      o     @:             @:     4  @:calc-realign@:}\n"
"@r{       @:      p     @:precision    @:    31  @:calc-precision@:}\n"
"@r{       @:      q     @:             @:        @:calc-quit@:}\n"
"@r{       @:      w     @:             @:        @:calc-why@:}\n"
"@r{       @:      x     @:command      @:        @:M-x calc-@:command}\n"
"@r{      a@:      y     @:            @:1,28,49  @:calc-copy-to-buffer@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:35957
#, no-wrap
msgid ""
"@r{      a@:      A     @:             @:     1  @:abs@:(a)}\n"
"@r{    a b@:      B     @:             @:     2  @:log@:(a,b)}\n"
"@r{    a b@:    I B     @:             @:     2  @:alog@:(a,b)  b^a}\n"
"@r{      a@:      C     @:             @:     1  @:cos@:(a)}\n"
"@r{      a@:    I C     @:             @:     1  @:arccos@:(a)}\n"
"@r{      a@:    H C     @:             @:     1  @:cosh@:(a)}\n"
"@r{      a@:  I H C     @:             @:     1  @:arccosh@:(a)}\n"
"@r{       @:      D     @:             @:     4  @:calc-redo@:}\n"
"@r{      a@:      E     @:             @:     1  @:exp@:(a)}\n"
"@r{      a@:    H E     @:             @:     1  @:exp10@:(a)  10.^a}\n"
"@r{      a@:      F     @:             @:  1,11  @:floor@:(a,d)}\n"
"@r{      a@:    I F     @:             @:  1,11  @:ceil@:(a,d)}\n"
"@r{      a@:    H F     @:             @:  1,11  @:ffloor@:(a,d)}\n"
"@r{      a@:  I H F     @:             @:  1,11  @:fceil@:(a,d)}\n"
"@r{      a@:      G     @:             @:     1  @:arg@:(a)}\n"
"@r{       @:      H     @:command      @:    32  @:@:Hyperbolic}\n"
"@r{       @:      I     @:command      @:    32  @:@:Inverse}\n"
"@r{      a@:      J     @:             @:     1  @:conj@:(a)}\n"
"@r{       @:      K     @:command      @:    32  @:@:Keep-args}\n"
"@r{      a@:      L     @:             @:     1  @:ln@:(a)}\n"
"@r{      a@:    H L     @:             @:     1  @:log10@:(a)}\n"
"@r{       @:      M     @:             @:        "
"@:calc-more-recursion-depth@:}\n"
"@r{       @:    I M     @:             @:        "
"@:calc-less-recursion-depth@:}\n"
"@r{      a@:      N     @:             @:     5  @:evalvn@:(a)}\n"
"@r{       @:      O     @:command      @:    32  @:@:Option}\n"
"@r{       @:      P     @:             @:        @:@:pi}\n"
"@r{       @:    I P     @:             @:        @:@:gamma}\n"
"@r{       @:    H P     @:             @:        @:@:e}\n"
"@r{       @:  I H P     @:             @:        @:@:phi}\n"
"@r{      a@:      Q     @:             @:     1  @:sqrt@:(a)}\n"
"@r{      a@:    I Q     @:             @:     1  @:sqr@:(a)  a^2}\n"
"@r{      a@:      R     @:             @:  1,11  @:round@:(a,d)}\n"
"@r{      a@:    I R     @:             @:  1,11  @:trunc@:(a,d)}\n"
"@r{      a@:    H R     @:             @:  1,11  @:fround@:(a,d)}\n"
"@r{      a@:  I H R     @:             @:  1,11  @:ftrunc@:(a,d)}\n"
"@r{      a@:      S     @:             @:     1  @:sin@:(a)}\n"
"@r{      a@:    I S     @:             @:     1  @:arcsin@:(a)}\n"
"@r{      a@:    H S     @:             @:     1  @:sinh@:(a)}\n"
"@r{      a@:  I H S     @:             @:     1  @:arcsinh@:(a)}\n"
"@r{      a@:      T     @:             @:     1  @:tan@:(a)}\n"
"@r{      a@:    I T     @:             @:     1  @:arctan@:(a)}\n"
"@r{      a@:    H T     @:             @:     1  @:tanh@:(a)}\n"
"@r{      a@:  I H T     @:             @:     1  @:arctanh@:(a)}\n"
"@r{       @:      U     @:             @:     4  @:calc-undo@:}\n"
"@r{       @:      X     @:             @:     4  "
"@:calc-call-last-kbd-macro@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:35972
#, no-wrap
msgid ""
"@r{    a b@:      a =   @:             @:     2  @:eq@:(a,b)  a=b}\n"
"@r{    a b@:      a #   @:             @:     2  @:neq@:(a,b)  a!=b}\n"
"@r{    a b@:      a <   @:             @:     2  @:lt@:(a,b)  a<b}\n"
"@r{    a b@:      a >   @:             @:     2  @:gt@:(a,b)  a>b}\n"
"@r{    a b@:      a [   @:             @:     2  @:leq@:(a,b)  a<=b}\n"
"@r{    a b@:      a ]   @:             @:     2  @:geq@:(a,b)  a>=b}\n"
"@r{    a b@:      a @{   @:             @:     2  @:in@:(a,b)}\n"
"@r{    a b@:      a &   @:             @:  2,45  @:land@:(a,b)  a&&b}\n"
"@r{    a b@:      a |   @:             @:  2,45  @:lor@:(a,b)  a||b}\n"
"@r{      a@:      a !   @:             @:  1,45  @:lnot@:(a)  !a}\n"
"@r{  a b c@:      a :   @:             @:    45  @:if@:(a,b,c)  a?b:c}\n"
"@r{      a@:      a .   @:             @:     1  @:rmeq@:(a)}\n"
"@r{      a@:      a \"   @:             @:   7,8  @:calc-expand-formula@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:35978
#, no-wrap
msgid ""
"@r{      a@:      a +   @:i, l, h      @:  6,38  @:sum@:(a,i,l,h)}\n"
"@r{      a@:      a -   @:i, l, h      @:  6,38  @:asum@:(a,i,l,h)}\n"
"@r{      a@:      a *   @:i, l, h      @:  6,38  @:prod@:(a,i,l,h)}\n"
"@r{    a b@:      a _   @:             @:     2  @:subscr@:(a,b)  a_b}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:35984
#, no-wrap
msgid ""
"@r{    a b@:      a \\   @:             @:     2  @:pdiv@:(a,b)}\n"
"@r{    a b@:      a %   @:             @:     2  @:prem@:(a,b)}\n"
"@r{    a b@:      a /   @:             @:     2  @:pdivrem@:(a,b)  [q,r]}\n"
"@r{    a b@:    H a /   @:             @:     2  @:pdivide@:(a,b)  q+r/b}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36006
#, no-wrap
msgid ""
"@r{      a@:      a a   @:             @:     1  @:apart@:(a)}\n"
"@r{      a@:      a b   @:old, new     @:    38  @:subst@:(a,old,new)}\n"
"@r{      a@:      a c   @:v            @:    38  @:collect@:(a,v)}\n"
"@r{      a@:      a d   @:v            @:  4,38  @:deriv@:(a,v)}\n"
"@r{      a@:    H a d   @:v            @:  4,38  @:tderiv@:(a,v)}\n"
"@r{      a@:      a e   @:             @:        @:esimplify@:(a)}\n"
"@r{      a@:      a f   @:             @:     1  @:factor@:(a)}\n"
"@r{      a@:    H a f   @:             @:     1  @:factors@:(a)}\n"
"@r{    a b@:      a g   @:             @:     2  @:pgcd@:(a,b)}\n"
"@r{      a@:      a i   @:v            @:    38  @:integ@:(a,v)}\n"
"@r{      a@:      a m   @:pats         @:    38  @:match@:(a,pats)}\n"
"@r{      a@:    I a m   @:pats         @:    38  @:matchnot@:(a,pats)}\n"
"@r{ data x@:      a p   @:             @:    28  @:polint@:(data,x)}\n"
"@r{ data x@:    H a p   @:             @:    28  @:ratint@:(data,x)}\n"
"@r{      a@:      a n   @:             @:     1  @:nrat@:(a)}\n"
"@r{      a@:      a r   @:rules        @:4,8,38  @:rewrite@:(a,rules,n)}\n"
"@r{      a@:      a s   @:             @:        @:simplify@:(a)}\n"
"@r{      a@:      a t   @:v, n         @: 31,39  @:taylor@:(a,v,n)}\n"
"@r{      a@:      a v   @:             @:   7,8  @:calc-alg-evaluate@:}\n"
"@r{      a@:      a x   @:             @:   4,8  @:expand@:(a)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36027
#, no-wrap
msgid ""
"@r{   data@:      a F   @:model, vars  @:    48  @:fit@:(m,iv,pv,data)}\n"
"@r{   data@:    I a F   @:model, vars  @:    48  @:xfit@:(m,iv,pv,data)}\n"
"@r{   data@:    H a F   @:model, vars  @:    48  @:efit@:(m,iv,pv,data)}\n"
"@r{      a@:      a I   @:v, l, h      @:    38  @:ninteg@:(a,v,l,h)}\n"
"@r{    a b@:      a M   @:op           @:    22  @:mapeq@:(op,a,b)}\n"
"@r{    a b@:    I a M   @:op           @:    22  @:mapeqr@:(op,a,b)}\n"
"@r{    a b@:    H a M   @:op           @:    22  @:mapeqp@:(op,a,b)}\n"
"@r{    a g@:      a N   @:v            @:    38  @:minimize@:(a,v,g)}\n"
"@r{    a g@:    H a N   @:v            @:    38  @:wminimize@:(a,v,g)}\n"
"@r{      a@:      a P   @:v            @:    38  @:roots@:(a,v)}\n"
"@r{    a g@:      a R   @:v            @:    38  @:root@:(a,v,g)}\n"
"@r{    a g@:    H a R   @:v            @:    38  @:wroot@:(a,v,g)}\n"
"@r{      a@:      a S   @:v            @:    38  @:solve@:(a,v)}\n"
"@r{      a@:    I a S   @:v            @:    38  @:finv@:(a,v)}\n"
"@r{      a@:    H a S   @:v            @:    38  @:fsolve@:(a,v)}\n"
"@r{      a@:  I H a S   @:v            @:    38  @:ffinv@:(a,v)}\n"
"@r{      a@:      a T   @:i, l, h      @:  6,38  @:table@:(a,i,l,h)}\n"
"@r{    a g@:      a X   @:v            @:    38  @:maximize@:(a,v,g)}\n"
"@r{    a g@:    H a X   @:v            @:    38  @:wmaximize@:(a,v,g)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36044
#, no-wrap
msgid ""
"@r{    a b@:      b a   @:             @:     9  @:and@:(a,b,w)}\n"
"@r{      a@:      b c   @:             @:     9  @:clip@:(a,w)}\n"
"@r{    a b@:      b d   @:             @:     9  @:diff@:(a,b,w)}\n"
"@r{      a@:      b l   @:             @:    10  @:lsh@:(a,n,w)}\n"
"@r{    a n@:    H b l   @:             @:     9  @:lsh@:(a,n,w)}\n"
"@r{      a@:      b n   @:             @:     9  @:not@:(a,w)}\n"
"@r{    a b@:      b o   @:             @:     9  @:or@:(a,b,w)}\n"
"@r{      v@:      b p   @:             @:     1  @:vpack@:(v)}\n"
"@r{      a@:      b r   @:             @:    10  @:rsh@:(a,n,w)}\n"
"@r{    a n@:    H b r   @:             @:     9  @:rsh@:(a,n,w)}\n"
"@r{      a@:      b t   @:             @:    10  @:rot@:(a,n,w)}\n"
"@r{    a n@:    H b t   @:             @:     9  @:rot@:(a,n,w)}\n"
"@r{      a@:      b u   @:             @:     1  @:vunpack@:(a)}\n"
"@r{       @:      b w   @:w            @:  9,50  @:calc-word-size@:}\n"
"@r{    a b@:      b x   @:             @:     9  @:xor@:(a,b,w)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36069
#, no-wrap
msgid ""
"@r{c s l p@:      b D   @:             @:        @:ddb@:(c,s,l,p)}\n"
"@r{  r n p@:      b F   @:             @:        @:fv@:(r,n,p)}\n"
"@r{  r n p@:    I b F   @:             @:        @:fvb@:(r,n,p)}\n"
"@r{  r n p@:    H b F   @:             @:        @:fvl@:(r,n,p)}\n"
"@r{      v@:      b I   @:             @:    19  @:irr@:(v)}\n"
"@r{      v@:    I b I   @:             @:    19  @:irrb@:(v)}\n"
"@r{      a@:      b L   @:             @:    10  @:ash@:(a,n,w)}\n"
"@r{    a n@:    H b L   @:             @:     9  @:ash@:(a,n,w)}\n"
"@r{  r n a@:      b M   @:             @:        @:pmt@:(r,n,a)}\n"
"@r{  r n a@:    I b M   @:             @:        @:pmtb@:(r,n,a)}\n"
"@r{  r n a@:    H b M   @:             @:        @:pmtl@:(r,n,a)}\n"
"@r{    r v@:      b N   @:             @:    19  @:npv@:(r,v)}\n"
"@r{    r v@:    I b N   @:             @:    19  @:npvb@:(r,v)}\n"
"@r{  r n p@:      b P   @:             @:        @:pv@:(r,n,p)}\n"
"@r{  r n p@:    I b P   @:             @:        @:pvb@:(r,n,p)}\n"
"@r{  r n p@:    H b P   @:             @:        @:pvl@:(r,n,p)}\n"
"@r{      a@:      b R   @:             @:    10  @:rash@:(a,n,w)}\n"
"@r{    a n@:    H b R   @:             @:     9  @:rash@:(a,n,w)}\n"
"@r{  c s l@:      b S   @:             @:        @:sln@:(c,s,l)}\n"
"@r{  n p a@:      b T   @:             @:        @:rate@:(n,p,a)}\n"
"@r{  n p a@:    I b T   @:             @:        @:rateb@:(n,p,a)}\n"
"@r{  n p a@:    H b T   @:             @:        @:ratel@:(n,p,a)}\n"
"@r{c s l p@:      b Y   @:             @:        @:syd@:(c,s,l,p)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36074
#, no-wrap
msgid ""
"@r{  r p a@:      b #   @:             @:        @:nper@:(r,p,a)}\n"
"@r{  r p a@:    I b #   @:             @:        @:nperb@:(r,p,a)}\n"
"@r{  r p a@:    H b #   @:             @:        @:nperl@:(r,p,a)}\n"
"@r{    a b@:      b %   @:             @:        @:relch@:(a,b)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36087
#, no-wrap
msgid ""
"@r{      a@:      c c   @:             @:     5  @:pclean@:(a,p)}\n"
"@r{      a@:      c 0-9 @:             @:        @:pclean@:(a,p)}\n"
"@r{      a@:    H c c   @:             @:     5  @:clean@:(a,p)}\n"
"@r{      a@:    H c 0-9 @:             @:        @:clean@:(a,p)}\n"
"@r{      a@:      c d   @:             @:     1  @:deg@:(a)}\n"
"@r{      a@:      c f   @:             @:     1  @:pfloat@:(a)}\n"
"@r{      a@:    H c f   @:             @:     1  @:float@:(a)}\n"
"@r{      a@:      c h   @:             @:     1  @:hms@:(a)}\n"
"@r{      a@:      c p   @:             @:        @:polar@:(a)}\n"
"@r{      a@:    I c p   @:             @:        @:rect@:(a)}\n"
"@r{      a@:      c r   @:             @:     1  @:rad@:(a)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36091
#, no-wrap
msgid ""
"@r{      a@:      c F   @:             @:     5  @:pfrac@:(a,p)}\n"
"@r{      a@:    H c F   @:             @:     5  @:frac@:(a,p)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36094
#, no-wrap
msgid ""
"@r{      a@:      c %   @:             @:        @:percent@:(a*100)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36108
#, no-wrap
msgid ""
"@r{       @:      d .   @:char         @:    50  @:calc-point-char@:}\n"
"@r{       @:      d ,   @:char         @:    50  @:calc-group-char@:}\n"
"@r{       @:      d <   @:             @: 13,50  @:calc-left-justify@:}\n"
"@r{       @:      d =   @:             @: 13,50  @:calc-center-justify@:}\n"
"@r{       @:      d >   @:             @: 13,50  @:calc-right-justify@:}\n"
"@r{       @:      d @{   @:label        @:    50  @:calc-left-label@:}\n"
"@r{       @:      d @}   @:label        @:    50  @:calc-right-label@:}\n"
"@r{       @:      d [   @:             @:     4  @:calc-truncate-up@:}\n"
"@r{       @:      d ]   @:             @:     4  @:calc-truncate-down@:}\n"
"@r{       @:      d \"   @:             @: 12,50  "
"@:calc-display-strings@:}\n"
"@r{       @:      d @summarykey{SPC} @:             @:        "
"@:calc-refresh@:}\n"
"@r{       @:      d @summarykey{RET} @:             @:     1  "
"@:calc-refresh-top@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36114
#, no-wrap
msgid ""
"@r{       @:      d 0   @:             @:    50  @:calc-decimal-radix@:}\n"
"@r{       @:      d 2   @:             @:    50  @:calc-binary-radix@:}\n"
"@r{       @:      d 6   @:             @:    50  @:calc-hex-radix@:}\n"
"@r{       @:      d 8   @:             @:    50  @:calc-octal-radix@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36134
#, no-wrap
msgid ""
"@r{       @:      d b   @:           @:12,13,50  @:calc-line-breaking@:}\n"
"@r{       @:      d c   @:             @:    50  "
"@:calc-complex-notation@:}\n"
"@r{       @:      d d   @:format       @:    50  @:calc-date-notation@:}\n"
"@r{       @:      d e   @:             @:  5,50  @:calc-eng-notation@:}\n"
"@r{       @:      d f   @:num          @: 31,50  @:calc-fix-notation@:}\n"
"@r{       @:      d g   @:           @:12,13,50  @:calc-group-digits@:}\n"
"@r{       @:      d h   @:format       @:    50  @:calc-hms-notation@:}\n"
"@r{       @:      d i   @:             @:    50  @:calc-i-notation@:}\n"
"@r{       @:      d j   @:             @:    50  @:calc-j-notation@:}\n"
"@r{       @:      d l   @:             @: 12,50  @:calc-line-numbering@:}\n"
"@r{       @:      d n   @:             @:  5,50  @:calc-normal-notation@:}\n"
"@r{       @:      d o   @:format       @:    50  @:calc-over-notation@:}\n"
"@r{       @:      d p   @:             @: 12,50  @:calc-show-plain@:}\n"
"@r{       @:      d r   @:radix        @: 31,50  @:calc-radix@:}\n"
"@r{       @:      d s   @:             @:  5,50  @:calc-sci-notation@:}\n"
"@r{       @:      d t   @:             @:    27  @:calc-truncate-stack@:}\n"
"@r{       @:      d w   @:             @: 12,13  @:calc-auto-why@:}\n"
"@r{       @:      d z   @:             @: 12,50  @:calc-leading-zeros@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36148
#, no-wrap
msgid ""
"@r{       @:      d B   @:             @:    50  @:calc-big-language@:}\n"
"@r{       @:      d C   @:             @:    50  @:calc-c-language@:}\n"
"@r{       @:      d E   @:             @:    50  @:calc-eqn-language@:}\n"
"@r{       @:      d F   @:             @:    50  "
"@:calc-fortran-language@:}\n"
"@r{       @:      d M   @:             @:    50  "
"@:calc-mathematica-language@:}\n"
"@r{       @:      d N   @:             @:    50  @:calc-normal-language@:}\n"
"@r{       @:      d O   @:             @:    50  @:calc-flat-language@:}\n"
"@r{       @:      d P   @:             @:    50  @:calc-pascal-language@:}\n"
"@r{       @:      d T   @:             @:    50  @:calc-tex-language@:}\n"
"@r{       @:      d L   @:             @:    50  @:calc-latex-language@:}\n"
"@r{       @:      d U   @:             @:    50  "
"@:calc-unformatted-language@:}\n"
"@r{       @:      d W   @:             @:    50  @:calc-maple-language@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36152
#, no-wrap
msgid ""
"@r{      a@:      f [   @:             @:     4  @:decr@:(a,n)}\n"
"@r{      a@:      f ]   @:             @:     4  @:incr@:(a,n)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36166
#, no-wrap
msgid ""
"@r{    a b@:      f b   @:             @:     2  @:beta@:(a,b)}\n"
"@r{      a@:      f e   @:             @:     1  @:erf@:(a)}\n"
"@r{      a@:    I f e   @:             @:     1  @:erfc@:(a)}\n"
"@r{      a@:      f g   @:             @:     1  @:gamma@:(a)}\n"
"@r{    a b@:      f h   @:             @:     2  @:hypot@:(a,b)}\n"
"@r{      a@:      f i   @:             @:     1  @:im@:(a)}\n"
"@r{    n a@:      f j   @:             @:     2  @:besJ@:(n,a)}\n"
"@r{    a b@:      f n   @:             @:     2  @:min@:(a,b)}\n"
"@r{      a@:      f r   @:             @:     1  @:re@:(a)}\n"
"@r{      a@:      f s   @:             @:     1  @:sign@:(a)}\n"
"@r{    a b@:      f x   @:             @:     2  @:max@:(a,b)}\n"
"@r{    n a@:      f y   @:             @:     2  @:besY@:(n,a)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36185
#, no-wrap
msgid ""
"@r{      a@:      f A   @:             @:     1  @:abssqr@:(a)}\n"
"@r{  x a b@:      f B   @:             @:        @:betaI@:(x,a,b)}\n"
"@r{  x a b@:    H f B   @:             @:        @:betaB@:(x,a,b)}\n"
"@r{      a@:      f E   @:             @:     1  @:expm1@:(a)}\n"
"@r{    a x@:      f G   @:             @:     2  @:gammaP@:(a,x)}\n"
"@r{    a x@:    I f G   @:             @:     2  @:gammaQ@:(a,x)}\n"
"@r{    a x@:    H f G   @:             @:     2  @:gammag@:(a,x)}\n"
"@r{    a x@:  I H f G   @:             @:     2  @:gammaG@:(a,x)}\n"
"@r{    a b@:      f I   @:             @:     2  @:ilog@:(a,b)}\n"
"@r{    a b@:    I f I   @:             @:     2  @:alog@:(a,b)  b^a}\n"
"@r{      a@:      f L   @:             @:     1  @:lnp1@:(a)}\n"
"@r{      a@:      f M   @:             @:     1  @:mant@:(a)}\n"
"@r{      a@:      f Q   @:             @:     1  @:isqrt@:(a)}\n"
"@r{      a@:    I f Q   @:             @:     1  @:sqr@:(a)  a^2}\n"
"@r{    a n@:      f S   @:             @:     2  @:scf@:(a,n)}\n"
"@r{    y x@:      f T   @:             @:        @:arctan2@:(y,x)}\n"
"@r{      a@:      f X   @:             @:     1  @:xpon@:(a)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36206
#, no-wrap
msgid ""
"@r{    x y@:      g a   @:             @: 28,40  @:calc-graph-add@:}\n"
"@r{       @:      g b   @:             @:    12  @:calc-graph-border@:}\n"
"@r{       @:      g c   @:             @:        @:calc-graph-clear@:}\n"
"@r{       @:      g d   @:             @:    41  @:calc-graph-delete@:}\n"
"@r{    x y@:      g f   @:             @: 28,40  @:calc-graph-fast@:}\n"
"@r{       @:      g g   @:             @:    12  @:calc-graph-grid@:}\n"
"@r{       @:      g h   @:title        @:        @:calc-graph-header@:}\n"
"@r{       @:      g j   @:             @:     4  @:calc-graph-juggle@:}\n"
"@r{       @:      g k   @:             @:    12  @:calc-graph-key@:}\n"
"@r{       @:      g l   @:             @:    12  @:calc-graph-log-x@:}\n"
"@r{       @:      g n   @:name         @:        @:calc-graph-name@:}\n"
"@r{       @:      g p   @:             @:    42  @:calc-graph-plot@:}\n"
"@r{       @:      g q   @:             @:        @:calc-graph-quit@:}\n"
"@r{       @:      g r   @:range        @:        @:calc-graph-range-x@:}\n"
"@r{       @:      g s   @:             @: 12,13  "
"@:calc-graph-line-style@:}\n"
"@r{       @:      g t   @:title        @:        @:calc-graph-title-x@:}\n"
"@r{       @:      g v   @:             @:        "
"@:calc-graph-view-commands@:}\n"
"@r{       @:      g x   @:display      @:        @:calc-graph-display@:}\n"
"@r{       @:      g z   @:             @:    12  @:calc-graph-zero-x@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36224
#, no-wrap
msgid ""
"@r{  x y z@:      g A   @:             @: 28,40  @:calc-graph-add-3d@:}\n"
"@r{       @:      g C   @:command      @:        @:calc-graph-command@:}\n"
"@r{       @:      g D   @:device       @: 43,44  @:calc-graph-device@:}\n"
"@r{  x y z@:      g F   @:             @: 28,40  @:calc-graph-fast-3d@:}\n"
"@r{       @:      g H   @:             @:    12  @:calc-graph-hide@:}\n"
"@r{       @:      g K   @:             @:        @:calc-graph-kill@:}\n"
"@r{       @:      g L   @:             @:    12  @:calc-graph-log-y@:}\n"
"@r{       @:      g N   @:number       @: 43,51  "
"@:calc-graph-num-points@:}\n"
"@r{       @:      g O   @:filename     @: 43,44  @:calc-graph-output@:}\n"
"@r{       @:      g P   @:             @:    42  @:calc-graph-print@:}\n"
"@r{       @:      g R   @:range        @:        @:calc-graph-range-y@:}\n"
"@r{       @:      g S   @:             @: 12,13  "
"@:calc-graph-point-style@:}\n"
"@r{       @:      g T   @:title        @:        @:calc-graph-title-y@:}\n"
"@r{       @:      g V   @:             @:        "
"@:calc-graph-view-trail@:}\n"
"@r{       @:      g X   @:format       @:        @:calc-graph-geometry@:}\n"
"@r{       @:      g Z   @:             @:    12  @:calc-graph-zero-y@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36229
#, no-wrap
msgid ""
"@r{       @:      g C-l @:             @:    12  @:calc-graph-log-z@:}\n"
"@r{       @:      g C-r @:range        @:        @:calc-graph-range-z@:}\n"
"@r{       @:      g C-t @:title        @:        @:calc-graph-title-z@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36241
#, no-wrap
msgid ""
"@r{       @:      h b   @:             @:        "
"@:calc-describe-bindings@:}\n"
"@r{       @:      h c   @:key          @:        "
"@:calc-describe-key-briefly@:}\n"
"@r{       @:      h f   @:function     @:        "
"@:calc-describe-function@:}\n"
"@r{       @:      h h   @:             @:        @:calc-full-help@:}\n"
"@r{       @:      h i   @:             @:        @:calc-info@:}\n"
"@r{       @:      h k   @:key          @:        @:calc-describe-key@:}\n"
"@r{       @:      h n   @:             @:        @:calc-view-news@:}\n"
"@r{       @:      h s   @:             @:        @:calc-info-summary@:}\n"
"@r{       @:      h t   @:             @:        @:calc-tutorial@:}\n"
"@r{       @:      h v   @:var          @:        "
"@:calc-describe-variable@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36249
#, no-wrap
msgid ""
"@r{       @:      j 1-9 @:             @:        @:calc-select-part@:}\n"
"@r{       @:      j @summarykey{RET} @:             @:    27  "
"@:calc-copy-selection@:}\n"
"@r{       @:      j @summarykey{DEL} @:             @:    27  "
"@:calc-del-selection@:}\n"
"@r{       @:      j '   @:formula      @:    27  @:calc-enter-selection@:}\n"
"@r{       @:      j `   @:editing      @: 27,30  @:calc-edit-selection@:}\n"
"@r{       @:      j \"   @:             @:  7,27  "
"@:calc-sel-expand-formula@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36256
#, no-wrap
msgid ""
"@r{       @:      j +   @:formula      @:    27  "
"@:calc-sel-add-both-sides@:}\n"
"@r{       @:      j -   @:formula      @:    27  "
"@:calc-sel-sub-both-sides@:}\n"
"@r{       @:      j *   @:formula      @:    27  "
"@:calc-sel-mult-both-sides@:}\n"
"@r{       @:      j /   @:formula      @:    27  "
"@:calc-sel-div-both-sides@:}\n"
"@r{       @:      j &   @:             @:    27  @:calc-sel-invert@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36272
#, no-wrap
msgid ""
"@r{       @:      j a   @:             @:    27  "
"@:calc-select-additional@:}\n"
"@r{       @:      j b   @:             @:    12  "
"@:calc-break-selections@:}\n"
"@r{       @:      j c   @:             @:        "
"@:calc-clear-selections@:}\n"
"@r{       @:      j d   @:             @: 12,50  @:calc-show-selections@:}\n"
"@r{       @:      j e   @:             @:    12  "
"@:calc-enable-selections@:}\n"
"@r{       @:      j l   @:             @:  4,27  @:calc-select-less@:}\n"
"@r{       @:      j m   @:             @:  4,27  @:calc-select-more@:}\n"
"@r{       @:      j n   @:             @:     4  @:calc-select-next@:}\n"
"@r{       @:      j o   @:             @:  4,27  @:calc-select-once@:}\n"
"@r{       @:      j p   @:             @:     4  @:calc-select-previous@:}\n"
"@r{       @:      j r   @:rules        @:4,8,27  "
"@:calc-rewrite-selection@:}\n"
"@r{       @:      j s   @:             @:  4,27  @:calc-select-here@:}\n"
"@r{       @:      j u   @:             @:    27  @:calc-unselect@:}\n"
"@r{       @:      j v   @:             @:  7,27  @:calc-sel-evaluate@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36286
#, no-wrap
msgid ""
"@r{       @:      j C   @:             @:    27  @:calc-sel-commute@:}\n"
"@r{       @:      j D   @:             @:  4,27  @:calc-sel-distribute@:}\n"
"@r{       @:      j E   @:             @:    27  @:calc-sel-jump-equals@:}\n"
"@r{       @:      j I   @:             @:    27  @:calc-sel-isolate@:}\n"
"@r{       @:    H j I   @:             @:    27  @:calc-sel-isolate@: "
"(full)}\n"
"@r{       @:      j L   @:             @:  4,27  @:calc-commute-left@:}\n"
"@r{       @:      j M   @:             @:    27  @:calc-sel-merge@:}\n"
"@r{       @:      j N   @:             @:    27  @:calc-sel-negate@:}\n"
"@r{       @:      j O   @:             @:  4,27  "
"@:calc-select-once-maybe@:}\n"
"@r{       @:      j R   @:             @:  4,27  @:calc-commute-right@:}\n"
"@r{       @:      j S   @:             @:  4,27  "
"@:calc-select-here-maybe@:}\n"
"@r{       @:      j U   @:             @:    27  @:calc-sel-unpack@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36308
#, no-wrap
msgid ""
"@r{       @:      k a   @:             @:        @:calc-random-again@:}\n"
"@r{      n@:      k b   @:             @:     1  @:bern@:(n)}\n"
"@r{    n x@:    H k b   @:             @:     2  @:bern@:(n,x)}\n"
"@r{    n m@:      k c   @:             @:     2  @:choose@:(n,m)}\n"
"@r{    n m@:    H k c   @:             @:     2  @:perm@:(n,m)}\n"
"@r{      n@:      k d   @:             @:     1  @:dfact@:(n)  n!!}\n"
"@r{      n@:      k e   @:             @:     1  @:euler@:(n)}\n"
"@r{    n x@:    H k e   @:             @:     2  @:euler@:(n,x)}\n"
"@r{      n@:      k f   @:             @:     4  @:prfac@:(n)}\n"
"@r{    n m@:      k g   @:             @:     2  @:gcd@:(n,m)}\n"
"@r{    m n@:      k h   @:             @:    14  @:shuffle@:(n,m)}\n"
"@r{    n m@:      k l   @:             @:     2  @:lcm@:(n,m)}\n"
"@r{      n@:      k m   @:             @:     1  @:moebius@:(n)}\n"
"@r{      n@:      k n   @:             @:     4  @:nextprime@:(n)}\n"
"@r{      n@:    I k n   @:             @:     4  @:prevprime@:(n)}\n"
"@r{      n@:      k p   @:             @:  4,28  @:calc-prime-test@:}\n"
"@r{      m@:      k r   @:             @:    14  @:random@:(m)}\n"
"@r{    n m@:      k s   @:             @:     2  @:stir1@:(n,m)}\n"
"@r{    n m@:    H k s   @:             @:     2  @:stir2@:(n,m)}\n"
"@r{      n@:      k t   @:             @:     1  @:totient@:(n)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36323
#, no-wrap
msgid ""
"@r{  n p x@:      k B   @:             @:        @:utpb@:(x,n,p)}\n"
"@r{  n p x@:    I k B   @:             @:        @:ltpb@:(x,n,p)}\n"
"@r{    v x@:      k C   @:             @:        @:utpc@:(x,v)}\n"
"@r{    v x@:    I k C   @:             @:        @:ltpc@:(x,v)}\n"
"@r{    n m@:      k E   @:             @:        @:egcd@:(n,m)}\n"
"@r{v1 v2 x@:      k F   @:             @:        @:utpf@:(x,v1,v2)}\n"
"@r{v1 v2 x@:    I k F   @:             @:        @:ltpf@:(x,v1,v2)}\n"
"@r{  m s x@:      k N   @:             @:        @:utpn@:(x,m,s)}\n"
"@r{  m s x@:    I k N   @:             @:        @:ltpn@:(x,m,s)}\n"
"@r{    m x@:      k P   @:             @:        @:utpp@:(x,m)}\n"
"@r{    m x@:    I k P   @:             @:        @:ltpp@:(x,m)}\n"
"@r{    v x@:      k T   @:             @:        @:utpt@:(x,v)}\n"
"@r{    v x@:    I k T   @:             @:        @:ltpt@:(x,v)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36348
#, no-wrap
msgid ""
"@r{    a b@:      l +   @:             @:        @:lupadd@:(a,b)}\n"
"@r{    a b@:    H l +   @:             @:        @:lufadd@:(a,b)}\n"
"@r{    a b@:      l -   @:             @:        @:lupsub@:(a,b)}\n"
"@r{    a b@:    H l -   @:             @:        @:lufsub@:(a,b)}\n"
"@r{    a b@:      l *   @:             @:        @:lupmul@:(a,b)}\n"
"@r{    a b@:    H l *   @:             @:        @:lufmul@:(a,b)}\n"
"@r{    a b@:      l /   @:             @:        @:lupdiv@:(a,b)}\n"
"@r{    a b@:    H l /   @:             @:        @:lufdiv@:(a,b)}\n"
"@r{      a@:      l d   @:             @:        @:dbpower@:(a)}\n"
"@r{    a b@:    O l d   @:             @:        @:dbpower@:(a,b)}\n"
"@r{      a@:    H l d   @:             @:        @:dbfield@:(a)}\n"
"@r{    a b@:  O H l d   @:             @:        @:dbfield@:(a,b)}\n"
"@r{      a@:      l n   @:             @:        @:nppower@:(a)}\n"
"@r{    a b@:    O l n   @:             @:        @:nppower@:(a,b)}\n"
"@r{      a@:    H l n   @:             @:        @:npfield@:(a)}\n"
"@r{    a b@:  O H l n   @:             @:        @:npfield@:(a,b)}\n"
"@r{      a@:      l q   @:             @:        @:lupquant@:(a)}\n"
"@r{    a b@:    O l q   @:             @:        @:lupquant@:(a,b)}\n"
"@r{      a@:    H l q   @:             @:        @:lufquant@:(a)}\n"
"@r{    a b@:  O H l q   @:             @:        @:lufquant@:(a,b)}\n"
"@r{      a@:      l s   @:             @:        @:spn@:(a)}\n"
"@r{      a@:      l m   @:             @:        @:midi@:(a)}\n"
"@r{      a@:      l f   @:             @:        @:freq@:(a)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36365
#, no-wrap
msgid ""
"@r{       @:      m a   @:             @: 12,13  @:calc-algebraic-mode@:}\n"
"@r{       @:      m d   @:             @:        @:calc-degrees-mode@:}\n"
"@r{       @:      m e   @:             @:        "
"@:calc-embedded-preserve-modes@:}\n"
"@r{       @:      m f   @:             @:    12  @:calc-frac-mode@:}\n"
"@r{       @:      m g   @:             @:    52  @:calc-get-modes@:}\n"
"@r{       @:      m h   @:             @:        @:calc-hms-mode@:}\n"
"@r{       @:      m i   @:             @: 12,13  @:calc-infinite-mode@:}\n"
"@r{       @:      m m   @:             @:        @:calc-save-modes@:}\n"
"@r{       @:      m p   @:             @:    12  @:calc-polar-mode@:}\n"
"@r{       @:      m r   @:             @:        @:calc-radians-mode@:}\n"
"@r{       @:      m s   @:             @:    12  @:calc-symbolic-mode@:}\n"
"@r{       @:      m t   @:             @:    12  "
"@:calc-total-algebraic-mode@:}\n"
"@r{       @:      m v   @:             @: 12,13  @:calc-matrix-mode@:}\n"
"@r{       @:      m w   @:             @:    13  @:calc-working@:}\n"
"@r{       @:      m x   @:             @:        "
"@:calc-always-load-extensions@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36378
#, no-wrap
msgid ""
"@r{       @:      m A   @:             @:    12  "
"@:calc-alg-simplify-mode@:}\n"
"@r{       @:      m B   @:             @:    12  "
"@:calc-bin-simplify-mode@:}\n"
"@r{       @:      m C   @:             @:    12  @:calc-auto-recompute@:}\n"
"@r{       @:      m D   @:             @:        "
"@:calc-default-simplify-mode@:}\n"
"@r{       @:      m E   @:             @:    12  "
"@:calc-ext-simplify-mode@:}\n"
"@r{       @:      m F   @:filename     @:    13  "
"@:calc-settings-file-name@:}\n"
"@r{       @:      m N   @:             @:    12  "
"@:calc-num-simplify-mode@:}\n"
"@r{       @:      m O   @:             @:    12  "
"@:calc-no-simplify-mode@:}\n"
"@r{       @:      m R   @:             @: 12,13  "
"@:calc-mode-record-mode@:}\n"
"@r{       @:      m S   @:             @:    12  @:calc-shift-prefix@:}\n"
"@r{       @:      m U   @:             @:    12  "
"@:calc-units-simplify-mode@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36382
#, no-wrap
msgid ""
"@r{       @:      r s   @:register     @:    27  "
"@:calc-copy-to-register@:}\n"
"@r{       @:      r i   @:register     @:        @:calc-insert-register@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36401
#, no-wrap
msgid ""
"@r{       @:      s c   @:var1, var2   @:    29  @:calc-copy-variable@:}\n"
"@r{       @:      s d   @:var, decl    @:        "
"@:calc-declare-variable@:}\n"
"@r{       @:      s e   @:var, editing @: 29,30  @:calc-edit-variable@:}\n"
"@r{       @:      s i   @:buffer       @:        "
"@:calc-insert-variables@:}\n"
"@r{       @:      s k   @:const, var   @:    29  "
"@:calc-copy-special-constant@:}\n"
"@r{    a b@:      s l   @:var          @:    29  @:@:a  (letting var=b)}\n"
"@r{  a ...@:      s m   @:op, var      @: 22,29  @:calc-store-map@:}\n"
"@r{       @:      s n   @:var          @: 29,47  @:calc-store-neg@:  "
"(v/-1)}\n"
"@r{       @:      s p   @:var          @:    29  "
"@:calc-permanent-variable@:}\n"
"@r{       @:      s r   @:var          @:    29  @:@:v  (recalled value)}\n"
"@r{       @:      r 0-9 @:             @:        @:calc-recall-quick@:}\n"
"@r{      a@:      s s   @:var          @: 28,29  @:calc-store@:}\n"
"@r{      a@:      s 0-9 @:             @:        @:calc-store-quick@:}\n"
"@r{      a@:      s t   @:var          @:    29  @:calc-store-into@:}\n"
"@r{      a@:      t 0-9 @:             @:        "
"@:calc-store-into-quick@:}\n"
"@r{       @:      s u   @:var          @:    29  @:calc-unstore@:}\n"
"@r{      a@:      s x   @:var          @:    29  @:calc-store-exchange@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36416
#, no-wrap
msgid ""
"@r{       @:      s A   @:editing      @:    30  "
"@:calc-edit-AlgSimpRules@:}\n"
"@r{       @:      s D   @:editing      @:    30  @:calc-edit-Decls@:}\n"
"@r{       @:      s E   @:editing      @:    30  @:calc-edit-EvalRules@:}\n"
"@r{       @:      s F   @:editing      @:    30  @:calc-edit-FitRules@:}\n"
"@r{       @:      s G   @:editing      @:    30  @:calc-edit-GenCount@:}\n"
"@r{       @:      s H   @:editing      @:    30  @:calc-edit-Holidays@:}\n"
"@r{       @:      s I   @:editing      @:    30  @:calc-edit-IntegLimit@:}\n"
"@r{       @:      s L   @:editing      @:    30  @:calc-edit-LineStyles@:}\n"
"@r{       @:      s P   @:editing      @:    30  "
"@:calc-edit-PointStyles@:}\n"
"@r{       @:      s R   @:editing      @:    30  "
"@:calc-edit-PlotRejects@:}\n"
"@r{       @:      s T   @:editing      @:    30  @:calc-edit-TimeZone@:}\n"
"@r{       @:      s U   @:editing      @:    30  @:calc-edit-Units@:}\n"
"@r{       @:      s X   @:editing      @:    30  "
"@:calc-edit-ExtSimpRules@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36429
#, no-wrap
msgid ""
"@r{      a@:      s +   @:var          @: 29,47  @:calc-store-plus@:  "
"(v+a)}\n"
"@r{      a@:      s -   @:var          @: 29,47  @:calc-store-minus@:  "
"(v-a)}\n"
"@r{      a@:      s *   @:var          @: 29,47  @:calc-store-times@:  "
"(v*a)}\n"
"@r{      a@:      s /   @:var          @: 29,47  @:calc-store-div@:  "
"(v/a)}\n"
"@r{      a@:      s ^   @:var          @: 29,47  @:calc-store-power@:  "
"(v^a)}\n"
"@r{      a@:      s |   @:var          @: 29,47  @:calc-store-concat@:  "
"(v|a)}\n"
"@r{       @:      s &   @:var          @: 29,47  @:calc-store-inv@:  "
"(v^-1)}\n"
"@r{       @:      s [   @:var          @: 29,47  @:calc-store-decr@:  "
"(v-1)}\n"
"@r{       @:      s ]   @:var          @: 29,47  @:calc-store-incr@:  "
"(v-(-1))}\n"
"@r{    a b@:      s :   @:             @:     2  @:assign@:(a,b)  a @tfn{:=} "
"b}\n"
"@r{      a@:      s =   @:             @:     1  @:evalto@:(a,b)  a "
"@tfn{=>}}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36436
#, no-wrap
msgid ""
"@r{       @:      t [   @:             @:     4  @:calc-trail-first@:}\n"
"@r{       @:      t ]   @:             @:     4  @:calc-trail-last@:}\n"
"@r{       @:      t <   @:             @:     4  "
"@:calc-trail-scroll-left@:}\n"
"@r{       @:      t >   @:             @:     4  "
"@:calc-trail-scroll-right@:}\n"
"@r{       @:      t .   @:             @:    12  "
"@:calc-full-trail-vectors@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36451
#, no-wrap
msgid ""
"@r{       @:      t b   @:             @:     4  @:calc-trail-backward@:}\n"
"@r{       @:      t d   @:             @: 12,50  @:calc-trail-display@:}\n"
"@r{       @:      t f   @:             @:     4  @:calc-trail-forward@:}\n"
"@r{       @:      t h   @:             @:        @:calc-trail-here@:}\n"
"@r{       @:      t i   @:             @:        @:calc-trail-in@:}\n"
"@r{       @:      t k   @:             @:     4  @:calc-trail-kill@:}\n"
"@r{       @:      t m   @:string       @:        @:calc-trail-marker@:}\n"
"@r{       @:      t n   @:             @:     4  @:calc-trail-next@:}\n"
"@r{       @:      t o   @:             @:        @:calc-trail-out@:}\n"
"@r{       @:      t p   @:             @:     4  @:calc-trail-previous@:}\n"
"@r{       @:      t r   @:string       @:        "
"@:calc-trail-isearch-backward@:}\n"
"@r{       @:      t s   @:string       @:        "
"@:calc-trail-isearch-forward@:}\n"
"@r{       @:      t y   @:             @:     4  @:calc-trail-yank@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36472
#, no-wrap
msgid ""
"@r{      d@:      t C   @:oz, nz       @:        @:tzconv@:(d,oz,nz)}\n"
"@r{d oz nz@:      t C   @:$            @:        @:tzconv@:(d,oz,nz)}\n"
"@r{      d@:      t D   @:             @:    15  @:date@:(d)}\n"
"@r{      d@:      t I   @:             @:     4  @:incmonth@:(d,n)}\n"
"@r{      d@:      t J   @:             @:    16  @:julian@:(d,z)}\n"
"@r{      d@:      t M   @:             @:    17  @:newmonth@:(d,n)}\n"
"@r{       @:      t N   @:             @:    16  @:now@:(z)}\n"
"@r{      d@:      t P   @:1            @:    31  @:year@:(d)}\n"
"@r{      d@:      t P   @:2            @:    31  @:month@:(d)}\n"
"@r{      d@:      t P   @:3            @:    31  @:day@:(d)}\n"
"@r{      d@:      t P   @:4            @:    31  @:hour@:(d)}\n"
"@r{      d@:      t P   @:5            @:    31  @:minute@:(d)}\n"
"@r{      d@:      t P   @:6            @:    31  @:second@:(d)}\n"
"@r{      d@:      t P   @:7            @:    31  @:weekday@:(d)}\n"
"@r{      d@:      t P   @:8            @:    31  @:yearday@:(d)}\n"
"@r{      d@:      t P   @:9            @:    31  @:time@:(d)}\n"
"@r{      d@:      t U   @:             @:    16  @:unixtime@:(d,z)}\n"
"@r{      d@:      t W   @:             @:    17  @:newweek@:(d,w)}\n"
"@r{      d@:      t Y   @:             @:    17  @:newyear@:(d,n)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36476
#, no-wrap
msgid ""
"@r{    a b@:      t +   @:             @:     2  @:badd@:(a,b)}\n"
"@r{    a b@:      t -   @:             @:     2  @:bsub@:(a,b)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36493
#, no-wrap
msgid ""
"@r{       @:      u a   @:             @:    12  @:calc-autorange-units@:}\n"
"@r{      a@:      u b   @:             @:        @:calc-base-units@:}\n"
"@r{      a@:      u c   @:units        @:    18  @:calc-convert-units@:}\n"
"@r{   defn@:      u d   @:unit, descr  @:        @:calc-define-unit@:}\n"
"@r{       @:      u e   @:             @:        @:calc-explain-units@:}\n"
"@r{       @:      u g   @:unit         @:        "
"@:calc-get-unit-definition@:}\n"
"@r{       @:      u n   @:units        @:    18  "
"@:calc-convert-exact-units@:}\n"
"@r{       @:      u p   @:             @:        @:calc-permanent-units@:}\n"
"@r{      a@:      u r   @:             @:        @:calc-remove-units@:}\n"
"@r{      a@:      u s   @:             @:        @:usimplify@:(a)}\n"
"@r{      a@:      u t   @:units        @:    18  "
"@:calc-convert-temperature@:}\n"
"@r{       @:      u u   @:unit         @:        @:calc-undefine-unit@:}\n"
"@r{       @:      u v   @:             @:        "
"@:calc-enter-units-table@:}\n"
"@r{      a@:      u x   @:             @:        @:calc-extract-units@:}\n"
"@r{      a@:      u 0-9 @:             @:        @:calc-quick-units@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36512
#, no-wrap
msgid ""
"@r{  v1 v2@:      u C   @:             @:    20  @:vcov@:(v1,v2)}\n"
"@r{  v1 v2@:    I u C   @:             @:    20  @:vpcov@:(v1,v2)}\n"
"@r{  v1 v2@:    H u C   @:             @:    20  @:vcorr@:(v1,v2)}\n"
"@r{      v@:      u G   @:             @:    19  @:vgmean@:(v)}\n"
"@r{    a b@:    H u G   @:             @:     2  @:agmean@:(a,b)}\n"
"@r{      v@:      u M   @:             @:    19  @:vmean@:(v)}\n"
"@r{      v@:    I u M   @:             @:    19  @:vmeane@:(v)}\n"
"@r{      v@:    H u M   @:             @:    19  @:vmedian@:(v)}\n"
"@r{      v@:  I H u M   @:             @:    19  @:vhmean@:(v)}\n"
"@r{      v@:      u N   @:             @:    19  @:vmin@:(v)}\n"
"@r{      v@:      u R   @:             @:        @:rms@:(v)}\n"
"@r{      v@:      u S   @:             @:    19  @:vsdev@:(v)}\n"
"@r{      v@:    I u S   @:             @:    19  @:vpsdev@:(v)}\n"
"@r{      v@:    H u S   @:             @:    19  @:vvar@:(v)}\n"
"@r{      v@:  I H u S   @:             @:    19  @:vpvar@:(v)}\n"
"@r{       @:      u V   @:             @:        "
"@:calc-view-units-table@:}\n"
"@r{      v@:      u X   @:             @:    19  @:vmax@:(v)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36517
#, no-wrap
msgid ""
"@r{      v@:      u +   @:             @:    19  @:vsum@:(v)}\n"
"@r{      v@:      u *   @:             @:    19  @:vprod@:(v)}\n"
"@r{      v@:      u #   @:             @:    19  @:vcount@:(v)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36529
#, no-wrap
msgid ""
"@r{       @:      V (   @:             @:    50  @:calc-vector-parens@:}\n"
"@r{       @:      V @{   @:             @:    50  @:calc-vector-braces@:}\n"
"@r{       @:      V [   @:             @:    50  @:calc-vector-brackets@:}\n"
"@r{       @:      V ]   @:ROCP         @:    50  @:calc-matrix-brackets@:}\n"
"@r{       @:      V ,   @:             @:    50  @:calc-vector-commas@:}\n"
"@r{       @:      V <   @:             @:    50  "
"@:calc-matrix-left-justify@:}\n"
"@r{       @:      V =   @:             @:    50  "
"@:calc-matrix-center-justify@:}\n"
"@r{       @:      V >   @:             @:    50  "
"@:calc-matrix-right-justify@:}\n"
"@r{       @:      V /   @:             @: 12,50  @:calc-break-vectors@:}\n"
"@r{       @:      V .   @:             @: 12,50  @:calc-full-vectors@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36537
#, no-wrap
msgid ""
"@r{    s t@:      V ^   @:             @:     2  @:vint@:(s,t)}\n"
"@r{    s t@:      V -   @:             @:     2  @:vdiff@:(s,t)}\n"
"@r{      s@:      V ~   @:             @:     1  @:vcompl@:(s)}\n"
"@r{      s@:      V #   @:             @:     1  @:vcard@:(s)}\n"
"@r{      s@:      V :   @:             @:     1  @:vspan@:(s)}\n"
"@r{      s@:      V +   @:             @:     1  @:rdup@:(s)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36540
#, no-wrap
msgid ""
"@r{      m@:      V &   @:             @:     1  @:inv@:(m)  1/m}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36574
#, no-wrap
msgid ""
"@r{      v@:      v a   @:n            @:        @:arrange@:(v,n)}\n"
"@r{      a@:      v b   @:n            @:        @:cvec@:(a,n)}\n"
"@r{      v@:      v c   @:n >0         @: 21,31  @:mcol@:(v,n)}\n"
"@r{      v@:      v c   @:n <0         @:    31  @:mrcol@:(v,-n)}\n"
"@r{      m@:      v c   @:0            @:    31  @:getdiag@:(m)}\n"
"@r{      v@:      v d   @:             @:    25  @:diag@:(v,n)}\n"
"@r{    v m@:      v e   @:             @:     2  @:vexp@:(v,m)}\n"
"@r{  v m f@:    H v e   @:             @:     2  @:vexp@:(v,m,f)}\n"
"@r{    v a@:      v f   @:             @:    26  @:find@:(v,a,n)}\n"
"@r{      v@:      v h   @:             @:     1  @:head@:(v)}\n"
"@r{      v@:    I v h   @:             @:     1  @:tail@:(v)}\n"
"@r{      v@:    H v h   @:             @:     1  @:rhead@:(v)}\n"
"@r{      v@:  I H v h   @:             @:     1  @:rtail@:(v)}\n"
"@r{       @:      v i   @:n            @:    31  @:idn@:(1,n)}\n"
"@r{       @:      v i   @:0            @:    31  @:idn@:(1)}\n"
"@r{    h t@:      v k   @:             @:     2  @:cons@:(h,t)}\n"
"@r{    h t@:    H v k   @:             @:     2  @:rcons@:(h,t)}\n"
"@r{      v@:      v l   @:             @:     1  @:vlen@:(v)}\n"
"@r{      v@:    H v l   @:             @:     1  @:mdims@:(v)}\n"
"@r{    v m@:      v m   @:             @:     2  @:vmask@:(v,m)}\n"
"@r{      v@:      v n   @:             @:     1  @:rnorm@:(v)}\n"
"@r{  a b c@:      v p   @:             @:    24  @:calc-pack@:}\n"
"@r{      v@:      v r   @:n >0         @: 21,31  @:mrow@:(v,n)}\n"
"@r{      v@:      v r   @:n <0         @:    31  @:mrrow@:(v,-n)}\n"
"@r{      m@:      v r   @:0            @:    31  @:getdiag@:(m)}\n"
"@r{  v i j@:      v s   @:             @:        @:subvec@:(v,i,j)}\n"
"@r{  v i j@:    I v s   @:             @:        @:rsubvec@:(v,i,j)}\n"
"@r{      m@:      v t   @:             @:     1  @:trn@:(m)}\n"
"@r{      v@:      v u   @:             @:    24  @:calc-unpack@:}\n"
"@r{      v@:      v v   @:             @:     1  @:rev@:(v)}\n"
"@r{       @:      v x   @:n            @:    31  @:index@:(n)}\n"
"@r{  n s i@:  C-u v x   @:             @:        @:index@:(n,s,i)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36605
#, no-wrap
msgid ""
"@r{      v@:      V A   @:op           @:    22  @:apply@:(op,v)}\n"
"@r{  v1 v2@:      V C   @:             @:     2  @:cross@:(v1,v2)}\n"
"@r{      m@:      V D   @:             @:     1  @:det@:(m)}\n"
"@r{      s@:      V E   @:             @:     1  @:venum@:(s)}\n"
"@r{      s@:      V F   @:             @:     1  @:vfloor@:(s)}\n"
"@r{      v@:      V G   @:             @:        @:grade@:(v)}\n"
"@r{      v@:    I V G   @:             @:        @:rgrade@:(v)}\n"
"@r{      v@:      V H   @:n            @:    31  @:histogram@:(v,n)}\n"
"@r{    v w@:    H V H   @:n            @:    31  @:histogram@:(v,w,n)}\n"
"@r{  v1 v2@:      V I   @:mop aop      @:    22  @:inner@:(mop,aop,v1,v2)}\n"
"@r{      m@:      V J   @:             @:     1  @:ctrn@:(m)}\n"
"@r{  m1 m2@:      V K   @:             @:        @:kron@:(m1,m2)}\n"
"@r{      m@:      V L   @:             @:     1  @:lud@:(m)}\n"
"@r{      v@:      V M   @:op           @: 22,23  @:map@:(op,v)}\n"
"@r{      v@:      V N   @:             @:     1  @:cnorm@:(v)}\n"
"@r{  v1 v2@:      V O   @:op           @:    22  @:outer@:(op,v1,v2)}\n"
"@r{      v@:      V R   @:op           @: 22,23  @:reduce@:(op,v)}\n"
"@r{      v@:    I V R   @:op           @: 22,23  @:rreduce@:(op,v)}\n"
"@r{    a n@:    H V R   @:op           @:    22  @:nest@:(op,a,n)}\n"
"@r{      a@:  I H V R   @:op           @:    22  @:fixp@:(op,a)}\n"
"@r{      v@:      V S   @:             @:        @:sort@:(v)}\n"
"@r{      v@:    I V S   @:             @:        @:rsort@:(v)}\n"
"@r{      m@:      V T   @:             @:     1  @:tr@:(m)}\n"
"@r{      v@:      V U   @:op           @:    22  @:accum@:(op,v)}\n"
"@r{      v@:    I V U   @:op           @:    22  @:raccum@:(op,v)}\n"
"@r{    a n@:    H V U   @:op           @:    22  @:anest@:(op,a,n)}\n"
"@r{      a@:  I H V U   @:op           @:    22  @:afixp@:(op,a)}\n"
"@r{    s t@:      V V   @:             @:     2  @:vunion@:(s,t)}\n"
"@r{    s t@:      V X   @:             @:     2  @:vxor@:(s,t)}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36608
#, no-wrap
msgid ""
"@r{       @:      Y     @:             @:        @:@:user commands}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36611
#, no-wrap
msgid ""
"@r{       @:      z     @:             @:        @:@:user commands}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36617
#, no-wrap
msgid ""
"@r{      c@:      Z [   @:             @:    45  @:calc-kbd-if@:}\n"
"@r{      c@:      Z |   @:             @:    45  @:calc-kbd-else-if@:}\n"
"@r{       @:      Z :   @:             @:        @:calc-kbd-else@:}\n"
"@r{       @:      Z ]   @:             @:        @:calc-kbd-end-if@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36626
#, no-wrap
msgid ""
"@r{       @:      Z @{   @:             @:     4  @:calc-kbd-loop@:}\n"
"@r{      c@:      Z /   @:             @:    45  @:calc-kbd-break@:}\n"
"@r{       @:      Z @}   @:             @:        @:calc-kbd-end-loop@:}\n"
"@r{      n@:      Z <   @:             @:        @:calc-kbd-repeat@:}\n"
"@r{       @:      Z >   @:             @:        @:calc-kbd-end-repeat@:}\n"
"@r{    n m@:      Z (   @:             @:        @:calc-kbd-for@:}\n"
"@r{      s@:      Z )   @:             @:        @:calc-kbd-end-for@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36629
#, no-wrap
msgid ""
"@r{       @:      Z C-g @:             @:        @:@:cancel if/loop "
"command}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36634
#, no-wrap
msgid ""
"@r{       @:      Z `   @:             @:        @:calc-kbd-push@:}\n"
"@r{       @:      Z '   @:             @:        @:calc-kbd-pop@:}\n"
"@r{       @:      Z #   @:             @:        @:calc-kbd-query@:}\n"
"\n"
msgstr ""

#. type: format
#: ../../calc.texi:36647
#, no-wrap
msgid ""
"@r{   comp@:      Z C   @:func, args   @:    50  "
"@:calc-user-define-composition@:}\n"
"@r{       @:      Z D   @:key, command @:        @:calc-user-define@:}\n"
"@r{       @:      Z E   @:key, editing @:    30  "
"@:calc-user-define-edit@:}\n"
"@r{   defn@:      Z F   @:k, c, f, a, n@:    28  "
"@:calc-user-define-formula@:}\n"
"@r{       @:      Z G   @:key          @:        @:calc-get-user-defn@:}\n"
"@r{       @:      Z I   @:             @:        "
"@:calc-user-define-invocation@:}\n"
"@r{       @:      Z K   @:key, command @:        "
"@:calc-user-define-kbd-macro@:}\n"
"@r{       @:      Z P   @:key          @:        "
"@:calc-user-define-permanent@:}\n"
"@r{       @:      Z S   @:             @:    30  "
"@:calc-edit-user-syntax@:}\n"
"@r{       @:      Z T   @:             @:    12  @:calc-timing@:}\n"
"@r{       @:      Z U   @:key          @:        @:calc-user-undefine@:}\n"
"\n"
msgstr ""

#. type: Plain text
#: ../../calc.texi:36654
msgid "NOTES"
msgstr ""

#. type: enumerate
#: ../../calc.texi:36662
msgid ""
"Positive prefix arguments apply to @expr{n} stack entries.  Negative prefix "
"arguments apply to the @expr{-n}th stack entry.  A prefix of zero applies to "
"the entire stack.  (For @key{LFD} and @kbd{M-@key{DEL}}, the meaning of the "
"sign is reversed.)"
msgstr ""

#. type: enumerate
#: ../../calc.texi:36668
msgid ""
"Positive prefix arguments apply to @expr{n} stack entries.  Negative prefix "
"arguments apply to the top stack entry and the next @expr{-n} stack entries."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36674
msgid ""
"Positive prefix arguments rotate top @expr{n} stack entries by one.  "
"Negative prefix arguments rotate the entire stack by @expr{-n}.  A prefix of "
"zero reverses the entire stack."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36678
msgid "Prefix argument specifies a repeat count or distance."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36683
msgid ""
"Positive prefix arguments specify a precision @expr{p}.  Negative prefix "
"arguments reduce the current precision by @expr{-p}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36688
msgid ""
"A prefix argument is interpreted as an additional step-size parameter.  A "
"plain @kbd{C-u} prefix means to prompt for the step size."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36693
msgid ""
"A prefix argument specifies simplification level and depth.  1=Basic "
"simplifications, 2=Algebraic simplifications, 3=Extended simplifications"
msgstr ""

#. type: enumerate
#: ../../calc.texi:36697
msgid "A negative prefix operates only on the top level of the input formula."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36702
msgid ""
"Positive prefix arguments specify a word size of @expr{w} bits, unsigned.  "
"Negative prefix arguments specify a word size of @expr{w} bits, signed."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36707
msgid ""
"Prefix arguments specify the shift amount @expr{n}.  The @expr{w} argument "
"cannot be specified in the keyboard version of this command."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36711
msgid "From the keyboard, @expr{d} is omitted and defaults to zero."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36716
msgid ""
"Mode is toggled; a positive prefix always sets the mode, and a negative "
"prefix always clears the mode."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36720
msgid "Some prefix argument values provide special variations of the mode."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36725
msgid ""
"A prefix argument, if any, is used for @expr{m} instead of taking @expr{m} "
"from the stack.  @expr{M} may take any of these values:"
msgstr ""

#. type: iftex
#: ../../calc.texi:36744
msgid ""
"{@advance@tableindent10pt @end iftex @table @asis @item Integer Random "
"integer in the interval @expr{[0 .. m)}.  @item Float Random floating-point "
"number in the interval @expr{[0 .. m)}.  @item 0.0 Gaussian with mean 1 and "
"standard deviation 0.  @item Error form Gaussian with specified mean and "
"standard deviation.  @item Interval Random integer or floating-point number "
"in that interval.  @item Vector Random element from the vector.  @end table "
"@iftex }"
msgstr ""

#. type: enumerate
#: ../../calc.texi:36750
msgid ""
"A prefix argument from 1 to 6 specifies number of date components to remove "
"from the stack.  @xref{Date Conversions}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36755
msgid ""
"A prefix argument specifies a time zone; @kbd{C-u} says to take the time "
"zone number or name from the top of the stack.  @xref{Time Zones}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36759
msgid "A prefix argument specifies a day number (0--6, 0--31, or 0--366)."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36764
msgid ""
"If the input has no units, you will be prompted for both the old and the new "
"units."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36769
msgid ""
"With a prefix argument, collect that many stack entries to form the input "
"data set.  Each entry may be a single value or a vector of values."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36776
msgid ""
"With a prefix argument of 1, take a single @texline @var{n}@math{\\times2} "
"@infoline @mathit{@var{N}x2} matrix from the stack instead of two separate "
"data vectors."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36783
msgid ""
"The row or column number @expr{n} may be given as a numeric prefix argument "
"instead.  A plain @kbd{C-u} prefix says to take @expr{n} from the top of the "
"stack.  If @expr{n} is a vector or interval, a subvector/submatrix of the "
"input is created."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36795
msgid ""
"The @expr{op} prompt can be answered with the key sequence for the desired "
"function, or with @kbd{x} or @kbd{z} followed by a function name, or with "
"@kbd{$} to take a formula from the top of the stack, or with @kbd{'} and a "
"typed formula.  In the last two cases, the formula may be a nameless "
"function like @samp{<#1+#2>} or @samp{<x, y : x+y>}; or it may include "
"@kbd{$}, @kbd{$$}, etc., where @kbd{$} will correspond to the last argument "
"of the created function; or otherwise you will be prompted for an argument "
"list.  The number of vectors popped from the stack by @kbd{V M} depends on "
"the number of arguments of the function."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36804
msgid ""
"One of the mapping direction keys @kbd{_} (horizontal, i.e., map by rows or "
"reduce across), @kbd{:} (vertical, i.e., map by columns or reduce down), or "
"@kbd{=} (map or reduce by rows) may be used before entering @expr{op}; these "
"modify the function name by adding the letter @code{r} for ``rows,'' "
"@code{c} for ``columns,'' @code{a} for ``across,'' or @code{d} for ``down.''"
msgstr ""

#. type: enumerate
#: ../../calc.texi:36812
msgid ""
"The prefix argument specifies a packing mode.  A nonnegative mode is the "
"number of items (for @kbd{v p}) or the number of levels (for @kbd{v u}).  A "
"negative mode is as described below.  With no prefix argument, the mode is "
"taken from the top of the stack and may be an integer or a vector of "
"integers."
msgstr ""

#. type: iftex
#: ../../calc.texi:36849
msgid ""
"{@advance@tableindent-20pt @end iftex @table @cite @item -1 (@var{2})  "
"Rectangular complex number.  @item -2 (@var{2})  Polar complex number.  "
"@item -3 (@var{3})  HMS form.  @item -4 (@var{2})  Error form.  @item -5 "
"(@var{2})  Modulo form.  @item -6 (@var{2})  Closed interval.  @item -7 "
"(@var{2})  Closed .. open interval.  @item -8 (@var{2})  Open .. closed "
"interval.  @item -9 (@var{2})  Open interval.  @item -10 (@var{2})  "
"Fraction.  @item -11 (@var{2})  Float with integer mantissa.  @item -12 "
"(@var{2})  Float with mantissa in @expr{[1 .. 10)}.  @item -13 (@var{1})  "
"Date form (using date numbers).  @item -14 (@var{3})  Date form (using year, "
"month, day).  @item -15 (@var{6})  Date form (using year, month, day, hour, "
"minute, second).  @end table @iftex }"
msgstr ""

#. type: enumerate
#: ../../calc.texi:36856
msgid ""
"A prefix argument specifies the size @expr{n} of the matrix.  With no prefix "
"argument, @expr{n} is omitted and the size is inferred from the input "
"vector."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36860
msgid "The prefix argument specifies the starting position @expr{n} (default 1)."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36864
msgid "Cursor position within stack buffer affects this command."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36868
msgid "Arguments are not actually removed from the stack by this command."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36872
msgid "Variable name may be a single digit or a full name."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36879
msgid ""
"Editing occurs in a separate buffer.  Press @kbd{C-c C-c} (or @key{LFD}, or "
"in some cases @key{RET}) to finish the edit, or kill the buffer with "
"@kbd{C-x k} to cancel the edit.  The @key{LFD} key prevents evaluation of "
"the result of the edit."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36883
msgid "The number prompted for can also be provided as a prefix argument."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36887
msgid "Press this key a second time to cancel the prefix."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36892
msgid ""
"With a negative prefix, deactivate all formulas.  With a positive prefix, "
"deactivate and then reactivate from scratch."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36899
msgid ""
"Default is to scan for nearest formula delimiter symbols.  With a prefix of "
"zero, formula is delimited by mark and point.  With a non-zero prefix, "
"formula is delimited by scanning forward or backward by that many lines."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36906
msgid ""
"Parse the region between point and mark as a vector.  A nonzero prefix "
"parses @var{n} lines before or after point as a vector.  A zero prefix "
"parses the current line as a vector.  A @kbd{C-u} prefix parses the region "
"between point and mark as a single formula."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36913
msgid ""
"Parse the rectangle defined by point and mark as a matrix.  A positive "
"prefix @var{n} divides the rectangle into columns of width @var{n}.  A zero "
"or @kbd{C-u} prefix parses each line as one formula.  A negative prefix "
"suppresses special treatment of bracketed portions of a line."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36917
msgid "A numeric prefix causes the current language mode to be ignored."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36922
msgid ""
"Responding to a prompt with a blank line answers that and all later prompts "
"by popping additional stack entries."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36927
msgid ""
"Answer for @expr{v} may also be of the form @expr{v = v_0} or @expr{v - "
"v_0}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36935
msgid ""
"With a positive prefix argument, stack contains many @expr{y}'s and one "
"common @expr{x}.  With a zero prefix, stack contains a vector of @expr{y}s "
"and a common @expr{x}.  With a negative prefix, stack contains many "
"@expr{[x,y]} vectors.  (For 3D plots, substitute @expr{z} for @expr{y} and "
"@expr{x,y} for @expr{x}.)"
msgstr ""

#. type: enumerate
#: ../../calc.texi:36939
msgid "With any prefix argument, all curves in the graph are deleted."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36944
msgid ""
"With a positive prefix, refines an existing plot with more data points.  "
"With a negative prefix, forces recomputation of the plot data."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36949
msgid ""
"With any prefix argument, set the default value instead of the value for "
"this graph."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36953
msgid "With a negative prefix argument, set the value for the printer."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36959
msgid ""
"Condition is considered ``true'' if it is a nonzero real or complex number, "
"or a formula whose value is known to be nonzero; it is ``false'' otherwise."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36970
msgid ""
"Several formulas separated by commas are pushed as multiple stack entries.  "
"Trailing @kbd{)}, @kbd{]}, @kbd{@}}, @kbd{>}, and @kbd{\"} delimiters may be "
"omitted.  The notation @kbd{$$$} refers to the value in stack level three, "
"and causes the formula to replace the top three stack levels.  The notation "
"@kbd{$3} refers to stack level three without causing that value to be "
"removed from the stack.  Use @key{LFD} in place of @key{RET} to prevent "
"evaluation; use @kbd{M-=} in place of @key{RET} to evaluate variables."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36978
msgid ""
"The variable is replaced by the formula shown on the right.  The Inverse "
"flag reverses the order of the operands, e.g., @kbd{I s - x} assigns "
"@texline @math{x \\coloneq a-x}.  @infoline @expr{x := a-x}."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36986
msgid ""
"Press @kbd{?} repeatedly to see how to choose a model.  Answer the variables "
"prompt with @expr{iv} or @expr{iv;pv} to specify independent and parameter "
"variables.  A positive prefix argument takes @mathit{@var{n}+1} vectors from "
"the stack; a zero prefix takes a matrix and a vector from the stack."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36991
msgid ""
"With a plain @kbd{C-u} prefix, replace the current region of the destination "
"buffer with the yanked text instead of inserting."
msgstr ""

#. type: enumerate
#: ../../calc.texi:36997
msgid ""
"All stack entries are reformatted; the @kbd{H} prefix inhibits this.  The "
"@kbd{I} prefix sets the mode temporarily, redraws the top stack entry, then "
"restores the original setting of the mode."
msgstr ""

#. type: enumerate
#: ../../calc.texi:37002
msgid ""
"A negative prefix sets the default 3D resolution instead of the default 2D "
"resolution."
msgstr ""

#. type: enumerate
#: ../../calc.texi:37009
msgid ""
"This grabs a vector of the form [@var{prec}, @var{wsize}, @var{ssize}, "
"@var{radix}, @var{flfmt}, @var{ang}, @var{frac}, @var{symb}, @var{polar}, "
"@var{matrix}, @var{simp}, @var{inf}].  A prefix argument from 1 to 12 grabs "
"the @var{n}th mode value only."
msgstr ""

#. type: iftex
#: ../../calc.texi:37013
msgid "(Space is provided below for you to keep your own written notes.)"
msgstr ""

#. type: iftex
#: ../../calc.texi:37015
msgid "@endgroup"
msgstr ""

#. type: unnumbered
#: ../../calc.texi:37021
#, no-wrap
msgid "Index of Key Sequences"
msgstr ""

#. type: unnumbered
#: ../../calc.texi:37026
#, no-wrap
msgid "Index of Calculator Commands"
msgstr ""

#. type: Plain text
#: ../../calc.texi:37032
msgid ""
"Since all Calculator commands begin with the prefix @samp{calc-}, the "
"@kbd{x} key has been provided as a variant of @kbd{M-x} which automatically "
"types @samp{calc-} for you.  Thus, @kbd{x last-args} is short for @kbd{M-x "
"calc-last-args}."
msgstr ""

#. type: unnumbered
#: ../../calc.texi:37036
#, no-wrap
msgid "Index of Algebraic Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:37041
msgid ""
"This is a list of built-in functions and operators usable in algebraic "
"expressions.  Their full Lisp names are derived by adding the prefix "
"@samp{calcFunc-}, as in @code{calcFunc-sqrt}."
msgstr ""

#. type: iftex
#: ../../calc.texi:37044
msgid ""
"All functions except those noted with ``*'' have corresponding Calc "
"keystrokes and can also be found in the Calc Summary."
msgstr ""

#. type: unnumbered
#: ../../calc.texi:37054
#, no-wrap
msgid "Index of Variables"
msgstr ""

#. type: Plain text
#: ../../calc.texi:37059
msgid ""
"The variables in this list that do not contain dashes are accessible as Calc "
"variables.  Add a @samp{var-} prefix to get the name of the corresponding "
"Lisp variable."
msgstr ""

#. type: Plain text
#: ../../calc.texi:37062
msgid ""
"The remaining variables are Lisp variables suitable for @code{setq}ing in "
"your Calc init file or @file{.emacs} file."
msgstr ""

#. type: unnumbered
#: ../../calc.texi:37066
#, no-wrap
msgid "Index of Lisp Math Functions"
msgstr ""

#. type: Plain text
#: ../../calc.texi:37072
msgid ""
"The following functions are meant to be used with @code{defmath}, not "
"@code{defun} definitions.  For names that do not start with @samp{calc-}, "
"the corresponding full Lisp name is derived by adding a prefix of "
"@samp{math-}."
msgstr ""
