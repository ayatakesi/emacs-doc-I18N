# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-09-22 12:28+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: titlefont{#1}
#: ../../cl.texi:3 ../../cl.texi:34
#, no-wrap
msgid "Common Lisp Extensions"
msgstr ""

#. type: include
#: ../../cl.texi:4
#, no-wrap
msgid "docstyle.texi"
msgstr ""

#. type: include
#: ../../cl.texi:5
#, no-wrap
msgid "emacsver.texi"
msgstr ""

#. type: copying
#: ../../cl.texi:9
msgid "This file documents the GNU Emacs Common Lisp emulation package."
msgstr ""

#. type: copying
#: ../../cl.texi:11
msgid "Copyright @copyright{} 1993, 2001--2021 Free Software Foundation, Inc."
msgstr ""

#. type: quotation
#: ../../cl.texi:19
msgid ""
"Permission is granted to copy, distribute and/or modify this document under "
"the terms of the GNU Free Documentation License, Version 1.3 or any later "
"version published by the Free Software Foundation; with no Invariant "
"Sections, with the Front-Cover Texts being ``A GNU Manual'', and with the "
"Back-Cover Texts as in (a) below.  A copy of the license is included in the "
"section entitled ``GNU Free Documentation License''."
msgstr ""

#. type: quotation
#: ../../cl.texi:22
msgid ""
"(a) The FSF's Back-Cover Text is: ``You have the freedom to copy and modify "
"this GNU manual.''"
msgstr ""

#. type: dircategory
#: ../../cl.texi:25
#, no-wrap
msgid "Emacs lisp libraries"
msgstr ""

#. type: menuentry
#: ../../cl.texi:28
msgid "CL-Lib: (cl)"
msgstr ""

#. type: menuentry
#: ../../cl.texi:28
msgid "Partial Common Lisp support for Emacs Lisp."
msgstr ""

#. type: center
#: ../../cl.texi:36
#, no-wrap
msgid "For GNU Emacs Lisp"
msgstr ""

#. type: center
#: ../../cl.texi:38
#, no-wrap
msgid "as distributed with Emacs @value{EMACSVER}"
msgstr ""

#. type: center
#: ../../cl.texi:40
#, no-wrap
msgid "Dave Gillespie"
msgstr ""

#. type: center
#: ../../cl.texi:41
#, no-wrap
msgid "daveg@@synaptics.com"
msgstr ""

#. type: node
#: ../../cl.texi:50
#, no-wrap
msgid "Top"
msgstr ""

#. type: top
#: ../../cl.texi:51
#, no-wrap
msgid "GNU Emacs Common Lisp Emulation"
msgstr ""

#. type: chapter
#: ../../cl.texi:69 ../../cl.texi:83 ../../cl.texi:84
#, no-wrap
msgid "Overview"
msgstr ""

#. type: menuentry
#: ../../cl.texi:69
msgid "Basics, usage, organization, naming conventions."
msgstr ""

#. type: chapter
#: ../../cl.texi:69 ../../cl.texi:268 ../../cl.texi:269
#, no-wrap
msgid "Program Structure"
msgstr ""

#. type: menuentry
#: ../../cl.texi:69
msgid "Arglists, @code{cl-eval-when}."
msgstr ""

#. type: chapter
#: ../../cl.texi:69 ../../cl.texi:670 ../../cl.texi:671
#, no-wrap
msgid "Predicates"
msgstr ""

#. type: menuentry
#: ../../cl.texi:69
msgid "Type predicates and equality predicates."
msgstr ""

#. type: chapter
#: ../../cl.texi:69 ../../cl.texi:835 ../../cl.texi:836
#, no-wrap
msgid "Control Structure"
msgstr ""

#. type: menuentry
#: ../../cl.texi:69
msgid "Assignment, conditionals, blocks, looping."
msgstr ""

#. type: appendixsec
#: ../../cl.texi:69 ../../cl.texi:2517 ../../cl.texi:2518 ../../cl.texi:4383
#, no-wrap
msgid "Macros"
msgstr ""

#. type: menuentry
#: ../../cl.texi:69
msgid "Destructuring, compiler macros."
msgstr ""

#. type: chapter
#: ../../cl.texi:69 ../../cl.texi:2597 ../../cl.texi:2598
#, no-wrap
msgid "Declarations"
msgstr ""

#. type: menuentry
#: ../../cl.texi:69
msgid "@code{cl-proclaim}, @code{cl-declare}, etc."
msgstr ""

#. type: chapter
#: ../../cl.texi:69 ../../cl.texi:2777 ../../cl.texi:2778
#, no-wrap
msgid "Symbols"
msgstr ""

#. type: menuentry
#: ../../cl.texi:69
msgid "Property lists, creating symbols."
msgstr ""

#. type: chapter
#: ../../cl.texi:69 ../../cl.texi:2906 ../../cl.texi:2907
#, no-wrap
msgid "Numbers"
msgstr ""

#. type: menuentry
#: ../../cl.texi:69
msgid "Predicates, functions, random numbers."
msgstr ""

#. type: chapter
#: ../../cl.texi:69 ../../cl.texi:3176 ../../cl.texi:3177
#, no-wrap
msgid "Sequences"
msgstr ""

#. type: menuentry
#: ../../cl.texi:69
msgid "Mapping, functions, searching, sorting."
msgstr ""

#. type: chapter
#: ../../cl.texi:69 ../../cl.texi:3667 ../../cl.texi:3668
#, no-wrap
msgid "Lists"
msgstr ""

#. type: menuentry
#: ../../cl.texi:69
msgid "Functions, substitution, sets, associations."
msgstr ""

#. type: chapter
#: ../../cl.texi:69 ../../cl.texi:3944 ../../cl.texi:3945
#, no-wrap
msgid "Structures"
msgstr ""

#. type: menuentry
#: ../../cl.texi:69
msgid "@code{cl-defstruct}."
msgstr ""

#. type: node
#: ../../cl.texi:69 ../../cl.texi:4319
#, no-wrap
msgid "Assertions"
msgstr ""

#. type: menuentry
#: ../../cl.texi:69
msgid "Assertions and type checking."
msgstr ""

#. type: menuentry
#: ../../cl.texi:76
msgid "Appendices"
msgstr ""

#. type: appendix
#: ../../cl.texi:76 ../../cl.texi:4380 ../../cl.texi:4381
#, no-wrap
msgid "Efficiency Concerns"
msgstr ""

#. type: menuentry
#: ../../cl.texi:76
msgid "Hints and techniques."
msgstr ""

#. type: appendix
#: ../../cl.texi:76 ../../cl.texi:4515 ../../cl.texi:4516
#, no-wrap
msgid "Common Lisp Compatibility"
msgstr ""

#. type: menuentry
#: ../../cl.texi:76
msgid "All known differences with Steele."
msgstr ""

#. type: appendix
#: ../../cl.texi:76 ../../cl.texi:4564 ../../cl.texi:4565
#, no-wrap
msgid "Porting Common Lisp"
msgstr ""

#. type: menuentry
#: ../../cl.texi:76
msgid "Hints for porting Common Lisp code."
msgstr ""

#. type: appendix
#: ../../cl.texi:76 ../../cl.texi:4763 ../../cl.texi:4764
#, no-wrap
msgid "Obsolete Features"
msgstr ""

#. type: menuentry
#: ../../cl.texi:76
msgid "Obsolete features."
msgstr ""

#. type: appendix
#: ../../cl.texi:76 ../../cl.texi:5200 ../../cl.texi:5201
#, no-wrap
msgid "GNU Free Documentation License"
msgstr ""

#. type: menuentry
#: ../../cl.texi:76
msgid "The license for this documentation."
msgstr ""

#. type: menuentry
#: ../../cl.texi:81
msgid "Indexes"
msgstr ""

#. type: unnumbered
#: ../../cl.texi:81 ../../cl.texi:5204 ../../cl.texi:5205
#, no-wrap
msgid "Function Index"
msgstr ""

#. type: menuentry
#: ../../cl.texi:81
msgid "An entry for each documented function."
msgstr ""

#. type: unnumbered
#: ../../cl.texi:81 ../../cl.texi:5208 ../../cl.texi:5209
#, no-wrap
msgid "Variable Index"
msgstr ""

#. type: menuentry
#: ../../cl.texi:81
msgid "An entry for each documented variable."
msgstr ""

#. type: unnumbered
#: ../../cl.texi:81 ../../cl.texi:5212 ../../cl.texi:5213
#, no-wrap
msgid "Concept Index"
msgstr ""

#. type: menuentry
#: ../../cl.texi:81
msgid "An entry for each concept."
msgstr ""

#. type: Plain text
#: ../../cl.texi:91
msgid ""
"This document describes a set of Emacs Lisp facilities borrowed from Common "
"Lisp.  All the facilities are described here in detail.  While this document "
"does not assume any prior knowledge of Common Lisp, it does assume a basic "
"familiarity with Emacs Lisp."
msgstr ""

#. type: Plain text
#: ../../cl.texi:98
msgid ""
"Common Lisp is a huge language, and Common Lisp systems tend to be massive "
"and extremely complex.  Emacs Lisp, by contrast, is rather minimalist in the "
"choice of Lisp features it offers the programmer.  As Emacs Lisp programmers "
"have grown in number, and the applications they write have grown more "
"ambitious, it has become clear that Emacs Lisp could benefit from many of "
"the conveniences of Common Lisp."
msgstr ""

#. type: Plain text
#: ../../cl.texi:103
msgid ""
"The @dfn{CL} package adds a number of Common Lisp functions and control "
"structures to Emacs Lisp.  While not a 100% complete implementation of "
"Common Lisp, it adds enough functionality to make Emacs Lisp programming "
"significantly more convenient."
msgstr ""

#. type: Plain text
#: ../../cl.texi:106
msgid ""
"Some Common Lisp features have been omitted from this package for various "
"reasons:"
msgstr ""

#. type: itemize
#: ../../cl.texi:113
msgid ""
"Some features are too complex or bulky relative to their benefit to Emacs "
"Lisp programmers.  CLOS and Common Lisp streams are fine examples of this "
"group.  (The separate package EIEIO implements a subset of CLOS "
"functionality.  @xref{Top, , Introduction, eieio, EIEIO}.)"
msgstr ""

#. type: itemize
#: ../../cl.texi:119
msgid ""
"Other features cannot be implemented without modification to the Emacs Lisp "
"interpreter itself, such as multiple return values, case-insensitive "
"symbols, and complex numbers.  This package generally makes no attempt to "
"emulate these features."
msgstr ""

#. type: Plain text
#: ../../cl.texi:128
msgid ""
"This package was originally written by Dave Gillespie, "
"@file{daveg@@synaptics.com}, as a total rewrite of an earlier 1986 "
"@file{cl.el} package by Cesar Quiroz.  Care has been taken to ensure that "
"each function is defined efficiently, concisely, and with minimal impact on "
"the rest of the Emacs environment.  Stefan Monnier added the file "
"@file{cl-lib.el} and rationalized the namespace for Emacs 24.3."
msgstr ""

#. type: section
#: ../../cl.texi:133 ../../cl.texi:135 ../../cl.texi:136
#, no-wrap
msgid "Usage"
msgstr ""

#. type: menuentry
#: ../../cl.texi:133
msgid "How to use this package."
msgstr ""

#. type: section
#: ../../cl.texi:133 ../../cl.texi:157 ../../cl.texi:158
#, no-wrap
msgid "Organization"
msgstr ""

#. type: menuentry
#: ../../cl.texi:133
msgid "The package's component files."
msgstr ""

#. type: section
#: ../../cl.texi:133 ../../cl.texi:225 ../../cl.texi:226
#, no-wrap
msgid "Naming Conventions"
msgstr ""

#. type: menuentry
#: ../../cl.texi:133
msgid "Notes on function names."
msgstr ""

#. type: Plain text
#: ../../cl.texi:143
msgid ""
"This package is distributed with Emacs, so there is no need to install any "
"additional files in order to start using it.  Lisp code that uses features "
"from this package should simply include at the beginning:"
msgstr ""

#. type: example
#: ../../cl.texi:146
#, no-wrap
msgid "(require 'cl-lib)\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:151
msgid ""
"You may wish to add such a statement to your init file, if you make frequent "
"use of features from this package."
msgstr ""

#. type: Plain text
#: ../../cl.texi:156
msgid ""
"Code that only uses macros from this package can enclose the above in "
"@code{eval-when-compile}.  Internally, this library is divided into several "
"files, @pxref{Organization}.  Your code should only ever load the main "
"@file{cl-lib} file, which will load the others as needed."
msgstr ""

#. type: Plain text
#: ../../cl.texi:162
msgid "The Common Lisp package is organized into four main files:"
msgstr ""

#. type: item
#: ../../cl.texi:164
#, no-wrap
msgid "cl-lib.el"
msgstr ""

#. type: table
#: ../../cl.texi:167
msgid ""
"This is the main file, which contains basic functions and information about "
"the package.  This file is relatively compact."
msgstr ""

#. type: item
#: ../../cl.texi:168
#, no-wrap
msgid "cl-extra.el"
msgstr ""

#. type: table
#: ../../cl.texi:173
msgid ""
"This file contains the larger, more complex or unusual functions.  It is "
"kept separate so that packages which only want to use Common Lisp "
"fundamentals like the @code{cl-incf} function won't need to pay the overhead "
"of loading the more advanced functions."
msgstr ""

#. type: item
#: ../../cl.texi:174
#, no-wrap
msgid "cl-seq.el"
msgstr ""

#. type: table
#: ../../cl.texi:177
msgid ""
"This file contains most of the advanced functions for operating on sequences "
"or lists, such as @code{cl-delete-if} and @code{cl-assoc}."
msgstr ""

#. type: item
#: ../../cl.texi:178
#, no-wrap
msgid "cl-macs.el"
msgstr ""

#. type: table
#: ../../cl.texi:185
msgid ""
"This file contains the features that are macros instead of functions.  "
"Macros expand when the caller is compiled, not when it is run, so the macros "
"generally only need to be present when the byte-compiler is running (or when "
"the macros are used in uncompiled code).  Most of the macros of this package "
"are isolated in @file{cl-macs.el} so that they won't take up memory unless "
"you are compiling."
msgstr ""

#. type: Plain text
#: ../../cl.texi:192
msgid ""
"The file @file{cl-lib.el} includes all necessary @code{autoload} commands "
"for the functions and macros in the other three files.  All you have to do "
"is @code{(require 'cl-lib)}, and @file{cl-lib.el} will take care of pulling "
"in the other files when they are needed."
msgstr ""

#. type: Plain text
#: ../../cl.texi:212
msgid ""
"There is another file, @file{cl.el}, which was the main entry point to this "
"package prior to Emacs 24.3.  Nowadays, it is replaced by @file{cl-lib.el}.  "
"The two provide the same features (in most cases), but use different "
"function names (in fact, @file{cl.el} mainly just defines aliases to the "
"@file{cl-lib.el} definitions).  Where @file{cl-lib.el} defines a function "
"called, for example, @code{cl-incf}, @file{cl.el} uses the same name but "
"without the @samp{cl-} prefix, e.g., @code{incf} in this example.  There are "
"a few exceptions to this.  First, functions such as @code{cl-defun} where "
"the unprefixed version was already used for a standard Emacs Lisp function.  "
"In such cases, the @file{cl.el} version adds a @samp{*} suffix, e.g., "
"@code{defun*}.  Second, there are some obsolete features that are only "
"implemented in @file{cl.el}, not in @file{cl-lib.el}, because they are "
"replaced by other standard Emacs Lisp features.  Finally, in a very few "
"cases the old @file{cl.el} versions do not behave in exactly the same way as "
"the @file{cl-lib.el} versions.  @xref{Obsolete Features}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:219
msgid ""
"Since the old @file{cl.el} does not use a clean namespace, Emacs has a "
"policy that packages distributed with Emacs must not load @code{cl} at run "
"time.  (It is ok for them to load @code{cl} at @emph{compile} time, with "
"@code{eval-when-compile}, and use the macros it provides.)  There is no such "
"restriction on the use of @code{cl-lib}.  New code should use @code{cl-lib} "
"rather than @code{cl}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:224
msgid ""
"There is one more file, @file{cl-compat.el}, which defines some routines "
"from the older Quiroz @file{cl.el} package that are not otherwise present in "
"the new package.  This file is obsolete and should not be used in new code."
msgstr ""

#. type: Plain text
#: ../../cl.texi:232
msgid ""
"Except where noted, all functions defined by this package have the same "
"calling conventions as their Common Lisp counterparts, and names that are "
"those of Common Lisp plus a @samp{cl-} prefix."
msgstr ""

#. type: Plain text
#: ../../cl.texi:236
msgid ""
"Internal function and variable names in the package are prefixed by "
"@code{cl--}.  Here is a complete list of functions prefixed by @code{cl-} "
"that were @emph{not} taken from Common Lisp:"
msgstr ""

#. type: example
#: ../../cl.texi:240
#, no-wrap
msgid ""
"cl-callf           cl-callf2          cl-defsubst\n"
"cl-letf            cl-letf*\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:246
msgid ""
"The following simple functions and macros are defined in @file{cl-lib.el}; "
"they do not cause other components like @file{cl-extra} to be loaded."
msgstr ""

#. type: example
#: ../../cl.texi:256
#, no-wrap
msgid ""
"cl-evenp           cl-oddp            cl-minusp\n"
"cl-plusp           cl-endp            cl-subst\n"
"cl-copy-list       cl-list*           cl-ldiff\n"
"cl-rest            cl-decf [1]        cl-incf [1]\n"
"cl-acons           cl-adjoin [2]      cl-pairlis\n"
"cl-pushnew [1,2]   cl-declaim         cl-proclaim\n"
"cl-caaar@dots{}cl-cddddr                  cl-first@dots{}cl-tenth\n"
"cl-mapcar [3]\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:260
msgid "[1] Only when @var{place} is a plain variable name."
msgstr ""

#. type: Plain text
#: ../../cl.texi:264
msgid ""
"[2] Only if @code{:test} is @code{eq}, @code{equal}, or unspecified, and "
"@code{:key} is not used."
msgstr ""

#. type: Plain text
#: ../../cl.texi:267
msgid "[3] Only for one sequence argument or two list arguments."
msgstr ""

#. type: Plain text
#: ../../cl.texi:275
msgid ""
"This section describes features of this package that have to do with "
"programs as a whole: advanced argument lists for functions, and the "
"@code{cl-eval-when} construct."
msgstr ""

#. type: section
#: ../../cl.texi:279 ../../cl.texi:281 ../../cl.texi:282
#, no-wrap
msgid "Argument Lists"
msgstr ""

#. type: menuentry
#: ../../cl.texi:279
msgid "@code{&key}, @code{&aux}, @code{cl-defun}, @code{cl-defmacro}."
msgstr ""

#. type: section
#: ../../cl.texi:279 ../../cl.texi:520 ../../cl.texi:521
#, no-wrap
msgid "Time of Evaluation"
msgstr ""

#. type: menuentry
#: ../../cl.texi:279
msgid "The @code{cl-eval-when} construct."
msgstr ""

#. type: cindex
#: ../../cl.texi:283
#, no-wrap
msgid "&key"
msgstr ""

#. type: cindex
#: ../../cl.texi:284
#, no-wrap
msgid "&aux"
msgstr ""

#. type: Plain text
#: ../../cl.texi:292
msgid ""
"Emacs Lisp's notation for argument lists of functions is a subset of the "
"Common Lisp notation.  As well as the familiar @code{&optional} and "
"@code{&rest} markers, Common Lisp allows you to specify default values for "
"optional arguments, and it provides the additional markers @code{&key} and "
"@code{&aux}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:297
msgid ""
"Since argument parsing is built-in to Emacs, there is no way for this "
"package to implement Common Lisp argument lists seamlessly.  Instead, this "
"package defines alternates for several Lisp forms which you must use if you "
"need Common Lisp argument lists."
msgstr ""

#. type: defmac
#: ../../cl.texi:298
#, no-wrap
msgid "cl-defun name arglist body@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:303
msgid ""
"This form is identical to the regular @code{defun} form, except that "
"@var{arglist} is allowed to be a full Common Lisp argument list.  Also, the "
"function body is enclosed in an implicit block called @var{name}; "
"@pxref{Blocks and Exits}."
msgstr ""

#. type: defmac
#: ../../cl.texi:305
#, no-wrap
msgid "cl-iter-defun name arglist body@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:310
msgid ""
"This form is identical to the regular @code{iter-defun} form, except that "
"@var{arglist} is allowed to be a full Common Lisp argument list.  Also, the "
"function body is enclosed in an implicit block called @var{name}; "
"@pxref{Blocks and Exits}."
msgstr ""

#. type: defmac
#: ../../cl.texi:312
#, no-wrap
msgid "cl-defsubst name arglist body@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:324
msgid ""
"This is just like @code{cl-defun}, except that the function that is defined "
"is automatically proclaimed @code{inline}, i.e., calls to it may be expanded "
"into in-line code by the byte compiler.  This is analogous to the "
"@code{defsubst} form; @code{cl-defsubst} uses a different method (compiler "
"macros) which works in all versions of Emacs, and also generates somewhat "
"more efficient inline expansions.  In particular, @code{cl-defsubst} "
"arranges for the processing of keyword arguments, default values, etc., to "
"be done at compile-time whenever possible."
msgstr ""

#. type: cindex
#: ../../cl.texi:326 ../../cl.texi:442
#, no-wrap
msgid "&allow-other-keys"
msgstr ""

#. type: defmac
#: ../../cl.texi:327
#, no-wrap
msgid "cl-defmacro name arglist body@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:337
msgid ""
"This is identical to the regular @code{defmacro} form, except that "
"@var{arglist} is allowed to be a full Common Lisp argument list.  The "
"@code{&environment} keyword is supported as described in Steele's book "
"@cite{Common Lisp, the Language}.  The @code{&whole} keyword is supported "
"only within destructured lists (see below); top-level @code{&whole} cannot "
"be implemented with the current Emacs Lisp interpreter.  The macro expander "
"body is enclosed in an implicit block called @var{name}."
msgstr ""

#. type: defmac
#: ../../cl.texi:339
#, no-wrap
msgid "cl-function symbol-or-lambda"
msgstr ""

#. type: defmac
#: ../../cl.texi:343
msgid ""
"This is identical to the regular @code{function} form, except that if the "
"argument is a @code{lambda} form then that form may use a full Common Lisp "
"argument list."
msgstr ""

#. type: Plain text
#: ../../cl.texi:348
msgid ""
"Also, all forms (such as @code{cl-flet} and @code{cl-labels}) defined in "
"this package that include @var{arglist}s in their syntax allow full Common "
"Lisp argument lists."
msgstr ""

#. type: Plain text
#: ../../cl.texi:354
msgid ""
"Note that it is @emph{not} necessary to use @code{cl-defun} in order to have "
"access to most CL features in your function.  These features are always "
"present; @code{cl-defun}'s only difference from @code{defun} is its more "
"flexible argument lists and its implicit block."
msgstr ""

#. type: Plain text
#: ../../cl.texi:356
msgid "The full form of a Common Lisp argument list is"
msgstr ""

#. type: example
#: ../../cl.texi:363
#, no-wrap
msgid ""
"(@var{var}@dots{}\n"
" &optional (@var{var} @var{initform} @var{svar})@dots{}\n"
" &rest @var{var}\n"
" &key ((@var{keyword} @var{var}) @var{initform} @var{svar})@dots{}\n"
" &aux (@var{var} @var{initform})@dots{})\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:368
msgid ""
"Each of the five argument list sections is optional.  The @var{svar}, "
"@var{initform}, and @var{keyword} parts are optional; if they are omitted, "
"then @samp{(@var{var})} may be written simply @samp{@var{var}}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:373
msgid ""
"The first section consists of zero or more @dfn{required} arguments.  These "
"arguments must always be specified in a call to the function; there is no "
"difference between Emacs Lisp and Common Lisp as far as required arguments "
"are concerned."
msgstr ""

#. type: Plain text
#: ../../cl.texi:387
msgid ""
"The second section consists of @dfn{optional} arguments.  These arguments "
"may be specified in the function call; if they are not, @var{initform} "
"specifies the default value used for the argument.  (No @var{initform} means "
"to use @code{nil} as the default.)  The @var{initform} is evaluated with the "
"bindings for the preceding arguments already established; @code{(a &optional "
"(b (1+ a)))} matches one or two arguments, with the second argument "
"defaulting to one plus the first argument.  If the @var{svar} is specified, "
"it is an auxiliary variable which is bound to @code{t} if the optional "
"argument was specified, or to @code{nil} if the argument was omitted.  If "
"you don't use an @var{svar}, then there will be no way for your function to "
"tell whether it was called with no argument, or with the default value "
"passed explicitly as an argument."
msgstr ""

#. type: Plain text
#: ../../cl.texi:395
msgid ""
"The third section consists of a single @dfn{rest} argument.  If more "
"arguments were passed to the function than are accounted for by the required "
"and optional arguments, those extra arguments are collected into a list and "
"bound to the ``rest'' argument variable.  Common Lisp's @code{&rest} is "
"equivalent to that of Emacs Lisp.  Common Lisp accepts @code{&body} as a "
"synonym for @code{&rest} in macro contexts; this package accepts it all the "
"time."
msgstr ""

#. type: Plain text
#: ../../cl.texi:399
msgid ""
"The fourth section consists of @dfn{keyword} arguments.  These are optional "
"arguments which are specified by name rather than positionally in the "
"argument list.  For example,"
msgstr ""

#. type: example
#: ../../cl.texi:402
#, no-wrap
msgid "(cl-defun foo (a &optional b &key c d (e 17)))\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:413
msgid ""
"defines a function which may be called with one, two, or more arguments.  "
"The first two arguments are bound to @code{a} and @code{b} in the usual "
"way.  The remaining arguments must be pairs of the form @code{:c}, "
"@code{:d}, or @code{:e} followed by the value to be bound to the "
"corresponding argument variable.  (Symbols whose names begin with a colon "
"are called @dfn{keywords}, and they are self-quoting in the same way as "
"@code{nil} and @code{t}.)"
msgstr ""

#. type: Plain text
#: ../../cl.texi:422
msgid ""
"For example, the call @code{(foo 1 2 :d 3 :c 4)} sets the five arguments to "
"1, 2, 4, 3, and 17, respectively.  If the same keyword appears more than "
"once in the function call, the first occurrence takes precedence over the "
"later ones.  Note that it is not possible to specify keyword arguments "
"without specifying the optional argument @code{b} as well, since @code{(foo "
"1 :c 2)} would bind @code{b} to the keyword @code{:c}, then signal an error "
"because @code{2} is not a valid keyword."
msgstr ""

#. type: Plain text
#: ../../cl.texi:425
msgid ""
"You can also explicitly specify the keyword argument; it need not be simply "
"the variable name prefixed with a colon.  For example,"
msgstr ""

#. type: example
#: ../../cl.texi:428
#, no-wrap
msgid "(cl-defun bar (&key (a 1) ((baz b) 4)))\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:437
msgid ""
"specifies a keyword @code{:a} that sets the variable @code{a} with default "
"value 1, as well as a keyword @code{baz} that sets the variable @code{b} "
"with default value 4.  In this case, because @code{baz} is not self-quoting, "
"you must quote it explicitly in the function call, like this:"
msgstr ""

#. type: example
#: ../../cl.texi:440
#, no-wrap
msgid "(bar :a 10 'baz 42)\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:452
msgid ""
"Ordinarily, it is an error to pass an unrecognized keyword to a function, "
"e.g., @code{(foo 1 2 :c 3 :goober 4)}.  You can ask Lisp to ignore "
"unrecognized keywords, either by adding the marker @code{&allow-other-keys} "
"after the keyword section of the argument list, or by specifying an "
"@code{:allow-other-keys} argument in the call whose value is "
"non-@code{nil}.  If the function uses both @code{&rest} and @code{&key} at "
"the same time, the ``rest'' argument is bound to the keyword list as it "
"appears in the call.  For example:"
msgstr ""

#. type: example
#: ../../cl.texi:457
#, no-wrap
msgid ""
"(cl-defun find-thing (thing &rest rest &key need &allow-other-keys)\n"
"  (or (apply 'cl-member thing thing-list :allow-other-keys t rest)\n"
"      (if need (error \"Thing not found\"))))\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:465
msgid ""
"This function takes a @code{:need} keyword argument, but also accepts other "
"keyword arguments which are passed on to the @code{cl-member} function.  "
"@code{allow-other-keys} is used to keep both @code{find-thing} and "
"@code{cl-member} from complaining about each others' keywords in the "
"arguments."
msgstr ""

#. type: Plain text
#: ../../cl.texi:472
msgid ""
"The fifth section of the argument list consists of @dfn{auxiliary "
"variables}.  These are not really arguments at all, but simply variables "
"which are bound to @code{nil} or to the specified @var{initforms} during "
"execution of the function.  There is no difference between the following two "
"functions, except for a matter of stylistic taste:"
msgstr ""

#. type: example
#: ../../cl.texi:476
#, no-wrap
msgid ""
"(cl-defun foo (a b &aux (c (+ a b)) d)\n"
"  @var{body})\n"
"\n"
msgstr ""

#. type: example
#: ../../cl.texi:480
#, no-wrap
msgid ""
"(cl-defun foo (a b)\n"
"  (let ((c (+ a b)) d)\n"
"    @var{body}))\n"
msgstr ""

#. type: cindex
#: ../../cl.texi:482
#, no-wrap
msgid "destructuring, in argument list"
msgstr ""

#. type: Plain text
#: ../../cl.texi:491
msgid ""
"Argument lists support @dfn{destructuring}.  In Common Lisp, destructuring "
"is only allowed with @code{defmacro}; this package allows it with "
"@code{cl-defun} and other argument lists as well.  In destructuring, any "
"argument variable (@var{var} in the above example) can be replaced by a list "
"of variables, or more generally, a recursive argument list.  The "
"corresponding argument value must be a list whose elements match this "
"recursive argument list.  For example:"
msgstr ""

#. type: example
#: ../../cl.texi:496
#, no-wrap
msgid ""
"(cl-defmacro dolist ((var listform &optional resultform)\n"
"                   &rest body)\n"
"  @dots{})\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:510
msgid ""
"This says that the first argument of @code{dolist} must be a list of two or "
"three items; if there are other arguments as well as this list, they are "
"stored in @code{body}.  All features allowed in regular argument lists are "
"allowed in these recursive argument lists.  In addition, the clause "
"@samp{&whole @var{var}} is allowed at the front of a recursive argument "
"list.  It binds @var{var} to the whole list being matched; thus "
"@code{(&whole all a b)} matches a list of two things, with @code{a} bound to "
"the first thing, @code{b} bound to the second thing, and @code{all} bound to "
"the list itself.  (Common Lisp allows @code{&whole} in top-level "
"@code{defmacro} argument lists as well, but Emacs Lisp does not support this "
"usage.)"
msgstr ""

#. type: Plain text
#: ../../cl.texi:514
msgid ""
"One last feature of destructuring is that the argument list may be dotted, "
"so that the argument list @code{(a b . c)} is functionally equivalent to "
"@code{(a b &rest c)}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:519
msgid ""
"If the optimization quality @code{safety} is set to 0 "
"(@pxref{Declarations}), error checking for wrong number of arguments and "
"invalid keyword arguments is disabled.  By default, argument lists are "
"rigorously checked."
msgstr ""

#. type: Plain text
#: ../../cl.texi:533
msgid ""
"Normally, the byte-compiler does not actually execute the forms in a file it "
"compiles.  For example, if a file contains @code{(setq foo t)}, the act of "
"compiling it will not actually set @code{foo} to @code{t}.  This is true "
"even if the @code{setq} was a top-level form (i.e., not enclosed in a "
"@code{defun} or other form).  Sometimes, though, you would like to have "
"certain top-level forms evaluated at compile-time.  For example, the "
"compiler effectively evaluates @code{defmacro} forms at compile-time so that "
"later parts of the file can refer to the macros that are defined."
msgstr ""

#. type: defmac
#: ../../cl.texi:534
#, no-wrap
msgid "cl-eval-when (situations@dots{}) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:540
msgid ""
"This form controls when the body @var{forms} are evaluated.  The "
"@var{situations} list may contain any set of the symbols @code{compile}, "
"@code{load}, and @code{eval} (or their long-winded ANSI equivalents, "
"@code{:compile-toplevel}, @code{:load-toplevel}, and @code{:execute})."
msgstr ""

#. type: defmac
#: ../../cl.texi:547
msgid ""
"The @code{cl-eval-when} form is handled differently depending on whether or "
"not it is being compiled as a top-level form.  Specifically, it gets special "
"treatment if it is being compiled by a command such as "
"@code{byte-compile-file} which compiles files or buffers of code, and it "
"appears either literally at the top level of the file or inside a top-level "
"@code{progn}."
msgstr ""

#. type: defmac
#: ../../cl.texi:552
msgid ""
"For compiled top-level @code{cl-eval-when}s, the body @var{forms} are "
"executed at compile-time if @code{compile} is in the @var{situations} list, "
"and the @var{forms} are written out to the file (to be executed at "
"load-time) if @code{load} is in the @var{situations} list."
msgstr ""

#. type: defmac
#: ../../cl.texi:559
msgid ""
"For non-compiled-top-level forms, only the @code{eval} situation is "
"relevant.  (This includes forms executed by the interpreter, forms compiled "
"with @code{byte-compile} rather than @code{byte-compile-file}, and "
"non-top-level forms.)  The @code{cl-eval-when} acts like a @code{progn} if "
"@code{eval} is specified, and like @code{nil} (ignoring the body "
"@var{forms}) if not."
msgstr ""

#. type: defmac
#: ../../cl.texi:563
msgid ""
"The rules become more subtle when @code{cl-eval-when}s are nested; consult "
"Steele (second edition) for the gruesome details (and some gruesome "
"examples)."
msgstr ""

#. type: defmac
#: ../../cl.texi:565
msgid "Some simple examples:"
msgstr ""

#. type: example
#: ../../cl.texi:575
#, no-wrap
msgid ""
";; Top-level forms in foo.el:\n"
"(cl-eval-when (compile)           (setq foo1 'bar))\n"
"(cl-eval-when (load)              (setq foo2 'bar))\n"
"(cl-eval-when (compile load)      (setq foo3 'bar))\n"
"(cl-eval-when (eval)              (setq foo4 'bar))\n"
"(cl-eval-when (eval compile)      (setq foo5 'bar))\n"
"(cl-eval-when (eval load)         (setq foo6 'bar))\n"
"(cl-eval-when (eval compile load) (setq foo7 'bar))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:579
msgid ""
"When @file{foo.el} is compiled, these variables will be set during the "
"compilation itself:"
msgstr ""

#. type: example
#: ../../cl.texi:582
#, no-wrap
msgid "foo1  foo3  foo5  foo7      ; 'compile'\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:585
msgid "When @file{foo.elc} is loaded, these variables will be set:"
msgstr ""

#. type: example
#: ../../cl.texi:588
#, no-wrap
msgid "foo2  foo3  foo6  foo7      ; 'load'\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:592
msgid "And if @file{foo.el} is loaded uncompiled, these variables will be set:"
msgstr ""

#. type: example
#: ../../cl.texi:595
#, no-wrap
msgid "foo4  foo5  foo6  foo7      ; 'eval'\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:600
msgid ""
"If these seven @code{cl-eval-when}s had been, say, inside a @code{defun}, "
"then the first three would have been equivalent to @code{nil} and the last "
"four would have been equivalent to the corresponding @code{setq}s."
msgstr ""

#. type: defmac
#: ../../cl.texi:606
msgid ""
"Note that @code{(cl-eval-when (load eval) @dots{})} is equivalent to "
"@code{(progn @dots{})} in all contexts.  The compiler treats certain "
"top-level forms, like @code{defmacro} (sort-of) and @code{require}, as if "
"they were wrapped in @code{(cl-eval-when (compile load eval) @dots{})}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:612
msgid ""
"Emacs includes two special forms related to @code{cl-eval-when}.  @xref{Eval "
"During Compile,,,elisp,GNU Emacs Lisp Reference Manual}.  One of these, "
"@code{eval-when-compile}, is not quite equivalent to any @code{cl-eval-when} "
"construct and is described below."
msgstr ""

#. type: Plain text
#: ../../cl.texi:615
msgid ""
"The other form, @code{(eval-and-compile @dots{})}, is exactly equivalent to "
"@samp{(cl-eval-when (compile load eval) @dots{})}."
msgstr ""

#. type: defmac
#: ../../cl.texi:616
#, no-wrap
msgid "eval-when-compile forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:623
msgid ""
"The @var{forms} are evaluated at compile-time; at execution time, this form "
"acts like a quoted constant of the resulting value.  Used at top-level, "
"@code{eval-when-compile} is just like @samp{eval-when (compile eval)}.  In "
"other contexts, @code{eval-when-compile} allows code to be evaluated once at "
"compile-time for efficiency or other reasons."
msgstr ""

#. type: defmac
#: ../../cl.texi:625
msgid "This form is similar to the @samp{#.} syntax of true Common Lisp."
msgstr ""

#. type: defmac
#: ../../cl.texi:627
#, no-wrap
msgid "cl-load-time-value form"
msgstr ""

#. type: defmac
#: ../../cl.texi:630
msgid ""
"The @var{form} is evaluated at load-time; at execution time, this form acts "
"like a quoted constant of the resulting value."
msgstr ""

#. type: defmac
#: ../../cl.texi:634
msgid ""
"Early Common Lisp had a @samp{#,} syntax that was similar to this, but ANSI "
"Common Lisp replaced it with @code{load-time-value} and gave it more "
"well-defined semantics."
msgstr ""

#. type: defmac
#: ../../cl.texi:642
msgid ""
"In a compiled file, @code{cl-load-time-value} arranges for @var{form} to be "
"evaluated when the @file{.elc} file is loaded and then used as if it were a "
"quoted constant.  In code compiled by @code{byte-compile} rather than "
"@code{byte-compile-file}, the effect is identical to "
"@code{eval-when-compile}.  In uncompiled code, both @code{eval-when-compile} "
"and @code{cl-load-time-value} act exactly like @code{progn}."
msgstr ""

#. type: example
#: ../../cl.texi:652
#, no-wrap
msgid ""
"(defun report ()\n"
"  (insert \"This function was executed on: \"\n"
"          (current-time-string)\n"
"          \", compiled on: \"\n"
"          (eval-when-compile (current-time-string))\n"
"          ;; or '#.(current-time-string) in real Common Lisp\n"
"          \", and loaded on: \"\n"
"          (cl-load-time-value (current-time-string))))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:657
msgid ""
"Byte-compiled, the above defun will result in the following code (or its "
"compiled equivalent, of course) in the @file{.elc} file:"
msgstr ""

#. type: example
#: ../../cl.texi:667
#, no-wrap
msgid ""
"(setq --temp-- (current-time-string))\n"
"(defun report ()\n"
"  (insert \"This function was executed on: \"\n"
"          (current-time-string)\n"
"          \", compiled on: \"\n"
"          '\"Wed Oct 31 16:32:28 2012\"\n"
"          \", and loaded on: \"\n"
"          --temp--))\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:676
msgid ""
"This section describes functions for testing whether various facts are true "
"or false."
msgstr ""

#. type: section
#: ../../cl.texi:680 ../../cl.texi:682 ../../cl.texi:683
#, no-wrap
msgid "Type Predicates"
msgstr ""

#. type: menuentry
#: ../../cl.texi:680
msgid "@code{cl-typep}, @code{cl-deftype}, and @code{cl-coerce}."
msgstr ""

#. type: section
#: ../../cl.texi:680 ../../cl.texi:806 ../../cl.texi:807
#, no-wrap
msgid "Equality Predicates"
msgstr ""

#. type: menuentry
#: ../../cl.texi:680
msgid "@code{cl-equalp}."
msgstr ""

#. type: defun
#: ../../cl.texi:685
#, no-wrap
msgid "cl-typep object type"
msgstr ""

#. type: defun
#: ../../cl.texi:689
msgid ""
"Check if @var{object} is of type @var{type}, where @var{type} is a (quoted) "
"type name of the sort used by Common Lisp.  For example, @code{(cl-typep foo "
"'integer)} is equivalent to @code{(integerp foo)}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:693
msgid ""
"The @var{type} argument to the above function is either a symbol or a list "
"beginning with a symbol."
msgstr ""

#. type: itemize
#: ../../cl.texi:700
msgid ""
"If the type name is a symbol, Emacs appends @samp{-p} to the symbol name to "
"form the name of a predicate function for testing the type.  (Built-in "
"predicates whose names end in @samp{p} rather than @samp{-p} are used when "
"appropriate.)"
msgstr ""

#. type: itemize
#: ../../cl.texi:706
msgid ""
"The type symbol @code{t} stands for the union of all types.  @code{(cl-typep "
"@var{object} t)} is always true.  Likewise, the type symbol @code{nil} "
"stands for nothing at all, and @code{(cl-typep @var{object} nil)} is always "
"false."
msgstr ""

#. type: itemize
#: ../../cl.texi:711
msgid ""
"The type symbol @code{null} represents the symbol @code{nil}.  Thus "
"@code{(cl-typep @var{object} 'null)} is equivalent to @code{(null "
"@var{object})}."
msgstr ""

#. type: itemize
#: ../../cl.texi:716
msgid ""
"The type symbol @code{atom} represents all objects that are not cons "
"cells. Thus @code{(cl-typep @var{object} 'atom)} is equivalent to "
"@code{(atom @var{object})}."
msgstr ""

#. type: itemize
#: ../../cl.texi:720
msgid ""
"The type symbol @code{real} is a synonym for @code{number}, and "
"@code{fixnum} is a synonym for @code{integer}."
msgstr ""

#. type: itemize
#: ../../cl.texi:724
msgid ""
"The type symbols @code{character} and @code{string-char} match integers in "
"the range from 0 to 255."
msgstr ""

#. type: itemize
#: ../../cl.texi:731
msgid ""
"The type list @code{(integer @var{low} @var{high})} represents all integers "
"between @var{low} and @var{high}, inclusive.  Either bound may be a list of "
"a single integer to specify an exclusive limit, or a @code{*} to specify no "
"limit.  The type @code{(integer * *)} is thus equivalent to @code{integer}."
msgstr ""

#. type: itemize
#: ../../cl.texi:736
msgid ""
"Likewise, lists beginning with @code{float}, @code{real}, or @code{number} "
"represent numbers of that type falling in a particular range."
msgstr ""

#. type: itemize
#: ../../cl.texi:741
msgid ""
"Lists beginning with @code{and}, @code{or}, and @code{not} form combinations "
"of types.  For example, @code{(or integer (float 0 *))} represents all "
"objects that are integers or non-negative floats."
msgstr ""

#. type: itemize
#: ../../cl.texi:747
msgid ""
"Lists beginning with @code{member} or @code{cl-member} represent objects "
"@code{eql} to any of the following values.  For example, @code{(member 1 2 3 "
"4)} is equivalent to @code{(integer 1 4)}, and @code{(member nil)} is "
"equivalent to @code{null}."
msgstr ""

#. type: itemize
#: ../../cl.texi:752
msgid ""
"Lists of the form @code{(satisfies @var{predicate})} represent all objects "
"for which @var{predicate} returns true when called with that object as an "
"argument."
msgstr ""

#. type: Plain text
#: ../../cl.texi:756
msgid ""
"The following function and macro (not technically predicates) are related to "
"@code{cl-typep}."
msgstr ""

#. type: defun
#: ../../cl.texi:757
#, no-wrap
msgid "cl-coerce object type"
msgstr ""

#. type: defun
#: ../../cl.texi:769
msgid ""
"This function attempts to convert @var{object} to the specified @var{type}.  "
"If @var{object} is already of that type as determined by @code{cl-typep}, it "
"is simply returned.  Otherwise, certain types of conversions will be made: "
"If @var{type} is any sequence type (@code{string}, @code{list}, etc.)@: then "
"@var{object} will be converted to that type if possible.  If @var{type} is "
"@code{character}, then strings of length one and symbols with one-character "
"names can be coerced.  If @var{type} is @code{float}, then integers can be "
"coerced in versions of Emacs that support floats.  In all other "
"circumstances, @code{cl-coerce} signals an error."
msgstr ""

#. type: defmac
#: ../../cl.texi:771
#, no-wrap
msgid "cl-deftype name arglist forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:784
msgid ""
"This macro defines a new type called @var{name}.  It is similar to "
"@code{defmacro} in many ways; when @var{name} is encountered as a type name, "
"the body @var{forms} are evaluated and should return a type specifier that "
"is equivalent to the type.  The @var{arglist} is a Common Lisp argument list "
"of the sort accepted by @code{cl-defmacro}.  The type specifier "
"@samp{(@var{name} @var{args}@dots{})} is expanded by calling the expander "
"with those arguments; the type symbol @samp{@var{name}} is expanded by "
"calling the expander with no arguments.  The @var{arglist} is processed the "
"same as for @code{cl-defmacro} except that optional arguments without "
"explicit defaults use @code{*} instead of @code{nil} as the ``default'' "
"default.  Some examples:"
msgstr ""

#. type: example
#: ../../cl.texi:793
#, no-wrap
msgid ""
"(cl-deftype null () '(satisfies null))    ; predefined\n"
"(cl-deftype list () '(or null cons))      ; predefined\n"
"(cl-deftype unsigned-byte (&optional bits)\n"
"  (list 'integer 0 (if (eq bits '*) bits (1- (ash 1 bits)))))\n"
"(unsigned-byte 8)  @equiv{}  (integer 0 255)\n"
"(unsigned-byte)  @equiv{}  (integer 0 *)\n"
"unsigned-byte  @equiv{}  (integer 0 *)\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:799
msgid ""
"The last example shows how the Common Lisp @code{unsigned-byte} type "
"specifier could be implemented if desired; this package does not implement "
"@code{unsigned-byte} by default."
msgstr ""

#. type: Plain text
#: ../../cl.texi:805
msgid ""
"The @code{cl-typecase} (@pxref{Conditionals}) and @code{cl-check-type} "
"(@pxref{Assertions}) macros also use type names.  The @code{cl-map}, "
"@code{cl-concatenate}, and @code{cl-merge} functions take type-name "
"arguments to specify the type of sequence to return.  @xref{Sequences}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:811
msgid "This package defines the Common Lisp predicate @code{cl-equalp}."
msgstr ""

#. type: defun
#: ../../cl.texi:812
#, no-wrap
msgid "cl-equalp a b"
msgstr ""

#. type: defun
#: ../../cl.texi:818
msgid ""
"This function is a more flexible version of @code{equal}.  In particular, it "
"compares strings case-insensitively, and it compares numbers without regard "
"to type (so that @code{(cl-equalp 3 3.0)} is true).  Vectors and conses are "
"compared recursively.  All other objects are compared as if by @code{equal}."
msgstr ""

#. type: defun
#: ../../cl.texi:826
msgid ""
"This function differs from Common Lisp @code{equalp} in several respects.  "
"First, Common Lisp's @code{equalp} also compares @emph{characters} "
"case-insensitively, which would be impractical in this package since Emacs "
"does not distinguish between integers and characters.  In keeping with the "
"idea that strings are less vector-like in Emacs Lisp, this package's "
"@code{cl-equalp} also will not compare strings against vectors of integers."
msgstr ""

#. type: Plain text
#: ../../cl.texi:834
msgid ""
"Also note that the Common Lisp functions @code{member} and @code{assoc} use "
"@code{eql} to compare elements, whereas Emacs Lisp follows the MacLisp "
"tradition and uses @code{equal} for these two functions.  The functions "
"@code{cl-member} and @code{cl-assoc} use @code{eql}, as in Common Lisp.  The "
"standard Emacs Lisp functions @code{memq} and @code{assq} use @code{eq}, and "
"the standard @code{memql} uses @code{eql}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:843
msgid ""
"The features described in the following sections implement various advanced "
"control structures, including extensions to the standard @code{setf} "
"facility, and a number of looping and conditional constructs."
msgstr ""

#. type: section
#: ../../cl.texi:853 ../../cl.texi:855 ../../cl.texi:856
#, no-wrap
msgid "Assignment"
msgstr ""

#. type: menuentry
#: ../../cl.texi:853
msgid "The @code{cl-psetq} form."
msgstr ""

#. type: section
#: ../../cl.texi:853 ../../cl.texi:892 ../../cl.texi:893
#, no-wrap
msgid "Generalized Variables"
msgstr ""

#. type: menuentry
#: ../../cl.texi:853
msgid "Extensions to generalized variables."
msgstr ""

#. type: section
#: ../../cl.texi:853 ../../cl.texi:1257 ../../cl.texi:1258
#, no-wrap
msgid "Variable Bindings"
msgstr ""

#. type: menuentry
#: ../../cl.texi:853
msgid "@code{cl-progv}, @code{cl-flet}, @code{cl-macrolet}."
msgstr ""

#. type: section
#: ../../cl.texi:853 ../../cl.texi:1441 ../../cl.texi:1442
#, no-wrap
msgid "Conditionals"
msgstr ""

#. type: menuentry
#: ../../cl.texi:853
msgid "@code{cl-case}, @code{cl-typecase}."
msgstr ""

#. type: section
#: ../../cl.texi:853 ../../cl.texi:1516 ../../cl.texi:1517
#, no-wrap
msgid "Blocks and Exits"
msgstr ""

#. type: menuentry
#: ../../cl.texi:853
msgid "@code{cl-block}, @code{cl-return}, @code{cl-return-from}."
msgstr ""

#. type: section
#: ../../cl.texi:853 ../../cl.texi:1597 ../../cl.texi:1598
#, no-wrap
msgid "Iteration"
msgstr ""

#. type: menuentry
#: ../../cl.texi:853
msgid "@code{cl-do}, @code{cl-dotimes}, @code{cl-dolist}, @code{cl-do-symbols}."
msgstr ""

#. type: section
#: ../../cl.texi:853 ../../cl.texi:1738 ../../cl.texi:1739
#, no-wrap
msgid "Loop Facility"
msgstr ""

#. type: menuentry
#: ../../cl.texi:853
msgid "The Common Lisp @code{loop} macro."
msgstr ""

#. type: section
#: ../../cl.texi:853 ../../cl.texi:2481 ../../cl.texi:2482
#, no-wrap
msgid "Multiple Values"
msgstr ""

#. type: menuentry
#: ../../cl.texi:853
msgid "@code{cl-values}, @code{cl-multiple-value-bind}, etc."
msgstr ""

#. type: Plain text
#: ../../cl.texi:861
msgid ""
"The @code{cl-psetq} form is just like @code{setq}, except that multiple "
"assignments are done in parallel rather than sequentially."
msgstr ""

#. type: defmac
#: ../../cl.texi:862
#, no-wrap
msgid "cl-psetq [symbol form]@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:868
msgid ""
"This special form (actually a macro) is used to assign to several variables "
"simultaneously.  Given only one @var{symbol} and @var{form}, it has the same "
"effect as @code{setq}.  Given several @var{symbol} and @var{form} pairs, it "
"evaluates all the @var{form}s in advance and then stores the corresponding "
"variables afterwards."
msgstr ""

#. type: example
#: ../../cl.texi:882
#, no-wrap
msgid ""
"(setq x 2 y 3)\n"
"(setq x (+ x y)  y (* x y))\n"
"x\n"
"     @result{} 5\n"
"y                     ; @r{@code{y} was computed after @code{x} was set.}\n"
"     @result{} 15\n"
"(setq x 2 y 3)\n"
"(cl-psetq x (+ x y)  y (* x y))\n"
"x\n"
"     @result{} 5\n"
"y                     ; @r{@code{y} was computed before @code{x} was set.}\n"
"     @result{} 6\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:888
msgid ""
"The simplest use of @code{cl-psetq} is @code{(cl-psetq x y y x)}, which "
"exchanges the values of two variables.  (The @code{cl-rotatef} form provides "
"an even more convenient way to swap two variables; @pxref{Modify Macros}.)"
msgstr ""

#. type: defmac
#: ../../cl.texi:890
msgid "@code{cl-psetq} always returns @code{nil}."
msgstr ""

#. type: cindex
#: ../../cl.texi:894
#, no-wrap
msgid "generalized variable"
msgstr ""

#. type: Plain text
#: ../../cl.texi:904
msgid ""
"A @dfn{generalized variable} or @dfn{place form} is one of the many places "
"in Lisp memory where values can be stored.  The simplest place form is a "
"regular Lisp variable.  But the @sc{car}s and @sc{cdr}s of lists, elements "
"of arrays, properties of symbols, and many other locations are also places "
"where Lisp values are stored.  For basic information, @pxref{Generalized "
"Variables,,,elisp,GNU Emacs Lisp Reference Manual}.  This package provides "
"several additional features related to generalized variables."
msgstr ""

#. type: subsection
#: ../../cl.texi:908 ../../cl.texi:910 ../../cl.texi:911
#, no-wrap
msgid "Setf Extensions"
msgstr ""

#. type: menuentry
#: ../../cl.texi:908
msgid "Additional @code{setf} places."
msgstr ""

#. type: subsection
#: ../../cl.texi:908 ../../cl.texi:1043 ../../cl.texi:1044
#, no-wrap
msgid "Modify Macros"
msgstr ""

#. type: menuentry
#: ../../cl.texi:908
msgid "@code{cl-incf}, @code{cl-rotatef}, @code{cl-letf}, @code{cl-callf}, etc."
msgstr ""

#. type: Plain text
#: ../../cl.texi:916
msgid ""
"Several standard (e.g., @code{car}) and Emacs-specific (e.g., "
"@code{window-point}) Lisp functions are @code{setf}-able by default.  This "
"package defines @code{setf} handlers for several additional functions:"
msgstr ""

#. type: itemize
#: ../../cl.texi:920
msgid "Functions from this package:"
msgstr ""

#. type: example
#: ../../cl.texi:923
#, no-wrap
msgid ""
"cl-rest        cl-subseq      cl-get         cl-getf\n"
"cl-caaar@dots{}cl-cddddr          cl-first@dots{}cl-tenth\n"
msgstr ""

#. type: itemize
#: ../../cl.texi:928
msgid ""
"Note that for @code{cl-getf} (as for @code{nthcdr}), the list argument of "
"the function must itself be a valid @var{place} form."
msgstr ""

#. type: itemize
#: ../../cl.texi:931
msgid "General Emacs Lisp functions:"
msgstr ""

#. type: example
#: ../../cl.texi:957
#, no-wrap
msgid ""
"buffer-file-name                   getenv\n"
"buffer-modified-p                  global-key-binding\n"
"buffer-name                        local-key-binding\n"
"buffer-string                      mark\n"
"buffer-substring                   mark-marker\n"
"current-buffer                     marker-position\n"
"current-case-table                 mouse-position\n"
"current-column                     point\n"
"current-global-map                 point-marker\n"
"current-input-mode                 point-max\n"
"current-local-map                  point-min\n"
"current-window-configuration       read-mouse-position\n"
"default-file-modes                 screen-height\n"
"documentation-property             screen-width\n"
"face-background                    selected-window\n"
"face-background-pixmap             selected-screen\n"
"face-font                          selected-frame\n"
"face-foreground                    standard-case-table\n"
"face-underline-p                   syntax-table\n"
"file-modes                         visited-file-modtime\n"
"frame-height                       window-height\n"
"frame-parameters                   window-width\n"
"frame-visible-p                    x-get-secondary-selection\n"
"frame-width                        x-get-selection\n"
"get-register\n"
msgstr ""

#. type: itemize
#: ../../cl.texi:964
msgid ""
"Most of these have directly corresponding ``set'' functions, like "
"@code{use-local-map} for @code{current-local-map}, or @code{goto-char} for "
"@code{point}.  A few, like @code{point-min}, expand to longer sequences of "
"code when they are used with @code{setf} (@code{(narrow-to-region x "
"(point-max))} in this case)."
msgstr ""

#. type: itemize
#: ../../cl.texi:971
msgid ""
"A call of the form @code{(substring @var{subplace} @var{n} [@var{m}])}, "
"where @var{subplace} is itself a valid generalized variable whose current "
"value is a string, and where the value stored is also a string.  The new "
"string is spliced into the specified part of the destination string.  For "
"example:"
msgstr ""

#. type: example
#: ../../cl.texi:985
#, no-wrap
msgid ""
"(setq a (list \"hello\" \"world\"))\n"
"     @result{} (\"hello\" \"world\")\n"
"(cadr a)\n"
"     @result{} \"world\"\n"
"(substring (cadr a) 2 4)\n"
"     @result{} \"rl\"\n"
"(setf (substring (cadr a) 2 4) \"o\")\n"
"     @result{} \"o\"\n"
"(cadr a)\n"
"     @result{} \"wood\"\n"
"a\n"
"     @result{} (\"hello\" \"wood\")\n"
msgstr ""

#. type: itemize
#: ../../cl.texi:989
msgid ""
"The generalized variable @code{buffer-substring}, listed above, also works "
"in this way by replacing a portion of the current buffer."
msgstr ""

#. type: itemize
#: ../../cl.texi:1009
msgid ""
"A macro call, in which case the macro is expanded and @code{setf} is applied "
"to the resulting form."
msgstr ""

#. type: Plain text
#: ../../cl.texi:1016
msgid ""
"The @code{setf} macro takes care to evaluate all subforms in the proper "
"left-to-right order; for example,"
msgstr ""

#. type: example
#: ../../cl.texi:1019
#, no-wrap
msgid "(setf (aref vec (cl-incf i)) i)\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1029
msgid ""
"looks like it will evaluate @code{(cl-incf i)} exactly once, before the "
"following access to @code{i}; the @code{setf} expander will insert temporary "
"variables as necessary to ensure that it does in fact work this way no "
"matter what setf-method is defined for @code{aref}.  (In this case, "
"@code{aset} would be used and no such steps would be necessary since "
"@code{aset} takes its arguments in a convenient order.)"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1033
msgid ""
"However, if the @var{place} form is a macro which explicitly evaluates its "
"arguments in an unusual order, this unusual order will be preserved.  "
"Adapting an example from Steele, given"
msgstr ""

#. type: example
#: ../../cl.texi:1036
#, no-wrap
msgid "(defmacro wrong-order (x y) (list 'aref y x))\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1042
msgid ""
"the form @code{(setf (wrong-order @var{a} @var{b}) 17)} will evaluate "
"@var{b} first, then @var{a}, just as in an actual call to "
"@code{wrong-order}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:1050
msgid ""
"This package defines a number of macros that operate on generalized "
"variables.  Many are interesting and useful even when the @var{place} is "
"just a variable name."
msgstr ""

#. type: defmac
#: ../../cl.texi:1051
#, no-wrap
msgid "cl-psetf [place form]@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1057
msgid ""
"This macro is to @code{setf} what @code{cl-psetq} is to @code{setq}: When "
"several @var{place}s and @var{form}s are involved, the assignments take "
"place in parallel rather than sequentially.  Specifically, all subforms are "
"evaluated from left to right, then all the assignments are done (in an "
"undefined order)."
msgstr ""

#. type: defmac
#: ../../cl.texi:1059
#, no-wrap
msgid "cl-incf place &optional x"
msgstr ""

#. type: defmac
#: ../../cl.texi:1064
msgid ""
"This macro increments the number stored in @var{place} by one, or by @var{x} "
"if specified.  The incremented value is returned.  For example, "
"@code{(cl-incf i)} is equivalent to @code{(setq i (1+ i))}, and "
"@code{(cl-incf (car x) 2)} is equivalent to @code{(setcar x (+ (car x) 2))}."
msgstr ""

#. type: defmac
#: ../../cl.texi:1067
msgid ""
"As with @code{setf}, care is taken to preserve the ``apparent'' order of "
"evaluation.  For example,"
msgstr ""

#. type: example
#: ../../cl.texi:1070
#, no-wrap
msgid "(cl-incf (aref vec (cl-incf i)))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1077
msgid ""
"appears to increment @code{i} once, then increment the element of @code{vec} "
"addressed by @code{i}; this is indeed exactly what it does, which means the "
"above form is @emph{not} equivalent to the ``obvious'' expansion,"
msgstr ""

#. type: example
#: ../../cl.texi:1081
#, no-wrap
msgid ""
"(setf (aref vec (cl-incf i))\n"
"      (1+ (aref vec (cl-incf i))))   ; wrong!\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1085
msgid "but rather to something more like"
msgstr ""

#. type: example
#: ../../cl.texi:1089
#, no-wrap
msgid ""
"(let ((temp (cl-incf i)))\n"
"  (setf (aref vec temp) (1+ (aref vec temp))))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1094
msgid ""
"Again, all of this is taken care of automatically by @code{cl-incf} and the "
"other generalized-variable macros."
msgstr ""

#. type: defmac
#: ../../cl.texi:1098
msgid ""
"As a more Emacs-specific example of @code{cl-incf}, the expression "
"@code{(cl-incf (point) @var{n})} is essentially equivalent to "
"@code{(forward-char @var{n})}."
msgstr ""

#. type: defmac
#: ../../cl.texi:1100
#, no-wrap
msgid "cl-decf place &optional x"
msgstr ""

#. type: defmac
#: ../../cl.texi:1103
msgid ""
"This macro decrements the number stored in @var{place} by one, or by @var{x} "
"if specified."
msgstr ""

#. type: defmac
#: ../../cl.texi:1105
#, no-wrap
msgid "cl-pushnew x place @t{&key :test :test-not :key}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1111
msgid ""
"This macro inserts @var{x} at the front of the list stored in @var{place}, "
"but only if @var{x} was not @code{eql} to any existing element of the list.  "
"The optional keyword arguments are interpreted in the same way as for "
"@code{cl-adjoin}.  @xref{Lists as Sets}."
msgstr ""

#. type: defmac
#: ../../cl.texi:1113
#, no-wrap
msgid "cl-shiftf place@dots{} newvalue"
msgstr ""

#. type: defmac
#: ../../cl.texi:1119
msgid ""
"This macro shifts the @var{place}s left by one, shifting in the value of "
"@var{newvalue} (which may be any Lisp expression, not just a generalized "
"variable), and returning the value shifted out of the first @var{place}.  "
"Thus, @code{(cl-shiftf @var{a} @var{b} @var{c} @var{d})} is equivalent to"
msgstr ""

#. type: example
#: ../../cl.texi:1126
#, no-wrap
msgid ""
"(prog1\n"
"    @var{a}\n"
"  (cl-psetf @var{a} @var{b}\n"
"            @var{b} @var{c}\n"
"            @var{c} @var{d}))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1131
msgid ""
"except that the subforms of @var{a}, @var{b}, and @var{c} are actually "
"evaluated only once each and in the apparent order."
msgstr ""

#. type: defmac
#: ../../cl.texi:1133
#, no-wrap
msgid "cl-rotatef place@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1136
msgid ""
"This macro rotates the @var{place}s left by one in circular fashion.  Thus, "
"@code{(cl-rotatef @var{a} @var{b} @var{c} @var{d})} is equivalent to"
msgstr ""

#. type: example
#: ../../cl.texi:1142
#, no-wrap
msgid ""
"(cl-psetf @var{a} @var{b}\n"
"          @var{b} @var{c}\n"
"          @var{c} @var{d}\n"
"          @var{d} @var{a})\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1148
msgid ""
"except for the evaluation of subforms.  @code{cl-rotatef} always returns "
"@code{nil}.  Note that @code{(cl-rotatef @var{a} @var{b})} conveniently "
"exchanges @var{a} and @var{b}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:1152
msgid ""
"The following macros were invented for this package; they have no analogues "
"in Common Lisp."
msgstr ""

#. type: defmac
#: ../../cl.texi:1153
#, no-wrap
msgid "cl-letf (bindings@dots{}) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1162
msgid ""
"This macro is analogous to @code{let}, but for generalized variables rather "
"than just symbols.  Each @var{binding} should be of the form "
"@code{(@var{place} @var{value})}; the original contents of the @var{place}s "
"are saved, the @var{value}s are stored in them, and then the body "
"@var{form}s are executed.  Afterwards, the @var{places} are set back to "
"their original saved contents.  This cleanup happens even if the @var{form}s "
"exit irregularly due to a @code{throw} or an error."
msgstr ""

#. type: defmac
#: ../../cl.texi:1164
msgid "For example,"
msgstr ""

#. type: example
#: ../../cl.texi:1169
#, no-wrap
msgid ""
"(cl-letf (((point) (point-min))\n"
"          (a 17))\n"
"     @dots{})\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1177
msgid ""
"moves point in the current buffer to the beginning of the buffer, and also "
"binds @code{a} to 17 (as if by a normal @code{let}, since @code{a} is just a "
"regular variable).  After the body exits, @code{a} is set back to its "
"original value and point is moved back to its original position."
msgstr ""

#. type: defmac
#: ../../cl.texi:1185
msgid ""
"Note that @code{cl-letf} on @code{(point)} is not quite like a "
"@code{save-excursion}, as the latter effectively saves a marker which tracks "
"insertions and deletions in the buffer.  Actually, a @code{cl-letf} of "
"@code{(point-marker)} is much closer to this behavior.  (@code{point} and "
"@code{point-marker} are equivalent as @code{setf} places; each will accept "
"either an integer or a marker as the stored value.)"
msgstr ""

#. type: defmac
#: ../../cl.texi:1190
msgid ""
"Like in the case of @code{let}, the @var{value} forms are evaluated in the "
"order they appear, but the order of bindings is unspecified.  Therefore, "
"avoid binding the same @var{place} more than once in a single @code{cl-letf} "
"form."
msgstr ""

#. type: defmac
#: ../../cl.texi:1194
msgid ""
"Since generalized variables look like lists, @code{let}'s shorthand of using "
"@samp{foo} for @samp{(foo nil)} as a @var{binding} would be ambiguous in "
"@code{cl-letf} and is not allowed."
msgstr ""

#. type: defmac
#: ../../cl.texi:1202
msgid ""
"However, a @var{binding} specifier may be a one-element list "
"@samp{(@var{place})}, which is similar to @samp{(@var{place} @var{place})}.  "
"In other words, the @var{place} is not disturbed on entry to the body, and "
"the only effect of the @code{cl-letf} is to restore the original value of "
"@var{place} afterwards."
msgstr ""

#. type: defmac
#: ../../cl.texi:1214
msgid ""
"Note that in this case, and in fact almost every case, @var{place} must have "
"a well-defined value outside the @code{cl-letf} body.  There is essentially "
"only one exception to this, which is @var{place} a plain variable with a "
"specified @var{value} (such as @code{(a 17)} in the above example)."
msgstr ""

#. type: defmac
#: ../../cl.texi:1222
#, no-wrap
msgid "cl-letf* (bindings@dots{}) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1225
msgid ""
"This macro is to @code{cl-letf} what @code{let*} is to @code{let}: It does "
"the bindings in sequential rather than parallel order."
msgstr ""

#. type: defmac
#: ../../cl.texi:1227
#, no-wrap
msgid "cl-callf @var{function} @var{place} @var{args}@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1234
msgid ""
"This is the ``generic'' modify macro.  It calls @var{function}, which should "
"be an unquoted function name, macro name, or lambda.  It passes @var{place} "
"and @var{args} as arguments, and assigns the result back to @var{place}.  "
"For example, @code{(cl-incf @var{place} @var{n})} is the same as "
"@code{(cl-callf + @var{place} @var{n})}.  Some more examples:"
msgstr ""

#. type: example
#: ../../cl.texi:1239
#, no-wrap
msgid ""
"(cl-callf abs my-number)\n"
"(cl-callf concat (buffer-name) \"<\" (number-to-string n) \">\")\n"
"(cl-callf cl-union happy-people (list joe bob) :test 'same-person)\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1242
msgid "Note again that @code{cl-callf} is an extension to standard Common Lisp."
msgstr ""

#. type: defmac
#: ../../cl.texi:1244
#, no-wrap
msgid "cl-callf2 @var{function} @var{arg1} @var{place} @var{args}@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1249
msgid ""
"This macro is like @code{cl-callf}, except that @var{place} is the "
"@emph{second} argument of @var{function} rather than the first.  For "
"example, @code{(push @var{x} @var{place})} is equivalent to @code{(cl-callf2 "
"cons @var{x} @var{place})}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:1255
msgid ""
"The @code{cl-callf} and @code{cl-callf2} macros serve as building blocks for "
"other macros like @code{cl-incf}, and @code{cl-pushnew}.  The @code{cl-letf} "
"and @code{cl-letf*} macros are used in the processing of symbol macros; "
"@pxref{Macro Bindings}."
msgstr ""

#. type: cindex
#: ../../cl.texi:1259
#, no-wrap
msgid "variable binding"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1264
msgid ""
"These Lisp forms make bindings to variables and function names, analogous to "
"Lisp's built-in @code{let} form."
msgstr ""

#. type: Plain text
#: ../../cl.texi:1267
msgid ""
"@xref{Modify Macros}, for the @code{cl-letf} and @code{cl-letf*} forms which "
"are also related to variable bindings."
msgstr ""

#. type: subsection
#: ../../cl.texi:1272 ../../cl.texi:1274 ../../cl.texi:1275
#, no-wrap
msgid "Dynamic Bindings"
msgstr ""

#. type: menuentry
#: ../../cl.texi:1272
msgid "The @code{cl-progv} form."
msgstr ""

#. type: subsection
#: ../../cl.texi:1272 ../../cl.texi:1295 ../../cl.texi:1296
#, no-wrap
msgid "Function Bindings"
msgstr ""

#. type: menuentry
#: ../../cl.texi:1272
msgid "@code{cl-flet} and @code{cl-labels}."
msgstr ""

#. type: subsection
#: ../../cl.texi:1272 ../../cl.texi:1346 ../../cl.texi:1347
#, no-wrap
msgid "Macro Bindings"
msgstr ""

#. type: menuentry
#: ../../cl.texi:1272
msgid "@code{cl-macrolet} and @code{cl-symbol-macrolet}."
msgstr ""

#. type: cindex
#: ../../cl.texi:1276
#, no-wrap
msgid "dynamic binding"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1282
msgid ""
"The standard @code{let} form binds variables whose names are known at "
"compile-time.  The @code{cl-progv} form provides an easy way to bind "
"variables whose names are computed at run-time."
msgstr ""

#. type: defmac
#: ../../cl.texi:1283
#, no-wrap
msgid "cl-progv symbols values forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1293
msgid ""
"This form establishes @code{let}-style variable bindings on a set of "
"variables computed at run-time.  The expressions @var{symbols} and "
"@var{values} are evaluated, and must return lists of symbols and values, "
"respectively.  The symbols are bound to the corresponding values for the "
"duration of the body @var{form}s.  If @var{values} is shorter than "
"@var{symbols}, the last few symbols are bound to @code{nil}.  If "
"@var{symbols} is shorter than @var{values}, the excess values are ignored."
msgstr ""

#. type: cindex
#: ../../cl.texi:1297
#, no-wrap
msgid "function binding"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1302
msgid "These forms make @code{let}-like bindings to functions instead of variables."
msgstr ""

#. type: defmac
#: ../../cl.texi:1303
#, no-wrap
msgid "cl-flet (bindings@dots{}) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1309
msgid ""
"This form establishes @code{let}-style bindings for functions rather than "
"values.  Each @var{binding} must be a list of the form @samp{(@var{name} "
"@var{arglist} @var{body}@dots{})}.  Within @var{forms}, any reference to the "
"function @var{name} uses the local definition instead of the global one."
msgstr ""

#. type: defmac
#: ../../cl.texi:1313
msgid ""
"A ``reference'' to a function name is either a call to that function, or a "
"use of its name quoted by @code{function} to be passed on to, say, "
"@code{mapcar}."
msgstr ""

#. type: defmac
#: ../../cl.texi:1316
msgid ""
"The bindings are lexical in scope.  This means that all references to the "
"named functions must appear physically within @var{forms}."
msgstr ""

#. type: defmac
#: ../../cl.texi:1321
msgid ""
"Functions defined by @code{cl-flet} may use the full Common Lisp argument "
"notation supported by @code{cl-defun}; also, the function body is enclosed "
"in an implicit block as if by @code{cl-defun}.  @xref{Program Structure}."
msgstr ""

#. type: defmac
#: ../../cl.texi:1325
msgid ""
"Note that the @file{cl.el} version of this macro behaves slightly "
"differently.  In particular, its binding is dynamic rather than lexical.  "
"@xref{Obsolete Macros}."
msgstr ""

#. type: defmac
#: ../../cl.texi:1327
#, no-wrap
msgid "cl-labels (bindings@dots{}) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1334
msgid ""
"The @code{cl-labels} form is like @code{cl-flet}, except that the function "
"bindings can be recursive.  The scoping is lexical, but you can only capture "
"functions in closures if @code{lexical-binding} is @code{t}.  "
"@xref{Closures,,,elisp,GNU Emacs Lisp Reference Manual}, and @ref{Using "
"Lexical Binding,,,elisp,GNU Emacs Lisp Reference Manual}."
msgstr ""

#. type: defmac
#: ../../cl.texi:1341
msgid ""
"Lexical scoping means that all references to the named functions must appear "
"physically within the body of the @code{cl-labels} form.  References may "
"appear both in the body @var{forms} of @code{cl-labels} itself, and in the "
"bodies of the functions themselves.  Thus, @code{cl-labels} can define local "
"recursive functions, or mutually-recursive sets of functions."
msgstr ""

#. type: defmac
#: ../../cl.texi:1344
msgid ""
"Note that the @file{cl.el} version of this macro behaves slightly "
"differently.  @xref{Obsolete Macros}."
msgstr ""

#. type: cindex
#: ../../cl.texi:1348
#, no-wrap
msgid "macro binding"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1352
msgid "These forms create local macros and ``symbol macros''."
msgstr ""

#. type: defmac
#: ../../cl.texi:1353
#, no-wrap
msgid "cl-macrolet (bindings@dots{}) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1359
msgid ""
"This form is analogous to @code{cl-flet}, but for macros instead of "
"functions.  Each @var{binding} is a list of the same form as the arguments "
"to @code{cl-defmacro} (i.e., a macro name, argument list, and macro-expander "
"forms).  The macro is defined accordingly for use within the body of the "
"@code{cl-macrolet}."
msgstr ""

#. type: defmac
#: ../../cl.texi:1366
msgid ""
"Because of the nature of macros, @code{cl-macrolet} is always lexically "
"scoped.  The @code{cl-macrolet} binding will affect only calls that appear "
"physically within the body @var{forms}, possibly after expansion of other "
"macros in the body.  Calls of @code{cl-macrolet} bound macros are expanded "
"in the global environment."
msgstr ""

#. type: defmac
#: ../../cl.texi:1368
#, no-wrap
msgid "cl-symbol-macrolet (bindings@dots{}) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1374
msgid ""
"This form creates @dfn{symbol macros}, which are macros that look like "
"variable references rather than function calls.  Each @var{binding} is a "
"list @samp{(@var{var} @var{expansion})}; any reference to @var{var} within "
"the body @var{forms} is replaced by @var{expansion}."
msgstr ""

#. type: example
#: ../../cl.texi:1381
#, no-wrap
msgid ""
"(setq bar '(5 . 9))\n"
"(cl-symbol-macrolet ((foo (car bar)))\n"
"  (cl-incf foo))\n"
"bar\n"
"     @result{} (6 . 9)\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1386
msgid ""
"A @code{setq} of a symbol macro is treated the same as a @code{setf}.  I.e., "
"@code{(setq foo 4)} in the above would be equivalent to @code{(setf foo 4)}, "
"which in turn expands to @code{(setf (car bar) 4)}."
msgstr ""

#. type: defmac
#: ../../cl.texi:1398
msgid ""
"Likewise, a @code{let} or @code{let*} binding a symbol macro is treated like "
"a @code{cl-letf} or @code{cl-letf*}.  This differs from true Common Lisp, "
"where the rules of lexical scoping cause a @code{let} binding to shadow a "
"@code{symbol-macrolet} binding.  In this package, such shadowing does not "
"occur, even when @code{lexical-binding} is @code{t}.  (This behavior "
"predates the addition of lexical binding to Emacs Lisp, and may change in "
"future to respect @code{lexical-binding}.)  At present in this package, only "
"@code{lexical-let} and @code{lexical-let*} will shadow a symbol macro.  "
"@xref{Obsolete Lexical Binding}."
msgstr ""

#. type: defmac
#: ../../cl.texi:1402
msgid ""
"There is no analogue of @code{defmacro} for symbol macros; all symbol macros "
"are local.  A typical use of @code{cl-symbol-macrolet} is in the expansion "
"of another macro:"
msgstr ""

#. type: example
#: ../../cl.texi:1410
#, no-wrap
msgid ""
"(cl-defmacro my-dolist ((x list) &rest body)\n"
"  (let ((var (cl-gensym)))\n"
"    (list 'cl-loop 'for var 'on list 'do\n"
"          (cl-list* 'cl-symbol-macrolet\n"
"                    (list (list x (list 'car var)))\n"
"                    body))))\n"
"\n"
msgstr ""

#. type: example
#: ../../cl.texi:1415
#, no-wrap
msgid ""
"(setq mylist '(1 2 3 4))\n"
"(my-dolist (x mylist) (cl-incf x))\n"
"mylist\n"
"     @result{} (2 3 4 5)\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1422
msgid ""
"In this example, the @code{my-dolist} macro is similar to @code{dolist} "
"(@pxref{Iteration}) except that the variable @code{x} becomes a true "
"reference onto the elements of the list.  The @code{my-dolist} call shown "
"here expands to"
msgstr ""

#. type: example
#: ../../cl.texi:1427
#, no-wrap
msgid ""
"(cl-loop for G1234 on mylist do\n"
"      (cl-symbol-macrolet ((x (car G1234)))\n"
"        (cl-incf x)))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1431
msgid "which in turn expands to"
msgstr ""

#. type: example
#: ../../cl.texi:1434
#, no-wrap
msgid "(cl-loop for G1234 on mylist do (cl-incf (car G1234)))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1439
msgid ""
"@xref{Loop Facility}, for a description of the @code{cl-loop} macro.  This "
"package defines a nonstandard @code{in-ref} loop clause that works much like "
"@code{my-dolist}."
msgstr ""

#. type: cindex
#: ../../cl.texi:1443
#, no-wrap
msgid "conditionals"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1448
msgid ""
"These conditional forms augment Emacs Lisp's simple @code{if}, @code{and}, "
"@code{or}, and @code{cond} forms."
msgstr ""

#. type: defmac
#: ../../cl.texi:1449
#, no-wrap
msgid "cl-case keyform clause@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1455
msgid ""
"This macro evaluates @var{keyform}, then compares it with the key values "
"listed in the various @var{clause}s.  Whichever clause matches the key is "
"executed; comparison is done by @code{eql}.  If no clause matches, the "
"@code{cl-case} form returns @code{nil}.  The clauses are of the form"
msgstr ""

#. type: example
#: ../../cl.texi:1458
#, no-wrap
msgid "(@var{keylist} @var{body-forms}@dots{})\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1471
msgid ""
"where @var{keylist} is a list of key values.  If there is exactly one value, "
"and it is not a cons cell or the symbol @code{nil} or @code{t}, then it can "
"be used by itself as a @var{keylist} without being enclosed in a list.  All "
"key values in the @code{cl-case} form must be distinct.  The final clauses "
"may use @code{t} in place of a @var{keylist} to indicate a default clause "
"that should be taken if none of the other clauses match.  (The symbol "
"@code{otherwise} is also recognized in place of @code{t}.  To make a clause "
"that matches the actual symbol @code{t}, @code{nil}, or @code{otherwise}, "
"enclose the symbol in a list.)"
msgstr ""

#. type: defmac
#: ../../cl.texi:1475
msgid ""
"For example, this expression reads a keystroke, then does one of four things "
"depending on whether it is an @samp{a}, a @samp{b}, a @key{RET} or "
"@kbd{C-j}, or anything else."
msgstr ""

#. type: example
#: ../../cl.texi:1482
#, no-wrap
msgid ""
"(cl-case (read-char)\n"
"  (?a (do-a-thing))\n"
"  (?b (do-b-thing))\n"
"  ((?\\r ?\\n) (do-ret-thing))\n"
"  (t (do-other-thing)))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1485
#, no-wrap
msgid "cl-ecase keyform clause@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1489
msgid ""
"This macro is just like @code{cl-case}, except that if the key does not "
"match any of the clauses, an error is signaled rather than simply returning "
"@code{nil}."
msgstr ""

#. type: defmac
#: ../../cl.texi:1491
#, no-wrap
msgid "cl-typecase keyform clause@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1496
msgid ""
"This macro is a version of @code{cl-case} that checks for types rather than "
"values.  Each @var{clause} is of the form @samp{(@var{type} "
"@var{body}@dots{})}.  @xref{Type Predicates}, for a description of type "
"specifiers.  For example,"
msgstr ""

#. type: example
#: ../../cl.texi:1503
#, no-wrap
msgid ""
"(cl-typecase x\n"
"  (integer (munch-integer x))\n"
"  (float (munch-float x))\n"
"  (string (munch-integer (string-to-number x)))\n"
"  (t (munch-anything x)))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1508
msgid ""
"The type specifier @code{t} matches any type of object; the word "
"@code{otherwise} is also allowed.  To make one clause match any of several "
"types, use an @code{(or @dots{})} type specifier."
msgstr ""

#. type: defmac
#: ../../cl.texi:1510
#, no-wrap
msgid "cl-etypecase keyform clause@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1514
msgid ""
"This macro is just like @code{cl-typecase}, except that if the key does not "
"match any of the clauses, an error is signaled rather than simply returning "
"@code{nil}."
msgstr ""

#. type: cindex
#: ../../cl.texi:1518
#, no-wrap
msgid "block"
msgstr ""

#. type: cindex
#: ../../cl.texi:1519
#, no-wrap
msgid "exit"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1528
msgid ""
"Common Lisp @dfn{blocks} provide a non-local exit mechanism very similar to "
"@code{catch} and @code{throw}, with lexical scoping.  This package actually "
"implements @code{cl-block} in terms of @code{catch}; however, the lexical "
"scoping allows the byte-compiler to omit the costly @code{catch} step if the "
"body of the block does not actually @code{cl-return-from} the block."
msgstr ""

#. type: defmac
#: ../../cl.texi:1529
#, no-wrap
msgid "cl-block name forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1535
msgid ""
"The @var{forms} are evaluated as if by a @code{progn}.  However, if any of "
"the @var{forms} execute @code{(cl-return-from @var{name})}, they will jump "
"out and return directly from the @code{cl-block} form.  The @code{cl-block} "
"returns the result of the last @var{form} unless a @code{cl-return-from} "
"occurs."
msgstr ""

#. type: defmac
#: ../../cl.texi:1549
msgid ""
"The @code{cl-block}/@code{cl-return-from} mechanism is quite similar to the "
"@code{catch}/@code{throw} mechanism.  The main differences are that block "
"@var{name}s are unevaluated symbols, rather than forms (such as quoted "
"symbols) that evaluate to a tag at run-time; and also that blocks are always "
"lexically scoped.  In a dynamically scoped @code{catch}, functions called "
"from the @code{catch} body can also @code{throw} to the @code{catch}.  This "
"is not an option for @code{cl-block}, where the @code{cl-return-from} "
"referring to a block name must appear physically within the @var{forms} that "
"make up the body of the block.  They may not appear within other called "
"functions, although they may appear within macro expansions or "
"@code{lambda}s in the body.  Block names and @code{catch} names form "
"independent name-spaces."
msgstr ""

#. type: defmac
#: ../../cl.texi:1555
msgid ""
"In true Common Lisp, @code{defun} and @code{defmacro} surround the function "
"or expander bodies with implicit blocks with the same name as the function "
"or macro.  This does not occur in Emacs Lisp, but this package provides "
"@code{cl-defun} and @code{cl-defmacro} forms, which do create the implicit "
"block."
msgstr ""

#. type: defmac
#: ../../cl.texi:1559
msgid ""
"The Common Lisp looping constructs defined by this package, such as "
"@code{cl-loop} and @code{cl-dolist}, also create implicit blocks just as in "
"Common Lisp."
msgstr ""

#. type: defmac
#: ../../cl.texi:1569
msgid ""
"Because they are implemented in terms of Emacs Lisp's @code{catch} and "
"@code{throw}, blocks have the same overhead as actual @code{catch} "
"constructs (roughly two function calls).  However, the byte compiler will "
"optimize away the @code{catch} if the block does not in fact contain any "
"@code{cl-return} or @code{cl-return-from} calls that jump to it.  This means "
"that @code{cl-do} loops and @code{cl-defun} functions that don't use "
"@code{cl-return} don't pay the overhead to support it."
msgstr ""

#. type: defmac
#: ../../cl.texi:1571
#, no-wrap
msgid "cl-return-from name [result]"
msgstr ""

#. type: defmac
#: ../../cl.texi:1576
msgid ""
"This macro returns from the block named @var{name}, which must be an "
"(unevaluated) symbol.  If a @var{result} form is specified, it is evaluated "
"to produce the result returned from the @code{block}.  Otherwise, @code{nil} "
"is returned."
msgstr ""

#. type: defmac
#: ../../cl.texi:1578
#, no-wrap
msgid "cl-return [result]"
msgstr ""

#. type: defmac
#: ../../cl.texi:1582
msgid ""
"This macro is exactly like @code{(cl-return-from nil @var{result})}.  Common "
"Lisp loops like @code{cl-do} and @code{cl-dolist} implicitly enclose "
"themselves in @code{nil} blocks."
msgstr ""

#. type: defmac
#: ../../cl.texi:1585
#, no-wrap
msgid "cl-tagbody &rest labels-or-statements"
msgstr ""

#. type: defmac
#: ../../cl.texi:1594
msgid ""
"This macro executes statements while allowing for control transfer to "
"user-defined labels.  Each element of @var{labels-or-statements} can be "
"either a label (an integer or a symbol), or a cons-cell (a statement).  This "
"distinction is made before macroexpansion.  Statements are executed in "
"sequence, discarding any return value.  Any statement can transfer control "
"at any time to the statements that follow one of the labels with the special "
"form @code{(go @var{label})}.  Labels have lexical scope and dynamic extent."
msgstr ""

#. type: cindex
#: ../../cl.texi:1599
#, no-wrap
msgid "iteration"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1605
msgid ""
"The macros described here provide more sophisticated, high-level looping "
"constructs to complement Emacs Lisp's basic loop forms "
"(@pxref{Iteration,,,elisp,GNU Emacs Lisp Reference Manual})."
msgstr ""

#. type: defmac
#: ../../cl.texi:1606
#, no-wrap
msgid "cl-loop forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1612
msgid ""
"This package supports both the simple, old-style meaning of @code{loop} and "
"the extremely powerful and flexible feature known as the @dfn{Loop Facility} "
"or @dfn{Loop Macro}.  This more advanced facility is discussed in the "
"following section; @pxref{Loop Facility}.  The simple form of @code{loop} is "
"described here."
msgstr ""

#. type: defmac
#: ../../cl.texi:1617
msgid ""
"If @code{cl-loop} is followed by zero or more Lisp expressions, then "
"@code{(cl-loop @var{exprs}@dots{})} simply creates an infinite loop "
"executing the expressions over and over.  The loop is enclosed in an "
"implicit @code{nil} block.  Thus,"
msgstr ""

#. type: example
#: ../../cl.texi:1620
#, no-wrap
msgid "(cl-loop (foo)  (if (no-more) (return 72))  (bar))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1624
msgid "is exactly equivalent to"
msgstr ""

#. type: example
#: ../../cl.texi:1627
#, no-wrap
msgid "(cl-block nil (while t (foo)  (if (no-more) (return 72))  (bar)))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1634
msgid ""
"If any of the expressions are plain symbols, the loop is instead interpreted "
"as a Loop Macro specification as described later.  (This is not a "
"restriction in practice, since a plain symbol in the above notation would "
"simply access and throw away the value of a variable.)"
msgstr ""

#. type: defmac
#: ../../cl.texi:1636
#, no-wrap
msgid "cl-do (spec@dots{}) (end-test [result@dots{}]) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1639
msgid "This macro creates a general iterative loop.  Each @var{spec} is of the form"
msgstr ""

#. type: example
#: ../../cl.texi:1642
#, no-wrap
msgid "(@var{var} [@var{init} [@var{step}]])\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1653
msgid ""
"The loop works as follows: First, each @var{var} is bound to the associated "
"@var{init} value as if by a @code{let} form.  Then, in each iteration of the "
"loop, the @var{end-test} is evaluated; if true, the loop is finished.  "
"Otherwise, the body @var{forms} are evaluated, then each @var{var} is set to "
"the associated @var{step} expression (as if by a @code{cl-psetq} form) and "
"the next iteration begins.  Once the @var{end-test} becomes true, the "
"@var{result} forms are evaluated (with the @var{var}s still bound to their "
"values) to produce the result returned by @code{cl-do}."
msgstr ""

#. type: defmac
#: ../../cl.texi:1657
msgid ""
"The entire @code{cl-do} loop is enclosed in an implicit @code{nil} block, so "
"that you can use @code{(cl-return)} to break out of the loop at any time."
msgstr ""

#. type: defmac
#: ../../cl.texi:1667
msgid ""
"If there are no @var{result} forms, the loop returns @code{nil}.  If a given "
"@var{var} has no @var{step} form, it is bound to its @var{init} value but "
"not otherwise modified during the @code{cl-do} loop (unless the code "
"explicitly modifies it); this case is just a shorthand for putting a "
"@code{(let ((@var{var} @var{init})) @dots{})} around the loop.  If "
"@var{init} is also omitted it defaults to @code{nil}, and in this case a "
"plain @samp{@var{var}} can be used in place of @samp{(@var{var})}, again "
"following the analogy with @code{let}."
msgstr ""

#. type: defmac
#: ../../cl.texi:1674
msgid ""
"This example (from Steele) illustrates a loop that applies the function "
"@code{f} to successive pairs of values from the lists @code{foo} and "
"@code{bar}; it is equivalent to the call @code{(cl-mapcar 'f foo bar)}.  "
"Note that this loop has no body @var{forms} at all, performing all its work "
"as side effects of the rest of the loop."
msgstr ""

#. type: example
#: ../../cl.texi:1681
#, no-wrap
msgid ""
"(cl-do ((x foo (cdr x))\n"
"        (y bar (cdr y))\n"
"        (z nil (cons (f (car x) (car y)) z)))\n"
"     ((or (null x) (null y))\n"
"      (nreverse z)))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1684
#, no-wrap
msgid "cl-do* (spec@dots{}) (end-test [result@dots{}]) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1689
msgid ""
"This is to @code{cl-do} what @code{let*} is to @code{let}.  In particular, "
"the initial values are bound as if by @code{let*} rather than @code{let}, "
"and the steps are assigned as if by @code{setq} rather than @code{cl-psetq}."
msgstr ""

#. type: defmac
#: ../../cl.texi:1691
msgid "Here is another way to write the above loop:"
msgstr ""

#. type: example
#: ../../cl.texi:1701
#, no-wrap
msgid ""
"(cl-do* ((xp foo (cdr xp))\n"
"         (yp bar (cdr yp))\n"
"         (x (car xp) (car xp))\n"
"         (y (car yp) (car yp))\n"
"         z)\n"
"  ((or (null xp) (null yp))\n"
"   (nreverse z))\n"
"  (push (f x y) z))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1704
#, no-wrap
msgid "cl-dolist (var list [result]) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1707
msgid ""
"This is exactly like the standard Emacs Lisp macro @code{dolist}, but "
"surrounds the loop with an implicit @code{nil} block."
msgstr ""

#. type: defmac
#: ../../cl.texi:1709
#, no-wrap
msgid "cl-dotimes (var count [result]) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1718
msgid ""
"This is exactly like the standard Emacs Lisp macro @code{dotimes}, but "
"surrounds the loop with an implicit @code{nil} block.  The body is executed "
"with @var{var} bound to the integers from zero (inclusive) to @var{count} "
"(exclusive), in turn.  Then the @var{result} form is evaluated with "
"@var{var} bound to the total number of iterations that were done (i.e., "
"@code{(max 0 @var{count})})  to get the return value for the loop form.  Use "
"of @var{result} is deprecated."
msgstr ""

#. type: defmac
#: ../../cl.texi:1720
#, no-wrap
msgid "cl-do-symbols (var [obarray [result]]) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1728
msgid ""
"This loop iterates over all interned symbols.  If @var{obarray} is specified "
"and is not @code{nil}, it loops over all symbols in that obarray.  For each "
"symbol, the body @var{forms} are evaluated with @var{var} bound to that "
"symbol.  The symbols are visited in an unspecified order.  Afterward the "
"@var{result} form, if any, is evaluated (with @var{var} bound to @code{nil}) "
"to get the return value.  The loop is surrounded by an implicit @code{nil} "
"block."
msgstr ""

#. type: defmac
#: ../../cl.texi:1730
#, no-wrap
msgid "cl-do-all-symbols (var [result]) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1733
msgid ""
"This is identical to @code{cl-do-symbols} except that the @var{obarray} "
"argument is omitted; it always iterates over the default obarray."
msgstr ""

#. type: Plain text
#: ../../cl.texi:1737
msgid ""
"@xref{Mapping over Sequences}, for some more functions for iterating over "
"vectors or lists."
msgstr ""

#. type: cindex
#: ../../cl.texi:1740
#, no-wrap
msgid "loop facility"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1747
msgid ""
"A common complaint with Lisp's traditional looping constructs was that they "
"were either too simple and limited, such as @code{dotimes} or @code{while}, "
"or too unreadable and obscure, like Common Lisp's @code{do} loop."
msgstr ""

#. type: Plain text
#: ../../cl.texi:1751
msgid ""
"To remedy this, Common Lisp added a construct called the ``Loop Facility'' "
"or ``@code{loop} macro'', with an easy-to-use but very powerful and "
"expressive syntax."
msgstr ""

#. type: subsection
#: ../../cl.texi:1759 ../../cl.texi:1761 ../../cl.texi:1762
#, no-wrap
msgid "Loop Basics"
msgstr ""

#. type: menuentry
#: ../../cl.texi:1759
msgid "The @code{cl-loop} macro, basic clause structure."
msgstr ""

#. type: subsection
#: ../../cl.texi:1759 ../../cl.texi:1820 ../../cl.texi:1821
#, no-wrap
msgid "Loop Examples"
msgstr ""

#. type: menuentry
#: ../../cl.texi:1759
msgid "Working examples of the @code{cl-loop} macro."
msgstr ""

#. type: subsection
#: ../../cl.texi:1759 ../../cl.texi:1893 ../../cl.texi:1894
#, no-wrap
msgid "For Clauses"
msgstr ""

#. type: menuentry
#: ../../cl.texi:1759
msgid "Clauses introduced by @code{for} or @code{as}."
msgstr ""

#. type: subsection
#: ../../cl.texi:1759 ../../cl.texi:2198 ../../cl.texi:2199
#, no-wrap
msgid "Iteration Clauses"
msgstr ""

#. type: menuentry
#: ../../cl.texi:1759
msgid "@code{repeat}, @code{while}, @code{thereis}, etc."
msgstr ""

#. type: subsection
#: ../../cl.texi:1759 ../../cl.texi:2262 ../../cl.texi:2263
#, no-wrap
msgid "Accumulation Clauses"
msgstr ""

#. type: menuentry
#: ../../cl.texi:1759
msgid "@code{collect}, @code{sum}, @code{maximize}, etc."
msgstr ""

#. type: subsection
#: ../../cl.texi:1759 ../../cl.texi:2331 ../../cl.texi:2332
#, no-wrap
msgid "Other Clauses"
msgstr ""

#. type: menuentry
#: ../../cl.texi:1759
msgid "@code{with}, @code{if}, @code{initially}, @code{finally}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:1769
msgid ""
"The @code{cl-loop} macro essentially creates a mini-language within Lisp "
"that is specially tailored for describing loops.  While this language is a "
"little strange-looking by the standards of regular Lisp, it turns out to be "
"very easy to learn and well-suited to its purpose."
msgstr ""

#. type: Plain text
#: ../../cl.texi:1773
msgid ""
"Since @code{cl-loop} is a macro, all parsing of the loop language takes "
"place at byte-compile time; compiled @code{cl-loop}s are just as efficient "
"as the equivalent @code{while} loops written longhand."
msgstr ""

#. type: defmac
#: ../../cl.texi:1774
#, no-wrap
msgid "cl-loop clauses@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:1782
msgid ""
"A loop construct consists of a series of @var{clause}s, each introduced by a "
"symbol like @code{for} or @code{do}.  Clauses are simply strung together in "
"the argument list of @code{cl-loop}, with minimal extra parentheses.  The "
"various types of clauses specify initializations, such as the binding of "
"temporary variables, actions to be taken in the loop, stepping actions, and "
"final cleanup."
msgstr ""

#. type: defmac
#: ../../cl.texi:1785
msgid "Common Lisp specifies a certain general order of clauses in a loop:"
msgstr ""

#. type: example
#: ../../cl.texi:1790
#, no-wrap
msgid ""
"(loop @var{name-clause}\n"
"      @var{var-clauses}@dots{}\n"
"      @var{action-clauses}@dots{})\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:1799
msgid ""
"The @var{name-clause} optionally gives a name to the implicit block that "
"surrounds the loop.  By default, the implicit block is named @code{nil}.  "
"The @var{var-clauses} specify what variables should be bound during the "
"loop, and how they should be modified or iterated throughout the course of "
"the loop.  The @var{action-clauses} are things to be done during the loop, "
"such as computing, collecting, and returning values."
msgstr ""

#. type: defmac
#: ../../cl.texi:1805
msgid ""
"The Emacs version of the @code{cl-loop} macro is less restrictive about the "
"order of clauses, but things will behave most predictably if you put the "
"variable-binding clauses @code{with}, @code{for}, and @code{repeat} before "
"the action clauses.  As in Common Lisp, @code{initially} and @code{finally} "
"clauses can go anywhere."
msgstr ""

#. type: defmac
#: ../../cl.texi:1813
msgid ""
"Loops generally return @code{nil} by default, but you can cause them to "
"return a value by using an accumulation clause like @code{collect}, an "
"end-test clause like @code{always}, or an explicit @code{return} clause to "
"jump out of the implicit block.  (Because the loop body is enclosed in an "
"implicit block, you can also use regular Lisp @code{cl-return} or "
"@code{cl-return-from} to break out of the loop.)"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1819
msgid ""
"The following sections give some examples of the loop macro in action, and "
"describe the particular loop clauses in great detail.  Consult the second "
"edition of Steele for additional discussion and examples."
msgstr ""

#. type: Plain text
#: ../../cl.texi:1827
msgid ""
"Before listing the full set of clauses that are allowed, let's look at a few "
"example loops just to get a feel for the @code{cl-loop} language."
msgstr ""

#. type: example
#: ../../cl.texi:1831
#, no-wrap
msgid ""
"(cl-loop for buf in (buffer-list)\n"
"         collect (buffer-file-name buf))\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1841
msgid ""
"This loop iterates over all Emacs buffers, using the list returned by "
"@code{buffer-list}.  For each buffer @var{buf}, it calls "
"@code{buffer-file-name} and collects the results into a list, which is then "
"returned from the @code{cl-loop} construct.  The result is a list of the "
"file names of all the buffers in Emacs's memory.  The words @code{for}, "
"@code{in}, and @code{collect} are reserved words in the @code{cl-loop} "
"language."
msgstr ""

#. type: example
#: ../../cl.texi:1844
#, no-wrap
msgid "(cl-loop repeat 20 do (insert \"Yowsa\\n\"))\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1849
msgid "This loop inserts the phrase ``Yowsa'' twenty times in the current buffer."
msgstr ""

#. type: example
#: ../../cl.texi:1852
#, no-wrap
msgid "(cl-loop until (eobp) do (munch-line) (forward-line 1))\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1858
msgid ""
"This loop calls @code{munch-line} on every line until the end of the "
"buffer.  If point is already at the end of the buffer, the loop exits "
"immediately."
msgstr ""

#. type: example
#: ../../cl.texi:1861
#, no-wrap
msgid "(cl-loop do (munch-line) until (eobp) do (forward-line 1))\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1866
msgid ""
"This loop is similar to the above one, except that @code{munch-line} is "
"always called at least once."
msgstr ""

#. type: example
#: ../../cl.texi:1872
#, no-wrap
msgid ""
"(cl-loop for x from 1 to 100\n"
"         for y = (* x x)\n"
"         until (>= y 729)\n"
"         finally return (list x (= y 729)))\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1886
msgid ""
"This more complicated loop searches for a number @code{x} whose square is "
"729.  For safety's sake it only examines @code{x} values up to 100; dropping "
"the phrase @samp{to 100} would cause the loop to count upwards with no "
"limit.  The second @code{for} clause defines @code{y} to be the square of "
"@code{x} within the loop; the expression after the @code{=} sign is "
"reevaluated each time through the loop.  The @code{until} clause gives a "
"condition for terminating the loop, and the @code{finally} clause says what "
"to do when the loop finishes.  (This particular example was written less "
"concisely than it could have been, just for the sake of illustration.)"
msgstr ""

#. type: Plain text
#: ../../cl.texi:1892
msgid ""
"Note that even though this loop contains three clauses (two @code{for}s and "
"an @code{until}) that would have been enough to define loops all by "
"themselves, it still creates a single loop rather than some sort of "
"triple-nested loop.  You must explicitly nest your @code{cl-loop} constructs "
"if you want nested loops."
msgstr ""

#. type: Plain text
#: ../../cl.texi:1901
msgid ""
"Most loops are governed by one or more @code{for} clauses.  A @code{for} "
"clause simultaneously describes variables to be bound, how those variables "
"are to be stepped during the loop, and usually an end condition based on "
"those variables."
msgstr ""

#. type: Plain text
#: ../../cl.texi:1912
msgid ""
"The word @code{as} is a synonym for the word @code{for}.  This word is "
"followed by a variable name, then a word like @code{from} or @code{across} "
"that describes the kind of iteration desired.  In Common Lisp, the phrase "
"@code{being the} sometimes precedes the type of iteration; in this package "
"both @code{being} and @code{the} are optional.  The word @code{each} is a "
"synonym for @code{the}, and the word that follows it may be singular or "
"plural: @samp{for x being the elements of y} or @samp{for x being each "
"element of y}.  Which form you use is purely a matter of style."
msgstr ""

#. type: Plain text
#: ../../cl.texi:1914
msgid "The variable is bound around the loop as if by @code{let}:"
msgstr ""

#. type: example
#: ../../cl.texi:1920
#, no-wrap
msgid ""
"(setq i 'happy)\n"
"(cl-loop for i from 1 to 10 do (do-something-with i))\n"
"i\n"
"     @result{} happy\n"
msgstr ""

#. type: item
#: ../../cl.texi:1923
#, no-wrap
msgid "for @var{var} from @var{expr1} to @var{expr2} by @var{expr3}"
msgstr ""

#. type: table
#: ../../cl.texi:1927
msgid ""
"This type of @code{for} clause creates a counting loop.  Each of the three "
"sub-terms is optional, though there must be at least one term so that the "
"clause is marked as a counting clause."
msgstr ""

#. type: table
#: ../../cl.texi:1936
msgid ""
"The three expressions are the starting value, the ending value, and the step "
"value, respectively, of the variable.  The loop counts upwards by default "
"(@var{expr3} must be positive), from @var{expr1} to @var{expr2} "
"inclusively.  If you omit the @code{from} term, the loop counts from zero; "
"if you omit the @code{to} term, the loop counts forever without stopping "
"(unless stopped by some other loop clause, of course); if you omit the "
"@code{by} term, the loop counts in steps of one."
msgstr ""

#. type: table
#: ../../cl.texi:1945
msgid ""
"You can replace the word @code{from} with @code{upfrom} or @code{downfrom} "
"to indicate the direction of the loop.  Likewise, you can replace @code{to} "
"with @code{upto} or @code{downto}.  For example, @samp{for x from 5 downto "
"1} executes five times with @code{x} taking on the integers from 5 down to 1 "
"in turn.  Also, you can replace @code{to} with @code{below} or @code{above}, "
"which are like @code{upto} and @code{downto} respectively except that they "
"are exclusive rather than inclusive limits:"
msgstr ""

#. type: example
#: ../../cl.texi:1951
#, no-wrap
msgid ""
"(cl-loop for x to 10 collect x)\n"
"        @result{} (0 1 2 3 4 5 6 7 8 9 10)\n"
"(cl-loop for x below 10 collect x)\n"
"        @result{} (0 1 2 3 4 5 6 7 8 9)\n"
msgstr ""

#. type: table
#: ../../cl.texi:1957
msgid ""
"The @code{by} value is always positive, even for downward-counting loops.  "
"Some sort of @code{from} value is required for downward loops; @samp{for x "
"downto 5} is not a valid loop clause all by itself."
msgstr ""

#. type: item
#: ../../cl.texi:1958
#, no-wrap
msgid "for @var{var} in @var{list} by @var{function}"
msgstr ""

#. type: table
#: ../../cl.texi:1963
msgid ""
"This clause iterates @var{var} over all the elements of @var{list}, in "
"turn.  If you specify the @code{by} term, then @var{function} is used to "
"traverse the list instead of @code{cdr}; it must be a function taking one "
"argument.  For example:"
msgstr ""

#. type: example
#: ../../cl.texi:1969
#, no-wrap
msgid ""
"(cl-loop for x in '(1 2 3 4 5 6) collect (* x x))\n"
"        @result{} (1 4 9 16 25 36)\n"
"(cl-loop for x in '(1 2 3 4 5 6) by 'cddr collect (* x x))\n"
"        @result{} (1 9 25)\n"
msgstr ""

#. type: item
#: ../../cl.texi:1971
#, no-wrap
msgid "for @var{var} on @var{list} by @var{function}"
msgstr ""

#. type: table
#: ../../cl.texi:1973
msgid "This clause iterates @var{var} over all the cons cells of @var{list}."
msgstr ""

#. type: example
#: ../../cl.texi:1977
#, no-wrap
msgid ""
"(cl-loop for x on '(1 2 3 4) collect x)\n"
"        @result{} ((1 2 3 4) (2 3 4) (3 4) (4))\n"
msgstr ""

#. type: item
#: ../../cl.texi:1979
#, no-wrap
msgid "for @var{var} in-ref @var{list} by @var{function}"
msgstr ""

#. type: table
#: ../../cl.texi:1983
msgid ""
"This is like a regular @code{in} clause, but @var{var} becomes a "
"@code{setf}-able ``reference'' onto the elements of the list rather than "
"just a temporary variable.  For example,"
msgstr ""

#. type: example
#: ../../cl.texi:1986
#, no-wrap
msgid "(cl-loop for x in-ref my-list do (cl-incf x))\n"
msgstr ""

#. type: table
#: ../../cl.texi:1991
msgid ""
"increments every element of @code{my-list} in place.  This clause is an "
"extension to standard Common Lisp."
msgstr ""

#. type: item
#: ../../cl.texi:1992
#, no-wrap
msgid "for @var{var} across @var{array}"
msgstr ""

#. type: table
#: ../../cl.texi:1995
msgid ""
"This clause iterates @var{var} over all the elements of @var{array}, which "
"may be a vector or a string."
msgstr ""

#. type: example
#: ../../cl.texi:1999
#, no-wrap
msgid ""
"(cl-loop for x across \"aeiou\"\n"
"         do (use-vowel (char-to-string x)))\n"
msgstr ""

#. type: item
#: ../../cl.texi:2001
#, no-wrap
msgid "for @var{var} across-ref @var{array}"
msgstr ""

#. type: table
#: ../../cl.texi:2004
msgid ""
"This clause iterates over an array, with @var{var} a @code{setf}-able "
"reference onto the elements; see @code{in-ref} above."
msgstr ""

#. type: item
#: ../../cl.texi:2005
#, no-wrap
msgid "for @var{var} being the elements of @var{sequence}"
msgstr ""

#. type: table
#: ../../cl.texi:2012
msgid ""
"This clause iterates over the elements of @var{sequence}, which may be a "
"list, vector, or string.  Since the type must be determined at run-time, "
"this is somewhat less efficient than @code{in} or @code{across}.  The clause "
"may be followed by the additional term @samp{using (index @var{var2})} to "
"cause @var{var2} to be bound to the successive indices (starting at 0) of "
"the elements."
msgstr ""

#. type: table
#: ../../cl.texi:2016
msgid ""
"This clause type is taken from older versions of the @code{loop} macro, and "
"is not present in modern Common Lisp.  The @samp{using (sequence @dots{})} "
"term of the older macros is not supported."
msgstr ""

#. type: item
#: ../../cl.texi:2017
#, no-wrap
msgid "for @var{var} being the elements of-ref @var{sequence}"
msgstr ""

#. type: table
#: ../../cl.texi:2020
msgid ""
"This clause iterates over a sequence, with @var{var} a @code{setf}-able "
"reference onto the elements; see @code{in-ref} above."
msgstr ""

#. type: item
#: ../../cl.texi:2021
#, no-wrap
msgid "for @var{var} being the symbols [of @var{obarray}]"
msgstr ""

#. type: table
#: ../../cl.texi:2026
msgid ""
"This clause iterates over symbols, either over all interned symbols or over "
"all symbols in @var{obarray}.  The loop is executed with @var{var} bound to "
"each symbol in turn.  The symbols are visited in an unspecified order."
msgstr ""

#. type: table
#: ../../cl.texi:2028
msgid "As an example,"
msgstr ""

#. type: example
#: ../../cl.texi:2034
#, no-wrap
msgid ""
"(cl-loop for sym being the symbols\n"
"         when (fboundp sym)\n"
"         when (string-match \"^map\" (symbol-name sym))\n"
"         collect sym)\n"
msgstr ""

#. type: table
#: ../../cl.texi:2038
msgid "returns a list of all the functions whose names begin with @samp{map}."
msgstr ""

#. type: table
#: ../../cl.texi:2041
msgid ""
"The Common Lisp words @code{external-symbols} and @code{present-symbols} are "
"also recognized but are equivalent to @code{symbols} in Emacs Lisp."
msgstr ""

#. type: table
#: ../../cl.texi:2048
msgid ""
"Due to a minor implementation restriction, it will not work to have more "
"than one @code{for} clause iterating over symbols, hash tables, keymaps, "
"overlays, or intervals in a given @code{cl-loop}.  Fortunately, it would "
"rarely if ever be useful to do so.  It @emph{is} valid to mix one of these "
"types of clauses with other clauses like @code{for @dots{} to} or "
"@code{while}."
msgstr ""

#. type: item
#: ../../cl.texi:2049
#, no-wrap
msgid "for @var{var} being the hash-keys of @var{hash-table}"
msgstr ""

#. type: itemx
#: ../../cl.texi:2050
#, no-wrap
msgid "for @var{var} being the hash-values of @var{hash-table}"
msgstr ""

#. type: table
#: ../../cl.texi:2054
msgid ""
"This clause iterates over the entries in @var{hash-table} with @var{var} "
"bound to each key, or value.  A @samp{using} clause can bind a second "
"variable to the opposite part."
msgstr ""

#. type: example
#: ../../cl.texi:2060
#, no-wrap
msgid ""
"(cl-loop for k being the hash-keys of h\n"
"               using (hash-values v)\n"
"         do\n"
"         (message \"key %S -> value %S\" k v))\n"
msgstr ""

#. type: item
#: ../../cl.texi:2062
#, no-wrap
msgid "for @var{var} being the key-codes of @var{keymap}"
msgstr ""

#. type: itemx
#: ../../cl.texi:2063
#, no-wrap
msgid "for @var{var} being the key-bindings of @var{keymap}"
msgstr ""

#. type: table
#: ../../cl.texi:2069
msgid ""
"This clause iterates over the entries in @var{keymap}.  The iteration does "
"not enter nested keymaps but does enter inherited (parent) keymaps.  A "
"@code{using} clause can access both the codes and the bindings together."
msgstr ""

#. type: example
#: ../../cl.texi:2075
#, no-wrap
msgid ""
"(cl-loop for c being the key-codes of (current-local-map)\n"
"               using (key-bindings b)\n"
"         do\n"
"         (message \"key %S -> binding %S\" c b))\n"
msgstr ""

#. type: item
#: ../../cl.texi:2078
#, no-wrap
msgid "for @var{var} being the key-seqs of @var{keymap}"
msgstr ""

#. type: table
#: ../../cl.texi:2085
msgid ""
"This clause iterates over all key sequences defined by @var{keymap} and its "
"nested keymaps, where @var{var} takes on values which are vectors.  The "
"strings or vectors are reused for each iteration, so you must copy them if "
"you wish to keep them permanently.  You can add a @samp{using (key-bindings "
"@dots{})} clause to get the command bindings as well."
msgstr ""

#. type: item
#: ../../cl.texi:2086
#, no-wrap
msgid "for @var{var} being the overlays [of @var{buffer}] @dots{}"
msgstr ""

#. type: table
#: ../../cl.texi:2094
msgid ""
"This clause iterates over the ``overlays'' of a buffer (the clause "
"@code{extents} is synonymous with @code{overlays}).  If the @code{of} term "
"is omitted, the current buffer is used.  This clause also accepts optional "
"@samp{from @var{pos}} and @samp{to @var{pos}} terms, limiting the clause to "
"overlays which overlap the specified region."
msgstr ""

#. type: item
#: ../../cl.texi:2095
#, no-wrap
msgid "for @var{var} being the intervals [of @var{buffer}] @dots{}"
msgstr ""

#. type: table
#: ../../cl.texi:2103
msgid ""
"This clause iterates over all intervals of a buffer with constant text "
"properties.  The variable @var{var} will be bound to conses of start and end "
"positions, where one start position is always equal to the previous end "
"position.  The clause allows @code{of}, @code{from}, @code{to}, and "
"@code{property} terms, where the latter term restricts the search to just "
"the specified property.  The @code{of} term may specify either a buffer or a "
"string."
msgstr ""

#. type: item
#: ../../cl.texi:2104
#, no-wrap
msgid "for @var{var} being the frames"
msgstr ""

#. type: table
#: ../../cl.texi:2108
msgid ""
"This clause iterates over all Emacs frames. The clause @code{screens} is a "
"synonym for @code{frames}.  The frames are visited in @code{next-frame} "
"order starting from @code{selected-frame}."
msgstr ""

#. type: item
#: ../../cl.texi:2109
#, no-wrap
msgid "for @var{var} being the windows [of @var{frame}]"
msgstr ""

#. type: table
#: ../../cl.texi:2117
msgid ""
"This clause iterates over the windows (in the Emacs sense) of the current "
"frame, or of the specified @var{frame}.  It visits windows in "
"@code{next-window} order starting from @code{selected-window} (or "
"@code{frame-selected-window} if you specify @var{frame}).  This clause "
"treats the minibuffer window in the same way as @code{next-window} does.  "
"For greater flexibility, consider using @code{walk-windows} instead."
msgstr ""

#. type: item
#: ../../cl.texi:2118
#, no-wrap
msgid "for @var{var} being the buffers"
msgstr ""

#. type: table
#: ../../cl.texi:2121
msgid ""
"This clause iterates over all buffers in Emacs.  It is equivalent to "
"@samp{for @var{var} in (buffer-list)}."
msgstr ""

#. type: item
#: ../../cl.texi:2122
#, no-wrap
msgid "for @var{var} = @var{expr1} then @var{expr2}"
msgstr ""

#. type: table
#: ../../cl.texi:2128
msgid ""
"This clause does a general iteration.  The first time through the loop, "
"@var{var} will be bound to @var{expr1}.  On the second and successive "
"iterations it will be set by evaluating @var{expr2} (which may refer to the "
"old value of @var{var}).  For example, these two loops are effectively the "
"same:"
msgstr ""

#. type: example
#: ../../cl.texi:2132
#, no-wrap
msgid ""
"(cl-loop for x on my-list by 'cddr do @dots{})\n"
"(cl-loop for x = my-list then (cddr x) while x do @dots{})\n"
msgstr ""

#. type: table
#: ../../cl.texi:2137
msgid ""
"Note that this type of @code{for} clause does not imply any sort of "
"terminating condition; the above example combines it with a @code{while} "
"clause to tell when to end the loop."
msgstr ""

#. type: table
#: ../../cl.texi:2140
msgid ""
"If you omit the @code{then} term, @var{expr1} is used both for the initial "
"setting and for successive settings:"
msgstr ""

#. type: example
#: ../../cl.texi:2143
#, no-wrap
msgid "(cl-loop for x = (random) when (> x 0) return x)\n"
msgstr ""

#. type: table
#: ../../cl.texi:2148
msgid ""
"This loop keeps taking random numbers from the @code{(random)} function "
"until it gets a positive one, which it then returns."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2155
msgid ""
"If you include several @code{for} clauses in a row, they are treated "
"sequentially (as if by @code{let*} and @code{setq}).  You can instead use "
"the word @code{and} to link the clauses, in which case they are processed in "
"parallel (as if by @code{let} and @code{cl-psetq})."
msgstr ""

#. type: example
#: ../../cl.texi:2161
#, no-wrap
msgid ""
"(cl-loop for x below 5 for y = nil then x collect (list x y))\n"
"        @result{} ((0 nil) (1 1) (2 2) (3 3) (4 4))\n"
"(cl-loop for x below 5 and y = nil then x collect (list x y))\n"
"        @result{} ((0 nil) (1 0) (2 1) (3 2) (4 3))\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:2169
msgid ""
"In the first loop, @code{y} is set based on the value of @code{x} that was "
"just set by the previous clause; in the second loop, @code{x} and @code{y} "
"are set simultaneously so @code{y} is set based on the value of @code{x} "
"left over from the previous time through the loop."
msgstr ""

#. type: cindex
#: ../../cl.texi:2170
#, no-wrap
msgid "destructuring, in cl-loop"
msgstr ""

#. type: Plain text
#: ../../cl.texi:2178
msgid ""
"Another feature of the @code{cl-loop} macro is @emph{destructuring}, similar "
"in concept to the destructuring provided by @code{defmacro} (@pxref{Argument "
"Lists}).  The @var{var} part of any @code{for} clause can be given as a list "
"of variables instead of a single variable.  The values produced during loop "
"execution must be lists; the values in the lists are stored in the "
"corresponding variables."
msgstr ""

#. type: example
#: ../../cl.texi:2182
#, no-wrap
msgid ""
"(cl-loop for (x y) in '((2 3) (4 5) (6 7)) collect (+ x y))\n"
"        @result{} (5 9 13)\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:2191
msgid ""
"In loop destructuring, if there are more values than variables the trailing "
"values are ignored, and if there are more variables than values the trailing "
"variables get the value @code{nil}.  If @code{nil} is used as a variable "
"name, the corresponding values are ignored.  Destructuring may be nested, "
"and dotted lists of variables like @code{(x . y)} are allowed, so for "
"example to process an alist"
msgstr ""

#. type: example
#: ../../cl.texi:2196
#, no-wrap
msgid ""
"(cl-loop for (key . value) in '((a . 1) (b . 2))\n"
"         collect value)\n"
"        @result{} (1 2)\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:2205
msgid ""
"Aside from @code{for} clauses, there are several other loop clauses that "
"control the way the loop operates.  They might be used by themselves, or in "
"conjunction with one or more @code{for} clauses."
msgstr ""

#. type: item
#: ../../cl.texi:2207
#, no-wrap
msgid "repeat @var{integer}"
msgstr ""

#. type: table
#: ../../cl.texi:2210
msgid ""
"This clause simply counts up to the specified number using an internal "
"temporary variable.  The loops"
msgstr ""

#. type: example
#: ../../cl.texi:2214
#, no-wrap
msgid ""
"(cl-loop repeat (1+ n) do @dots{})\n"
"(cl-loop for temp to n do @dots{})\n"
msgstr ""

#. type: table
#: ../../cl.texi:2219
msgid ""
"are identical except that the second one forces you to choose a name for a "
"variable you aren't actually going to use."
msgstr ""

#. type: item
#: ../../cl.texi:2220
#, no-wrap
msgid "while @var{condition}"
msgstr ""

#. type: table
#: ../../cl.texi:2225
msgid ""
"This clause stops the loop when the specified condition (any Lisp "
"expression) becomes @code{nil}.  For example, the following two loops are "
"equivalent, except for the implicit @code{nil} block that surrounds the "
"second one:"
msgstr ""

#. type: example
#: ../../cl.texi:2229
#, no-wrap
msgid ""
"(while @var{cond} @var{forms}@dots{})\n"
"(cl-loop while @var{cond} do @var{forms}@dots{})\n"
msgstr ""

#. type: item
#: ../../cl.texi:2231
#, no-wrap
msgid "until @var{condition}"
msgstr ""

#. type: table
#: ../../cl.texi:2234
msgid ""
"This clause stops the loop when the specified condition is true, i.e., "
"non-@code{nil}."
msgstr ""

#. type: item
#: ../../cl.texi:2235
#, no-wrap
msgid "always @var{condition}"
msgstr ""

#. type: table
#: ../../cl.texi:2240
msgid ""
"This clause stops the loop when the specified condition is @code{nil}.  "
"Unlike @code{while}, it stops the loop using @code{return nil} so that the "
"@code{finally} clauses are not executed.  If all the conditions were "
"non-@code{nil}, the loop returns @code{t}:"
msgstr ""

#. type: example
#: ../../cl.texi:2245
#, no-wrap
msgid ""
"(if (cl-loop for size in size-list always (> size 10))\n"
"    (only-big-sizes)\n"
"  (some-small-sizes))\n"
msgstr ""

#. type: item
#: ../../cl.texi:2247
#, no-wrap
msgid "never @var{condition}"
msgstr ""

#. type: table
#: ../../cl.texi:2250
msgid ""
"This clause is like @code{always}, except that the loop returns @code{t} if "
"any conditions were false, or @code{nil} otherwise."
msgstr ""

#. type: item
#: ../../cl.texi:2251
#, no-wrap
msgid "thereis @var{condition}"
msgstr ""

#. type: table
#: ../../cl.texi:2255
msgid ""
"This clause stops the loop when the specified form is non-@code{nil}; in "
"this case, it returns that non-@code{nil} value.  If all the values were "
"@code{nil}, the loop returns @code{nil}."
msgstr ""

#. type: item
#: ../../cl.texi:2256
#, no-wrap
msgid "iter-by @var{iterator}"
msgstr ""

#. type: table
#: ../../cl.texi:2260
msgid ""
"This clause iterates over the values from the specified form, an iterator "
"object.  See (@pxref{Generators,,,elisp,GNU Emacs Lisp Reference Manual})."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2269
msgid ""
"These clauses cause the loop to accumulate information about the specified "
"Lisp @var{form}.  The accumulated result is returned from the loop unless "
"overridden, say, by a @code{return} clause."
msgstr ""

#. type: item
#: ../../cl.texi:2271
#, no-wrap
msgid "collect @var{form}"
msgstr ""

#. type: table
#: ../../cl.texi:2274
msgid ""
"This clause collects the values of @var{form} into a list.  Several examples "
"of @code{collect} appear elsewhere in this manual."
msgstr ""

#. type: table
#: ../../cl.texi:2277
msgid ""
"The word @code{collecting} is a synonym for @code{collect}, and likewise for "
"the other accumulation clauses."
msgstr ""

#. type: item
#: ../../cl.texi:2278
#, no-wrap
msgid "append @var{form}"
msgstr ""

#. type: table
#: ../../cl.texi:2281
msgid "This clause collects lists of values into a result list using @code{append}."
msgstr ""

#. type: item
#: ../../cl.texi:2282
#, no-wrap
msgid "nconc @var{form}"
msgstr ""

#. type: table
#: ../../cl.texi:2285
msgid ""
"This clause collects lists of values into a result list by destructively "
"modifying the lists rather than copying them."
msgstr ""

#. type: item
#: ../../cl.texi:2286
#, no-wrap
msgid "concat @var{form}"
msgstr ""

#. type: table
#: ../../cl.texi:2290
msgid ""
"This clause concatenates the values of the specified @var{form} into a "
"string.  (It and the following clause are extensions to standard Common "
"Lisp.)"
msgstr ""

#. type: item
#: ../../cl.texi:2291
#, no-wrap
msgid "vconcat @var{form}"
msgstr ""

#. type: table
#: ../../cl.texi:2294
msgid ""
"This clause concatenates the values of the specified @var{form} into a "
"vector."
msgstr ""

#. type: item
#: ../../cl.texi:2295
#, no-wrap
msgid "count @var{form}"
msgstr ""

#. type: table
#: ../../cl.texi:2298
msgid ""
"This clause counts the number of times the specified @var{form} evaluates to "
"a non-@code{nil} value."
msgstr ""

#. type: item
#: ../../cl.texi:2299
#, no-wrap
msgid "sum @var{form}"
msgstr ""

#. type: table
#: ../../cl.texi:2302
msgid ""
"This clause accumulates the sum of the values of the specified @var{form}, "
"which must evaluate to a number."
msgstr ""

#. type: item
#: ../../cl.texi:2303
#, no-wrap
msgid "maximize @var{form}"
msgstr ""

#. type: table
#: ../../cl.texi:2307
msgid ""
"This clause accumulates the maximum value of the specified @var{form}, which "
"must evaluate to a number.  The return value is undefined if @code{maximize} "
"is executed zero times."
msgstr ""

#. type: item
#: ../../cl.texi:2308
#, no-wrap
msgid "minimize @var{form}"
msgstr ""

#. type: table
#: ../../cl.texi:2310
msgid "This clause accumulates the minimum value of the specified @var{form}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2319
msgid ""
"Accumulation clauses can be followed by @samp{into @var{var}} to cause the "
"data to be collected into variable @var{var} (which is automatically "
"@code{let}-bound during the loop) rather than an unnamed temporary "
"variable.  Also, @code{into} accumulations do not automatically imply a "
"return value.  The loop must use some explicit mechanism, such as "
"@code{finally return}, to return the accumulated result."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2322
msgid ""
"It is valid for several accumulation clauses of the same type to accumulate "
"into the same place.  From Steele:"
msgstr ""

#. type: example
#: ../../cl.texi:2329
#, no-wrap
msgid ""
"(cl-loop for name in '(fred sue alice joe june)\n"
"         for kids in '((bob ken) () () (kris sunshine) ())\n"
"         collect name\n"
"         append kids)\n"
"        @result{} (fred bob ken sue alice joe kris sunshine june)\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:2336
msgid "This section describes the remaining loop clauses."
msgstr ""

#. type: item
#: ../../cl.texi:2338
#, no-wrap
msgid "with @var{var} = @var{value}"
msgstr ""

#. type: table
#: ../../cl.texi:2342
msgid ""
"This clause binds a variable to a value around the loop, but otherwise "
"leaves the variable alone during the loop.  The following loops are "
"basically equivalent:"
msgstr ""

#. type: example
#: ../../cl.texi:2347
#, no-wrap
msgid ""
"(cl-loop with x = 17 do @dots{})\n"
"(let ((x 17)) (cl-loop do @dots{}))\n"
"(cl-loop for x = 17 then x do @dots{})\n"
msgstr ""

#. type: table
#: ../../cl.texi:2351
msgid ""
"Naturally, the variable @var{var} might be used for some purpose in the rest "
"of the loop.  For example:"
msgstr ""

#. type: example
#: ../../cl.texi:2355
#, no-wrap
msgid ""
"(cl-loop for x in my-list  with res = nil  do (push x res)\n"
"         finally return res)\n"
msgstr ""

#. type: table
#: ../../cl.texi:2363
msgid ""
"This loop inserts the elements of @code{my-list} at the front of a new list "
"being accumulated in @code{res}, then returns the list @code{res} at the end "
"of the loop.  The effect is similar to that of a @code{collect} clause, but "
"the list gets reversed by virtue of the fact that elements are being pushed "
"onto the front of @code{res} rather than the end."
msgstr ""

#. type: table
#: ../../cl.texi:2367
msgid ""
"If you omit the @code{=} term, the variable is initialized to @code{nil}.  "
"(Thus the @samp{= nil} in the above example is unnecessary.)"
msgstr ""

#. type: table
#: ../../cl.texi:2372
msgid ""
"Bindings made by @code{with} are sequential by default, as if by "
"@code{let*}.  Just like @code{for} clauses, @code{with} clauses can be "
"linked with @code{and} to cause the bindings to be made by @code{let} "
"instead."
msgstr ""

#. type: item
#: ../../cl.texi:2373
#, no-wrap
msgid "if @var{condition} @var{clause}"
msgstr ""

#. type: table
#: ../../cl.texi:2382
msgid ""
"This clause executes the following loop clause only if the specified "
"condition is true.  The following @var{clause} should be an accumulation, "
"@code{do}, @code{return}, @code{if}, or @code{unless} clause.  Several "
"clauses may be linked by separating them with @code{and}.  These clauses may "
"be followed by @code{else} and a clause or clauses to execute if the "
"condition was false.  The whole construct may optionally be followed by the "
"word @code{end} (which may be used to disambiguate an @code{else} or "
"@code{and} in a nested @code{if})."
msgstr ""

#. type: table
#: ../../cl.texi:2385
msgid ""
"The actual non-@code{nil} value of the condition form is available by the "
"name @code{it} in the ``then'' part.  For example:"
msgstr ""

#. type: example
#: ../../cl.texi:2401
#, no-wrap
msgid ""
"(setq funny-numbers '(6 13 -1))\n"
"     @result{} (6 13 -1)\n"
"(cl-loop for x below 10\n"
"         if (cl-oddp x)\n"
"           collect x into odds\n"
"           and if (memq x funny-numbers) return (cdr it) end\n"
"         else\n"
"           collect x into evens\n"
"         finally return (vector odds evens))\n"
"        @result{} [(1 3 5 7 9) (0 2 4 6 8)]\n"
"(setq funny-numbers '(6 7 13 -1))\n"
"     @result{} (6 7 13 -1)\n"
"(cl-loop <@r{same thing again}>)\n"
"        @result{} (13 -1)\n"
msgstr ""

#. type: table
#: ../../cl.texi:2412
msgid ""
"Note the use of @code{and} to put two clauses into the ``then'' part, one of "
"which is itself an @code{if} clause.  Note also that @code{end}, while "
"normally optional, was necessary here to make it clear that the @code{else} "
"refers to the outermost @code{if} clause.  In the first case, the loop "
"returns a vector of lists of the odd and even values of @var{x}.  In the "
"second case, the odd number 7 is one of the @code{funny-numbers} so the loop "
"returns early; the actual returned value is based on the result of the "
"@code{memq} call."
msgstr ""

#. type: item
#: ../../cl.texi:2413
#, no-wrap
msgid "when @var{condition} @var{clause}"
msgstr ""

#. type: table
#: ../../cl.texi:2415
msgid "This clause is just a synonym for @code{if}."
msgstr ""

#. type: item
#: ../../cl.texi:2416
#, no-wrap
msgid "unless @var{condition} @var{clause}"
msgstr ""

#. type: table
#: ../../cl.texi:2419
msgid ""
"The @code{unless} clause is just like @code{if} except that the sense of the "
"condition is reversed."
msgstr ""

#. type: item
#: ../../cl.texi:2420
#, no-wrap
msgid "named @var{name}"
msgstr ""

#. type: table
#: ../../cl.texi:2424
msgid ""
"This clause gives a name other than @code{nil} to the implicit block "
"surrounding the loop.  The @var{name} is the symbol to be used as the block "
"name."
msgstr ""

#. type: item
#: ../../cl.texi:2425
#, no-wrap
msgid "initially [do] @var{forms}@dots{}"
msgstr ""

#. type: table
#: ../../cl.texi:2432
msgid ""
"This keyword introduces one or more Lisp forms which will be executed before "
"the loop itself begins (but after any variables requested by @code{for} or "
"@code{with} have been bound to their initial values).  @code{initially} "
"clauses can appear anywhere; if there are several, they are executed in the "
"order they appear in the loop.  The keyword @code{do} is optional."
msgstr ""

#. type: item
#: ../../cl.texi:2433
#, no-wrap
msgid "finally [do] @var{forms}@dots{}"
msgstr ""

#. type: table
#: ../../cl.texi:2439
msgid ""
"This introduces Lisp forms which will be executed after the loop finishes "
"(say, on request of a @code{for} or @code{while}).  @code{initially} and "
"@code{finally} clauses may appear anywhere in the loop construct, but they "
"are executed (in the specified order) at the beginning or end, respectively, "
"of the loop."
msgstr ""

#. type: item
#: ../../cl.texi:2440
#, no-wrap
msgid "finally return @var{form}"
msgstr ""

#. type: table
#: ../../cl.texi:2447
msgid ""
"This says that @var{form} should be executed after the loop is done to "
"obtain a return value.  (Without this, or some other clause like "
"@code{collect} or @code{return}, the loop will simply return @code{nil}.)  "
"Variables bound by @code{for}, @code{with}, or @code{into} will still "
"contain their final values when @var{form} is executed."
msgstr ""

#. type: item
#: ../../cl.texi:2448
#, no-wrap
msgid "do @var{forms}@dots{}"
msgstr ""

#. type: table
#: ../../cl.texi:2453
msgid ""
"The word @code{do} may be followed by any number of Lisp expressions which "
"are executed as an implicit @code{progn} in the body of the loop.  Many of "
"the examples in this section illustrate the use of @code{do}."
msgstr ""

#. type: item
#: ../../cl.texi:2454
#, no-wrap
msgid "return @var{form}"
msgstr ""

#. type: table
#: ../../cl.texi:2461
msgid ""
"This clause causes the loop to return immediately.  The following Lisp form "
"is evaluated to give the return value of the loop form.  The @code{finally} "
"clauses, if any, are not executed.  Of course, @code{return} is generally "
"used inside an @code{if} or @code{unless}, as its use in a top-level loop "
"clause would mean the loop would never get to ``loop'' more than once."
msgstr ""

#. type: table
#: ../../cl.texi:2466
msgid ""
"The clause @samp{return @var{form}} is equivalent to @samp{do (cl-return "
"@var{form})} (or @code{cl-return-from} if the loop was named).  The "
"@code{return} clause is implemented a bit more efficiently, though."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2474
msgid ""
"While there is no high-level way to add user extensions to @code{cl-loop}, "
"this package does offer two properties called @code{cl-loop-handler} and "
"@code{cl-loop-for-handler} which are functions to be called when a given "
"symbol is encountered as a top-level loop clause or @code{for} clause, "
"respectively.  Consult the source code in file @file{cl-macs.el} for "
"details."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2480
msgid ""
"This package's @code{cl-loop} macro is compatible with that of Common Lisp, "
"except that a few features are not implemented: @code{loop-finish} and "
"data-type specifiers.  Naturally, the @code{for} clauses that iterate over "
"keymaps, overlays, intervals, frames, windows, and buffers are "
"Emacs-specific extensions."
msgstr ""

#. type: cindex
#: ../../cl.texi:2483
#, no-wrap
msgid "multiple values"
msgstr ""

#. type: Plain text
#: ../../cl.texi:2497
msgid ""
"Common Lisp functions can return zero or more results.  Emacs Lisp "
"functions, by contrast, always return exactly one result.  This package "
"makes no attempt to emulate Common Lisp multiple return values; Emacs "
"versions of Common Lisp functions that return more than one value either "
"return just the first value (as in @code{cl-compiler-macroexpand}) or return "
"a list of values.  This package @emph{does} define placeholders for the "
"Common Lisp functions that work with multiple values, but in Emacs Lisp "
"these functions simply operate on lists instead.  The @code{cl-values} form, "
"for example, is a synonym for @code{list} in Emacs."
msgstr ""

#. type: defmac
#: ../../cl.texi:2498
#, no-wrap
msgid "cl-multiple-value-bind (var@dots{}) values-form forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:2505
msgid ""
"This form evaluates @var{values-form}, which must return a list of values.  "
"It then binds the @var{var}s to these respective values, as if by "
"@code{let}, and then executes the body @var{forms}.  If there are more "
"@var{var}s than values, the extra @var{var}s are bound to @code{nil}.  If "
"there are fewer @var{var}s than values, the excess values are ignored."
msgstr ""

#. type: defmac
#: ../../cl.texi:2507
#, no-wrap
msgid "cl-multiple-value-setq (var@dots{}) form"
msgstr ""

#. type: defmac
#: ../../cl.texi:2512
msgid ""
"This form evaluates @var{form}, which must return a list of values.  It then "
"sets the @var{var}s to these respective values, as if by @code{setq}.  Extra "
"@var{var}s or values are treated the same as in "
"@code{cl-multiple-value-bind}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2516
msgid ""
"Since a perfect emulation is not feasible in Emacs Lisp, this package opts "
"to keep it as simple and predictable as possible."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2526
msgid ""
"This package implements the various Common Lisp features of @code{defmacro}, "
"such as destructuring, @code{&environment}, and @code{&body}.  Top-level "
"@code{&whole} is not implemented for @code{defmacro} due to technical "
"difficulties.  @xref{Argument Lists}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2529
msgid "Destructuring is made available to the user by way of the following macro:"
msgstr ""

#. type: defmac
#: ../../cl.texi:2530
#, no-wrap
msgid "cl-destructuring-bind arglist expr forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:2539
msgid ""
"This macro expands to code that executes @var{forms}, with the variables in "
"@var{arglist} bound to the list of values returned by @var{expr}.  The "
"@var{arglist} can include all the features allowed for @code{cl-defmacro} "
"argument lists, including destructuring.  (The @code{&environment} keyword "
"is not allowed.)  The macro expansion will signal an error if @var{expr} "
"returns a list of the wrong number of arguments or with incorrect keyword "
"arguments."
msgstr ""

#. type: cindex
#: ../../cl.texi:2541
#, no-wrap
msgid "compiler macros"
msgstr ""

#. type: cindex
#: ../../cl.texi:2542
#, no-wrap
msgid "define compiler macros"
msgstr ""

#. type: Plain text
#: ../../cl.texi:2546
msgid ""
"This package also includes the Common Lisp @code{define-compiler-macro} "
"facility, which allows you to define compile-time expansions and "
"optimizations for your functions."
msgstr ""

#. type: defmac
#: ../../cl.texi:2547
#, no-wrap
msgid "cl-define-compiler-macro name arglist forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:2552
msgid ""
"This form is similar to @code{defmacro}, except that it only expands calls "
"to @var{name} at compile-time; calls processed by the Lisp interpreter are "
"not expanded, nor are they expanded by the @code{macroexpand} function."
msgstr ""

#. type: defmac
#: ../../cl.texi:2560
msgid ""
"The argument list may begin with a @code{&whole} keyword and a variable.  "
"This variable is bound to the macro-call form itself, i.e., to a list of the "
"form @samp{(@var{name} @var{args}@dots{})}.  If the macro expander returns "
"this form unchanged, then the compiler treats it as a normal function call.  "
"This allows compiler macros to work as optimizers for special cases of a "
"function, leaving complicated cases alone."
msgstr ""

#. type: defmac
#: ../../cl.texi:2563
msgid ""
"For example, here is a simplified version of a definition that appears as a "
"standard part of this package:"
msgstr ""

#. type: example
#: ../../cl.texi:2571
#, no-wrap
msgid ""
"(cl-define-compiler-macro cl-member (&whole form a list &rest keys)\n"
"     (if (and (null keys)\n"
"              (eq (car-safe a) 'quote)\n"
"              (not (floatp (cadr a))))\n"
"         (list 'memq a list)\n"
"       form))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:2581
msgid ""
"This definition causes @code{(cl-member @var{a} @var{list})} to change to a "
"call to the faster @code{memq} in the common case where @var{a} is a "
"non-floating-point constant; if @var{a} is anything else, or if there are "
"any keyword arguments in the call, then the original @code{cl-member} call "
"is left intact.  (The actual compiler macro for @code{cl-member} optimizes a "
"number of other cases, including common @code{:test} predicates.)"
msgstr ""

#. type: defun
#: ../../cl.texi:2583
#, no-wrap
msgid "cl-compiler-macroexpand form"
msgstr ""

#. type: defun
#: ../../cl.texi:2591
msgid ""
"This function is analogous to @code{macroexpand}, except that it expands "
"compiler macros rather than regular macros.  It returns @var{form} unchanged "
"if it is not a call to a function for which a compiler macro has been "
"defined, or if that compiler macro decided to punt by returning its "
"@code{&whole} argument.  Like @code{macroexpand}, it expands repeatedly "
"until it reaches a form for which no further expansion is possible."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2596
msgid ""
"@xref{Macro Bindings}, for descriptions of the @code{cl-macrolet} and "
"@code{cl-symbol-macrolet} forms for making ``local'' macro definitions."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2608
msgid ""
"Common Lisp includes a complex and powerful ``declaration'' mechanism that "
"allows you to give the compiler special hints about the types of data that "
"will be stored in particular variables, and about the ways those variables "
"and functions will be used.  This package defines versions of all the Common "
"Lisp declaration forms: @code{declare}, @code{locally}, @code{proclaim}, "
"@code{declaim}, and @code{the}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2612
msgid ""
"Most of the Common Lisp declarations are not currently useful in Emacs "
"Lisp.  For example, the byte-code system provides little opportunity to "
"benefit from type information."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2619
msgid ""
"A few declarations are meaningful when byte compiler optimizations are "
"enabled, as they are by the default.  Otherwise these declarations will "
"effectively be ignored."
msgstr ""

#. type: defun
#: ../../cl.texi:2620
#, no-wrap
msgid "cl-proclaim decl-spec"
msgstr ""

#. type: defun
#: ../../cl.texi:2624
msgid ""
"This function records a ``global'' declaration specified by "
"@var{decl-spec}.  Since @code{cl-proclaim} is a function, @var{decl-spec} is "
"evaluated and thus should normally be quoted."
msgstr ""

#. type: defmac
#: ../../cl.texi:2626
#, no-wrap
msgid "cl-declaim decl-specs@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:2635
msgid ""
"This macro is like @code{cl-proclaim}, except that it takes any number of "
"@var{decl-spec} arguments, and the arguments are unevaluated and unquoted.  "
"The @code{cl-declaim} macro also puts @code{(cl-eval-when (compile load "
"eval) @dots{})} around the declarations so that they will be registered at "
"compile-time as well as at run-time.  (This is vital, since normally the "
"declarations are meant to influence the way the compiler treats the rest of "
"the file that contains the @code{cl-declaim} form.)"
msgstr ""

#. type: defmac
#: ../../cl.texi:2637
#, no-wrap
msgid "cl-declare decl-specs@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:2644
msgid ""
"This macro is used to make declarations within functions and other code.  "
"Common Lisp allows declarations in various locations, generally at the "
"beginning of any of the many ``implicit @code{progn}s'' throughout Lisp "
"syntax, such as function bodies, @code{let} bodies, etc.  Currently the only "
"declaration understood by @code{cl-declare} is @code{special}."
msgstr ""

#. type: defmac
#: ../../cl.texi:2646
#, no-wrap
msgid "cl-locally declarations@dots{} forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:2648
msgid "In this package, @code{cl-locally} is no different from @code{progn}."
msgstr ""

#. type: defmac
#: ../../cl.texi:2650
#, no-wrap
msgid "cl-the type form"
msgstr ""

#. type: defmac
#: ../../cl.texi:2655
msgid ""
"@code{cl-the} returns the value of @code{form}, first checking (if "
"optimization settings permit) that it is of type @code{type}.  Future "
"byte-compiler optimizations may also make use of this information to improve "
"runtime efficiency."
msgstr ""

#. type: defmac
#: ../../cl.texi:2663
msgid ""
"For example, @code{mapcar} can map over both lists and arrays.  It is hard "
"for the compiler to expand @code{mapcar} into an in-line loop unless it "
"knows whether the sequence will be a list or an array ahead of time.  With "
"@code{(mapcar 'car (cl-the vector foo))}, a future compiler would have "
"enough information to expand the loop in-line.  For now, Emacs Lisp will "
"treat the above code as exactly equivalent to @code{(mapcar 'car foo)}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2672
msgid ""
"Each @var{decl-spec} in a @code{cl-proclaim}, @code{cl-declaim}, or "
"@code{cl-declare} should be a list beginning with a symbol that says what "
"kind of declaration it is.  This package currently understands "
"@code{special}, @code{inline}, @code{notinline}, @code{optimize}, and "
"@code{warn} declarations.  (The @code{warn} declaration is an extension of "
"standard Common Lisp.)  Other Common Lisp declarations, such as @code{type} "
"and @code{ftype}, are silently ignored."
msgstr ""

#. type: item
#: ../../cl.texi:2674
#, no-wrap
msgid "special"
msgstr ""

#. type: table
#: ../../cl.texi:2683
msgid ""
"Since all variables in Emacs Lisp are ``special'' (in the Common Lisp "
"sense), @code{special} declarations are only advisory.  They simply tell the "
"byte compiler that the specified variables are intentionally being referred "
"to without being bound in the body of the function.  The compiler normally "
"emits warnings for such references, since they could be typographical errors "
"for references to local variables."
msgstr ""

#. type: table
#: ../../cl.texi:2686
msgid ""
"The declaration @code{(cl-declare (special @var{var1} @var{var2}))} is "
"equivalent to @code{(defvar @var{var1}) (defvar @var{var2})}."
msgstr ""

#. type: table
#: ../../cl.texi:2690
msgid ""
"In top-level contexts, it is generally better to write @code{(defvar "
"@var{var})} than @code{(cl-declaim (special @var{var}))}, since "
"@code{defvar} makes your intentions clearer."
msgstr ""

#. type: item
#: ../../cl.texi:2691
#, no-wrap
msgid "inline"
msgstr ""

#. type: table
#: ../../cl.texi:2700
msgid ""
"The @code{inline} @var{decl-spec} lists one or more functions whose bodies "
"should be expanded ``in-line'' into calling functions whenever the compiler "
"is able to arrange for it.  For example, the function @code{cl-acons} is "
"declared @code{inline} by this package so that the form @code{(cl-acons "
"@var{key} @var{value} @var{alist})} will expand directly into @code{(cons "
"(cons @var{key} @var{value}) @var{alist})} when it is called in user "
"functions, so as to save function calls."
msgstr ""

#. type: table
#: ../../cl.texi:2704
msgid ""
"The following declarations are all equivalent.  Note that the "
"@code{defsubst} form is a convenient way to define a function and declare it "
"inline all at once."
msgstr ""

#. type: example
#: ../../cl.texi:2710
#, no-wrap
msgid ""
"(cl-declaim (inline foo bar))\n"
"(cl-eval-when (compile load eval)\n"
"  (cl-proclaim '(inline foo bar)))\n"
"(defsubst foo (@dots{}) @dots{})       ; instead of defun\n"
msgstr ""

#. type: table
#: ../../cl.texi:2717
msgid ""
"@strong{Please note:} this declaration remains in effect after the "
"containing source file is done.  It is correct to use it to request that a "
"function you have defined should be inlined, but it is impolite to use it to "
"request inlining of an external function."
msgstr ""

#. type: table
#: ../../cl.texi:2723
msgid ""
"In Common Lisp, it is possible to use @code{(declare (inline @dots{}))} "
"before a particular call to a function to cause just that call to be "
"inlined; the current byte compilers provide no way to implement this, so "
"@code{(cl-declare (inline @dots{}))} is currently ignored by this package."
msgstr ""

#. type: item
#: ../../cl.texi:2724
#, no-wrap
msgid "notinline"
msgstr ""

#. type: table
#: ../../cl.texi:2728
msgid ""
"The @code{notinline} declaration lists functions which should not be inlined "
"after all; it cancels a previous @code{inline} declaration."
msgstr ""

#. type: item
#: ../../cl.texi:2729
#, no-wrap
msgid "optimize"
msgstr ""

#. type: table
#: ../../cl.texi:2732
msgid ""
"This declaration controls how much optimization is performed by the "
"compiler."
msgstr ""

#. type: table
#: ../../cl.texi:2739
msgid ""
"The word @code{optimize} is followed by any number of lists like "
"@code{(speed 3)} or @code{(safety 2)}.  Common Lisp defines several "
"optimization ``qualities''; this package ignores all but @code{speed} and "
"@code{safety}.  The value of a quality should be an integer from 0 to 3, "
"with 0 meaning ``unimportant'' and 3 meaning ``very important''.  The "
"default level for both qualities is 1."
msgstr ""

#. type: table
#: ../../cl.texi:2750
msgid ""
"In this package, the @code{speed} quality is tied to the "
"@code{byte-optimize} flag, which is set to @code{nil} for @code{(speed 0)} "
"and to @code{t} for higher settings; and the @code{safety} quality is tied "
"to the @code{byte-compile-delete-errors} flag, which is set to @code{nil} "
"for @code{(safety 3)} and to @code{t} for all lower settings.  (The latter "
"flag controls whether the compiler is allowed to optimize out code whose "
"only side-effect could be to signal an error, e.g., rewriting @code{(progn "
"foo bar)} to @code{bar} when it is not known whether @code{foo} will be "
"bound at run-time.)"
msgstr ""

#. type: table
#: ../../cl.texi:2756
msgid ""
"Note that even compiling with @code{(safety 0)}, the Emacs byte-code system "
"provides sufficient checking to prevent real harm from being done.  For "
"example, barring serious bugs in Emacs itself, Emacs will not crash with a "
"segmentation fault just because of an error in a fully-optimized Lisp "
"program."
msgstr ""

#. type: table
#: ../../cl.texi:2764
msgid ""
"The @code{optimize} declaration is normally used in a top-level "
"@code{cl-proclaim} or @code{cl-declaim} in a file; Common Lisp allows it to "
"be used with @code{declare} to set the level of optimization locally for a "
"given form, but this will not work correctly with the current "
"byte-compiler.  (The @code{cl-declare} will set the new optimization level, "
"but that level will not automatically be unset after the enclosing form is "
"done.)"
msgstr ""

#. type: item
#: ../../cl.texi:2765
#, no-wrap
msgid "warn"
msgstr ""

#. type: table
#: ../../cl.texi:2775
msgid ""
"This declaration controls what sorts of warnings are generated by the byte "
"compiler.  The word @code{warn} is followed by any number of ``warning "
"qualities'', similar in form to optimization qualities.  The currently "
"supported warning types are @code{redefine}, @code{callargs}, "
"@code{unresolved}, and @code{free-vars}; in the current system, a value of 0 "
"will disable these warnings and any higher value will enable them.  See the "
"documentation of the variable @code{byte-compile-warnings} for more details."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2783
msgid ""
"This package defines several symbol-related features that were missing from "
"Emacs Lisp."
msgstr ""

#. type: section
#: ../../cl.texi:2787 ../../cl.texi:2789 ../../cl.texi:2790
#, no-wrap
msgid "Property Lists"
msgstr ""

#. type: menuentry
#: ../../cl.texi:2787
msgid "@code{cl-get}, @code{cl-remprop}, @code{cl-getf}, @code{cl-remf}."
msgstr ""

#. type: section
#: ../../cl.texi:2787 ../../cl.texi:2870 ../../cl.texi:2871
#, no-wrap
msgid "Creating Symbols"
msgstr ""

#. type: menuentry
#: ../../cl.texi:2787
msgid "@code{cl-gensym}, @code{cl-gentemp}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2797
msgid ""
"These functions augment the standard Emacs Lisp functions @code{get} and "
"@code{put} for operating on properties attached to symbols.  There are also "
"functions for working with property lists as first-class data structures not "
"attached to particular symbols."
msgstr ""

#. type: defun
#: ../../cl.texi:2798
#, no-wrap
msgid "cl-get symbol property &optional default"
msgstr ""

#. type: defun
#: ../../cl.texi:2804
msgid ""
"This function is like @code{get}, except that if the property is not found, "
"the @var{default} argument provides the return value.  (The Emacs Lisp "
"@code{get} function always uses @code{nil} as the default; this package's "
"@code{cl-get} is equivalent to Common Lisp's @code{get}.)"
msgstr ""

#. type: defun
#: ../../cl.texi:2807
msgid ""
"The @code{cl-get} function is @code{setf}-able; when used in this fashion, "
"the @var{default} argument is allowed but ignored."
msgstr ""

#. type: defun
#: ../../cl.texi:2809
#, no-wrap
msgid "cl-remprop symbol property"
msgstr ""

#. type: defun
#: ../../cl.texi:2818
msgid ""
"This function removes the entry for @var{property} from the property list of "
"@var{symbol}.  It returns a true value if the property was indeed found and "
"removed, or @code{nil} if there was no such property.  (This function was "
"probably omitted from Emacs originally because, since @code{get} did not "
"allow a @var{default}, it was very difficult to distinguish between a "
"missing property and a property whose value was @code{nil}; thus, setting a "
"property to @code{nil} was close enough to @code{cl-remprop} for most "
"purposes.)"
msgstr ""

#. type: defun
#: ../../cl.texi:2820
#, no-wrap
msgid "cl-getf place property &optional default"
msgstr ""

#. type: defun
#: ../../cl.texi:2827
msgid ""
"This function scans the list @var{place} as if it were a property list, "
"i.e., a list of alternating property names and values.  If an even-numbered "
"element of @var{place} is found which is @code{eq} to @var{property}, the "
"following odd-numbered element is returned.  Otherwise, @var{default} is "
"returned (or @code{nil} if no default is given)."
msgstr ""

#. type: defun
#: ../../cl.texi:2829
msgid "In particular,"
msgstr ""

#. type: example
#: ../../cl.texi:2832
#, no-wrap
msgid "(get sym prop)  @equiv{}  (cl-getf (symbol-plist sym) prop)\n"
msgstr ""

#. type: defun
#: ../../cl.texi:2840
msgid ""
"It is valid to use @code{cl-getf} as a @code{setf} place, in which case its "
"@var{place} argument must itself be a valid @code{setf} place.  The "
"@var{default} argument, if any, is ignored in this context.  The effect is "
"to change (via @code{setcar}) the value cell in the list that corresponds to "
"@var{property}, or to cons a new property-value pair onto the list if the "
"property is not yet present."
msgstr ""

#. type: example
#: ../../cl.texi:2843
#, no-wrap
msgid "(put sym prop val) @equiv{} (setf (cl-getf (symbol-plist sym) prop) val)\n"
msgstr ""

#. type: defun
#: ../../cl.texi:2847
msgid ""
"The @code{get} and @code{cl-get} functions are also @code{setf}-able.  The "
"fact that @code{default} is ignored can sometimes be useful:"
msgstr ""

#. type: example
#: ../../cl.texi:2850
#, no-wrap
msgid "(cl-incf (cl-get 'foo 'usage-count 0))\n"
msgstr ""

#. type: defun
#: ../../cl.texi:2854
msgid ""
"Here, symbol @code{foo}'s @code{usage-count} property is incremented if it "
"exists, or set to 1 (an incremented 0) otherwise."
msgstr ""

#. type: defun
#: ../../cl.texi:2858
msgid ""
"When not used as a @code{setf} form, @code{cl-getf} is just a regular "
"function and its @var{place} argument can actually be any Lisp expression."
msgstr ""

#. type: defmac
#: ../../cl.texi:2860
#, no-wrap
msgid "cl-remf place property"
msgstr ""

#. type: defmac
#: ../../cl.texi:2868
msgid ""
"This macro removes the property-value pair for @var{property} from the "
"property list stored at @var{place}, which is any @code{setf}-able place "
"expression.  It returns true if the property was found.  Note that if "
"@var{property} happens to be first on the list, this will effectively do a "
"@code{(setf @var{place} (cddr @var{place}))}, whereas if it occurs later, "
"this simply uses @code{setcdr} to splice out the property and value cells."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2876
msgid ""
"These functions create unique symbols, typically for use as temporary "
"variables."
msgstr ""

#. type: defun
#: ../../cl.texi:2877
#, no-wrap
msgid "cl-gensym &optional x"
msgstr ""

#. type: defun
#: ../../cl.texi:2887
msgid ""
"This function creates a new, uninterned symbol (using @code{make-symbol})  "
"with a unique name.  (The name of an uninterned symbol is relevant only if "
"the symbol is printed.)  By default, the name is generated from an "
"increasing sequence of numbers, @samp{G1000}, @samp{G1001}, @samp{G1002}, "
"etc.  If the optional argument @var{x} is a string, that string is used as a "
"prefix instead of @samp{G}.  Uninterned symbols are used in macro expansions "
"for temporary variables, to ensure that their names will not conflict with "
"``real'' variables in the user's code."
msgstr ""

#. type: defun
#: ../../cl.texi:2891
msgid ""
"(Internally, the variable @code{cl--gensym-counter} holds the counter used "
"to generate names.  It is initialized with zero and incremented after each "
"use.)"
msgstr ""

#. type: defun
#: ../../cl.texi:2893
#, no-wrap
msgid "cl-gentemp &optional x"
msgstr ""

#. type: defun
#: ../../cl.texi:2898
msgid ""
"This function is like @code{cl-gensym}, except that it produces a new "
"@emph{interned} symbol.  If the symbol that is generated already exists, the "
"function keeps incrementing the counter and trying again until a new symbol "
"is generated."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2905
msgid ""
"This package automatically creates all keywords that are called for by "
"@code{&key} argument specifiers, and discourages the use of keywords as data "
"unrelated to keyword arguments, so the related function @code{defkeyword} "
"(to create self-quoting keyword symbols) is not provided."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2912
msgid ""
"This section defines a few simple Common Lisp operations on numbers that "
"were left out of Emacs Lisp."
msgstr ""

#. type: section
#: ../../cl.texi:2918 ../../cl.texi:2920 ../../cl.texi:2921
#, no-wrap
msgid "Predicates on Numbers"
msgstr ""

#. type: menuentry
#: ../../cl.texi:2918
msgid "@code{cl-plusp}, @code{cl-oddp}, etc."
msgstr ""

#. type: section
#: ../../cl.texi:2918 ../../cl.texi:2953 ../../cl.texi:2954
#, no-wrap
msgid "Numerical Functions"
msgstr ""

#. type: menuentry
#: ../../cl.texi:2918
msgid "@code{cl-floor}, @code{cl-ceiling}, etc."
msgstr ""

#. type: section
#: ../../cl.texi:2918 ../../cl.texi:3045 ../../cl.texi:3046
#, no-wrap
msgid "Random Numbers"
msgstr ""

#. type: menuentry
#: ../../cl.texi:2918
msgid "@code{cl-random}, @code{cl-make-random-state}."
msgstr ""

#. type: section
#: ../../cl.texi:2918 ../../cl.texi:3101 ../../cl.texi:3102
#, no-wrap
msgid "Implementation Parameters"
msgstr ""

#. type: menuentry
#: ../../cl.texi:2918
msgid "@code{cl-most-positive-float}, etc."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2926
msgid ""
"These functions return @code{t} if the specified condition is true of the "
"numerical argument, or @code{nil} otherwise."
msgstr ""

#. type: defun
#: ../../cl.texi:2927
#, no-wrap
msgid "cl-plusp number"
msgstr ""

#. type: defun
#: ../../cl.texi:2930
msgid ""
"This predicate tests whether @var{number} is positive.  It is an error if "
"the argument is not a number."
msgstr ""

#. type: defun
#: ../../cl.texi:2932
#, no-wrap
msgid "cl-minusp number"
msgstr ""

#. type: defun
#: ../../cl.texi:2935
msgid ""
"This predicate tests whether @var{number} is negative.  It is an error if "
"the argument is not a number."
msgstr ""

#. type: defun
#: ../../cl.texi:2937
#, no-wrap
msgid "cl-oddp integer"
msgstr ""

#. type: defun
#: ../../cl.texi:2940
msgid ""
"This predicate tests whether @var{integer} is odd.  It is an error if the "
"argument is not an integer."
msgstr ""

#. type: defun
#: ../../cl.texi:2942
#, no-wrap
msgid "cl-evenp integer"
msgstr ""

#. type: defun
#: ../../cl.texi:2945
msgid ""
"This predicate tests whether @var{integer} is even.  It is an error if the "
"argument is not an integer."
msgstr ""

#. type: defun
#: ../../cl.texi:2947
#, no-wrap
msgid "cl-digit-char-p char radix"
msgstr ""

#. type: defun
#: ../../cl.texi:2951
msgid ""
"Test if @var{char} is a digit in the specified @var{radix} (default is 10).  "
"If it is, return the numerical value of digit @var{char} in @var{radix}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:2958
msgid "These functions perform various arithmetic operations on numbers."
msgstr ""

#. type: defun
#: ../../cl.texi:2959
#, no-wrap
msgid "cl-gcd &rest integers"
msgstr ""

#. type: defun
#: ../../cl.texi:2963
msgid ""
"This function returns the Greatest Common Divisor of the arguments.  For one "
"argument, it returns the absolute value of that argument.  For zero "
"arguments, it returns zero."
msgstr ""

#. type: defun
#: ../../cl.texi:2965
#, no-wrap
msgid "cl-lcm &rest integers"
msgstr ""

#. type: defun
#: ../../cl.texi:2969
msgid ""
"This function returns the Least Common Multiple of the arguments.  For one "
"argument, it returns the absolute value of that argument.  For zero "
"arguments, it returns one."
msgstr ""

#. type: defun
#: ../../cl.texi:2971
#, no-wrap
msgid "cl-isqrt integer"
msgstr ""

#. type: defun
#: ../../cl.texi:2975
msgid ""
"This function computes the ``integer square root'' of its integer argument, "
"i.e., the greatest integer less than or equal to the true square root of the "
"argument."
msgstr ""

#. type: defun
#: ../../cl.texi:2977
#, no-wrap
msgid "cl-floor number &optional divisor"
msgstr ""

#. type: defun
#: ../../cl.texi:2986
msgid ""
"With one argument, @code{cl-floor} returns a list of two numbers: The "
"argument rounded down (toward minus infinity) to an integer, and the "
"``remainder'' which would have to be added back to the first return value to "
"yield the argument again.  If the argument is an integer @var{x}, the result "
"is always the list @code{(@var{x} 0)}.  If the argument is a floating-point "
"number, the first result is a Lisp integer and the second is a Lisp float "
"between 0 (inclusive) and 1 (exclusive)."
msgstr ""

#. type: defun
#: ../../cl.texi:2995
msgid ""
"With two arguments, @code{cl-floor} divides @var{number} by @var{divisor}, "
"and returns the floor of the quotient and the corresponding remainder as a "
"list of two numbers.  If @code{(cl-floor @var{x} @var{y})} returns "
"@code{(@var{q} @var{r})}, then @code{@var{q}*@var{y} + @var{r} = @var{x}}, "
"with @var{r} between 0 (inclusive) and @var{r} (exclusive).  Also, note that "
"@code{(cl-floor @var{x})} is exactly equivalent to @code{(cl-floor @var{x} "
"1)}."
msgstr ""

#. type: defun
#: ../../cl.texi:2999
msgid ""
"This function is entirely compatible with Common Lisp's @code{floor} "
"function, except that it returns the two results in a list since Emacs Lisp "
"does not support multiple-valued functions."
msgstr ""

#. type: defun
#: ../../cl.texi:3001
#, no-wrap
msgid "cl-ceiling number &optional divisor"
msgstr ""

#. type: defun
#: ../../cl.texi:3006
msgid ""
"This function implements the Common Lisp @code{ceiling} function, which is "
"analogous to @code{floor} except that it rounds the argument or quotient of "
"the arguments up toward plus infinity.  The remainder will be between 0 and "
"minus @var{r}."
msgstr ""

#. type: defun
#: ../../cl.texi:3008
#, no-wrap
msgid "cl-truncate number &optional divisor"
msgstr ""

#. type: defun
#: ../../cl.texi:3015
msgid ""
"This function implements the Common Lisp @code{truncate} function, which is "
"analogous to @code{floor} except that it rounds the argument or quotient of "
"the arguments toward zero.  Thus it is equivalent to @code{cl-floor} if the "
"argument or quotient is positive, or to @code{cl-ceiling} otherwise.  The "
"remainder has the same sign as @var{number}."
msgstr ""

#. type: defun
#: ../../cl.texi:3017
#, no-wrap
msgid "cl-round number &optional divisor"
msgstr ""

#. type: defun
#: ../../cl.texi:3023
msgid ""
"This function implements the Common Lisp @code{round} function, which is "
"analogous to @code{floor} except that it rounds the argument or quotient of "
"the arguments to the nearest integer.  In the case of a tie (the argument or "
"quotient is exactly halfway between two integers), it rounds to the even "
"integer."
msgstr ""

#. type: defun
#: ../../cl.texi:3025
#, no-wrap
msgid "cl-mod number divisor"
msgstr ""

#. type: defun
#: ../../cl.texi:3028
msgid ""
"This function returns the same value as the second return value of "
"@code{cl-floor}."
msgstr ""

#. type: defun
#: ../../cl.texi:3030
#, no-wrap
msgid "cl-rem number divisor"
msgstr ""

#. type: defun
#: ../../cl.texi:3033
msgid ""
"This function returns the same value as the second return value of "
"@code{cl-truncate}."
msgstr ""

#. type: defun
#: ../../cl.texi:3035
#, no-wrap
msgid "cl-parse-integer string &key start end radix junk-allowed"
msgstr ""

#. type: defun
#: ../../cl.texi:3043
msgid ""
"This function implements the Common Lisp @code{parse-integer} function.  It "
"parses an integer in the specified @var{radix} from the substring of "
"@var{string} between @var{start} and @var{end}.  Any leading and trailing "
"whitespace chars are ignored.  The function signals an error if the "
"substring between @var{start} and @var{end} cannot be parsed as an integer, "
"unless @var{junk-allowed} is non-@code{nil}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3055
msgid ""
"This package also provides an implementation of the Common Lisp random "
"number generator.  It uses its own additive-congruential algorithm, which is "
"much more likely to give statistically clean random numbers than the simple "
"generators supplied by many operating systems."
msgstr ""

#. type: defun
#: ../../cl.texi:3056
#, no-wrap
msgid "cl-random number &optional state"
msgstr ""

#. type: defun
#: ../../cl.texi:3068
msgid ""
"This function returns a random nonnegative number less than @var{number}, "
"and of the same type (either integer or floating-point).  The @var{state} "
"argument should be a @code{random-state} object that holds the state of the "
"random number generator.  The function modifies this state object as a side "
"effect.  If @var{state} is omitted, it defaults to the internal variable "
"@code{cl--random-state}, which contains a pre-initialized default "
"@code{random-state} object.  (Since any number of programs in the Emacs "
"process may be accessing @code{cl--random-state} in interleaved fashion, the "
"sequence generated from this will be irreproducible for all intents and "
"purposes.)"
msgstr ""

#. type: defun
#: ../../cl.texi:3070
#, no-wrap
msgid "cl-make-random-state &optional state"
msgstr ""

#. type: defun
#: ../../cl.texi:3078
msgid ""
"This function creates or copies a @code{random-state} object.  If "
"@var{state} is omitted or @code{nil}, it returns a new copy of "
"@code{cl--random-state}.  This is a copy in the sense that future sequences "
"of calls to @code{(cl-random @var{n})} and @code{(cl-random @var{n} "
"@var{s})} (where @var{s} is the new random-state object) will return "
"identical sequences of random numbers."
msgstr ""

#. type: defun
#: ../../cl.texi:3086
msgid ""
"If @var{state} is a @code{random-state} object, this function returns a copy "
"of that object.  If @var{state} is @code{t}, this function returns a new "
"@code{random-state} object seeded from the date and time.  As an extension "
"to Common Lisp, @var{state} may also be an integer in which case the new "
"object is seeded from that integer; each different integer seed will result "
"in a completely different sequence of random numbers."
msgstr ""

#. type: defun
#: ../../cl.texi:3094
msgid ""
"It is valid to print a @code{random-state} object to a buffer or file and "
"later read it back with @code{read}.  If a program wishes to use a sequence "
"of pseudo-random numbers which can be reproduced later for debugging, it can "
"call @code{(cl-make-random-state t)} to get a new sequence, then print this "
"sequence to a file.  When the program is later rerun, it can read the "
"original run's random-state from the file."
msgstr ""

#. type: defun
#: ../../cl.texi:3096
#, no-wrap
msgid "cl-random-state-p object"
msgstr ""

#. type: defun
#: ../../cl.texi:3099
msgid ""
"This predicate returns @code{t} if @var{object} is a @code{random-state} "
"object, or @code{nil} otherwise."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3107
msgid ""
"This package defines several useful constants having to do with "
"floating-point numbers."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3112
msgid ""
"It determines their values by exercising the computer's floating-point "
"arithmetic in various ways.  Because this operation might be slow, the code "
"for initializing them is kept in a separate function that must be called "
"before the parameters can be used."
msgstr ""

#. type: defun
#: ../../cl.texi:3113
#, no-wrap
msgid "cl-float-limits"
msgstr ""

#. type: defun
#: ../../cl.texi:3119
msgid ""
"This function makes sure that the Common Lisp floating-point parameters like "
"@code{cl-most-positive-float} have been initialized.  Until it is called, "
"these parameters have unspecified values.  If the parameters have already "
"been initialized, the function returns immediately."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3128
msgid ""
"Since true Common Lisp supports up to four different kinds of floating-point "
"numbers, it has families of constants like "
"@code{most-positive-single-float}, @code{most-positive-double-float}, "
"@code{most-positive-long-float}, and so on.  This package uses just one set "
"of constants because Emacs has only one kind of floating-point number, "
"namely the IEEE binary64 floating-point format.  @xref{Float "
"Basics,,,elisp,GNU Emacs Lisp Reference Manual}."
msgstr ""

#. type: defvar
#: ../../cl.texi:3129
#, no-wrap
msgid "cl-most-positive-float"
msgstr ""

#. type: defvar
#: ../../cl.texi:3133
msgid ""
"This constant equals the largest finite value a Lisp float can hold.  For "
"IEEE binary64 format, this equals @code{(- (expt 2 1024) (expt 2 971))}, "
"which equals @code{1.7976931348623157e+308}."
msgstr ""

#. type: defvar
#: ../../cl.texi:3135
#, no-wrap
msgid "cl-most-negative-float"
msgstr ""

#. type: defvar
#: ../../cl.texi:3138
msgid ""
"This constant equals the most negative finite value a Lisp float can hold.  "
"For IEEE binary64 format, this equals @code{(- cl-most-positive-float)}."
msgstr ""

#. type: defvar
#: ../../cl.texi:3140
#, no-wrap
msgid "cl-least-positive-normalized-float"
msgstr ""

#. type: defvar
#: ../../cl.texi:3145
msgid ""
"This constant equals the smallest positive Lisp float that is "
"@dfn{normalized}, i.e., that has full precision.  For IEEE binary64 format, "
"this equals @code{(expt 2 -1022)}, which equals "
"@code{2.2250738585072014e-308}."
msgstr ""

#. type: defvar
#: ../../cl.texi:3147
#, no-wrap
msgid "cl-least-positive-float"
msgstr ""

#. type: defvar
#: ../../cl.texi:3152
msgid ""
"This constant equals the smallest Lisp float value greater than zero.  For "
"IEEE binary64 format, this equals @code{5e-324} (which equals @code{(expt 2 "
"-1074)}) if subnormal numbers are supported, and "
"@code{cl-least-positive-normalized-float} otherwise."
msgstr ""

#. type: defvar
#: ../../cl.texi:3154
#, no-wrap
msgid "cl-least-negative-float"
msgstr ""

#. type: defvar
#: ../../cl.texi:3156
msgid "This constant is the negative counterpart of @code{cl-least-positive-float}."
msgstr ""

#. type: defvar
#: ../../cl.texi:3158
#, no-wrap
msgid "cl-least-negative-normalized-float"
msgstr ""

#. type: defvar
#: ../../cl.texi:3161
msgid ""
"This constant is the negative counterpart of "
"@code{cl-least-positive-normalized-float}."
msgstr ""

#. type: defvar
#: ../../cl.texi:3163
#, no-wrap
msgid "cl-float-epsilon"
msgstr ""

#. type: defvar
#: ../../cl.texi:3168
msgid ""
"This constant is the smallest positive Lisp float that can be added to 1.0 "
"to produce a distinct value.  Adding a smaller number to 1.0 will yield 1.0 "
"again due to roundoff.  For IEEE binary64 format, this equals @code{(expt 2 "
"-52)}, which equals @code{2.220446049250313e-16}."
msgstr ""

#. type: defvar
#: ../../cl.texi:3170
#, no-wrap
msgid "cl-float-negative-epsilon"
msgstr ""

#. type: defvar
#: ../../cl.texi:3174
msgid ""
"This is the smallest positive value that can be subtracted from 1.0 to "
"produce a distinct value.  For IEEE binary64 format, this equals @code{(expt "
"2 -53)}, which equals @code{1.1102230246251565e-16}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3184
msgid ""
"Common Lisp defines a number of functions that operate on @dfn{sequences}, "
"which are either lists, strings, or vectors.  Emacs Lisp includes a few of "
"these, notably @code{elt} and @code{length}; this package defines most of "
"the rest."
msgstr ""

#. type: section
#: ../../cl.texi:3191 ../../cl.texi:3193 ../../cl.texi:3194
#, no-wrap
msgid "Sequence Basics"
msgstr ""

#. type: menuentry
#: ../../cl.texi:3191
msgid "Arguments shared by all sequence functions."
msgstr ""

#. type: section
#: ../../cl.texi:3191 ../../cl.texi:3270 ../../cl.texi:3271
#, no-wrap
msgid "Mapping over Sequences"
msgstr ""

#. type: menuentry
#: ../../cl.texi:3191
msgid "@code{cl-mapcar}, @code{cl-map}, @code{cl-maplist}, etc."
msgstr ""

#. type: section
#: ../../cl.texi:3191 ../../cl.texi:3411 ../../cl.texi:3412
#, no-wrap
msgid "Sequence Functions"
msgstr ""

#. type: menuentry
#: ../../cl.texi:3191
msgid "@code{cl-subseq}, @code{cl-remove}, @code{cl-substitute}, etc."
msgstr ""

#. type: section
#: ../../cl.texi:3191 ../../cl.texi:3539 ../../cl.texi:3540
#, no-wrap
msgid "Searching Sequences"
msgstr ""

#. type: menuentry
#: ../../cl.texi:3191
msgid "@code{cl-find}, @code{cl-count}, @code{cl-search}, etc."
msgstr ""

#. type: section
#: ../../cl.texi:3191 ../../cl.texi:3608 ../../cl.texi:3609
#, no-wrap
msgid "Sorting Sequences"
msgstr ""

#. type: menuentry
#: ../../cl.texi:3191
msgid "@code{cl-sort}, @code{cl-stable-sort}, @code{cl-merge}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3200
msgid ""
"Many of the sequence functions take keyword arguments; @pxref{Argument "
"Lists}.  All keyword arguments are optional and, if specified, may appear in "
"any order."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3209
msgid ""
"The @code{:key} argument should be passed either @code{nil}, or a function "
"of one argument.  This key function is used as a filter through which the "
"elements of the sequence are seen; for example, @code{(cl-find x y :key "
"'car)} is similar to @code{(cl-assoc x y)}.  It searches for an element of "
"the list whose @sc{car} equals @code{x}, rather than for an element which "
"equals @code{x} itself.  If @code{:key} is omitted or @code{nil}, the filter "
"is effectively the identity function."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3221
msgid ""
"The @code{:test} and @code{:test-not} arguments should be either @code{nil}, "
"or functions of two arguments.  The test function is used to compare two "
"sequence elements, or to compare a search value with sequence elements.  "
"(The two values are passed to the test function in the same order as the "
"original sequence function arguments from which they are derived, or, if "
"they both come from the same sequence, in the same order as they appear in "
"that sequence.)  The @code{:test} argument specifies a function which must "
"return true (non-@code{nil}) to indicate a match; instead, you may use "
"@code{:test-not} to give a function which returns @emph{false} to indicate a "
"match.  The default test function is @code{eql}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3227
msgid ""
"Many functions that take @var{item} and @code{:test} or @code{:test-not} "
"arguments also come in @code{-if} and @code{-if-not} varieties, where a "
"@var{predicate} function is passed instead of @var{item}, and sequence "
"elements match if the predicate returns true on them (or false in the case "
"of @code{-if-not}).  For example:"
msgstr ""

#. type: example
#: ../../cl.texi:3230
#, no-wrap
msgid "(cl-remove 0 seq :test '=)  @equiv{}  (cl-remove-if 'zerop seq)\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:3234
msgid "to remove all zeros from sequence @code{seq}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3246
msgid ""
"Some operations can work on a subsequence of the argument sequence; these "
"function take @code{:start} and @code{:end} arguments, which default to zero "
"and the length of the sequence, respectively.  Only elements between "
"@var{start} (inclusive) and @var{end} (exclusive) are affected by the "
"operation.  The @var{end} argument may be passed @code{nil} to signify the "
"length of the sequence; otherwise, both @var{start} and @var{end} must be "
"integers, with @code{0 <= @var{start} <= @var{end} <= (length @var{seq})}.  "
"If the function takes two sequence arguments, the limits are defined by "
"keywords @code{:start1} and @code{:end1} for the first, and @code{:start2} "
"and @code{:end2} for the second."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3252
msgid ""
"A few functions accept a @code{:from-end} argument, which, if "
"non-@code{nil}, causes the operation to go from right-to-left through the "
"sequence instead of left-to-right, and a @code{:count} argument, which "
"specifies an integer maximum number of elements to be removed or otherwise "
"processed."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3262
msgid ""
"The sequence functions make no guarantees about the order in which the "
"@code{:test}, @code{:test-not}, and @code{:key} functions are called on "
"various elements.  Therefore, it is a bad idea to depend on side effects of "
"these functions.  For example, @code{:from-end} may cause the sequence to be "
"scanned actually in reverse, or it may be scanned forwards but computing a "
"result ``as if'' it were scanned backwards.  (Some functions, like "
"@code{cl-mapcar} and @code{cl-every}, @emph{do} specify exactly the order in "
"which the function is called so side effects are perfectly acceptable in "
"those cases.)"
msgstr ""

#. type: Plain text
#: ../../cl.texi:3269
msgid ""
"Strings may contain ``text properties'' as well as character data.  Except "
"as noted, it is undefined whether or not text properties are preserved by "
"sequence functions.  For example, @code{(cl-remove ?A @var{str})} may or may "
"not preserve the properties of the characters copied from @var{str} into the "
"result."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3277
msgid ""
"These functions ``map'' the function you specify over the elements of lists "
"or arrays.  They are all variations on the theme of the built-in function "
"@code{mapcar}."
msgstr ""

#. type: defun
#: ../../cl.texi:3278
#, no-wrap
msgid "cl-mapcar function seq &rest more-seqs"
msgstr ""

#. type: defun
#: ../../cl.texi:3288
msgid ""
"This function calls @var{function} on successive parallel sets of elements "
"from its argument sequences.  Given a single @var{seq} argument it is "
"equivalent to @code{mapcar}; given @var{n} sequences, it calls the function "
"with the first elements of each of the sequences as the @var{n} arguments to "
"yield the first element of the result list, then with the second elements, "
"and so on.  The mapping stops as soon as the shortest sequence runs out.  "
"The argument sequences may be any mixture of lists, strings, and vectors; "
"the return sequence is always a list."
msgstr ""

#. type: defun
#: ../../cl.texi:3293
msgid ""
"Common Lisp's @code{mapcar} accepts multiple arguments but works only on "
"lists; Emacs Lisp's @code{mapcar} accepts a single sequence argument.  This "
"package's @code{cl-mapcar} works as a compatible superset of both."
msgstr ""

#. type: defun
#: ../../cl.texi:3295
#, no-wrap
msgid "cl-map result-type function seq &rest more-seqs"
msgstr ""

#. type: defun
#: ../../cl.texi:3303
msgid ""
"This function maps @var{function} over the argument sequences, just like "
"@code{cl-mapcar}, but it returns a sequence of type @var{result-type} rather "
"than a list.  @var{result-type} must be one of the following symbols: "
"@code{vector}, @code{string}, @code{list} (in which case the effect is the "
"same as for @code{cl-mapcar}), or @code{nil} (in which case the results are "
"thrown away and @code{cl-map} returns @code{nil})."
msgstr ""

#. type: defun
#: ../../cl.texi:3305
#, no-wrap
msgid "cl-maplist function list &rest more-lists"
msgstr ""

#. type: defun
#: ../../cl.texi:3312
msgid ""
"This function calls @var{function} on each of its argument lists, then on "
"the @sc{cdr}s of those lists, and so on, until the shortest list runs out.  "
"The results are returned in the form of a list.  Thus, @code{cl-maplist} is "
"like @code{cl-mapcar} except that it passes in the list pointers themselves "
"rather than the @sc{car}s of the advancing pointers."
msgstr ""

#. type: defun
#: ../../cl.texi:3314
#, no-wrap
msgid "cl-mapc function seq &rest more-seqs"
msgstr ""

#. type: defun
#: ../../cl.texi:3323
msgid ""
"This function is like @code{cl-mapcar}, except that the values returned by "
"@var{function} are ignored and thrown away rather than being collected into "
"a list.  The return value of @code{cl-mapc} is @var{seq}, the first "
"sequence.  This function is more general than the Emacs primitive "
"@code{mapc}.  (Note that this function is called @code{cl-mapc} even in "
"@file{cl.el}, rather than @code{mapc*} as you might expect.)"
msgstr ""

#. type: defun
#: ../../cl.texi:3325
#, no-wrap
msgid "cl-mapl function list &rest more-lists"
msgstr ""

#. type: defun
#: ../../cl.texi:3328
msgid ""
"This function is like @code{cl-maplist}, except that it throws away the "
"values returned by @var{function}."
msgstr ""

#. type: defun
#: ../../cl.texi:3330
#, no-wrap
msgid "cl-mapcan function seq &rest more-seqs"
msgstr ""

#. type: defun
#: ../../cl.texi:3334
msgid ""
"This function is like @code{cl-mapcar}, except that it concatenates the "
"return values (which must be lists) using @code{nconc}, rather than simply "
"collecting them into a list."
msgstr ""

#. type: defun
#: ../../cl.texi:3336
#, no-wrap
msgid "cl-mapcon function list &rest more-lists"
msgstr ""

#. type: defun
#: ../../cl.texi:3339
msgid ""
"This function is like @code{cl-maplist}, except that it concatenates the "
"return values using @code{nconc}."
msgstr ""

#. type: defun
#: ../../cl.texi:3341
#, no-wrap
msgid "cl-some predicate seq &rest more-seqs"
msgstr ""

#. type: defun
#: ../../cl.texi:3350
msgid ""
"This function calls @var{predicate} on each element of @var{seq} in turn; if "
"@var{predicate} returns a non-@code{nil} value, @code{cl-some} returns that "
"value, otherwise it returns @code{nil}.  Given several sequence arguments, "
"it steps through the sequences in parallel until the shortest one runs out, "
"just as in @code{cl-mapcar}.  You can rely on the left-to-right order in "
"which the elements are visited, and on the fact that mapping stops "
"immediately as soon as @var{predicate} returns non-@code{nil}."
msgstr ""

#. type: defun
#: ../../cl.texi:3352
#, no-wrap
msgid "cl-every predicate seq &rest more-seqs"
msgstr ""

#. type: defun
#: ../../cl.texi:3357
msgid ""
"This function calls @var{predicate} on each element of the sequence(s)  in "
"turn; it returns @code{nil} as soon as @var{predicate} returns @code{nil} "
"for any element, or @code{t} if the predicate was true for all elements."
msgstr ""

#. type: defun
#: ../../cl.texi:3359
#, no-wrap
msgid "cl-notany predicate seq &rest more-seqs"
msgstr ""

#. type: defun
#: ../../cl.texi:3364
msgid ""
"This function calls @var{predicate} on each element of the sequence(s)  in "
"turn; it returns @code{nil} as soon as @var{predicate} returns a "
"non-@code{nil} value for any element, or @code{t} if the predicate was "
"@code{nil} for all elements."
msgstr ""

#. type: defun
#: ../../cl.texi:3366
#, no-wrap
msgid "cl-notevery predicate seq &rest more-seqs"
msgstr ""

#. type: defun
#: ../../cl.texi:3371
msgid ""
"This function calls @var{predicate} on each element of the sequence(s)  in "
"turn; it returns a non-@code{nil} value as soon as @var{predicate} returns "
"@code{nil} for any element, or @code{nil} if the predicate was true for all "
"elements."
msgstr ""

#. type: defun
#: ../../cl.texi:3373
#, no-wrap
msgid "cl-reduce function seq @t{&key :from-end :start :end :initial-value :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3382
msgid ""
"This function combines the elements of @var{seq} using an associative binary "
"operation.  Suppose @var{function} is @code{*} and @var{seq} is the list "
"@code{(2 3 4 5)}.  The first two elements of the list are combined with "
"@code{(* 2 3) = 6}; this is combined with the next element, @code{(* 6 4) = "
"24}, and that is combined with the final element: @code{(* 24 5) = 120}.  "
"Note that the @code{*} function happens to be self-reducing, so that "
"@code{(* 2 3 4 5)} has the same effect as an explicit call to "
"@code{cl-reduce}."
msgstr ""

#. type: defun
#: ../../cl.texi:3385
msgid ""
"If @code{:from-end} is true, the reduction is right-associative instead of "
"left-associative:"
msgstr ""

#. type: example
#: ../../cl.texi:3391
#, no-wrap
msgid ""
"(cl-reduce '- '(1 2 3 4))\n"
"        @equiv{} (- (- (- 1 2) 3) 4) @result{} -8\n"
"(cl-reduce '- '(1 2 3 4) :from-end t)\n"
"        @equiv{} (- 1 (- 2 (- 3 4))) @result{} -2\n"
msgstr ""

#. type: defun
#: ../../cl.texi:3395
msgid ""
"If @code{:key} is specified, it is a function of one argument, which is "
"called on each of the sequence elements in turn."
msgstr ""

#. type: defun
#: ../../cl.texi:3399
msgid ""
"If @code{:initial-value} is specified, it is effectively added to the front "
"(or rear in the case of @code{:from-end}) of the sequence.  The @code{:key} "
"function is @emph{not} applied to the initial value."
msgstr ""

#. type: defun
#: ../../cl.texi:3404
msgid ""
"If the sequence, including the initial value, has exactly one element then "
"that element is returned without ever calling @var{function}.  If the "
"sequence is empty (and there is no initial value), then @var{function} is "
"called with no arguments to obtain the return value."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3410
msgid ""
"All of these mapping operations can be expressed conveniently in terms of "
"the @code{cl-loop} macro.  In compiled code, @code{cl-loop} will be faster "
"since it generates the loop as in-line code with no function calls."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3417
msgid ""
"This section describes a number of Common Lisp functions for operating on "
"sequences."
msgstr ""

#. type: defun
#: ../../cl.texi:3418
#, no-wrap
msgid "cl-subseq sequence start &optional end"
msgstr ""

#. type: defun
#: ../../cl.texi:3426
msgid ""
"This function returns a given subsequence of the argument @var{sequence}, "
"which may be a list, string, or vector.  The indices @var{start} and "
"@var{end} must be in range, and @var{start} must be no greater than "
"@var{end}.  If @var{end} is omitted, it defaults to the length of the "
"sequence.  The return value is always a copy; it does not share structure "
"with @var{sequence}."
msgstr ""

#. type: defun
#: ../../cl.texi:3433
msgid ""
"As an extension to Common Lisp, @var{start} and/or @var{end} may be "
"negative, in which case they represent a distance back from the end of the "
"sequence.  This is for compatibility with Emacs's @code{substring} "
"function.  Note that @code{cl-subseq} is the @emph{only} sequence function "
"that allows negative @var{start} and @var{end}."
msgstr ""

#. type: defun
#: ../../cl.texi:3437
msgid ""
"You can use @code{setf} on a @code{cl-subseq} form to replace a specified "
"range of elements with elements from another sequence.  The replacement is "
"done as if by @code{cl-replace}, described below."
msgstr ""

#. type: defun
#: ../../cl.texi:3439
#, no-wrap
msgid "cl-concatenate result-type &rest seqs"
msgstr ""

#. type: defun
#: ../../cl.texi:3446
msgid ""
"This function concatenates the argument sequences together to form a result "
"sequence of type @var{result-type}, one of the symbols @code{vector}, "
"@code{string}, or @code{list}.  The arguments are always copied, even in "
"cases such as @code{(cl-concatenate 'list '(1 2 3))} where the result is "
"identical to an argument."
msgstr ""

#. type: defun
#: ../../cl.texi:3448
#, no-wrap
msgid "cl-fill seq item @t{&key :start :end}"
msgstr ""

#. type: defun
#: ../../cl.texi:3451
msgid ""
"This function fills the elements of the sequence (or the specified part of "
"the sequence) with the value @var{item}."
msgstr ""

#. type: defun
#: ../../cl.texi:3453
#, no-wrap
msgid "cl-replace seq1 seq2 @t{&key :start1 :end1 :start2 :end2}"
msgstr ""

#. type: defun
#: ../../cl.texi:3458
msgid ""
"This function copies part of @var{seq2} into part of @var{seq1}.  The "
"sequence @var{seq1} is not stretched or resized; the amount of data copied "
"is simply the shorter of the source and destination (sub)sequences.  The "
"function returns @var{seq1}."
msgstr ""

#. type: defun
#: ../../cl.texi:3465
msgid ""
"If @var{seq1} and @var{seq2} are @code{eq}, then the replacement will work "
"correctly even if the regions indicated by the start and end arguments "
"overlap.  However, if @var{seq1} and @var{seq2} are lists that share storage "
"but are not @code{eq}, and the start and end arguments specify overlapping "
"regions, the effect is undefined."
msgstr ""

#. type: defun
#: ../../cl.texi:3467
#, no-wrap
msgid ""
"cl-remove item seq @t{&key :test :test-not :key :count :start :end "
":from-end}"
msgstr ""

#. type: defun
#: ../../cl.texi:3482
msgid ""
"This returns a copy of @var{seq} with all elements matching @var{item} "
"removed.  The result may share storage with or be @code{eq} to @var{seq} in "
"some circumstances, but the original @var{seq} will not be modified.  The "
"@code{:test}, @code{:test-not}, and @code{:key} arguments define the "
"matching test that is used; by default, elements @code{eql} to @var{item} "
"are removed.  The @code{:count} argument specifies the maximum number of "
"matching elements that can be removed (only the leftmost @var{count} matches "
"are removed).  The @code{:start} and @code{:end} arguments specify a region "
"in @var{seq} in which elements will be removed; elements outside that region "
"are not matched or removed.  The @code{:from-end} argument, if true, says "
"that elements should be deleted from the end of the sequence rather than the "
"beginning (this matters only if @var{count} was also specified)."
msgstr ""

#. type: defun
#: ../../cl.texi:3484
#, no-wrap
msgid ""
"cl-delete item seq @t{&key :test :test-not :key :count :start :end "
":from-end}"
msgstr ""

#. type: defun
#: ../../cl.texi:3493
msgid ""
"This deletes all elements of @var{seq} that match @var{item}.  It is a "
"destructive operation.  Since Emacs Lisp does not support stretchable "
"strings or vectors, this is the same as @code{cl-remove} for those sequence "
"types.  On lists, @code{cl-remove} will copy the list if necessary to "
"preserve the original list, whereas @code{cl-delete} will splice out parts "
"of the argument list.  Compare @code{append} and @code{nconc}, which are "
"analogous non-destructive and destructive list operations in Emacs Lisp."
msgstr ""

#. type: findex
#: ../../cl.texi:3495
#, no-wrap
msgid "cl-remove-if"
msgstr ""

#. type: findex
#: ../../cl.texi:3496
#, no-wrap
msgid "cl-remove-if-not"
msgstr ""

#. type: findex
#: ../../cl.texi:3497
#, no-wrap
msgid "cl-delete-if"
msgstr ""

#. type: findex
#: ../../cl.texi:3498
#, no-wrap
msgid "cl-delete-if-not"
msgstr ""

#. type: Plain text
#: ../../cl.texi:3501
msgid ""
"The predicate-oriented functions @code{cl-remove-if}, "
"@code{cl-remove-if-not}, @code{cl-delete-if}, and @code{cl-delete-if-not} "
"are defined similarly."
msgstr ""

#. type: defun
#: ../../cl.texi:3502
#, no-wrap
msgid "cl-remove-duplicates seq @t{&key :test :test-not :key :start :end :from-end}"
msgstr ""

#. type: defun
#: ../../cl.texi:3510
msgid ""
"This function returns a copy of @var{seq} with duplicate elements removed.  "
"Specifically, if two elements from the sequence match according to the "
"@code{:test}, @code{:test-not}, and @code{:key} arguments, only the "
"rightmost one is retained.  If @code{:from-end} is true, the leftmost one is "
"retained instead.  If @code{:start} or @code{:end} is specified, only "
"elements within that subsequence are examined or removed."
msgstr ""

#. type: defun
#: ../../cl.texi:3512
#, no-wrap
msgid "cl-delete-duplicates seq @t{&key :test :test-not :key :start :end :from-end}"
msgstr ""

#. type: defun
#: ../../cl.texi:3515
msgid ""
"This function deletes duplicate elements from @var{seq}.  It is a "
"destructive version of @code{cl-remove-duplicates}."
msgstr ""

#. type: defun
#: ../../cl.texi:3517
#, no-wrap
msgid ""
"cl-substitute new old seq @t{&key :test :test-not :key :count :start :end "
":from-end}"
msgstr ""

#. type: defun
#: ../../cl.texi:3522
msgid ""
"This function returns a copy of @var{seq}, with all elements matching "
"@var{old} replaced with @var{new}.  The @code{:count}, @code{:start}, "
"@code{:end}, and @code{:from-end} arguments may be used to limit the number "
"of substitutions made."
msgstr ""

#. type: defun
#: ../../cl.texi:3524
#, no-wrap
msgid ""
"cl-nsubstitute new old seq @t{&key :test :test-not :key :count :start :end "
":from-end}"
msgstr ""

#. type: defun
#: ../../cl.texi:3528
msgid ""
"This is a destructive version of @code{cl-substitute}; it performs the "
"substitution using @code{setcar} or @code{aset} rather than by returning a "
"changed copy of the sequence."
msgstr ""

#. type: findex
#: ../../cl.texi:3530
#, no-wrap
msgid "cl-substitute-if"
msgstr ""

#. type: findex
#: ../../cl.texi:3531
#, no-wrap
msgid "cl-substitute-if-not"
msgstr ""

#. type: findex
#: ../../cl.texi:3532
#, no-wrap
msgid "cl-nsubstitute-if"
msgstr ""

#. type: findex
#: ../../cl.texi:3533
#, no-wrap
msgid "cl-nsubstitute-if-not"
msgstr ""

#. type: Plain text
#: ../../cl.texi:3538
msgid ""
"The functions @code{cl-substitute-if}, @code{cl-substitute-if-not}, "
"@code{cl-nsubstitute-if}, and @code{cl-nsubstitute-if-not} are defined "
"similarly.  For these, a @var{predicate} is given in place of the @var{old} "
"argument."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3545
msgid ""
"These functions search for elements or subsequences in a sequence.  (See "
"also @code{cl-member} and @code{cl-assoc}; @pxref{Lists}.)"
msgstr ""

#. type: defun
#: ../../cl.texi:3546
#, no-wrap
msgid "cl-find item seq @t{&key :test :test-not :key :start :end :from-end}"
msgstr ""

#. type: defun
#: ../../cl.texi:3553
msgid ""
"This function searches @var{seq} for an element matching @var{item}.  If it "
"finds a match, it returns the matching element.  Otherwise, it returns "
"@code{nil}.  It returns the leftmost match, unless @code{:from-end} is true, "
"in which case it returns the rightmost match.  The @code{:start} and "
"@code{:end} arguments may be used to limit the range of elements that are "
"searched."
msgstr ""

#. type: defun
#: ../../cl.texi:3555
#, no-wrap
msgid "cl-position item seq @t{&key :test :test-not :key :start :end :from-end}"
msgstr ""

#. type: defun
#: ../../cl.texi:3561
msgid ""
"This function is like @code{cl-find}, except that it returns the integer "
"position in the sequence of the matching item rather than the item itself.  "
"The position is relative to the start of the sequence as a whole, even if "
"@code{:start} is non-zero.  The function returns @code{nil} if no matching "
"element was found."
msgstr ""

#. type: defun
#: ../../cl.texi:3563
#, no-wrap
msgid "cl-count item seq @t{&key :test :test-not :key :start :end}"
msgstr ""

#. type: defun
#: ../../cl.texi:3566
msgid ""
"This function returns the number of elements of @var{seq} which match "
"@var{item}.  The result is always a nonnegative integer."
msgstr ""

#. type: findex
#: ../../cl.texi:3568
#, no-wrap
msgid "cl-find-if"
msgstr ""

#. type: findex
#: ../../cl.texi:3569
#, no-wrap
msgid "cl-find-if-not"
msgstr ""

#. type: findex
#: ../../cl.texi:3570
#, no-wrap
msgid "cl-position-if"
msgstr ""

#. type: findex
#: ../../cl.texi:3571
#, no-wrap
msgid "cl-position-if-not"
msgstr ""

#. type: findex
#: ../../cl.texi:3572
#, no-wrap
msgid "cl-count-if"
msgstr ""

#. type: findex
#: ../../cl.texi:3573
#, no-wrap
msgid "cl-count-if-not"
msgstr ""

#. type: Plain text
#: ../../cl.texi:3577
msgid ""
"The @code{cl-find-if}, @code{cl-find-if-not}, @code{cl-position-if}, "
"@code{cl-position-if-not}, @code{cl-count-if}, and @code{cl-count-if-not} "
"functions are defined similarly."
msgstr ""

#. type: defun
#: ../../cl.texi:3578
#, no-wrap
msgid ""
"cl-mismatch seq1 seq2 @t{&key :test :test-not :key :start1 :end1 :start2 "
":end2 :from-end}"
msgstr ""

#. type: defun
#: ../../cl.texi:3587
msgid ""
"This function compares the specified parts of @var{seq1} and @var{seq2}.  If "
"they are the same length and the corresponding elements match (according to "
"@code{:test}, @code{:test-not}, and @code{:key}), the function returns "
"@code{nil}.  If there is a mismatch, the function returns the index "
"(relative to @var{seq1})  of the first mismatching element.  This will be "
"the leftmost pair of elements that do not match, or the position at which "
"the shorter of the two otherwise-matching sequences runs out."
msgstr ""

#. type: defun
#: ../../cl.texi:3592
msgid ""
"If @code{:from-end} is true, then the elements are compared from right to "
"left starting at @code{(1- @var{end1})} and @code{(1- @var{end2})}.  If the "
"sequences differ, then one plus the index of the rightmost difference "
"(relative to @var{seq1}) is returned."
msgstr ""

#. type: defun
#: ../../cl.texi:3595
msgid ""
"An interesting example is @code{(cl-mismatch str1 str2 :key 'upcase)}, which "
"compares two strings case-insensitively."
msgstr ""

#. type: defun
#: ../../cl.texi:3597
#, no-wrap
msgid ""
"cl-search seq1 seq2 @t{&key :test :test-not :key :from-end :start1 :end1 "
":start2 :end2}"
msgstr ""

#. type: defun
#: ../../cl.texi:3606
msgid ""
"This function searches @var{seq2} for a subsequence that matches @var{seq1} "
"(or part of it specified by @code{:start1} and @code{:end1}).  Only matches "
"that fall entirely within the region defined by @code{:start2} and "
"@code{:end2} will be considered.  The return value is the index of the "
"leftmost element of the leftmost match, relative to the start of @var{seq2}, "
"or @code{nil} if no matches were found.  If @code{:from-end} is true, the "
"function finds the @emph{rightmost} matching subsequence."
msgstr ""

#. type: defun
#: ../../cl.texi:3611
#, no-wrap
msgid "cl-sort seq predicate @t{&key :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3619
msgid ""
"This function sorts @var{seq} into increasing order as determined by using "
"@var{predicate} to compare pairs of elements.  @var{predicate} should return "
"true (non-@code{nil}) if and only if its first argument is less than (not "
"equal to) its second argument.  For example, @code{<} and "
"@code{string-lessp} are suitable predicate functions for sorting numbers and "
"strings, respectively; @code{>} would sort numbers into decreasing rather "
"than increasing order."
msgstr ""

#. type: defun
#: ../../cl.texi:3624
msgid ""
"This function differs from Emacs's built-in @code{sort} in that it can "
"operate on any type of sequence, not just lists.  Also, it accepts a "
"@code{:key} argument, which is used to preprocess data fed to the "
"@var{predicate} function.  For example,"
msgstr ""

#. type: example
#: ../../cl.texi:3627
#, no-wrap
msgid "(setq data (cl-sort data 'string-lessp :key 'downcase))\n"
msgstr ""

#. type: defun
#: ../../cl.texi:3635
msgid ""
"sorts @var{data}, a sequence of strings, into increasing alphabetical order "
"without regard to case.  A @code{:key} function of @code{car} would be "
"useful for sorting association lists.  It should only be a simple accessor "
"though, since it's used heavily in the current implementation."
msgstr ""

#. type: defun
#: ../../cl.texi:3638
msgid ""
"The @code{cl-sort} function is destructive; it sorts lists by actually "
"rearranging the @sc{cdr} pointers in suitable fashion."
msgstr ""

#. type: defun
#: ../../cl.texi:3640
#, no-wrap
msgid "cl-stable-sort seq predicate @t{&key :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3644
msgid ""
"This function sorts @var{seq} @dfn{stably}, meaning two elements which are "
"equal in terms of @var{predicate} are guaranteed not to be rearranged out of "
"their original order by the sort."
msgstr ""

#. type: defun
#: ../../cl.texi:3649
msgid ""
"In practice, @code{cl-sort} and @code{cl-stable-sort} are equivalent in "
"Emacs Lisp because the underlying @code{sort} function is stable by "
"default.  However, this package reserves the right to use non-stable methods "
"for @code{cl-sort} in the future."
msgstr ""

#. type: defun
#: ../../cl.texi:3651
#, no-wrap
msgid "cl-merge type seq1 seq2 predicate @t{&key :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3665
msgid ""
"This function merges two sequences @var{seq1} and @var{seq2} by interleaving "
"their elements.  The result sequence, of type @var{type} (in the sense of "
"@code{cl-concatenate}), has length equal to the sum of the lengths of the "
"two input sequences.  The sequences may be modified destructively.  Order of "
"elements within @var{seq1} and @var{seq2} is preserved in the interleaving; "
"elements of the two sequences are compared by @var{predicate} (in the sense "
"of @code{sort}) and the lesser element goes first in the result.  When "
"elements are equal, those from @var{seq1} precede those from @var{seq2} in "
"the result.  Thus, if @var{seq1} and @var{seq2} are both sorted according to "
"@var{predicate}, then the result will be a merged sequence which is (stably) "
"sorted according to @var{predicate}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3672
msgid "The functions described here operate on lists."
msgstr ""

#. type: section
#: ../../cl.texi:3678 ../../cl.texi:3680 ../../cl.texi:3681
#, no-wrap
msgid "List Functions"
msgstr ""

#. type: menuentry
#: ../../cl.texi:3678
msgid "@code{cl-caddr}, @code{cl-first}, @code{cl-list*}, etc."
msgstr ""

#. type: section
#: ../../cl.texi:3678 ../../cl.texi:3753 ../../cl.texi:3754
#, no-wrap
msgid "Substitution of Expressions"
msgstr ""

#. type: menuentry
#: ../../cl.texi:3678
msgid "@code{cl-subst}, @code{cl-sublis}, etc."
msgstr ""

#. type: section
#: ../../cl.texi:3678 ../../cl.texi:3802 ../../cl.texi:3803
#, no-wrap
msgid "Lists as Sets"
msgstr ""

#. type: menuentry
#: ../../cl.texi:3678
msgid "@code{cl-member}, @code{cl-adjoin}, @code{cl-union}, etc."
msgstr ""

#. type: section
#: ../../cl.texi:3678 ../../cl.texi:3900 ../../cl.texi:3901
#, no-wrap
msgid "Association Lists"
msgstr ""

#. type: menuentry
#: ../../cl.texi:3678
msgid "@code{cl-assoc}, @code{cl-acons}, @code{cl-pairlis}, etc."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3686
msgid ""
"This section describes a number of simple operations on lists, i.e., chains "
"of cons cells."
msgstr ""

#. type: defun
#: ../../cl.texi:3687
#, no-wrap
msgid "cl-caddr x"
msgstr ""

#. type: defun
#: ../../cl.texi:3693
msgid ""
"This function is equivalent to @code{(car (cdr (cdr @var{x})))}.  Likewise, "
"this package aliases all 24 @code{c@var{xxx}r} functions where @var{xxx} is "
"up to four @samp{a}s and/or @samp{d}s.  All of these functions are "
"@code{setf}-able, and calls to them are expanded inline by the byte-compiler "
"for maximum efficiency."
msgstr ""

#. type: defun
#: ../../cl.texi:3695
#, no-wrap
msgid "cl-first x"
msgstr ""

#. type: defun
#: ../../cl.texi:3699
msgid ""
"This function is a synonym for @code{(car @var{x})}.  Likewise, the "
"functions @code{cl-second}, @code{cl-third}, @dots{}, through "
"@code{cl-tenth} return the given element of the list @var{x}."
msgstr ""

#. type: defun
#: ../../cl.texi:3701
#, no-wrap
msgid "cl-rest x"
msgstr ""

#. type: defun
#: ../../cl.texi:3703
msgid "This function is a synonym for @code{(cdr @var{x})}."
msgstr ""

#. type: defun
#: ../../cl.texi:3705
#, no-wrap
msgid "cl-endp x"
msgstr ""

#. type: defun
#: ../../cl.texi:3708
msgid ""
"This function acts like @code{null}, but signals an error if @code{x} is "
"neither a @code{nil} nor a cons cell."
msgstr ""

#. type: defun
#: ../../cl.texi:3710
#, no-wrap
msgid "cl-list-length x"
msgstr ""

#. type: defun
#: ../../cl.texi:3717
msgid ""
"This function returns the length of list @var{x}, exactly like @code{(length "
"@var{x})}, except that if @var{x} is a circular list (where the "
"@sc{cdr}-chain forms a loop rather than terminating with @code{nil}), this "
"function returns @code{nil}.  (The regular @code{length} function would get "
"stuck if given a circular list.  See also the @code{safe-length} function.)"
msgstr ""

#. type: defun
#: ../../cl.texi:3719
#, no-wrap
msgid "cl-list* arg &rest others"
msgstr ""

#. type: defun
#: ../../cl.texi:3726
msgid ""
"This function constructs a list of its arguments.  The final argument "
"becomes the @sc{cdr} of the last cell constructed.  Thus, @code{(cl-list* "
"@var{a} @var{b} @var{c})} is equivalent to @code{(cons @var{a} (cons @var{b} "
"@var{c}))}, and @code{(cl-list* @var{a} @var{b} nil)} is equivalent to "
"@code{(list @var{a} @var{b})}."
msgstr ""

#. type: defun
#: ../../cl.texi:3728
#, no-wrap
msgid "cl-ldiff list sublist"
msgstr ""

#. type: defun
#: ../../cl.texi:3737
msgid ""
"If @var{sublist} is a sublist of @var{list}, i.e., is @code{eq} to one of "
"the cons cells of @var{list}, then this function returns a copy of the part "
"of @var{list} up to but not including @var{sublist}.  For example, "
"@code{(cl-ldiff x (cddr x))} returns the first two elements of the list "
"@code{x}.  The result is a copy; the original @var{list} is not modified.  "
"If @var{sublist} is not a sublist of @var{list}, a copy of the entire "
"@var{list} is returned."
msgstr ""

#. type: defun
#: ../../cl.texi:3739
#, no-wrap
msgid "cl-copy-list list"
msgstr ""

#. type: defun
#: ../../cl.texi:3742
msgid ""
"This function returns a copy of the list @var{list}.  It copies dotted lists "
"like @code{(1 2 . 3)} correctly."
msgstr ""

#. type: defun
#: ../../cl.texi:3744
#, no-wrap
msgid "cl-tree-equal x y @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3751
msgid ""
"This function compares two trees of cons cells.  If @var{x} and @var{y} are "
"both cons cells, their @sc{car}s and @sc{cdr}s are compared recursively.  If "
"neither @var{x} nor @var{y} is a cons cell, they are compared by @code{eql}, "
"or according to the specified test.  The @code{:key} function, if specified, "
"is applied to the elements of both trees.  @xref{Sequences}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3760
msgid ""
"These functions substitute elements throughout a tree of cons cells.  "
"(@xref{Sequence Functions}, for the @code{cl-substitute} function, which "
"works on just the top-level elements of a list.)"
msgstr ""

#. type: defun
#: ../../cl.texi:3761
#, no-wrap
msgid "cl-subst new old tree @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3774
msgid ""
"This function substitutes occurrences of @var{old} with @var{new} in "
"@var{tree}, a tree of cons cells.  It returns a substituted tree, which will "
"be a copy except that it may share storage with the argument @var{tree} in "
"parts where no substitutions occurred.  The original @var{tree} is not "
"modified.  This function recurses on, and compares against @var{old}, both "
"@sc{car}s and @sc{cdr}s of the component cons cells.  If @var{old} is itself "
"a cons cell, then matching cells in the tree are substituted as usual "
"without recursively substituting in that cell.  Comparisons with @var{old} "
"are done according to the specified test (@code{eql} by default).  The "
"@code{:key} function is applied to the elements of the tree but not to "
"@var{old}."
msgstr ""

#. type: defun
#: ../../cl.texi:3776
#, no-wrap
msgid "cl-nsubst new old tree @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3780
msgid ""
"This function is like @code{cl-subst}, except that it works by destructive "
"modification (by @code{setcar} or @code{setcdr})  rather than copying."
msgstr ""

#. type: findex
#: ../../cl.texi:3782
#, no-wrap
msgid "cl-subst-if"
msgstr ""

#. type: findex
#: ../../cl.texi:3783
#, no-wrap
msgid "cl-subst-if-not"
msgstr ""

#. type: findex
#: ../../cl.texi:3784
#, no-wrap
msgid "cl-nsubst-if"
msgstr ""

#. type: findex
#: ../../cl.texi:3785
#, no-wrap
msgid "cl-nsubst-if-not"
msgstr ""

#. type: Plain text
#: ../../cl.texi:3788
msgid ""
"The @code{cl-subst-if}, @code{cl-subst-if-not}, @code{cl-nsubst-if}, and "
"@code{cl-nsubst-if-not} functions are defined similarly."
msgstr ""

#. type: defun
#: ../../cl.texi:3789
#, no-wrap
msgid "cl-sublis alist tree @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3796
msgid ""
"This function is like @code{cl-subst}, except that it takes an association "
"list @var{alist} of @var{old}-@var{new} pairs.  Each element of the tree "
"(after applying the @code{:key} function, if any), is compared with the "
"@sc{car}s of @var{alist}; if it matches, it is replaced by the corresponding "
"@sc{cdr}."
msgstr ""

#. type: defun
#: ../../cl.texi:3798
#, no-wrap
msgid "cl-nsublis alist tree @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3800
msgid "This is a destructive version of @code{cl-sublis}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3808
msgid "These functions perform operations on lists that represent sets of elements."
msgstr ""

#. type: defun
#: ../../cl.texi:3809
#, no-wrap
msgid "cl-member item list @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3816
msgid ""
"This function searches @var{list} for an element matching @var{item}.  If a "
"match is found, it returns the cons cell whose @sc{car} was the matching "
"element.  Otherwise, it returns @code{nil}.  Elements are compared by "
"@code{eql} by default; you can use the @code{:test}, @code{:test-not}, and "
"@code{:key} arguments to modify this behavior.  @xref{Sequences}."
msgstr ""

#. type: defun
#: ../../cl.texi:3820
msgid ""
"The standard Emacs lisp function @code{member} uses @code{equal} for "
"comparisons; it is equivalent to @code{(cl-member @var{item} @var{list} "
":test 'equal)}."
msgstr ""

#. type: findex
#: ../../cl.texi:3822
#, no-wrap
msgid "cl-member-if"
msgstr ""

#. type: findex
#: ../../cl.texi:3823
#, no-wrap
msgid "cl-member-if-not"
msgstr ""

#. type: Plain text
#: ../../cl.texi:3826
msgid ""
"The @code{cl-member-if} and @code{cl-member-if-not} functions analogously "
"search for elements that satisfy a given predicate."
msgstr ""

#. type: defun
#: ../../cl.texi:3827
#, no-wrap
msgid "cl-tailp sublist list"
msgstr ""

#. type: defun
#: ../../cl.texi:3831
msgid ""
"This function returns @code{t} if @var{sublist} is a sublist of @var{list}, "
"i.e., if @var{sublist} is @code{eql} to @var{list} or to any of its "
"@sc{cdr}s."
msgstr ""

#. type: defun
#: ../../cl.texi:3833
#, no-wrap
msgid "cl-adjoin item list @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3841
msgid ""
"This function conses @var{item} onto the front of @var{list}, like "
"@code{(cons @var{item} @var{list})}, but only if @var{item} is not already "
"present on the list (as determined by @code{cl-member}).  If a @code{:key} "
"argument is specified, it is applied to @var{item} as well as to the "
"elements of @var{list} during the search, on the reasoning that @var{item} "
"is ``about'' to become part of the list."
msgstr ""

#. type: defun
#: ../../cl.texi:3843
#, no-wrap
msgid "cl-union list1 list2 @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3853
msgid ""
"This function combines two lists that represent sets of items, returning a "
"list that represents the union of those two sets.  The resulting list "
"contains all items that appear in @var{list1} or @var{list2}, and no "
"others.  If an item appears in both @var{list1} and @var{list2} it is copied "
"only once.  If an item is duplicated in @var{list1} or @var{list2}, it is "
"undefined whether or not that duplication will survive in the result list.  "
"The order of elements in the result list is also undefined."
msgstr ""

#. type: defun
#: ../../cl.texi:3855
#, no-wrap
msgid "cl-nunion list1 list2 @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3858
msgid ""
"This is a destructive version of @code{cl-union}; rather than copying, it "
"tries to reuse the storage of the argument lists if possible."
msgstr ""

#. type: defun
#: ../../cl.texi:3860
#, no-wrap
msgid "cl-intersection list1 list2 @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3864
msgid ""
"This function computes the intersection of the sets represented by "
"@var{list1} and @var{list2}.  It returns the list of items that appear in "
"both @var{list1} and @var{list2}."
msgstr ""

#. type: defun
#: ../../cl.texi:3866
#, no-wrap
msgid "cl-nintersection list1 list2 @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3870
msgid ""
"This is a destructive version of @code{cl-intersection}.  It tries to reuse "
"storage of @var{list1} rather than copying.  It does @emph{not} reuse the "
"storage of @var{list2}."
msgstr ""

#. type: defun
#: ../../cl.texi:3872
#, no-wrap
msgid "cl-set-difference list1 list2 @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3876
msgid ""
"This function computes the ``set difference'' of @var{list1} and "
"@var{list2}, i.e., the set of elements that appear in @var{list1} but "
"@emph{not} in @var{list2}."
msgstr ""

#. type: defun
#: ../../cl.texi:3878
#, no-wrap
msgid "cl-nset-difference list1 list2 @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3881
msgid ""
"This is a destructive @code{cl-set-difference}, which will try to reuse "
"@var{list1} if possible."
msgstr ""

#. type: defun
#: ../../cl.texi:3883
#, no-wrap
msgid "cl-set-exclusive-or list1 list2 @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3887
msgid ""
"This function computes the ``set exclusive or'' of @var{list1} and "
"@var{list2}, i.e., the set of elements that appear in exactly one of "
"@var{list1} and @var{list2}."
msgstr ""

#. type: defun
#: ../../cl.texi:3889
#, no-wrap
msgid "cl-nset-exclusive-or list1 list2 @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3892
msgid ""
"This is a destructive @code{cl-set-exclusive-or}, which will try to reuse "
"@var{list1} and @var{list2} if possible."
msgstr ""

#. type: defun
#: ../../cl.texi:3894
#, no-wrap
msgid "cl-subsetp list1 list2 @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3898
msgid ""
"This function checks whether @var{list1} represents a subset of @var{list2}, "
"i.e., whether every element of @var{list1} also appears in @var{list2}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3907
msgid ""
"An @dfn{association list} is a list representing a mapping from one set of "
"values to another; any list whose elements are cons cells is an association "
"list."
msgstr ""

#. type: defun
#: ../../cl.texi:3908
#, no-wrap
msgid "cl-assoc item a-list @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3918
msgid ""
"This function searches the association list @var{a-list} for an element "
"whose @sc{car} matches (in the sense of @code{:test}, @code{:test-not}, and "
"@code{:key}, or by comparison with @code{eql})  a given @var{item}.  It "
"returns the matching element, if any, otherwise @code{nil}.  It ignores "
"elements of @var{a-list} that are not cons cells.  (This corresponds to the "
"behavior of @code{assq} and @code{assoc} in Emacs Lisp; Common Lisp's "
"@code{assoc} ignores @code{nil}s but considers any other non-cons elements "
"of @var{a-list} to be an error.)"
msgstr ""

#. type: defun
#: ../../cl.texi:3920
#, no-wrap
msgid "cl-rassoc item a-list @t{&key :test :test-not :key}"
msgstr ""

#. type: defun
#: ../../cl.texi:3924
msgid ""
"This function searches for an element whose @sc{cdr} matches @var{item}.  If "
"@var{a-list} represents a mapping, this applies the inverse of the mapping "
"to @var{item}."
msgstr ""

#. type: findex
#: ../../cl.texi:3926
#, no-wrap
msgid "cl-assoc-if"
msgstr ""

#. type: findex
#: ../../cl.texi:3927
#, no-wrap
msgid "cl-assoc-if-not"
msgstr ""

#. type: findex
#: ../../cl.texi:3928
#, no-wrap
msgid "cl-rassoc-if"
msgstr ""

#. type: findex
#: ../../cl.texi:3929
#, no-wrap
msgid "cl-rassoc-if-not"
msgstr ""

#. type: Plain text
#: ../../cl.texi:3932
msgid ""
"The @code{cl-assoc-if}, @code{cl-assoc-if-not}, @code{cl-rassoc-if}, and "
"@code{cl-rassoc-if-not} functions are defined similarly."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3934
msgid "Two simple functions for constructing association lists are:"
msgstr ""

#. type: defun
#: ../../cl.texi:3935
#, no-wrap
msgid "cl-acons key value alist"
msgstr ""

#. type: defun
#: ../../cl.texi:3937
msgid ""
"This is equivalent to @code{(cons (cons @var{key} @var{value}) "
"@var{alist})}."
msgstr ""

#. type: defun
#: ../../cl.texi:3939
#, no-wrap
msgid "cl-pairlis keys values &optional alist"
msgstr ""

#. type: defun
#: ../../cl.texi:3942
msgid ""
"This is equivalent to @code{(nconc (cl-mapcar 'cons @var{keys} @var{values})  "
"@var{alist})}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3955
msgid ""
"The Common Lisp @dfn{structure} mechanism provides a general way to define "
"data types similar to C's @code{struct} types.  A structure is a Lisp object "
"containing some number of @dfn{slots}, each of which can hold any Lisp data "
"object.  Functions are provided for accessing and setting the slots, "
"creating or copying structure objects, and recognizing objects of a "
"particular structure type."
msgstr ""

#. type: Plain text
#: ../../cl.texi:3961
msgid ""
"In true Common Lisp, each structure type is a new type distinct from all "
"existing Lisp types.  Since the underlying Emacs Lisp system provides no way "
"to create new distinct types, this package implements structures as vectors "
"(or lists upon request) with a special ``tag'' symbol to identify them."
msgstr ""

#. type: defmac
#: ../../cl.texi:3962
#, no-wrap
msgid "cl-defstruct name slots@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:3968
msgid ""
"The @code{cl-defstruct} form defines a new structure type called @var{name}, "
"with the specified @var{slots}.  (The @var{slots} may begin with a string "
"which documents the structure type.)  In the simplest case, @var{name} and "
"each of the @var{slots} are symbols.  For example,"
msgstr ""

#. type: example
#: ../../cl.texi:3971
#, no-wrap
msgid "(cl-defstruct person name age sex)\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:3979
msgid ""
"defines a struct type called @code{person} that contains three slots.  Given "
"a @code{person} object @var{p}, you can access those slots by calling "
"@code{(person-name @var{p})}, @code{(person-age @var{p})}, and "
"@code{(person-sex @var{p})}.  You can also change these slots by using "
"@code{setf} on any of these place forms, for example:"
msgstr ""

#. type: example
#: ../../cl.texi:3982
#, no-wrap
msgid "(cl-incf (person-age birthday-boy))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:3990
msgid ""
"You can create a new @code{person} by calling @code{make-person}, which "
"takes keyword arguments @code{:name}, @code{:age}, and @code{:sex} to "
"specify the initial values of these slots in the new object.  (Omitting any "
"of these arguments leaves the corresponding slot ``undefined'', according to "
"the Common Lisp standard; in Emacs Lisp, such uninitialized slots are filled "
"with @code{nil}.)"
msgstr ""

#. type: defmac
#: ../../cl.texi:3993
msgid ""
"Given a @code{person}, @code{(copy-person @var{p})} makes a new object of "
"the same type whose slots are @code{eq} to those of @var{p}."
msgstr ""

#. type: defmac
#: ../../cl.texi:3996
msgid ""
"Given any Lisp object @var{x}, @code{(person-p @var{x})} returns true if "
"@var{x} is a @code{person}, and false otherwise."
msgstr ""

#. type: defmac
#: ../../cl.texi:4008
msgid ""
"Accessors like @code{person-name} normally check their arguments "
"(effectively using @code{person-p}) and signal an error if the argument is "
"the wrong type.  This check is affected by @code{(optimize (safety "
"@dots{}))} declarations.  Safety level 1, the default, uses a somewhat "
"optimized check that will detect all incorrect arguments, but may use an "
"uninformative error message (e.g., ``expected a vector'' instead of "
"``expected a @code{person}'').  Safety level 0 omits all checks except as "
"provided by the underlying @code{aref} call; safety levels 2 and 3 do "
"rigorous checking that will always print a descriptive error message for "
"incorrect inputs.  @xref{Declarations}."
msgstr ""

#. type: example
#: ../../cl.texi:4026
#, no-wrap
msgid ""
"(setq dave (make-person :name \"Dave\" :sex 'male))\n"
"     @result{} [cl-struct-person \"Dave\" nil male]\n"
"(setq other (copy-person dave))\n"
"     @result{} [cl-struct-person \"Dave\" nil male]\n"
"(eq dave other)\n"
"     @result{} nil\n"
"(eq (person-name dave) (person-name other))\n"
"     @result{} t\n"
"(person-p dave)\n"
"     @result{} t\n"
"(person-p [1 2 3 4])\n"
"     @result{} nil\n"
"(person-p \"Bogus\")\n"
"     @result{} nil\n"
"(person-p '[cl-struct-person counterfeit person object])\n"
"     @result{} t\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:4034
msgid ""
"In general, @var{name} is either a name symbol or a list of a name symbol "
"followed by any number of @dfn{struct options}; each @var{slot} is either a "
"slot symbol or a list of the form @samp{(@var{slot-name} @var{default-value} "
"@var{slot-options}@dots{})}.  The @var{default-value} is a Lisp form that is "
"evaluated any time an instance of the structure type is created without "
"specifying that slot's value."
msgstr ""

#. type: example
#: ../../cl.texi:4040
#, no-wrap
msgid ""
"(cl-defstruct person\n"
"     (name nil :read-only t)\n"
"     age\n"
"     (sex 'unknown))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:4044
msgid ""
"@var{slot-options} is a list of keyword-value pairs, where the following "
"keywords can be used:"
msgstr ""

#. type: item
#: ../../cl.texi:4046
#, no-wrap
msgid ":read-only"
msgstr ""

#. type: table
#: ../../cl.texi:4050
msgid ""
"A non-nil value means the slot should not be @code{setf}-able; the slot's "
"value is determined when the object is created and does not change "
"afterward."
msgstr ""

#. type: item
#: ../../cl.texi:4051 ../../cl.texi:4214
#, no-wrap
msgid ":type"
msgstr ""

#. type: table
#: ../../cl.texi:4053
msgid "The expected type of the values held in this slot."
msgstr ""

#. type: item
#: ../../cl.texi:4054
#, no-wrap
msgid ":documentation"
msgstr ""

#. type: table
#: ../../cl.texi:4056
msgid "A documentation string describing the slot."
msgstr ""

#. type: defmac
#: ../../cl.texi:4059
msgid "Other slot options are currently ignored."
msgstr ""

#. type: defmac
#: ../../cl.texi:4065
msgid ""
"For obscure historical reasons, structure options take a different form than "
"slot options.  A structure option is either a keyword symbol, or a list "
"beginning with a keyword symbol possibly followed by arguments.  (By "
"contrast, slot options are key-value pairs not enclosed in lists.)"
msgstr ""

#. type: example
#: ../../cl.texi:4071
#, no-wrap
msgid ""
"(cl-defstruct (person (:constructor create-person)\n"
"                      (:type list)\n"
"                      :named)\n"
"     name age sex)\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:4074
msgid "The following structure options are recognized."
msgstr ""

#. type: item
#: ../../cl.texi:4076
#, no-wrap
msgid ":conc-name"
msgstr ""

#. type: table
#: ../../cl.texi:4083
msgid ""
"The argument is a symbol whose print name is used as the prefix for the "
"names of slot accessor functions.  The default is the name of the struct "
"type followed by a hyphen.  The option @code{(:conc-name p-)} would change "
"this prefix to @code{p-}.  Specifying @code{nil} as an argument means no "
"prefix, so that the slot names themselves are used to name the accessor "
"functions."
msgstr ""

#. type: item
#: ../../cl.texi:4084
#, no-wrap
msgid ":constructor"
msgstr ""

#. type: table
#: ../../cl.texi:4091
msgid ""
"In the simple case, this option takes one argument which is an alternate "
"name to use for the constructor function.  The default is "
"@code{make-@var{name}}, e.g., @code{make-person}.  The above example changes "
"this to @code{create-person}.  Specifying @code{nil} as an argument means "
"that no standard constructor should be generated at all."
msgstr ""

#. type: table
#: ../../cl.texi:4105
msgid ""
"In the full form of this option, the constructor name is followed by an "
"arbitrary argument list.  @xref{Program Structure}, for a description of the "
"format of Common Lisp argument lists.  All options, such as @code{&rest} and "
"@code{&key}, are supported.  The argument names should match the slot names; "
"each slot is initialized from the corresponding argument.  Slots whose names "
"do not appear in the argument list are initialized based on the "
"@var{default-value} in their slot descriptor.  Also, @code{&optional} and "
"@code{&key} arguments that don't specify defaults take their defaults from "
"the slot descriptor.  It is valid to include arguments that don't correspond "
"to slot names; these are useful if they are referred to in the defaults for "
"optional, keyword, or @code{&aux} arguments that @emph{do} correspond to "
"slots."
msgstr ""

#. type: table
#: ../../cl.texi:4110
msgid ""
"You can specify any number of full-format @code{:constructor} options on a "
"structure.  The default constructor is still generated as well unless you "
"disable it with a simple-format @code{:constructor} option."
msgstr ""

#. type: example
#: ../../cl.texi:4122
#, no-wrap
msgid ""
"(cl-defstruct\n"
"    (person\n"
"     (:constructor nil)   ; no default constructor\n"
"     (:constructor new-person\n"
"                   (name sex &optional (age 0)))\n"
"     (:constructor new-hound (&key (name \"Rover\")\n"
"                                   (dog-years 0)\n"
"                              &aux (age (* 7 dog-years))\n"
"                                   (sex 'canine))))\n"
"    name age sex)\n"
msgstr ""

#. type: table
#: ../../cl.texi:4130
msgid ""
"The first constructor here takes its arguments positionally rather than by "
"keyword.  (In official Common Lisp terminology, constructors that work By "
"Order of Arguments instead of by keyword are called ``BOA constructors''.  "
"No, I'm not making this up.)  For example, @code{(new-person \"Jane\" "
"'female)} generates a person whose slots are @code{\"Jane\"}, 0, and "
"@code{female}, respectively."
msgstr ""

#. type: table
#: ../../cl.texi:4137
msgid ""
"The second constructor takes two keyword arguments, @code{:name}, which "
"initializes the @code{name} slot and defaults to @code{\"Rover\"}, and "
"@code{:dog-years}, which does not itself correspond to a slot but which is "
"used to initialize the @code{age} slot.  The @code{sex} slot is forced to "
"the symbol @code{canine} with no syntax for overriding it."
msgstr ""

#. type: item
#: ../../cl.texi:4138
#, no-wrap
msgid ":copier"
msgstr ""

#. type: table
#: ../../cl.texi:4143
msgid ""
"The argument is an alternate name for the copier function for this type.  "
"The default is @code{copy-@var{name}}.  @code{nil} means not to generate a "
"copier function.  (In this implementation, all copier functions are simply "
"synonyms for @code{copy-sequence}.)"
msgstr ""

#. type: item
#: ../../cl.texi:4144
#, no-wrap
msgid ":predicate"
msgstr ""

#. type: table
#: ../../cl.texi:4150
msgid ""
"The argument is an alternate name for the predicate that recognizes objects "
"of this type.  The default is @code{@var{name}-p}.  @code{nil} means not to "
"generate a predicate function.  (If the @code{:type} option is used without "
"the @code{:named} option, no predicate is ever generated.)"
msgstr ""

#. type: table
#: ../../cl.texi:4156
msgid ""
"In true Common Lisp, @code{typep} is always able to recognize a structure "
"object even if @code{:predicate} was used.  In this package, @code{cl-typep} "
"simply looks for a function called @code{@var{typename}-p}, so it will work "
"for structure types only if they used the default predicate name."
msgstr ""

#. type: item
#: ../../cl.texi:4157
#, no-wrap
msgid ":include"
msgstr ""

#. type: table
#: ../../cl.texi:4166
msgid ""
"This option implements a very limited form of C@t{++}-style inheritance.  "
"The argument is the name of another structure type previously created with "
"@code{cl-defstruct}.  The effect is to cause the new structure type to "
"inherit all of the included structure's slots (plus, of course, any new "
"slots described by this struct's slot descriptors).  The new structure is "
"considered a ``specialization'' of the included one.  In fact, the predicate "
"and slot accessors for the included type will also accept objects of the new "
"type."
msgstr ""

#. type: table
#: ../../cl.texi:4171
msgid ""
"If there are extra arguments to the @code{:include} option after the "
"included-structure name, these options are treated as replacement slot "
"descriptors for slots in the included structure, possibly with modified "
"default values.  Borrowing an example from Steele:"
msgstr ""

#. type: example
#: ../../cl.texi:4179
#, no-wrap
msgid ""
"(cl-defstruct person name (age 0) sex)\n"
"        @result{} person\n"
"(cl-defstruct (astronaut (:include person (age 45)))\n"
"     helmet-size\n"
"     (favorite-beverage 'tang))\n"
"        @result{} astronaut\n"
"\n"
msgstr ""

#. type: example
#: ../../cl.texi:4184
#, no-wrap
msgid ""
"(setq joe (make-person :name \"Joe\"))\n"
"     @result{} [cl-struct-person \"Joe\" 0 nil]\n"
"(setq buzz (make-astronaut :name \"Buzz\"))\n"
"     @result{} [cl-struct-astronaut \"Buzz\" 45 nil nil tang]\n"
"\n"
msgstr ""

#. type: example
#: ../../cl.texi:4189
#, no-wrap
msgid ""
"(list (person-p joe) (person-p buzz))\n"
"     @result{} (t t)\n"
"(list (astronaut-p joe) (astronaut-p buzz))\n"
"     @result{} (nil t)\n"
"\n"
msgstr ""

#. type: example
#: ../../cl.texi:4194
#, no-wrap
msgid ""
"(person-name buzz)\n"
"     @result{} \"Buzz\"\n"
"(astronaut-name joe)\n"
"     @result{} error: \"astronaut-name accessing a non-astronaut\"\n"
msgstr ""

#. type: table
#: ../../cl.texi:4202
msgid ""
"Thus, if @code{astronaut} is a specialization of @code{person}, then every "
"@code{astronaut} is also a @code{person} (but not the other way around).  "
"Every @code{astronaut} includes all the slots of a @code{person}, plus extra "
"slots that are specific to astronauts.  Operations that work on people (like "
"@code{person-name})  work on astronauts just like other people."
msgstr ""

#. type: item
#: ../../cl.texi:4203
#, no-wrap
msgid ":noinline"
msgstr ""

#. type: table
#: ../../cl.texi:4206
msgid ""
"If this option is present, this structure's functions will not be inlined, "
"even functions that normally would."
msgstr ""

#. type: item
#: ../../cl.texi:4207
#, no-wrap
msgid ":print-function"
msgstr ""

#. type: table
#: ../../cl.texi:4213
msgid ""
"In full Common Lisp, this option allows you to specify a function that is "
"called to print an instance of the structure type.  The Emacs Lisp system "
"offers no hooks into the Lisp printer which would allow for such a feature, "
"so this package simply ignores @code{:print-function}."
msgstr ""

#. type: table
#: ../../cl.texi:4220
msgid ""
"The argument should be one of the symbols @code{vector} or @code{list}.  "
"This tells which underlying Lisp data type should be used to implement the "
"new structure type.  Records are used by default, but @code{(:type vector)} "
"will cause structure objects to be stored as vectors and @code{(:type list)} "
"lists instead."
msgstr ""

#. type: table
#: ../../cl.texi:4225
msgid ""
"The record and vector representations for structure objects have the "
"advantage that all structure slots can be accessed quickly, although "
"creating them are a bit slower in Emacs Lisp.  Lists are easier to create, "
"but take a relatively long time accessing the later slots."
msgstr ""

#. type: item
#: ../../cl.texi:4226
#, no-wrap
msgid ":named"
msgstr ""

#. type: table
#: ../../cl.texi:4232
msgid ""
"This option, which takes no arguments, causes a characteristic ``tag'' "
"symbol to be stored at the front of the structure object.  Using "
"@code{:type} without also using @code{:named} will result in a structure "
"type stored as plain vectors or lists with no identifying features."
msgstr ""

#. type: table
#: ../../cl.texi:4236
msgid ""
"The default, if you don't specify @code{:type} explicitly, is to use "
"records, which are always tagged.  Therefore, @code{:named} is only useful "
"in conjunction with @code{:type}."
msgstr ""

#. type: example
#: ../../cl.texi:4242
#, no-wrap
msgid ""
"(cl-defstruct (person1) name age sex)\n"
"(cl-defstruct (person2 (:type list) :named) name age sex)\n"
"(cl-defstruct (person3 (:type list)) name age sex)\n"
"(cl-defstruct (person4 (:type vector)) name age sex)\n"
"\n"
msgstr ""

#. type: example
#: ../../cl.texi:4251
#, no-wrap
msgid ""
"(setq p1 (make-person1))\n"
"     @result{} #s(person1 nil nil nil)\n"
"(setq p2 (make-person2))\n"
"     @result{} (person2 nil nil nil)\n"
"(setq p3 (make-person3))\n"
"     @result{} (nil nil nil)\n"
"(setq p4 (make-person4))\n"
"     @result{} [nil nil nil]\n"
"\n"
msgstr ""

#. type: example
#: ../../cl.texi:4258
#, no-wrap
msgid ""
"(person1-p p1)\n"
"     @result{} t\n"
"(person2-p p2)\n"
"     @result{} t\n"
"(person3-p p3)\n"
"     @result{} error: function person3-p undefined\n"
msgstr ""

#. type: table
#: ../../cl.texi:4268
msgid ""
"Since unnamed structures don't have tags, @code{cl-defstruct} is not able to "
"make a useful predicate for recognizing them.  Also, accessors like "
"@code{person3-name} will be generated but they will not be able to do any "
"type checking.  The @code{person3-name} function, for example, will simply "
"be a synonym for @code{car} in this case.  By contrast, @code{person2-name} "
"is able to verify that its argument is indeed a @code{person2} object before "
"proceeding."
msgstr ""

#. type: item
#: ../../cl.texi:4269
#, no-wrap
msgid ":initial-offset"
msgstr ""

#. type: table
#: ../../cl.texi:4279
msgid ""
"The argument must be a nonnegative integer.  It specifies a number of slots "
"to be left ``empty'' at the front of the structure.  If the structure is "
"named, the tag appears at the specified position in the list or vector; "
"otherwise, the first slot appears at that position.  Earlier positions are "
"filled with @code{nil} by the constructors and ignored otherwise.  If the "
"type @code{:include}s another type, then @code{:initial-offset} specifies a "
"number of slots to be skipped between the last slot of the included type and "
"the first new slot."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4284
msgid ""
"Except as noted, the @code{cl-defstruct} facility of this package is "
"entirely compatible with that of Common Lisp."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4287
msgid ""
"The @code{cl-defstruct} package also provides a few structure introspection "
"functions."
msgstr ""

#. type: defun
#: ../../cl.texi:4288
#, no-wrap
msgid "cl-struct-sequence-type struct-type"
msgstr ""

#. type: defun
#: ../../cl.texi:4293
msgid ""
"This function returns the underlying data structure for @code{struct-type}, "
"which is a symbol.  It returns @code{record}, @code{vector} or @code{list}, "
"or @code{nil} if @code{struct-type} is not actually a structure."
msgstr ""

#. type: defun
#: ../../cl.texi:4295
#, no-wrap
msgid "cl-struct-slot-info struct-type"
msgstr ""

#. type: defun
#: ../../cl.texi:4302
msgid ""
"This function returns a list of slot descriptors for structure "
"@code{struct-type}.  Each entry in the list is @code{(name . opts)}, where "
"@code{name} is the name of the slot and @code{opts} is the list of slot "
"options given to @code{defstruct}.  Dummy entries represent the slots used "
"for the struct name and that are skipped to implement "
"@code{:initial-offset}."
msgstr ""

#. type: defun
#: ../../cl.texi:4304
#, no-wrap
msgid "cl-struct-slot-offset struct-type slot-name"
msgstr ""

#. type: defun
#: ../../cl.texi:4310
msgid ""
"Return the offset of slot @code{slot-name} in @code{struct-type}.  The "
"returned zero-based slot index is relative to the start of the structure "
"data type and is adjusted for any structure name and :initial-offset slots.  "
"Signal error if struct @code{struct-type} does not contain @code{slot-name}."
msgstr ""

#. type: defun
#: ../../cl.texi:4312
#, no-wrap
msgid "cl-struct-slot-value struct-type slot-name inst"
msgstr ""

#. type: defun
#: ../../cl.texi:4317
msgid ""
"Return the value of slot @code{slot-name} in @code{inst} of "
"@code{struct-type}.  @code{struct} and @code{slot-name} are symbols.  "
"@code{inst} is a structure instance.  This routine is also a @code{setf} "
"place.  Can signal the same errors as @code{cl-struct-slot-offset}."
msgstr ""

#. type: chapter
#: ../../cl.texi:4320
#, no-wrap
msgid "Assertions and Errors"
msgstr ""

#. type: Plain text
#: ../../cl.texi:4327
msgid ""
"This section describes two macros that test @dfn{assertions}, i.e., "
"conditions which must be true if the program is operating correctly.  "
"Assertions never add to the behavior of a Lisp program; they simply make "
"``sanity checks'' to make sure everything is as it should be."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4332
msgid ""
"If the optimization property @code{speed} has been set to 3, and "
"@code{safety} is less than 3, then the byte-compiler will optimize away the "
"following assertions.  Because assertions might be optimized away, it is a "
"bad idea for them to include side-effects."
msgstr ""

#. type: defmac
#: ../../cl.texi:4333
#, no-wrap
msgid "cl-assert test-form [show-args string args@dots{}]"
msgstr ""

#. type: defmac
#: ../../cl.texi:4337
msgid ""
"This form verifies that @var{test-form} is true (i.e., evaluates to a "
"non-@code{nil} value).  If so, it returns @code{nil}.  If the test is not "
"satisfied, @code{cl-assert} signals an error."
msgstr ""

#. type: defmac
#: ../../cl.texi:4342
msgid ""
"A default error message will be supplied which includes @var{test-form}.  "
"You can specify a different error message by including a @var{string} "
"argument plus optional extra arguments.  Those arguments are simply passed "
"to @code{error} to signal the error."
msgstr ""

#. type: defmac
#: ../../cl.texi:4347
msgid ""
"If the optional second argument @var{show-args} is @code{t} instead of "
"@code{nil}, then the error message (with or without @var{string})  will also "
"include all non-constant arguments of the top-level @var{form}.  For "
"example:"
msgstr ""

#. type: example
#: ../../cl.texi:4350
#, no-wrap
msgid "(cl-assert (> x 10) t \"x is too small: %d\")\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:4357
msgid ""
"This usage of @var{show-args} is an extension to Common Lisp.  In true "
"Common Lisp, the second argument gives a list of @var{places} which can be "
"@code{setf}'d by the user before continuing from the error.  Since Emacs "
"Lisp does not support continuable errors, it makes no sense to specify "
"@var{places}."
msgstr ""

#. type: defmac
#: ../../cl.texi:4359
#, no-wrap
msgid "cl-check-type form type [string]"
msgstr ""

#. type: defmac
#: ../../cl.texi:4366
msgid ""
"This form verifies that @var{form} evaluates to a value of type @var{type}.  "
"If so, it returns @code{nil}.  If not, @code{cl-check-type} signals a "
"@code{wrong-type-argument} error.  The default error message lists the "
"erroneous value along with @var{type} and @var{form} themselves.  If "
"@var{string} is specified, it is included in the error message in place of "
"@var{type}.  For example:"
msgstr ""

#. type: example
#: ../../cl.texi:4369
#, no-wrap
msgid "(cl-check-type x (integer 1 *) \"a positive integer\")\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:4373
msgid ""
"@xref{Type Predicates}, for a description of the type specifiers that may be "
"used for @var{type}."
msgstr ""

#. type: defmac
#: ../../cl.texi:4378
msgid ""
"Note that in Common Lisp, the first argument to @code{check-type} must be a "
"@var{place} suitable for use by @code{setf}, because @code{check-type} "
"signals a continuable error that allows the user to modify @var{place}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4391
msgid ""
"Many of the advanced features of this package, such as @code{cl-defun}, "
"@code{cl-loop}, etc., are implemented as Lisp macros.  In byte-compiled "
"code, these complex notations will be expanded into equivalent Lisp code "
"which is simple and efficient.  For example, the form"
msgstr ""

#. type: example
#: ../../cl.texi:4394
#, no-wrap
msgid "(cl-incf i n)\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:4398
msgid "is expanded at compile-time to the Lisp form"
msgstr ""

#. type: example
#: ../../cl.texi:4401
#, no-wrap
msgid "(setq i (+ i n))\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:4407
msgid ""
"which is the most efficient way of doing this operation in Lisp.  Thus, "
"there is no performance penalty for using the more readable @code{cl-incf} "
"form in your compiled code."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4415
msgid ""
"@emph{Interpreted} code, on the other hand, must expand these macros every "
"time they are executed.  For this reason it is strongly recommended that "
"code making heavy use of macros be compiled.  A loop using @code{cl-incf} a "
"hundred times will execute considerably faster if compiled, and will also "
"garbage-collect less because the macro expansion will not have to be "
"generated, used, and thrown away a hundred times."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4418
msgid ""
"You can find out how a macro expands by using the @code{cl-prettyexpand} "
"function."
msgstr ""

#. type: defun
#: ../../cl.texi:4419
#, no-wrap
msgid "cl-prettyexpand form &optional full"
msgstr ""

#. type: defun
#: ../../cl.texi:4425
msgid ""
"This function takes a single Lisp form as an argument and inserts a nicely "
"formatted copy of it in the current buffer (which must be in Lisp mode so "
"that indentation works properly).  It also expands all Lisp macros that "
"appear in the form.  The easiest way to use this function is to go to the "
"@file{*scratch*} buffer and type, say,"
msgstr ""

#. type: example
#: ../../cl.texi:4428
#, no-wrap
msgid "(cl-prettyexpand '(cl-loop for x below 10 collect x))\n"
msgstr ""

#. type: defun
#: ../../cl.texi:4433
msgid ""
"and type @kbd{C-x C-e} immediately after the closing parenthesis; an "
"expansion similar to:"
msgstr ""

#. type: example
#: ../../cl.texi:4442
#, no-wrap
msgid ""
"(cl-block nil\n"
"     (let* ((x 0)\n"
"            (G1004 nil))\n"
"       (while (< x 10)\n"
"         (setq G1004 (cons x G1004))\n"
"         (setq x (+ x 1)))\n"
"       (nreverse G1004)))\n"
msgstr ""

#. type: defun
#: ../../cl.texi:4449
msgid ""
"will be inserted into the buffer.  (The @code{cl-block} macro is expanded "
"differently in the interpreter and compiler, so @code{cl-prettyexpand} just "
"leaves it alone.  The temporary variable @code{G1004} was created by "
"@code{cl-gensym}.)"
msgstr ""

#. type: defun
#: ../../cl.texi:4454
msgid ""
"If the optional argument @var{full} is true, then @emph{all} macros are "
"expanded, including @code{cl-block}, @code{cl-eval-when}, and compiler "
"macros.  Expansion is done as if @var{form} were a top-level form in a file "
"being compiled."
msgstr ""

#. type: example
#: ../../cl.texi:4466
#, no-wrap
msgid ""
"(cl-prettyexpand '(cl-pushnew 'x list))\n"
"     @print{} (setq list (cl-adjoin 'x list))\n"
"(cl-prettyexpand '(cl-pushnew 'x list) t)\n"
"     @print{} (setq list (if (memq 'x list) list (cons 'x list)))\n"
"(cl-prettyexpand '(caddr (cl-member 'a list)) t)\n"
"     @print{} (car (cdr (cdr (memq 'a list))))\n"
msgstr ""

#. type: defun
#: ../../cl.texi:4471
msgid ""
"Note that @code{cl-adjoin}, @code{cl-caddr}, and @code{cl-member} all have "
"built-in compiler macros to optimize them in common cases."
msgstr ""

#. type: appendixsec
#: ../../cl.texi:4473
#, no-wrap
msgid "Error Checking"
msgstr ""

#. type: Plain text
#: ../../cl.texi:4480
msgid ""
"Common Lisp compliance has in general not been sacrificed for the sake of "
"efficiency.  A few exceptions have been made for cases where substantial "
"gains were possible at the expense of marginal incompatibility."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4492
msgid ""
"The Common Lisp standard (as embodied in Steele's book) uses the phrase ``it "
"is an error if'' to indicate a situation that is not supposed to arise in "
"complying programs; implementations are strongly encouraged but not required "
"to signal an error in these situations.  This package sometimes omits such "
"error checking in the interest of compactness and efficiency.  For example, "
"@code{cl-do} variable specifiers are supposed to be lists of one, two, or "
"three forms; extra forms are ignored by this package rather than signaling a "
"syntax error.  Functions taking keyword arguments will accept an odd number "
"of arguments, treating the trailing keyword as if it were followed by the "
"value @code{nil}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4502
msgid ""
"Argument lists (as processed by @code{cl-defun} and friends)  @emph{are} "
"checked rigorously except for the minor point just mentioned; in particular, "
"keyword arguments are checked for validity, and @code{&allow-other-keys} and "
"@code{:allow-other-keys} are fully implemented.  Keyword validity checking "
"is slightly time consuming (though not too bad in byte-compiled code); you "
"can use @code{&allow-other-keys} to omit this check.  Functions defined in "
"this package such as @code{cl-find} and @code{cl-member} do check their "
"keyword arguments for validity."
msgstr ""

#. type: appendixsec
#: ../../cl.texi:4503
#, no-wrap
msgid "Compiler Optimizations"
msgstr ""

#. type: Plain text
#: ../../cl.texi:4514
msgid ""
"Changing the value of @code{byte-optimize} from the default @code{t} is "
"highly discouraged; many of the Common Lisp macros emit code that can be "
"improved by optimization.  In particular, @code{cl-block}s (whether explicit "
"or implicit in constructs like @code{cl-defun} and @code{cl-loop}) carry a "
"fair run-time penalty; the byte-compiler removes @code{cl-block}s that are "
"not actually referenced by @code{cl-return} or @code{cl-return-from} inside "
"the block."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4522
msgid ""
"The following is a list of some of the most important incompatibilities "
"between this package and Common Lisp as documented in Steele (2nd edition)."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4529
msgid ""
"The word @code{cl-defun} is required instead of @code{defun} in order to use "
"extended Common Lisp argument lists in a function.  Likewise, "
"@code{cl-defmacro} and @code{cl-function} are versions of those forms which "
"understand full-featured argument lists.  The @code{&whole} keyword does not "
"work in @code{cl-defmacro} argument lists (except inside recursive argument "
"lists)."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4533
msgid ""
"The @code{equal} predicate does not distinguish between IEEE floating-point "
"plus and minus zero.  The @code{cl-equalp} predicate has several differences "
"with Common Lisp; @pxref{Predicates}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4539
msgid ""
"The @code{cl-do-all-symbols} form is the same as @code{cl-do-symbols} with "
"no @var{obarray} argument.  In Common Lisp, this form would iterate over all "
"symbols in all packages.  Since Emacs obarrays are not a first-class package "
"mechanism, there is no way for @code{cl-do-all-symbols} to locate any but "
"the default obarray."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4542
msgid ""
"The @code{cl-loop} macro is complete except that @code{loop-finish} and type "
"specifiers are unimplemented."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4550
msgid ""
"The multiple-value return facility treats lists as multiple values, since "
"Emacs Lisp cannot support multiple return values directly.  The macros will "
"be compatible with Common Lisp if @code{cl-values} or @code{cl-values-list} "
"is always used to return to a @code{cl-multiple-value-bind} or other "
"multiple-value receiver; if @code{cl-values} is used without "
"@code{cl-multiple-value-@dots{}} or vice-versa the effect will be different "
"from Common Lisp."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4556
msgid ""
"Many Common Lisp declarations are ignored, and others match the Common Lisp "
"standard in concept but not in detail.  For example, local @code{special} "
"declarations, which are purely advisory in Emacs Lisp, do not rigorously "
"obey the scoping rules set down in Steele's book."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4558
msgid "The variable @code{cl--gensym-counter} starts out with zero."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4561
msgid ""
"The @code{cl-defstruct} facility is compatible, except that the @code{:type} "
"slot option is ignored."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4563
msgid "The second argument of @code{cl-check-type} is treated differently."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4577
msgid ""
"This package is meant to be used as an extension to Emacs Lisp, not as an "
"Emacs implementation of true Common Lisp.  Some of the remaining differences "
"between Emacs Lisp and Common Lisp make it difficult to port large Common "
"Lisp applications to Emacs.  For one, some of the features in this package "
"are not fully compliant with ANSI or Steele; @pxref{Common Lisp "
"Compatibility}.  But there are also quite a few features that this package "
"does not provide at all.  Here are some major omissions that you will want "
"to watch out for when bringing Common Lisp code into Emacs."
msgstr ""

#. type: itemize
#: ../../cl.texi:4584
msgid ""
"Case-insensitivity.  Symbols in Common Lisp are case-insensitive by "
"default.  Some programs refer to a function or variable as @code{foo} in one "
"place and @code{Foo} or @code{FOO} in another.  Emacs Lisp will treat these "
"as three distinct symbols."
msgstr ""

#. type: itemize
#: ../../cl.texi:4589
msgid ""
"Some Common Lisp code is written entirely in upper case.  While Emacs is "
"happy to let the program's own functions and variables use this convention, "
"calls to Lisp builtins like @code{if} and @code{defun} will have to be "
"changed to lower case."
msgstr ""

#. type: itemize
#: ../../cl.texi:4600
msgid ""
"Lexical scoping.  In Common Lisp, function arguments and @code{let} bindings "
"apply only to references physically within their bodies (or within macro "
"expansions in their bodies).  Traditionally, Emacs Lisp uses @dfn{dynamic "
"scoping} wherein a binding to a variable is visible even inside functions "
"called from the body.  @xref{Dynamic Binding,,,elisp,GNU Emacs Lisp "
"Reference Manual}.  Lexical binding is available since Emacs 24.1, so be "
"sure to set @code{lexical-binding} to @code{t} if you need to emulate this "
"aspect of Common Lisp.  @xref{Lexical Binding,,,elisp,GNU Emacs Lisp "
"Reference Manual}."
msgstr ""

#. type: itemize
#: ../../cl.texi:4603
msgid ""
"Here is an example of a Common Lisp code fragment that would fail in Emacs "
"Lisp if @code{lexical-binding} were set to @code{nil}:"
msgstr ""

#. type: example
#: ../../cl.texi:4609
#, no-wrap
msgid ""
"(defun map-odd-elements (func list)\n"
"  (loop for x in list\n"
"        for flag = t then (not flag)\n"
"        collect (if flag x (funcall func x))))\n"
"\n"
msgstr ""

#. type: example
#: ../../cl.texi:4612
#, no-wrap
msgid ""
"(defun add-odd-elements (list x)\n"
"  (map-odd-elements (lambda (a) (+ a x)) list))\n"
msgstr ""

#. type: itemize
#: ../../cl.texi:4620
msgid ""
"With lexical binding, the two functions' usages of @code{x} are completely "
"independent.  With dynamic binding, the binding to @code{x} made by "
"@code{add-odd-elements} will have been hidden by the binding in "
"@code{map-odd-elements} by the time the @code{(+ a x)} function is called."
msgstr ""

#. type: itemize
#: ../../cl.texi:4625
msgid ""
"Internally, this package uses lexical binding so that such problems do not "
"occur.  @xref{Obsolete Lexical Binding}, for a description of the obsolete "
"@code{lexical-let} form that emulates a Common Lisp-style lexical binding "
"when dynamic binding is in use."
msgstr ""

#. type: itemize
#: ../../cl.texi:4633
msgid ""
"Reader macros.  Common Lisp includes a second type of macro that works at "
"the level of individual characters.  For example, Common Lisp implements the "
"quote notation by a reader macro called @code{'}, whereas Emacs Lisp's "
"parser just treats quote as a special case.  Some Lisp packages use reader "
"macros to create special syntaxes for themselves, which the Emacs parser is "
"incapable of reading."
msgstr ""

#. type: itemize
#: ../../cl.texi:4641
msgid ""
"Other syntactic features.  Common Lisp provides a number of notations "
"beginning with @code{#} that the Emacs Lisp parser won't understand.  For "
"example, @samp{#| @dots{} |#} is an alternate comment notation, and "
"@samp{#+lucid (foo)} tells the parser to ignore the @code{(foo)} except in "
"Lucid Common Lisp."
msgstr ""

#. type: itemize
#: ../../cl.texi:4652
msgid ""
"Packages.  In Common Lisp, symbols are divided into @dfn{packages}.  Symbols "
"that are Lisp built-ins are typically stored in one package; symbols that "
"are vendor extensions are put in another, and each application program would "
"have a package for its own symbols.  Certain symbols are ``exported'' by a "
"package and others are internal; certain packages ``use'' or import the "
"exported symbols of other packages.  To access symbols that would not "
"normally be visible due to this importing and exporting, Common Lisp "
"provides a syntax like @code{package:symbol} or @code{package::symbol}."
msgstr ""

#. type: itemize
#: ../../cl.texi:4663
msgid ""
"Emacs Lisp has a single namespace for all interned symbols, and then uses a "
"naming convention of putting a prefix like @code{cl-} in front of the name.  "
"Some Emacs packages adopt the Common Lisp-like convention of using "
"@code{cl:} or @code{cl::} as the prefix.  However, the Emacs parser does not "
"understand colons and just treats them as part of the symbol name.  Thus, "
"while @code{mapcar} and @code{lisp:mapcar} may refer to the same symbol in "
"Common Lisp, they are totally distinct in Emacs Lisp.  Common Lisp programs "
"that refer to a symbol by the full name sometimes and the short name other "
"times will not port cleanly to Emacs."
msgstr ""

#. type: itemize
#: ../../cl.texi:4667
msgid ""
"Emacs Lisp does have a concept of ``obarrays'', which are package-like "
"collections of symbols, but this feature is not strong enough to be used as "
"a true package mechanism."
msgstr ""

#. type: itemize
#: ../../cl.texi:4682
msgid ""
"The @code{format} function is quite different between Common Lisp and Emacs "
"Lisp.  It takes an additional ``destination'' argument before the format "
"string.  A destination of @code{nil} means to format to a string as in Emacs "
"Lisp; a destination of @code{t} means to write to the terminal (similar to "
"@code{message} in Emacs).  Also, format control strings are utterly "
"different; @code{~} is used instead of @code{%} to introduce format codes, "
"and the set of available codes is much richer.  There are no notations like "
"@code{\\n} for string literals; instead, @code{format} is used with the "
"``newline'' format code, @code{~%}.  More advanced formatting codes provide "
"such features as paragraph filling, case conversion, and even loops and "
"conditionals."
msgstr ""

#. type: itemize
#: ../../cl.texi:4689
msgid ""
"While it would have been possible to implement most of Common Lisp "
"@code{format} in this package (under the name @code{cl-format}, of course), "
"it was not deemed worthwhile.  It would have required a huge amount of code "
"to implement even a decent subset of @code{format}, yet the functionality it "
"would provide over Emacs Lisp's @code{format} would rarely be useful."
msgstr ""

#. type: itemize
#: ../../cl.texi:4695
msgid ""
"Vector constants use square brackets in Emacs Lisp, but @code{#(a b c)} "
"notation in Common Lisp.  To further complicate matters, Emacs has its own "
"@code{#(} notation for something entirely different---strings with "
"properties."
msgstr ""

#. type: itemize
#: ../../cl.texi:4702
msgid ""
"Characters are distinct from integers in Common Lisp.  The notation for "
"character constants is also different: @code{#\\A} in Common Lisp where "
"Emacs Lisp uses @code{?A}.  Also, @code{string=} and @code{string-equal} are "
"synonyms in Emacs Lisp, whereas the latter is case-insensitive in Common "
"Lisp."
msgstr ""

#. type: itemize
#: ../../cl.texi:4712
msgid ""
"Data types.  Some Common Lisp data types do not exist in Emacs Lisp.  "
"Rational numbers and complex numbers are not present, nor are large integers "
"(all integers are ``fixnums'').  All arrays are one-dimensional.  There are "
"no readtables or pathnames; streams are a set of existing data types rather "
"than a new data type of their own.  Hash tables, random-states, and packages "
"(obarrays) are built from Lisp vectors or lists rather than being distinct "
"types."
msgstr ""

#. type: itemize
#: ../../cl.texi:4718
msgid ""
"The Common Lisp Object System (CLOS) is not implemented, nor is the Common "
"Lisp Condition System.  However, the EIEIO package (@pxref{Top, , "
"Introduction, eieio, EIEIO}) does implement some CLOS functionality."
msgstr ""

#. type: itemize
#: ../../cl.texi:4727
msgid ""
"Common Lisp features that are completely redundant with Emacs Lisp features "
"of a different name generally have not been implemented.  For example, "
"Common Lisp writes @code{defconstant} where Emacs Lisp uses "
"@code{defconst}.  Similarly, @code{make-list} takes its arguments in "
"different ways in the two Lisps but does exactly the same thing, so this "
"package has not bothered to implement a Common Lisp-style @code{make-list}."
msgstr ""

#. type: itemize
#: ../../cl.texi:4731
msgid ""
"A few more notable Common Lisp features not included in this package: "
"@code{compiler-let}, @code{prog}, @code{ldb/dpb}, @code{cerror}."
msgstr ""

#. type: itemize
#: ../../cl.texi:4739
msgid ""
"Recursion.  While recursion works in Emacs Lisp just like it does in Common "
"Lisp, various details of the Emacs Lisp system and compiler make recursion "
"much less efficient than it is in most Lisps.  Some schools of thought "
"prefer to use recursion in Lisp over other techniques; they would sum a list "
"of numbers using something like"
msgstr ""

#. type: example
#: ../../cl.texi:4745
#, no-wrap
msgid ""
"(defun sum-list (list)\n"
"  (if list\n"
"      (+ (car list) (sum-list (cdr list)))\n"
"    0))\n"
msgstr ""

#. type: itemize
#: ../../cl.texi:4750
msgid "where a more iteratively-minded programmer might write one of these forms:"
msgstr ""

#. type: example
#: ../../cl.texi:4754
#, no-wrap
msgid ""
"(let ((total 0)) (dolist (x my-list) (incf total x)) total)\n"
"(loop for x in my-list sum x)\n"
msgstr ""

#. type: itemize
#: ../../cl.texi:4761
msgid ""
"While this would be mainly a stylistic choice in most Common Lisps, in Emacs "
"Lisp you should be aware that the iterative forms are much faster than "
"recursion.  Also, Lisp programmers will want to note that the current Emacs "
"Lisp compiler does not optimize tail recursion."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4771
msgid ""
"This section describes some features of the package that are obsolete and "
"should not be used in new code.  They are either only provided by the old "
"@file{cl.el} entry point, not by the newer @file{cl-lib.el}; or where "
"versions with a @samp{cl-} prefix do exist they do not behave in exactly the "
"same way."
msgstr ""

#. type: appendixsec
#: ../../cl.texi:4776 ../../cl.texi:4778 ../../cl.texi:4779
#, no-wrap
msgid "Obsolete Lexical Binding"
msgstr ""

#. type: menuentry
#: ../../cl.texi:4776
msgid "An approximation of lexical binding."
msgstr ""

#. type: appendixsec
#: ../../cl.texi:4776 ../../cl.texi:4894 ../../cl.texi:4895
#, no-wrap
msgid "Obsolete Macros"
msgstr ""

#. type: menuentry
#: ../../cl.texi:4776
msgid "Obsolete macros."
msgstr ""

#. type: node
#: ../../cl.texi:4776 ../../cl.texi:4969
#, no-wrap
msgid "Obsolete Setf Customization"
msgstr ""

#. type: menuentry
#: ../../cl.texi:4776
msgid "Obsolete ways to customize setf."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4784
msgid ""
"The following macros are extensions to Common Lisp, where all bindings are "
"lexical unless declared otherwise.  These features are likewise obsolete "
"since the introduction of true lexical binding in Emacs 24.1."
msgstr ""

#. type: defmac
#: ../../cl.texi:4785
#, no-wrap
msgid "lexical-let (bindings@dots{}) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:4788
msgid ""
"This form is exactly like @code{let} except that the bindings it establishes "
"are purely lexical."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4796
msgid ""
"Lexical bindings are similar to local variables in a language like C: Only "
"the code physically within the body of the @code{lexical-let} (after macro "
"expansion) may refer to the bound variables."
msgstr ""

#. type: example
#: ../../cl.texi:4804
#, no-wrap
msgid ""
"(setq a 5)\n"
"(defun foo (b) (+ a b))\n"
"(let ((a 2)) (foo a))\n"
"     @result{} 4\n"
"(lexical-let ((a 2)) (foo a))\n"
"     @result{} 7\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:4812
msgid ""
"In this example, a regular @code{let} binding of @code{a} actually makes a "
"temporary change to the global variable @code{a}, so @code{foo} is able to "
"see the binding of @code{a} to 2.  But @code{lexical-let} actually creates a "
"distinct local variable @code{a} for use within its body, without any effect "
"on the global variable of the same name."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4817
msgid ""
"The most important use of lexical bindings is to create @dfn{closures}.  A "
"closure is a function object that refers to an outside lexical variable "
"(@pxref{Closures,,,elisp,GNU Emacs Lisp Reference Manual}).  For example:"
msgstr ""

#. type: example
#: ../../cl.texi:4825
#, no-wrap
msgid ""
"(defun make-adder (n)\n"
"  (lexical-let ((n n))\n"
"    (function (lambda (m) (+ n m)))))\n"
"(setq add17 (make-adder 17))\n"
"(funcall add17 4)\n"
"     @result{} 21\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:4833
msgid ""
"The call @code{(make-adder 17)} returns a function object which adds 17 to "
"its argument.  If @code{let} had been used instead of @code{lexical-let}, "
"the function object would have referred to the global @code{n}, which would "
"have been bound to 17 only during the call to @code{make-adder} itself."
msgstr ""

#. type: example
#: ../../cl.texi:4850
#, no-wrap
msgid ""
"(defun make-counter ()\n"
"  (lexical-let ((n 0))\n"
"    (cl-function (lambda (&optional (m 1)) (cl-incf n m)))))\n"
"(setq count-1 (make-counter))\n"
"(funcall count-1 3)\n"
"     @result{} 3\n"
"(funcall count-1 14)\n"
"     @result{} 17\n"
"(setq count-2 (make-counter))\n"
"(funcall count-2 5)\n"
"     @result{} 5\n"
"(funcall count-1 2)\n"
"     @result{} 19\n"
"(funcall count-2)\n"
"     @result{} 6\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:4856
msgid ""
"Here we see that each call to @code{make-counter} creates a distinct local "
"variable @code{n}, which serves as a private counter for the function object "
"that is returned."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4866
msgid ""
"Closed-over lexical variables persist until the last reference to them goes "
"away, just like all other Lisp objects.  For example, @code{count-2} refers "
"to a function object which refers to an instance of the variable @code{n}; "
"this is the only reference to that variable, so after @code{(setq count-2 "
"nil)} the garbage collector would be able to delete this instance of "
"@code{n}.  Of course, if a @code{lexical-let} does not actually create any "
"closures, then the lexical variables are free as soon as the "
"@code{lexical-let} returns."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4872
msgid ""
"Many closures are used only during the extent of the bindings they refer to; "
"these are known as ``downward funargs'' in Lisp parlance.  When a closure is "
"used in this way, regular Emacs Lisp dynamic bindings suffice and will be "
"more efficient than @code{lexical-let} closures:"
msgstr ""

#. type: example
#: ../../cl.texi:4878
#, no-wrap
msgid ""
"(defun add-to-list (x list)\n"
"  (mapcar (lambda (y) (+ x y))) list)\n"
"(add-to-list 7 '(1 2 5))\n"
"     @result{} (8 9 12)\n"
msgstr ""

#. type: Plain text
#: ../../cl.texi:4883
msgid ""
"Since this lambda is only used while @code{x} is still bound, it is not "
"necessary to make a true closure out of it."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4888
msgid ""
"You can use @code{defun} or @code{flet} inside a @code{lexical-let} to "
"create a named closure.  If several closures are created in the body of a "
"single @code{lexical-let}, they all close over the same instance of the "
"lexical variable."
msgstr ""

#. type: defmac
#: ../../cl.texi:4889
#, no-wrap
msgid "lexical-let* (bindings@dots{}) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:4892
msgid ""
"This form is just like @code{lexical-let}, except that the bindings are made "
"sequentially in the manner of @code{let*}."
msgstr ""

#. type: Plain text
#: ../../cl.texi:4901
msgid ""
"The following macros are obsolete, and are replaced by versions with a "
"@samp{cl-} prefix that do not behave in exactly the same way.  Consequently, "
"the @file{cl.el} versions are not simply aliases to the @file{cl-lib.el} "
"versions."
msgstr ""

#. type: defmac
#: ../../cl.texi:4902
#, no-wrap
msgid "flet (bindings@dots{}) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:4907
msgid ""
"This macro is replaced by @code{cl-flet} (@pxref{Function Bindings}), which "
"behaves the same way as Common Lisp's @code{flet}.  This @code{flet} takes "
"the same arguments as @code{cl-flet}, but does not behave in precisely the "
"same way."
msgstr ""

#. type: defmac
#: ../../cl.texi:4913
msgid ""
"While @code{flet} in Common Lisp establishes a lexical function binding, "
"this @code{flet} makes a dynamic binding (it dates from a time before Emacs "
"had lexical binding).  The result is that @code{flet} affects indirect calls "
"to a function as well as calls directly inside the @code{flet} form itself."
msgstr ""

#. type: defmac
#: ../../cl.texi:4918
msgid ""
"This will even work on Emacs primitives, although note that some calls to "
"primitive functions internal to Emacs are made without going through the "
"symbol's function cell, and so will not be affected by @code{flet}.  For "
"example,"
msgstr ""

#. type: example
#: ../../cl.texi:4922
#, no-wrap
msgid ""
"(flet ((message (&rest args) (push args saved-msgs)))\n"
"  (do-something))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:4932
msgid ""
"This code attempts to replace the built-in function @code{message} with a "
"function that simply saves the messages in a list rather than displaying "
"them.  The original definition of @code{message} will be restored after "
"@code{do-something} exits.  This code will work fine on messages generated "
"by other Lisp code, but messages generated directly inside Emacs will not be "
"caught since they make direct C-language calls to the message routines "
"rather than going through the Lisp @code{message} function."
msgstr ""

#. type: defmac
#: ../../cl.texi:4938
msgid ""
"For those cases where the dynamic scoping of @code{flet} is desired, "
"@code{cl-flet} is clearly not a substitute.  The most direct replacement "
"would be instead to use @code{cl-letf} to temporarily rebind "
"@code{(symbol-function '@var{fun})}.  But in most cases, a better substitute "
"is to use advice, such as:"
msgstr ""

#. type: example
#: ../../cl.texi:4945
#, no-wrap
msgid ""
"(defvar my-fun-advice-enable nil)\n"
"(add-advice '@var{fun} :around\n"
"            (lambda (orig &rest args)\n"
"              (if my-fun-advice-enable (do-something)\n"
"                (apply orig args))))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:4949
msgid ""
"so that you can then replace the @code{flet} with a simple dynamically "
"scoped binding of @code{my-fun-advice-enable}."
msgstr ""

#. type: defmac
#: ../../cl.texi:4956
msgid ""
"Note that many primitives (e.g., @code{+}) have special byte-compile "
"handling.  Attempts to redefine such functions using @code{flet}, "
"@code{cl-letf}, or advice will fail when byte-compiled."
msgstr ""

#. type: defmac
#: ../../cl.texi:4958
#, no-wrap
msgid "labels (bindings@dots{}) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:4963
msgid ""
"This macro is replaced by @code{cl-labels} (@pxref{Function Bindings}), "
"which behaves the same way as Common Lisp's @code{labels}.  This "
"@code{labels} takes the same arguments as @code{cl-labels}, but does not "
"behave in precisely the same way."
msgstr ""

#. type: defmac
#: ../../cl.texi:4967
msgid ""
"This version of @code{labels} uses the obsolete @code{lexical-let} form "
"(@pxref{Obsolete Lexical Binding}), rather than the true lexical binding "
"that @code{cl-labels} uses."
msgstr ""

#. type: appendixsec
#: ../../cl.texi:4970
#, no-wrap
msgid "Obsolete Ways to Customize Setf"
msgstr ""

#. type: Plain text
#: ../../cl.texi:4978
msgid ""
"Common Lisp defines three macros, @code{define-modify-macro}, "
"@code{defsetf}, and @code{define-setf-method}, that allow the user to extend "
"generalized variables in various ways.  In Emacs, these are obsolete, "
"replaced by various features of @file{gv.el} in Emacs 24.3.  @xref{Adding "
"Generalized Variables,,,elisp,GNU Emacs Lisp Reference Manual}."
msgstr ""

#. type: defmac
#: ../../cl.texi:4980
#, no-wrap
msgid "define-modify-macro name arglist function [doc-string]"
msgstr ""

#. type: defmac
#: ../../cl.texi:4984
msgid ""
"This macro defines a ``read-modify-write'' macro similar to @code{cl-incf} "
"and @code{cl-decf}.  You can replace this macro with @code{gv-letplace}."
msgstr ""

#. type: defmac
#: ../../cl.texi:4987
msgid ""
"The macro @var{name} is defined to take a @var{place} argument followed by "
"additional arguments described by @var{arglist}.  The call"
msgstr ""

#. type: example
#: ../../cl.texi:4990
#, no-wrap
msgid "(@var{name} @var{place} @var{args}@dots{})\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:4994 ../../cl.texi:5051
msgid "will be expanded to"
msgstr ""

#. type: example
#: ../../cl.texi:4997
#, no-wrap
msgid "(cl-callf @var{func} @var{place} @var{args}@dots{})\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:5001
msgid "which in turn is roughly equivalent to"
msgstr ""

#. type: example
#: ../../cl.texi:5004
#, no-wrap
msgid "(setf @var{place} (@var{func} @var{place} @var{args}@dots{}))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:5007
msgid "For example:"
msgstr ""

#. type: example
#: ../../cl.texi:5011
#, no-wrap
msgid ""
"(define-modify-macro incf (&optional (n 1)) +)\n"
"(define-modify-macro concatf (&rest args) concat)\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:5015
msgid ""
"Note that @code{&key} is not allowed in @var{arglist}, but @code{&rest} is "
"sufficient to pass keywords on to the function."
msgstr ""

#. type: defmac
#: ../../cl.texi:5020
msgid ""
"Most of the modify macros defined by Common Lisp do not exactly follow the "
"pattern of @code{define-modify-macro}.  For example, @code{push} takes its "
"arguments in the wrong order, and @code{pop} is completely irregular."
msgstr ""

#. type: defmac
#: ../../cl.texi:5023
msgid "The above @code{incf} example could be written using @code{gv-letplace} as:"
msgstr ""

#. type: example
#: ../../cl.texi:5028
#, no-wrap
msgid ""
"(defmacro incf (place &optional n)\n"
"  (gv-letplace (getter setter) place\n"
"    (macroexp-let2 nil v (or n 1)\n"
"      (funcall setter `(+ ,v ,getter)))))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:5037
#, no-wrap
msgid "defsetf access-fn update-fn"
msgstr ""

#. type: defmac
#: ../../cl.texi:5040
msgid ""
"This is the simpler of two @code{defsetf} forms, and is replaced by "
"@code{gv-define-simple-setter}."
msgstr ""

#. type: defmac
#: ../../cl.texi:5044
msgid ""
"With @var{access-fn} the name of a function that accesses a place, this "
"declares @var{update-fn} to be the corresponding store function.  From now "
"on,"
msgstr ""

#. type: example
#: ../../cl.texi:5047
#, no-wrap
msgid "(setf (@var{access-fn} @var{arg1} @var{arg2} @var{arg3}) @var{value})\n"
msgstr ""

#. type: example
#: ../../cl.texi:5054
#, no-wrap
msgid "(@var{update-fn} @var{arg1} @var{arg2} @var{arg3} @var{value})\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:5062
msgid ""
"The @var{update-fn} is required to be either a true function, or a macro "
"that evaluates its arguments in a function-like way.  Also, the "
"@var{update-fn} is expected to return @var{value} as its result.  Otherwise, "
"the above expansion would not obey the rules for the way @code{setf} is "
"supposed to behave."
msgstr ""

#. type: defmac
#: ../../cl.texi:5067
msgid ""
"As a special (non-Common-Lisp) extension, a third argument of @code{t} to "
"@code{defsetf} says that the return value of @code{update-fn} is not "
"suitable, so that the above @code{setf} should be expanded to something more "
"like"
msgstr ""

#. type: example
#: ../../cl.texi:5072
#, no-wrap
msgid ""
"(let ((temp @var{value}))\n"
"  (@var{update-fn} @var{arg1} @var{arg2} @var{arg3} temp)\n"
"  temp)\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:5075
msgid "Some examples are:"
msgstr ""

#. type: example
#: ../../cl.texi:5079
#, no-wrap
msgid ""
"(defsetf car setcar)\n"
"(defsetf buffer-name rename-buffer t)\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:5082
msgid "These translate directly to @code{gv-define-simple-setter}:"
msgstr ""

#. type: example
#: ../../cl.texi:5086
#, no-wrap
msgid ""
"(gv-define-simple-setter car setcar)\n"
"(gv-define-simple-setter buffer-name rename-buffer t)\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:5089
#, no-wrap
msgid "defsetf access-fn arglist (store-var) forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:5092
msgid ""
"This is the second, more complex, form of @code{defsetf}.  It can be "
"replaced by @code{gv-define-setter}."
msgstr ""

#. type: defmac
#: ../../cl.texi:5100
msgid ""
"This form of @code{defsetf} is rather like @code{defmacro} except for the "
"additional @var{store-var} argument.  The @var{forms} should return a Lisp "
"form that stores the value of @var{store-var} into the generalized variable "
"formed by a call to @var{access-fn} with arguments described by "
"@var{arglist}.  The @var{forms} may begin with a string which documents the "
"@code{setf} method (analogous to the doc string that appears at the front of "
"a function)."
msgstr ""

#. type: defmac
#: ../../cl.texi:5102
msgid "For example, the simple form of @code{defsetf} is shorthand for"
msgstr ""

#. type: example
#: ../../cl.texi:5106
#, no-wrap
msgid ""
"(defsetf @var{access-fn} (&rest args) (store)\n"
"  (append '(@var{update-fn}) args (list store)))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:5113
msgid ""
"The Lisp form that is returned can access the arguments from @var{arglist} "
"and @var{store-var} in an unrestricted fashion; macros like @code{cl-incf} "
"that invoke this setf-method will insert temporary variables as needed to "
"make sure the apparent order of evaluation is preserved."
msgstr ""

#. type: defmac
#: ../../cl.texi:5115
msgid "Another standard example:"
msgstr ""

#. type: example
#: ../../cl.texi:5119
#, no-wrap
msgid ""
"(defsetf nth (n x) (store)\n"
"  `(setcar (nthcdr ,n ,x) ,store))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:5122
msgid "You could write this using @code{gv-define-setter} as:"
msgstr ""

#. type: example
#: ../../cl.texi:5126
#, no-wrap
msgid ""
"(gv-define-setter nth (store n x)\n"
"  `(setcar (nthcdr ,n ,x) ,store))\n"
msgstr ""

#. type: defmac
#: ../../cl.texi:5129
#, no-wrap
msgid "define-setf-method access-fn arglist forms@dots{}"
msgstr ""

#. type: defmac
#: ../../cl.texi:5132
msgid ""
"This is the most general way to create new place forms.  You can replace "
"this by @code{gv-define-setter} or @code{gv-define-expander}."
msgstr ""

#. type: defmac
#: ../../cl.texi:5136
msgid ""
"When a @code{setf} to @var{access-fn} with arguments described by "
"@var{arglist} is expanded, the @var{forms} are evaluated and must return a "
"list of five items:"
msgstr ""

#. type: enumerate
#: ../../cl.texi:5140
msgid "A list of @dfn{temporary variables}."
msgstr ""

#. type: enumerate
#: ../../cl.texi:5145
msgid ""
"A list of @dfn{value forms} corresponding to the temporary variables above.  "
"The temporary variables will be bound to these value forms as the first step "
"of any operation on the generalized variable."
msgstr ""

#. type: enumerate
#: ../../cl.texi:5149
msgid ""
"A list of exactly one @dfn{store variable} (generally obtained from a call "
"to @code{gensym})."
msgstr ""

#. type: enumerate
#: ../../cl.texi:5154
msgid ""
"A Lisp form that stores the contents of the store variable into the "
"generalized variable, assuming the temporaries have been bound as described "
"above."
msgstr ""

#. type: enumerate
#: ../../cl.texi:5158
msgid ""
"A Lisp form that accesses the contents of the generalized variable, assuming "
"the temporaries have been bound."
msgstr ""

#. type: defmac
#: ../../cl.texi:5167
msgid ""
"This is exactly like the Common Lisp macro of the same name, except that the "
"method returns a list of five values rather than the five values themselves, "
"since Emacs Lisp does not support Common Lisp's notion of multiple return "
"values.  (Note that the @code{setf} implementation provided by @file{gv.el} "
"does not use this five item format.  Its use here is only for backwards "
"compatibility.)"
msgstr ""

#. type: defmac
#: ../../cl.texi:5169
msgid "Once again, the @var{forms} may begin with a documentation string."
msgstr ""

#. type: defmac
#: ../../cl.texi:5180
msgid ""
"A setf-method should be maximally conservative with regard to temporary "
"variables.  In the setf-methods generated by @code{defsetf}, the second "
"return value is simply the list of arguments in the place form, and the "
"first return value is a list of a corresponding number of temporary "
"variables generated by @code{cl-gensym}.  Macros like @code{cl-incf} that "
"use this setf-method will optimize away most temporaries that turn out to be "
"unnecessary, so there is little reason for the setf-method itself to "
"optimize."
msgstr ""

#. type: defun
#: ../../cl.texi:5184
#, no-wrap
msgid "get-setf-method place &optional env"
msgstr ""

#. type: defun
#: ../../cl.texi:5190
#, no-wrap
msgid ""
"This function returns the setf-method for @var{place}, by\n"
"invoking the definition previously recorded by @code{defsetf}\n"
"or @code{define-setf-method}.  The result is a list of five\n"
"values as described above.  You can use this function to build\n"
"your own @code{cl-incf}-like modify macros.\n"
"\n"
msgstr ""

#. type: defun
#: ../../cl.texi:5196
#, no-wrap
msgid ""
"The argument @var{env} specifies the ``environment'' to be\n"
"passed on to @code{macroexpand} if @code{get-setf-method} should\n"
"need to expand a macro in @var{place}.  It should come from\n"
"an @code{&environment} argument to the macro or setf-method\n"
"that called @code{get-setf-method}.\n"
msgstr ""

#. type: include
#: ../../cl.texi:5202
#, no-wrap
msgid "doclicense.texi"
msgstr ""
