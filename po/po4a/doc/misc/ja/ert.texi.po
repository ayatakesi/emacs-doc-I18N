# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-10-06 05:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: title
#: ../../../../../doc/misc/ert.texi:4 ../../../../../doc/misc/ert.texi:34
#, no-wrap
msgid "Emacs Lisp Regression Testing"
msgstr ""

#. type: include
#: ../../../../../doc/misc/ert.texi:5
#, no-wrap
msgid "docstyle.texi"
msgstr ""

#. type: dircategory
#: ../../../../../doc/misc/ert.texi:12
#, no-wrap
msgid "Emacs misc features"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:15
msgid "ERT: (ert)"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:15
msgid "Emacs Lisp regression testing tool."
msgstr ""

#. type: copying
#: ../../../../../doc/misc/ert.texi:19
msgid "Copyright @copyright{} 2008, 2010--2021 Free Software Foundation, Inc."
msgstr ""

#. type: quotation
#: ../../../../../doc/misc/ert.texi:27
msgid ""
"Permission is granted to copy, distribute and/or modify this document under "
"the terms of the GNU Free Documentation License, Version 1.3 or any later "
"version published by the Free Software Foundation; with no Invariant "
"Sections, with the Front-Cover Texts being ``A GNU Manual,'' and with the "
"Back-Cover Texts as in (a) below.  A copy of the license is included in the "
"section entitled ``GNU Free Documentation License''."
msgstr ""

#. type: quotation
#: ../../../../../doc/misc/ert.texi:30
msgid ""
"(a) The FSF's Back-Cover Text is: ``You have the freedom to copy and modify "
"this GNU manual.''"
msgstr ""

#. type: node
#: ../../../../../doc/misc/ert.texi:43
#, no-wrap
msgid "Top"
msgstr ""

#. type: top
#: ../../../../../doc/misc/ert.texi:44
#, no-wrap
msgid "ERT: Emacs Lisp Regression Testing"
msgstr ""

#. type: ifnottex
#: ../../../../../doc/misc/ert.texi:51
msgid ""
"ERT is a tool for automated testing in Emacs Lisp.  Its main features are "
"facilities for defining tests, running them and reporting the results, and "
"for debugging test failures interactively."
msgstr ""

#. type: ifnottex
#: ../../../../../doc/misc/ert.texi:58
msgid ""
"ERT is similar to tools for other environments such as JUnit, but has unique "
"features that take advantage of the dynamic and interactive nature of "
"Emacs.  Despite its name, it works well both for test-driven development "
"(see @url{https://en.wikipedia.org/wiki/Test-driven_development}) and for "
"traditional software development methods."
msgstr ""

#. type: chapter
#: ../../../../../doc/misc/ert.texi:68 ../../../../../doc/misc/ert.texi:112 ../../../../../doc/misc/ert.texi:113
#, no-wrap
msgid "Introduction"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:68
msgid "A simple example of an ERT test."
msgstr ""

#. type: chapter
#: ../../../../../doc/misc/ert.texi:68 ../../../../../doc/misc/ert.texi:73 ../../../../../doc/misc/ert.texi:180 ../../../../../doc/misc/ert.texi:181
#, no-wrap
msgid "How to Run Tests"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:68
msgid "Run tests in Emacs or from the command line."
msgstr ""

#. type: chapter
#: ../../../../../doc/misc/ert.texi:68 ../../../../../doc/misc/ert.texi:79 ../../../../../doc/misc/ert.texi:398 ../../../../../doc/misc/ert.texi:399
#, no-wrap
msgid "How to Write Tests"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:68
msgid "How to add tests to your Emacs Lisp code."
msgstr ""

#. type: chapter
#: ../../../../../doc/misc/ert.texi:68 ../../../../../doc/misc/ert.texi:86 ../../../../../doc/misc/ert.texi:700 ../../../../../doc/misc/ert.texi:701
#, no-wrap
msgid "How to Debug Tests"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:68
msgid "What to do if a test fails."
msgstr ""

#. type: chapter
#: ../../../../../doc/misc/ert.texi:68 ../../../../../doc/misc/ert.texi:91 ../../../../../doc/misc/ert.texi:841 ../../../../../doc/misc/ert.texi:842
#, no-wrap
msgid "Extending ERT"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:68
msgid "ERT is extensible in several ways."
msgstr ""

#. type: chapter
#: ../../../../../doc/misc/ert.texi:68 ../../../../../doc/misc/ert.texi:96 ../../../../../doc/misc/ert.texi:890 ../../../../../doc/misc/ert.texi:891
#, no-wrap
msgid "Other Testing Concepts"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:68
msgid "Features not in ERT."
msgstr ""

#. type: unnumbered
#: ../../../../../doc/misc/ert.texi:68 ../../../../../doc/misc/ert.texi:101 ../../../../../doc/misc/ert.texi:103 ../../../../../doc/misc/ert.texi:975 ../../../../../doc/misc/ert.texi:976
#, no-wrap
msgid "Index"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:68 ../../../../../doc/misc/ert.texi:103
msgid "Concept, Function and Variable Index"
msgstr ""

#. type: appendix
#: ../../../../../doc/misc/ert.texi:68 ../../../../../doc/misc/ert.texi:107 ../../../../../doc/misc/ert.texi:980 ../../../../../doc/misc/ert.texi:981
#, no-wrap
msgid "GNU Free Documentation License"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:68 ../../../../../doc/misc/ert.texi:107
msgid "The license for this documentation."
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:71
msgid "--- The Detailed Node Listing ---"
msgstr ""

#. type: section
#: ../../../../../doc/misc/ert.texi:77 ../../../../../doc/misc/ert.texi:196 ../../../../../doc/misc/ert.texi:199 ../../../../../doc/misc/ert.texi:200
#, no-wrap
msgid "Running Tests Interactively"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:77 ../../../../../doc/misc/ert.texi:196
msgid "Run tests in your current Emacs."
msgstr ""

#. type: section
#: ../../../../../doc/misc/ert.texi:77 ../../../../../doc/misc/ert.texi:196 ../../../../../doc/misc/ert.texi:294 ../../../../../doc/misc/ert.texi:295
#, no-wrap
msgid "Running Tests in Batch Mode"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:77 ../../../../../doc/misc/ert.texi:196
msgid "Run tests in emacs -Q."
msgstr ""

#. type: section
#: ../../../../../doc/misc/ert.texi:77 ../../../../../doc/misc/ert.texi:196 ../../../../../doc/misc/ert.texi:351 ../../../../../doc/misc/ert.texi:352
#, no-wrap
msgid "Test Selectors"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:77 ../../../../../doc/misc/ert.texi:196
msgid "Choose which tests to run."
msgstr ""

#. type: section
#: ../../../../../doc/misc/ert.texi:84 ../../../../../doc/misc/ert.texi:418 ../../../../../doc/misc/ert.texi:420 ../../../../../doc/misc/ert.texi:421
#, no-wrap
msgid "The @code{should} Macro"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:84 ../../../../../doc/misc/ert.texi:418
msgid "A powerful way to express assertions."
msgstr ""

#. type: section
#: ../../../../../doc/misc/ert.texi:84 ../../../../../doc/misc/ert.texi:418 ../../../../../doc/misc/ert.texi:487 ../../../../../doc/misc/ert.texi:488
#, no-wrap
msgid "Expected Failures"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:84 ../../../../../doc/misc/ert.texi:418
msgid "Tests for known bugs."
msgstr ""

#. type: section
#: ../../../../../doc/misc/ert.texi:84 ../../../../../doc/misc/ert.texi:418 ../../../../../doc/misc/ert.texi:543 ../../../../../doc/misc/ert.texi:544
#, no-wrap
msgid "Tests and Their Environment"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:84 ../../../../../doc/misc/ert.texi:418
msgid "Don't depend on customizations; no side effects."
msgstr ""

#. type: node
#: ../../../../../doc/misc/ert.texi:84 ../../../../../doc/misc/ert.texi:418 ../../../../../doc/misc/ert.texi:615
#, no-wrap
msgid "Useful Techniques"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:84 ../../../../../doc/misc/ert.texi:418
msgid "Some examples."
msgstr ""

#. type: section
#: ../../../../../doc/misc/ert.texi:89 ../../../../../doc/misc/ert.texi:710 ../../../../../doc/misc/ert.texi:713 ../../../../../doc/misc/ert.texi:714
#, no-wrap
msgid "Understanding Explanations"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:89 ../../../../../doc/misc/ert.texi:710
msgid "How ERT gives details on why an assertion failed."
msgstr ""

#. type: section
#: ../../../../../doc/misc/ert.texi:89 ../../../../../doc/misc/ert.texi:710 ../../../../../doc/misc/ert.texi:782 ../../../../../doc/misc/ert.texi:783
#, no-wrap
msgid "Interactive Debugging"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:89 ../../../../../doc/misc/ert.texi:710
msgid "Tools available in the ERT results buffer."
msgstr ""

#. type: section
#: ../../../../../doc/misc/ert.texi:94 ../../../../../doc/misc/ert.texi:850 ../../../../../doc/misc/ert.texi:853 ../../../../../doc/misc/ert.texi:854
#, no-wrap
msgid "Defining Explanation Functions"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:94 ../../../../../doc/misc/ert.texi:850
msgid "Teach ERT about more predicates."
msgstr ""

#. type: section
#: ../../../../../doc/misc/ert.texi:94 ../../../../../doc/misc/ert.texi:850 ../../../../../doc/misc/ert.texi:873 ../../../../../doc/misc/ert.texi:874
#, no-wrap
msgid "Low-Level Functions for Working with Tests"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:94 ../../../../../doc/misc/ert.texi:850
msgid "Use ERT's data for your purposes."
msgstr ""

#. type: node
#: ../../../../../doc/misc/ert.texi:99 ../../../../../doc/misc/ert.texi:899 ../../../../../doc/misc/ert.texi:901
#, no-wrap
msgid "Mocks and Stubs"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:99 ../../../../../doc/misc/ert.texi:899
msgid "Stubbing out code that is irrelevant to the test."
msgstr ""

#. type: section
#: ../../../../../doc/misc/ert.texi:99 ../../../../../doc/misc/ert.texi:899 ../../../../../doc/misc/ert.texi:915 ../../../../../doc/misc/ert.texi:916
#, no-wrap
msgid "Fixtures and Test Suites"
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:99 ../../../../../doc/misc/ert.texi:899
msgid "How ERT differs from tools for other languages."
msgstr ""

#. type: menuentry
#: ../../../../../doc/misc/ert.texi:105
msgid "Appendix"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:114
#, no-wrap
msgid "introduction to ERT"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:120
msgid ""
"ERT allows you to define @emph{tests} in addition to functions, macros, "
"variables, and the other usual Lisp constructs.  Tests are simply Lisp code: "
"code that invokes other code and checks whether it behaves as expected."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:124
msgid ""
"ERT keeps track of the tests that are defined and provides convenient "
"commands to run them to verify whether the definitions that are currently "
"loaded in Emacs pass the tests."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:127
msgid ""
"Some Lisp files have comments like the following (adapted from the package "
"@code{pp.el}):"
msgstr ""

#. type: lisp
#: ../../../../../doc/misc/ert.texi:132
#, no-wrap
msgid ""
";; (pp-to-string '(quote quote))          ; expected: \"'quote\"\n"
";; (pp-to-string '((quote a) (quote b)))  ; expected: \"('a 'b)\\n\"\n"
";; (pp-to-string '('a 'b))                ; same as above\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:139
msgid ""
"The code contained in these comments can be evaluated from time to time to "
"compare the output with the expected output.  ERT formalizes this and "
"introduces a common convention, which simplifies Emacs development, since "
"programmers no longer have to manually find and evaluate such comments."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:141
msgid "An ERT test definition equivalent to the above comments is this:"
msgstr ""

#. type: lisp
#: ../../../../../doc/misc/ert.texi:148
#, no-wrap
msgid ""
"(ert-deftest pp-test-quote ()\n"
"  \"Tests the rendering of `quote' symbols in `pp-to-string'.\"\n"
"  (should (equal (pp-to-string '(quote quote)) \"'quote\"))\n"
"  (should (equal (pp-to-string '((quote a) (quote b))) \"('a 'b)\\n\"))\n"
"  (should (equal (pp-to-string '('a 'b)) \"('a 'b)\\n\")))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:153
msgid ""
"If you know @code{defun}, the syntax of @code{ert-deftest} should look "
"familiar: This example defines a test named @code{pp-test-quote} that will "
"pass if the three calls to @code{equal} all return non-@code{nil}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:156
msgid ""
"@code{should} is a macro with the same meaning as @code{cl-assert} but "
"better error reporting.  @xref{The @code{should} Macro}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:163
msgid ""
"Each test should have a name that describes what functionality it tests.  "
"Test names can be chosen arbitrarily---they are in a namespace separate from "
"functions and variables---but should follow the usual Emacs Lisp convention "
"of having a prefix that indicates which package they belong to.  Test names "
"are displayed by ERT when reporting failures and can be used when selecting "
"which tests to run."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:167
msgid ""
"The empty parentheses @code{()} in the first line don't currently have any "
"meaning and are reserved for future extension.  They also make the syntax of "
"@code{ert-deftest} more similar to that of @code{defun}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:172
msgid ""
"The docstring describes what feature this test tests.  When running tests "
"interactively, the first line of the docstring is displayed for tests that "
"fail, so it is good if the first line makes sense on its own."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:178
msgid ""
"The body of a test can be arbitrary Lisp code.  It should have as few side "
"effects as possible; each test should be written to clean up after itself, "
"leaving Emacs in the same state as it was before the test.  Tests should "
"clean up even if they fail.  @xref{Tests and Their Environment}."
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:182
#, no-wrap
msgid "how to run ert tests"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:191
msgid ""
"You can run tests either in the Emacs you are working in, or on the command "
"line in a separate Emacs process in batch mode (i.e., with no user "
"interface).  The former mode is convenient during interactive development, "
"the latter is useful to make sure that tests pass independently of your "
"customizations; and it allows you to invoke tests from makefiles, and to "
"write scripts that run tests in several different Emacs versions."
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:201
#, no-wrap
msgid "running tests interactively"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:202
#, no-wrap
msgid "interactive testing"
msgstr ""

#. type: findex
#: ../../../../../doc/misc/ert.texi:204
#, no-wrap
msgid "ert"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:210
msgid ""
"You can run the tests that are currently defined in your Emacs with the "
"command @kbd{M-x ert @key{RET} t @key{RET}}.  (For an explanation of the "
"@code{t} argument, @pxref{Test Selectors}.) ERT will pop up a new buffer, "
"the ERT results buffer, showing the results of the tests run.  It looks like "
"this:"
msgstr ""

#. type: example
#: ../../../../../doc/misc/ert.texi:217
#, no-wrap
msgid ""
"Selector: t\n"
"Passed:  31\n"
"Skipped: 0\n"
"Failed:  2 (2 unexpected)\n"
"Total:   33/33\n"
"\n"
msgstr ""

#. type: example
#: ../../../../../doc/misc/ert.texi:221
#, no-wrap
msgid ""
"Started at:   2008-09-11 08:39:25-0700\n"
"Finished.\n"
"Finished at:  2008-09-11 08:39:27-0700\n"
"\n"
msgstr ""

#. type: example
#: ../../../../../doc/misc/ert.texi:223
#, no-wrap
msgid ""
"FF...............................\n"
"\n"
msgstr ""

#. type: example
#: ../../../../../doc/misc/ert.texi:233
#, no-wrap
msgid ""
"F addition-test\n"
"    (ert-test-failed\n"
"     ((should\n"
"       (=\n"
"        (+ 1 2)\n"
"        4))\n"
"      :form\n"
"      (= 3 4)\n"
"      :value nil))\n"
"\n"
msgstr ""

#. type: example
#: ../../../../../doc/misc/ert.texi:247 ../../../../../doc/misc/ert.texi:756
#, no-wrap
msgid ""
"F list-test\n"
"    (ert-test-failed\n"
"     ((should\n"
"       (equal\n"
"        (list 'a 'b 'c)\n"
"        '(a b d)))\n"
"      :form\n"
"      (equal\n"
"       (a b c)\n"
"       (a b d))\n"
"      :value nil :explanation\n"
"      (list-elt 2\n"
"                (different-atoms c d))))\n"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:249
#, no-wrap
msgid "test results buffer"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:254
msgid ""
"At the top, there is a summary of the results: we ran all tests defined in "
"the current Emacs (@code{Selector: t}), 31 of them passed, and 2 failed "
"unexpectedly.  @xref{Expected Failures}, for an explanation of the term "
"@emph{unexpected} in this context."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:262
msgid ""
"The line of dots and @code{F}s is a progress bar where each character "
"represents one test; it fills while the tests are running.  A dot means that "
"the test passed, an @code{F} means that it failed.  Below the progress bar, "
"ERT shows details about each test that had an unexpected result.  In the "
"example above, there are two failures, both due to failed @code{should} "
"forms.  @xref{Understanding Explanations}, for more details."
msgstr ""

#. type: kindex
#: ../../../../../doc/misc/ert.texi:263
#, no-wrap
msgid "TAB@r{, in ert results buffer}"
msgstr ""

#. type: kindex
#: ../../../../../doc/misc/ert.texi:264
#, no-wrap
msgid "S-TAB@r{, in ert results buffer}"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:268
msgid ""
"In the ERT results buffer, @kbd{@key{TAB}} and @kbd{S-@key{TAB}} cycle "
"between buttons.  Each name of a function or macro in this buffer is a "
"button; moving point to it and typing @kbd{@key{RET}} jumps to its "
"definition."
msgstr ""

#. type: kindex
#: ../../../../../doc/misc/ert.texi:269
#, no-wrap
msgid "r@r{, in ert results buffer}"
msgstr ""

#. type: kindex
#: ../../../../../doc/misc/ert.texi:270
#, no-wrap
msgid "d@r{, in ert results buffer}"
msgstr ""

#. type: kindex
#: ../../../../../doc/misc/ert.texi:271
#, no-wrap
msgid ".@r{, in ert results buffer}"
msgstr ""

#. type: kindex
#: ../../../../../doc/misc/ert.texi:272
#, no-wrap
msgid "b@r{, in ert results buffer}"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:273
#, no-wrap
msgid "backtrace of a failed test"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:281
msgid ""
"Pressing @kbd{r} re-runs the test near point on its own.  Pressing @kbd{d} "
"re-runs it with the debugger enabled.  @kbd{.} jumps to the definition of "
"the test near point (@kbd{@key{RET}} has the same effect if point is on the "
"name of the test).  On a failed test, @kbd{b} shows the backtrace of the "
"failure.  @xref{Debugging,, Backtraces, elisp, GNU Emacs Lisp Reference "
"Manual}, for more information about backtraces."
msgstr ""

#. type: kindex
#: ../../../../../doc/misc/ert.texi:282
#, no-wrap
msgid "l@r{, in ert results buffer}"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:286
msgid ""
"@kbd{l} shows the list of @code{should} forms executed in the test.  If any "
"messages were generated (with the Lisp function @code{message})  in a test "
"or any of the code that it invoked, @kbd{m} will show them."
msgstr ""

#. type: kindex
#: ../../../../../doc/misc/ert.texi:287
#, no-wrap
msgid "L@r{, in ert results buffer}"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:292
msgid ""
"By default, long expressions in the failure details are abbreviated using "
"@code{print-length} and @code{print-level}.  Pressing @kbd{L} while point is "
"on a test failure will increase the limits to show more of the expression."
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:296
#, no-wrap
msgid "running tests in batch mode"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:297
#, no-wrap
msgid "batch-mode testing"
msgstr ""

#. type: findex
#: ../../../../../doc/misc/ert.texi:299
#, no-wrap
msgid "ert-run-tests-batch"
msgstr ""

#. type: findex
#: ../../../../../doc/misc/ert.texi:300
#, no-wrap
msgid "ert-run-tests-batch-and-exit"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:305
msgid ""
"ERT supports automated invocations from the command line or from scripts or "
"makefiles.  There are two functions for this purpose, "
"@code{ert-run-tests-batch} and @code{ert-run-tests-batch-and-exit}.  They "
"can be used like this:"
msgstr ""

#. type: example
#: ../../../../../doc/misc/ert.texi:308
#, no-wrap
msgid "emacs -batch -l ert -l my-tests.el -f ert-run-tests-batch-and-exit\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:315
msgid ""
"This command will start up Emacs in batch mode, load ERT, load "
"@code{my-tests.el}, and run all tests defined in it.  It will exit with a "
"zero exit status if all tests passed, or nonzero if any tests failed or if "
"anything else went wrong.  It will also print progress messages and error "
"diagnostics to standard output."
msgstr ""

#. type: findex
#: ../../../../../doc/misc/ert.texi:316
#, no-wrap
msgid "ert-summarize-tests-batch-and-exit"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:321
msgid ""
"You can also redirect the above output to a log file, say @file{output.log}, "
"and use the @code{ert-summarize-tests-batch-and-exit} function to produce a "
"neat summary as shown below:"
msgstr ""

#. type: example
#: ../../../../../doc/misc/ert.texi:324
#, no-wrap
msgid "emacs -batch -l ert -f ert-summarize-tests-batch-and-exit output.log\n"
msgstr ""

#. type: vindex
#: ../../../../../doc/misc/ert.texi:326
#, no-wrap
msgid "ert-quiet"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:332
msgid ""
"By default, ERT in batch mode is quite verbose, printing a line with result "
"after each test.  This gives you progress information: how many tests have "
"been executed and how many there are.  However, in some cases this much "
"output may be undesirable.  In this case, set @code{ert-quiet} variable to a "
"non-nil value:"
msgstr ""

#. type: example
#: ../../../../../doc/misc/ert.texi:336
#, no-wrap
msgid ""
"emacs -batch -l ert -l my-tests.el \\\n"
"      --eval \"(let ((ert-quiet t)) (ert-run-tests-batch-and-exit))\"\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:339
msgid "In quiet mode ERT prints only unexpected results and summary."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:344
msgid ""
"You can specify selectors to only run a subset of your tests (@pxref{Test "
"Selectors}).  For example, the following would run all tests where the name "
"of the test matches the regular expression ``to-match''."
msgstr ""

#. type: example
#: ../../../../../doc/misc/ert.texi:348
#, no-wrap
msgid ""
"emacs -batch -l ert -l my-tests.el \\\n"
"      -eval '(ert-run-tests-batch-and-exit \"to-match\")'\n"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:353
#, no-wrap
msgid "test selector"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:354
#, no-wrap
msgid "selecting tests"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:359
msgid ""
"Functions like @code{ert} accept a @emph{test selector}, a Lisp expression "
"specifying a set of tests.  Test selector syntax is similar to Common Lisp's "
"type specifier syntax:"
msgstr ""

#. type: item
#: ../../../../../doc/misc/ert.texi:361
#, no-wrap
msgid "@code{nil} selects no tests."
msgstr ""

#. type: item
#: ../../../../../doc/misc/ert.texi:362
#, no-wrap
msgid "@code{t} selects all tests."
msgstr ""

#. type: item
#: ../../../../../doc/misc/ert.texi:363
#, no-wrap
msgid "@code{:new} selects all tests that have not been run yet."
msgstr ""

#. type: item
#: ../../../../../doc/misc/ert.texi:364
#, no-wrap
msgid ""
"@code{:failed} and @code{:passed} select tests according to their most "
"recent result."
msgstr ""

#. type: item
#: ../../../../../doc/misc/ert.texi:365
#, no-wrap
msgid ""
"@code{:expected}, @code{:unexpected} select tests according to their most "
"recent result."
msgstr ""

#. type: item
#: ../../../../../doc/misc/ert.texi:366
#, no-wrap
msgid "A string is a regular expression that selects all tests with matching names."
msgstr ""

#. type: item
#: ../../../../../doc/misc/ert.texi:367
#, no-wrap
msgid "A test (i.e., an object of @code{ert-test} data type) selects that test."
msgstr ""

#. type: item
#: ../../../../../doc/misc/ert.texi:368
#, no-wrap
msgid "A symbol selects the test that the symbol names."
msgstr ""

#. type: item
#: ../../../../../doc/misc/ert.texi:369
#, no-wrap
msgid "@code{(member @var{tests}...)} selects the elements of"
msgstr ""

#. type: itemize
#: ../../../../../doc/misc/ert.texi:371
msgid "@var{tests}, a list of tests or symbols naming tests."
msgstr ""

#. type: item
#: ../../../../../doc/misc/ert.texi:371
#, no-wrap
msgid "@code{(eql @var{test})} selects @var{test}, a test or a symbol"
msgstr ""

#. type: itemize
#: ../../../../../doc/misc/ert.texi:373
msgid "naming a test."
msgstr ""

#. type: item
#: ../../../../../doc/misc/ert.texi:373
#, no-wrap
msgid "@code{(and @var{selectors}@dots{})} selects the tests that match"
msgstr ""

#. type: itemize
#: ../../../../../doc/misc/ert.texi:375
msgid "all @var{selectors}."
msgstr ""

#. type: item
#: ../../../../../doc/misc/ert.texi:375
#, no-wrap
msgid "@code{(or @var{selectors}@dots{})} selects the tests that match"
msgstr ""

#. type: itemize
#: ../../../../../doc/misc/ert.texi:377
msgid "any of the @var{selectors}."
msgstr ""

#. type: item
#: ../../../../../doc/misc/ert.texi:377
#, no-wrap
msgid "@code{(not @var{selector})} selects all tests that do not match"
msgstr ""

#. type: itemize
#: ../../../../../doc/misc/ert.texi:379
msgid "@var{selector}."
msgstr ""

#. type: item
#: ../../../../../doc/misc/ert.texi:379
#, no-wrap
msgid "@code{(tag @var{tag})} selects all tests that have @var{tag} on"
msgstr ""

#. type: itemize
#: ../../../../../doc/misc/ert.texi:382
msgid ""
"their tags list.  (Tags are optional labels you can apply to tests when you "
"define them.)"
msgstr ""

#. type: item
#: ../../../../../doc/misc/ert.texi:382
#, no-wrap
msgid "@code{(satisfies @var{predicate})} selects all tests that"
msgstr ""

#. type: itemize
#: ../../../../../doc/misc/ert.texi:385
msgid ""
"satisfy @var{predicate}, a function that takes a test as argument and "
"returns non-@code{nil} if it is selected."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:396
msgid ""
"Selectors that are frequently useful when selecting tests to run include "
"@code{t} to run all tests that are currently defined in Emacs, "
"@code{\"^foo-\"} to run all tests in package @code{foo} (this assumes that "
"package @code{foo} uses the prefix @code{foo-} for its test names), "
"result-based selectors such as @code{(or :new :unexpected)} to run all tests "
"that have either not run yet or that had an unexpected result in the last "
"run, and tag-based selectors such as @code{(not (tag :causes-redisplay))} to "
"run all tests that are not tagged @code{:causes-redisplay}."
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:400
#, no-wrap
msgid "how to write tests"
msgstr ""

#. type: findex
#: ../../../../../doc/misc/ert.texi:402
#, no-wrap
msgid "ert-deftest"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:407
msgid ""
"ERT lets you define tests in the same way you define functions.  You can "
"type @code{ert-deftest} forms in a buffer and evaluate them there with "
"@code{eval-defun} or @code{compile-defun}, or you can save the file and load "
"it, optionally byte-compiling it first."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:411
msgid ""
"Just like @code{find-function} is only able to find where a function was "
"defined if the function was loaded from a file, ERT is only able to find "
"where a test was defined if the test was loaded from a file."
msgstr ""

#. type: findex
#: ../../../../../doc/misc/ert.texi:423
#, no-wrap
msgid "should@r{, ert macro}"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:431
msgid ""
"Test bodies can include arbitrary code; but to be useful, they need to check "
"whether the code being tested (or @emph{code under test})  does what it is "
"supposed to do.  The macro @code{should} is similar to @code{cl-assert} from "
"the cl package (@pxref{Assertions,,, cl, Common Lisp Extensions}), but "
"analyzes its argument form and records information that ERT can display to "
"help debugging."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:433
msgid "This test definition"
msgstr ""

#. type: lisp
#: ../../../../../doc/misc/ert.texi:437
#, no-wrap
msgid ""
"(ert-deftest addition-test ()\n"
"  (should (= (+ 1 2) 4)))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:440
msgid "will produce this output when run via @kbd{M-x ert}:"
msgstr ""

#. type: example
#: ../../../../../doc/misc/ert.texi:451 ../../../../../doc/misc/ert.texi:730
#, no-wrap
msgid ""
"F addition-test\n"
"    (ert-test-failed\n"
"     ((should\n"
"       (=\n"
"        (+ 1 2)\n"
"        4))\n"
"      :form\n"
"      (= 3 4)\n"
"      :value nil))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:458
msgid ""
"In this example, @code{should} recorded the fact that (= (+ 1 2) 4)  reduced "
"to (= 3 4) before it reduced to @code{nil}.  When debugging why the test "
"failed, it helps to know that the function @code{+} returned 3 here.  ERT "
"records the return value for any predicate called directly within "
"@code{should}."
msgstr ""

#. type: findex
#: ../../../../../doc/misc/ert.texi:459
#, no-wrap
msgid "should-not@r{, ert macro}"
msgstr ""

#. type: findex
#: ../../../../../doc/misc/ert.texi:460
#, no-wrap
msgid "should-error@r{, ert macro}"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:465
msgid ""
"In addition to @code{should}, ERT provides @code{should-not}, which checks "
"that the predicate returns @code{nil}, and @code{should-error}, which checks "
"that the form called within it signals an error.  An example use of "
"@code{should-error}:"
msgstr ""

#. type: lisp
#: ../../../../../doc/misc/ert.texi:470
#, no-wrap
msgid ""
"(ert-deftest test-divide-by-zero ()\n"
"  (should-error (/ 1 0)\n"
"                :type 'arith-error))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:478
msgid ""
"This checks that dividing one by zero signals an error of type "
"@code{arith-error}.  The @code{:type} argument to @code{should-error} is "
"optional; if absent, any type of error is accepted.  @code{should-error} "
"returns an error description of the error that was signaled, to allow "
"additional checks to be made.  The error description has the format "
"@code{(ERROR-SYMBOL . DATA)}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:482
msgid ""
"There is no @code{should-not-error} macro since tests that signal an error "
"fail anyway, so @code{should-not-error} is effectively the default."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:485
msgid ""
"@xref{Understanding Explanations}, for more details on what @code{should} "
"reports."
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:489
#, no-wrap
msgid "expected failures"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:490
#, no-wrap
msgid "known bugs"
msgstr ""

#. type: vindex
#: ../../../../../doc/misc/ert.texi:492
#, no-wrap
msgid ":expected-result"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:499
msgid ""
"Some bugs are complicated to fix, or not very important, and are left as "
"@emph{known bugs}.  If there is a test case that triggers the bug and fails, "
"ERT will alert you of this failure every time you run all tests.  For known "
"bugs, this alert is a distraction.  The way to suppress it is to add "
"@code{:expected-result :failed} to the test definition:"
msgstr ""

#. type: lisp
#: ../../../../../doc/misc/ert.texi:506
#, no-wrap
msgid ""
"(ert-deftest future-bug ()\n"
"  \"Test `time-forward' with negative arguments.\n"
"Since this functionality isn't implemented, the test is known to fail.\"\n"
"  :expected-result :failed\n"
"  (time-forward -1))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:511
msgid ""
"ERT will still display a small @code{f} in the progress bar as a reminder "
"that there is a known bug, and will count the test as failed, but it will be "
"quiet about it otherwise."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:516
msgid ""
"An alternative to marking the test as a known failure this way is to delete "
"the test.  This is a good idea if there is no intent to fix it, i.e., if the "
"behavior that was formerly considered a bug has become an accepted feature."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:522
msgid ""
"In general, however, it can be useful to keep tests that are known to fail.  "
"If someone wants to fix the bug, they will have a very good starting point: "
"an automated test case that reproduces the bug.  This makes it much easier "
"to fix the bug, demonstrate that it is fixed, and prevent future "
"regressions."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:528
msgid ""
"ERT displays the same kind of alerts for tests that pass unexpectedly as it "
"displays for unexpected failures.  This way, if you make code changes that "
"happen to fix a bug that you weren't aware of, you will know to remove the "
"@code{:expected-result} clause of that test and close the corresponding bug "
"report, if any."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:532
msgid ""
"Since @code{:expected-result} evaluates its argument when the test is "
"loaded, tests can be marked as known failures only on certain Emacs "
"versions, specific architectures, etc.:"
msgstr ""

#. type: lisp
#: ../../../../../doc/misc/ert.texi:540
#, no-wrap
msgid ""
"(ert-deftest foo ()\n"
"  \"A test that is expected to fail on Emacs 23 but succeed elsewhere.\"\n"
"  :expected-result (if (string-match \"GNU Emacs 23[.]\" (emacs-version))\n"
"                       :failed\n"
"                     :passed)\n"
"  ...)\n"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:546
#, no-wrap
msgid "skipping tests"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:547
#, no-wrap
msgid "test preconditions"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:548
#, no-wrap
msgid "preconditions of a test"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:554
msgid ""
"Sometimes, it doesn't make sense to run a test due to missing "
"preconditions.  A required Emacs feature might not be compiled in, the "
"function to be tested could call an external binary which might not be "
"available on the test machine, you name it.  In this case, the macro "
"@code{skip-unless} could be used to skip the test:"
msgstr ""

#. type: lisp
#: ../../../../../doc/misc/ert.texi:560
#, no-wrap
msgid ""
"(ert-deftest test-dbus ()\n"
"  \"A test that checks D-BUS functionality.\"\n"
"  (skip-unless (featurep 'dbusbind))\n"
"  ...)\n"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:562
#, no-wrap
msgid "tests and their environment"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:570
msgid ""
"The outcome of running a test should not depend on the current state of the "
"environment, and each test should leave its environment in the same state it "
"found it in.  In particular, a test should not depend on any Emacs "
"customization variables or hooks, and if it has to make any changes to "
"Emacs's state or state external to Emacs (such as the file system), it "
"should undo these changes before it returns, regardless of whether it passed "
"or failed."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:579
msgid ""
"Tests should not depend on the environment because any such dependencies can "
"make the test brittle or lead to failures that occur only under certain "
"circumstances and are hard to reproduce.  Of course, the code under test may "
"have settings that affect its behavior.  In that case, it is best to make "
"the test @code{let}-bind all such setting variables to set up a specific "
"configuration for the duration of the test.  The test can also set up a "
"number of different configurations and run the code under test with each."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:591
msgid ""
"Tests that have side effects on their environment should restore it to its "
"original state because any side effects that persist after the test can "
"disrupt the workflow of the programmer running the tests.  If the code under "
"test has side effects on Emacs's current state, such as on the current "
"buffer or window configuration, the test should create a temporary buffer "
"for the code to manipulate (using @code{with-temp-buffer}), or save and "
"restore the window configuration (using @code{save-window-excursion}), "
"respectively.  For aspects of the state that can not be preserved with such "
"macros, cleanup should be performed with @code{unwind-protect}, to ensure "
"that the cleanup occurs even if the test fails."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:595
msgid ""
"An exception to this are messages that the code under test prints with "
"@code{message} and similar logging; tests should not bother restoring the "
"@file{*Message*} buffer to its original state."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:607
msgid ""
"The above guidelines imply that tests should avoid calling highly "
"customizable commands such as @code{find-file}, except, of course, if such "
"commands are what they want to test.  The exact behavior of @code{find-file} "
"depends on many settings such as @code{find-file-wildcards}, "
"@code{enable-local-variables}, and @code{auto-mode-alist}.  It is difficult "
"to write a meaningful test if its behavior can be affected by so many "
"external factors.  Also, @code{find-file} has side effects that are hard to "
"predict and thus hard to undo: It may create a new buffer or reuse an "
"existing buffer if one is already visiting the requested file; and it runs "
"@code{find-file-hook}, which can have arbitrary side effects."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:613
msgid ""
"Instead, it is better to use lower-level mechanisms with simple and "
"predictable semantics like @code{with-temp-buffer}, @code{insert} or "
"@code{insert-file-contents-literally}, and to activate any desired mode by "
"calling the corresponding function directly, after binding the hook "
"variables to @code{nil}.  This avoids the above problems."
msgstr ""

#. type: section
#: ../../../../../doc/misc/ert.texi:616
#, no-wrap
msgid "Useful Techniques when Writing Tests"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:617
#, no-wrap
msgid "useful techniques"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:618
#, no-wrap
msgid "tips and tricks"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:622
msgid ""
"Testing simple functions that have no side effects and no dependencies on "
"their environment is easy.  Such tests often look like this:"
msgstr ""

#. type: lisp
#: ../../../../../doc/misc/ert.texi:631
#, no-wrap
msgid ""
"(ert-deftest ert-test-mismatch ()\n"
"  (should (eql (cl-mismatch \"\" \"\") nil))\n"
"  (should (eql (cl-mismatch \"\" \"a\") 0))\n"
"  (should (eql (cl-mismatch \"a\" \"a\") nil))\n"
"  (should (eql (cl-mismatch \"ab\" \"a\") 1))\n"
"  (should (eql (cl-mismatch \"Aa\" \"aA\") 0))\n"
"  (should (eql (cl-mismatch '(a b c) '(a b d)) 2)))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:638
msgid ""
"This test calls the function @code{cl-mismatch} several times with various "
"combinations of arguments and compares the return value to the expected "
"return value.  (Some programmers prefer @code{(should (eql EXPECTED "
"ACTUAL))} over the @code{(should (eql ACTUAL EXPECTED))} shown here.  ERT "
"works either way.)"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:640
msgid "Here's a more complicated test:"
msgstr ""

#. type: lisp
#: ../../../../../doc/misc/ert.texi:654
#, no-wrap
msgid ""
"(ert-deftest ert-test-record-backtrace ()\n"
"  (let ((test (make-ert-test :body (lambda () (ert-fail \"foo\")))))\n"
"    (let ((result (ert-run-test test)))\n"
"      (should (ert-test-failed-p result))\n"
"      (with-temp-buffer\n"
"        (ert--print-backtrace (ert-test-failed-backtrace result))\n"
"        (goto-char (point-min))\n"
"        (end-of-line)\n"
"        (let ((first-line (buffer-substring-no-properties\n"
"                           (point-min) (point))))\n"
"          (should (equal first-line\n"
"                         \"  signal(ert-test-failed "
"(\\\"foo\\\"))\")))))))\n"
msgstr ""

#. type: findex
#: ../../../../../doc/misc/ert.texi:656
#, no-wrap
msgid "make-ert-test"
msgstr ""

#. type: findex
#: ../../../../../doc/misc/ert.texi:657
#, no-wrap
msgid "ert-equal-including-properties"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:668
msgid ""
"This test creates a test object using @code{make-ert-test} whose body will "
"immediately signal failure.  It then runs that test and asserts that it "
"fails.  Then, it creates a temporary buffer and invokes "
"@code{ert--print-backtrace} to print the backtrace of the failed test to the "
"current buffer.  Finally, it extracts the first line from the buffer and "
"asserts that it matches what we expect.  It uses "
"@code{buffer-substring-no-properties} and @code{equal} to ignore text "
"properties; for a test that takes properties into account, "
"@code{buffer-substring} and @code{ert-equal-including-properties} could be "
"used instead."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:675
msgid ""
"The reason why this test only checks the first line of the backtrace is that "
"the remainder of the backtrace is dependent on ERT's internals as well as "
"whether the code is running interpreted or compiled.  By looking only at the "
"first line, the test checks a useful property---that the backtrace correctly "
"captures the call to @code{signal} that results from the call to "
"@code{ert-fail}---without being brittle."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:678
msgid ""
"This example also shows that writing tests is much easier if the code under "
"test was structured with testing in mind."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:685
msgid ""
"For example, if @code{ert-run-test} accepted only symbols that name tests "
"rather than test objects, the test would need a name for the failing test, "
"which would have to be a temporary symbol generated with @code{make-symbol}, "
"to avoid side effects on Emacs's state.  Choosing the right interface for "
"@code{ert-run-tests} allows the test to be simpler."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:692
msgid ""
"Similarly, if @code{ert--print-backtrace} printed the backtrace to a buffer "
"with a fixed name rather than the current buffer, it would be much harder "
"for the test to undo the side effect.  Of course, some code somewhere needs "
"to pick the buffer name.  But that logic is independent of the logic that "
"prints backtraces, and keeping them in separate functions allows us to test "
"them independently."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:698
msgid ""
"A lot of code that you will encounter in Emacs was not written with testing "
"in mind.  Sometimes, the easiest way to write tests for such code is to "
"restructure the code slightly to provide better interfaces for testing.  "
"Usually, this makes the interfaces easier to use as well."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:705
msgid ""
"This section describes how to use ERT's features to understand why a test "
"failed."
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:715
#, no-wrap
msgid "understanding explanations"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:716
#, no-wrap
msgid "explanations, understanding"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:719
msgid "Failed @code{should} forms are reported like this:"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:738
msgid ""
"ERT shows what the @code{should} expression looked like and what values its "
"subexpressions had: The source code of the assertion was @code{(should (= (+ "
"1 2) 4))}, which applied the function @code{=} to the arguments @code{3} and "
"@code{4}, resulting in the value @code{nil}.  In this case, the test is "
"wrong; it should expect 3 rather than 4."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:741
msgid ""
"If a predicate like @code{equal} is used with @code{should}, ERT provides a "
"so-called @emph{explanation}:"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:762
msgid ""
"In this case, the function @code{equal} was applied to the arguments "
"@code{(a b c)} and @code{(a b d)}.  ERT's explanation shows that the item at "
"index 2 differs between the two lists; in one list, it is the atom c, in the "
"other, it is the atom d."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:766
msgid ""
"In simple examples like the above, the explanation is unnecessary.  But in "
"cases where the difference is not immediately apparent, it can save time:"
msgstr ""

#. type: example
#: ../../../../../doc/misc/ert.texi:776
#, no-wrap
msgid ""
"F test1\n"
"    (ert-test-failed\n"
"     ((should\n"
"       (equal x y))\n"
"      :form\n"
"      (equal a a)\n"
"      :value nil :explanation\n"
"      (different-symbols-with-the-same-name a a)))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:780
msgid ""
"ERT only provides explanations for predicates that have an explanation "
"function registered.  @xref{Defining Explanation Functions}."
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:784
#, no-wrap
msgid "interactive debugging"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:785
#, no-wrap
msgid "debugging failed tests"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:790
msgid ""
"Debugging failed tests essentially works the same way as debugging any other "
"problems with Lisp code.  Here are a few tricks specific to tests:"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:792
#, no-wrap
msgid "re-running a failed test"
msgstr ""

#. type: itemize
#: ../../../../../doc/misc/ert.texi:798
msgid ""
"Re-run the failed test a few times to see if it fails in the same way each "
"time.  It's good to find out whether the behavior is deterministic before "
"spending any time looking for a cause.  In the ERT results buffer, @kbd{r} "
"re-runs the selected test."
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:799
#, no-wrap
msgid "jump to the test source code"
msgstr ""

#. type: itemize
#: ../../../../../doc/misc/ert.texi:804
msgid ""
"Use @kbd{.} to jump to the source code of the test to find out exactly what "
"it does.  Perhaps the test is broken rather than the code under test."
msgstr ""

#. type: itemize
#: ../../../../../doc/misc/ert.texi:809
msgid ""
"If the test contains a series of @code{should} forms and you can't tell "
"which one failed, use @kbd{l}, which shows you the list of all @code{should} "
"forms executed during the test before it failed."
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:810
#, no-wrap
msgid "show backtrace of failed test"
msgstr ""

#. type: itemize
#: ../../../../../doc/misc/ert.texi:817
msgid ""
"Use @kbd{b} to view the backtrace.  You can also use @kbd{d} to re-run the "
"test with debugging enabled, this will enter the debugger and show the "
"backtrace as well; but the top few frames shown there will not be relevant "
"to you since they are ERT's own debugger hook.  @kbd{b} strips them out, so "
"it is more convenient."
msgstr ""

#. type: itemize
#: ../../../../../doc/misc/ert.texi:822
msgid ""
"If the test or the code under testing prints messages using @code{message}, "
"use @kbd{m} to see what messages it printed before it failed.  This can be "
"useful to figure out how far it got."
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:823
#, no-wrap
msgid "instrumenting test for Edebug"
msgstr ""

#. type: itemize
#: ../../../../../doc/misc/ert.texi:829
msgid ""
"You can instrument tests for debugging the same way you instrument "
"@code{defun}s for debugging: go to the source code of the test and type "
"@kbd{C-u C-M-x}.  Then, go back to the ERT buffer and re-run the test with "
"@kbd{r} or @kbd{d}."
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:830
#, no-wrap
msgid "discard obsolete test results"
msgstr ""

#. type: itemize
#: ../../../../../doc/misc/ert.texi:838
msgid ""
"If you have been editing and rearranging tests, it is possible that ERT "
"remembers an old test that you have since renamed or removed: renamings or "
"removals of definitions in the source code leave around a stray definition "
"under the old name in the running process (this is a common problem in "
"Lisp).  In such a situation, hit @kbd{D} to let ERT forget about the "
"obsolete test."
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:843
#, no-wrap
msgid "extending ert"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:846
msgid "There are several ways to add functionality to ERT."
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:855
#, no-wrap
msgid "defining explanation functions"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:865
msgid ""
"The explanation function for a predicate is a function that takes the same "
"arguments as the predicate and returns an @emph{explanation}.  The "
"explanation should explain why the predicate, when invoked with the "
"arguments given to the explanation function, returns the value that it "
"returns.  The explanation can be any object but should have a comprehensible "
"printed representation.  If the return value of the predicate needs no "
"explanation for a given list of arguments, the explanation function should "
"return @code{nil}."
msgstr ""

#. type: vindex
#: ../../../../../doc/misc/ert.texi:866
#, no-wrap
msgid "ert-explainer@r{, property}"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:871
msgid ""
"To associate an explanation function with a predicate, add the property "
"@code{ert-explainer} to the symbol that names the predicate.  The value of "
"the property should be the symbol that names the explanation function."
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:875
#, no-wrap
msgid "low-level functions"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:881
msgid ""
"Both @code{ert-run-tests-interactively} and @code{ert-run-tests-batch} are "
"implemented on top of the lower-level test handling code in the sections of "
"@file{ert.el} labeled ``Facilities for running a single test'', ``Test "
"selectors'', and ``Facilities for running a whole set of tests''."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:886
msgid ""
"If you want to write code that works with ERT tests, you should take a look "
"at this lower-level code.  Symbols that start with @code{ert--} are internal "
"to ERT, whereas those that start with @code{ert-} are meant to be usable by "
"other code.  But there is no mature API yet."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:888
msgid "Contributions to ERT are welcome."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:894
msgid "For information on mocks, stubs, fixtures, or test suites, see below."
msgstr ""

#. type: section
#: ../../../../../doc/misc/ert.texi:902
#, no-wrap
msgid "Other Tools for Emacs Lisp"
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:903
#, no-wrap
msgid "mocks and stubs"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:909
msgid ""
"Stubbing out functions or using so-called @emph{mocks} can make it easier to "
"write tests.  See @url{https://en.wikipedia.org/wiki/Mock_object} for an "
"explanation of the corresponding concepts in object-oriented languages."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:913
msgid ""
"ERT does not have built-in support for mocks or stubs.  The package "
"@code{el-mock} (see @url{https://www.emacswiki.org/emacs/el-mock.el})  "
"offers mocks for Emacs Lisp and can be used in conjunction with ERT."
msgstr ""

#. type: cindex
#: ../../../../../doc/misc/ert.texi:917
#, no-wrap
msgid "fixtures"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:922
msgid ""
"In many ways, ERT is similar to frameworks for other languages like SUnit or "
"JUnit.  However, two features commonly found in such frameworks are notably "
"absent from ERT: fixtures and test suites."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:926
msgid ""
"Fixtures are mainly used (e.g., in SUnit or JUnit) to provide an environment "
"for a set of tests, and consist of set-up and tear-down functions."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:931
msgid ""
"While fixtures are a useful syntactic simplification in other languages, "
"this does not apply to Lisp, where higher-order functions and "
"@code{unwind-protect} are available.  One way to implement and use a fixture "
"in ERT is"
msgstr ""

#. type: lisp
#: ../../../../../doc/misc/ert.texi:938
#, no-wrap
msgid ""
"(defun my-fixture (body)\n"
"  (unwind-protect\n"
"      (progn [set up]\n"
"             (funcall body))\n"
"    [tear down]))\n"
"\n"
msgstr ""

#. type: lisp
#: ../../../../../doc/misc/ert.texi:943
#, no-wrap
msgid ""
"(ert-deftest my-test ()\n"
"  (my-fixture\n"
"   (lambda ()\n"
"     [test code])))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:949
msgid ""
"(Another way would be a @code{with-my-fixture} macro.)  This solves the "
"set-up and tear-down part, and additionally allows any test to use any "
"combination of fixtures, so it is more flexible than what other tools "
"typically allow."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:952
msgid ""
"If the test needs access to the environment the fixture sets up, the fixture "
"can be modified to pass arguments to the body."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:955
msgid ""
"These are well-known Lisp techniques.  Special syntax for them could be "
"added but would provide only a minor simplification."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:961
msgid ""
"(If you are interested in such syntax, note that splitting set-up and "
"tear-down into separate functions, like *Unit tools usually do, makes it "
"impossible to establish dynamic @code{let} bindings as part of the fixture.  "
"So, blindly imitating the way fixtures are implemented in other languages "
"would be counter-productive in Lisp.)"
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:963
msgid "The purpose of test suites is to group related tests together."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:969
msgid ""
"The most common use of this is to run just the tests for one particular "
"module.  Since symbol prefixes are the usual way of separating module "
"namespaces in Emacs Lisp, test selectors already solve this by allowing "
"regexp matching on test names; e.g., the selector @code{\"^ert-\"} selects "
"ERT's self-tests."
msgstr ""

#. type: Plain text
#: ../../../../../doc/misc/ert.texi:974
msgid ""
"Other uses include grouping tests by their expected execution time, e.g., to "
"run quick tests during interactive development and slow tests less often.  "
"This can be achieved with the @code{:tag} argument to @code{ert-deftest} and "
"@code{tag} test selectors."
msgstr ""

#. type: include
#: ../../../../../doc/misc/ert.texi:982
#, no-wrap
msgid "doclicense.texi"
msgstr ""
