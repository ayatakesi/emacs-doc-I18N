# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-10-16 23:19+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: ../../../../../doc/lispref/control.texi:6 ../../../../../doc/lispref/control.texi:7
#, no-wrap
msgid "Control Structures"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:8
#, no-wrap
msgid "special forms for control structures"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:9
#, no-wrap
msgid "forms for control structures"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:10
#, no-wrap
msgid "control structures"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:17
msgid ""
"A Lisp program consists of a set of @dfn{expressions}, or @dfn{forms} "
"(@pxref{Forms}).  We control the order of execution of these forms by "
"enclosing them in @dfn{control structures}.  Control structures are special "
"forms which control when, whether, or how many times to execute the forms "
"they contain."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:18
#, no-wrap
msgid "textual order"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:27
msgid ""
"The simplest order of execution is sequential execution: first form @var{a}, "
"then form @var{b}, and so on.  This is what happens when you write several "
"forms in succession in the body of a function, or at top level in a file of "
"Lisp code---the forms are executed in the order written.  We call this "
"@dfn{textual order}.  For example, if a function body consists of two forms "
"@var{a} and @var{b}, evaluation of the function evaluates first @var{a} and "
"then @var{b}.  The result of evaluating @var{b} becomes the value of the "
"function."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:30
msgid ""
"Explicit control structures make possible an order of execution other than "
"sequential."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:37
msgid ""
"Emacs Lisp provides several kinds of control structure, including other "
"varieties of sequencing, conditionals, iteration, and (controlled)  "
"jumps---all discussed below.  The built-in control structures are special "
"forms since their subforms are not necessarily evaluated or not evaluated "
"sequentially.  You can use macros to define your own control structure "
"constructs (@pxref{Macros})."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/control.texi:46 ../../../../../doc/lispref/control.texi:48 ../../../../../doc/lispref/control.texi:49
#, no-wrap
msgid "Sequencing"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:46
msgid "Evaluation in textual order."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/control.texi:46 ../../../../../doc/lispref/control.texi:148 ../../../../../doc/lispref/control.texi:149
#, no-wrap
msgid "Conditionals"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:46
msgid "@code{if}, @code{cond}, @code{when}, @code{unless}."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/control.texi:46 ../../../../../doc/lispref/control.texi:297
#, no-wrap
msgid "Combining Conditions"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:46
msgid "@code{and}, @code{or}, @code{not}, and friends."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/control.texi:46 ../../../../../doc/lispref/control.texi:431 ../../../../../doc/lispref/control.texi:432
#, no-wrap
msgid "Pattern-Matching Conditional"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:46
msgid "How to use @code{pcase} and friends."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/control.texi:46 ../../../../../doc/lispref/control.texi:1309 ../../../../../doc/lispref/control.texi:1310
#, no-wrap
msgid "Iteration"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:46
msgid "@code{while} loops."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/control.texi:46 ../../../../../doc/lispref/control.texi:1401 ../../../../../doc/lispref/control.texi:1402
#, no-wrap
msgid "Generators"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:46
msgid "Generic sequences and coroutines."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/control.texi:46 ../../../../../doc/lispref/control.texi:1519 ../../../../../doc/lispref/control.texi:1520
#, no-wrap
msgid "Nonlocal Exits"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:46
msgid "Jumping out of a sequence."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:50
#, no-wrap
msgid "sequencing"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:51
#, no-wrap
msgid "sequential execution"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:52
#, no-wrap
msgid "forms for sequential execution"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:59
msgid ""
"Evaluating forms in the order they appear is the most common way control "
"passes from one form to another.  In some contexts, such as in a function "
"body, this happens automatically.  Elsewhere you must use a control "
"structure construct to do this: @code{progn}, the simplest control construct "
"of Lisp."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:61
msgid "A @code{progn} special form looks like this:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:65
#, no-wrap
msgid "(progn @var{a} @var{b} @var{c} @dots{})\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:73
msgid ""
"and it says to execute the forms @var{a}, @var{b}, @var{c}, and so on, in "
"that order.  These forms are called the @dfn{body} of the @code{progn} "
"form.  The value of the last form in the body becomes the value of the "
"entire @code{progn}.  @code{(progn)} returns @code{nil}."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:74
#, no-wrap
msgid "implicit @code{progn}"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:85
msgid ""
"In the early days of Lisp, @code{progn} was the only way to execute two or "
"more forms in succession and use the value of the last of them.  But "
"programmers found they often needed to use a @code{progn} in the body of a "
"function, where (at that time) only one form was allowed.  So the body of a "
"function was made into an implicit @code{progn}: several forms are allowed "
"just as in the body of an actual @code{progn}.  Many other control "
"structures likewise contain an implicit @code{progn}.  As a result, "
"@code{progn} is not used as much as it was many years ago.  It is needed now "
"most often inside an @code{unwind-protect}, @code{and}, @code{or}, or in the "
"@var{then}-part of an @code{if}."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:86
#, no-wrap
msgid "progn forms@dots{}"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:89
msgid ""
"This special form evaluates all of the @var{forms}, in textual order, "
"returning the result of the final form."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:99
#, no-wrap
msgid ""
"(progn (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The third form\"\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:105
msgid ""
"Two other constructs likewise evaluate a series of forms but return "
"different values:"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:106
#, no-wrap
msgid "prog1 form1 forms@dots{}"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:109
msgid ""
"This special form evaluates @var{form1} and all of the @var{forms}, in "
"textual order, returning the result of @var{form1}."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:119
#, no-wrap
msgid ""
"(prog1 (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The first form\"\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:124
msgid ""
"Here is a way to remove the first element from a list in the variable "
"@code{x}, then return the value of that former element:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:127
#, no-wrap
msgid "(prog1 (car x) (setq x (cdr x)))\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:130
#, no-wrap
msgid "prog2 form1 form2 forms@dots{}"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:134
msgid ""
"This special form evaluates @var{form1}, @var{form2}, and all of the "
"following @var{forms}, in textual order, returning the result of "
"@var{form2}."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:144
#, no-wrap
msgid ""
"(prog2 (print \"The first form\")\n"
"       (print \"The second form\")\n"
"       (print \"The third form\"))\n"
"     @print{} \"The first form\"\n"
"     @print{} \"The second form\"\n"
"     @print{} \"The third form\"\n"
"@result{} \"The second form\"\n"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:150
#, no-wrap
msgid "conditional evaluation"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:151
#, no-wrap
msgid "forms, conditional"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:159
msgid ""
"Conditional control structures choose among alternatives.  Emacs Lisp has "
"five conditional forms: @code{if}, which is much the same as in other "
"languages; @code{when} and @code{unless}, which are variants of @code{if}; "
"@code{cond}, which is a generalized case statement; and @code{pcase}, which "
"is a generalization of @code{cond} (@pxref{Pattern-Matching Conditional})."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:160
#, no-wrap
msgid "if condition then-form else-forms@dots{}"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:167
msgid ""
"@code{if} chooses between the @var{then-form} and the @var{else-forms} based "
"on the value of @var{condition}.  If the evaluated @var{condition} is "
"non-@code{nil}, @var{then-form} is evaluated and the result returned.  "
"Otherwise, the @var{else-forms} are evaluated in textual order, and the "
"value of the last one is returned.  (The @var{else} part of @code{if} is an "
"example of an implicit @code{progn}.  @xref{Sequencing}.)"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:170
msgid ""
"If @var{condition} has the value @code{nil}, and no @var{else-forms} are "
"given, @code{if} returns @code{nil}."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:174
msgid ""
"@code{if} is a special form because the branch that is not selected is never "
"evaluated---it is ignored.  Thus, in this example, @code{true} is not "
"printed because @code{print} is never called:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:181
#, no-wrap
msgid ""
"(if nil\n"
"    (print 'true)\n"
"  'very-false)\n"
"@result{} very-false\n"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:185
#, no-wrap
msgid "when condition then-forms@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:188
msgid ""
"This is a variant of @code{if} where there are no @var{else-forms}, and "
"possibly several @var{then-forms}.  In particular,"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:191
#, no-wrap
msgid "(when @var{condition} @var{a} @var{b} @var{c})\n"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:195 ../../../../../doc/lispref/control.texi:210
msgid "is entirely equivalent to"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:198
#, no-wrap
msgid "(if @var{condition} (progn @var{a} @var{b} @var{c}) nil)\n"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:201
#, no-wrap
msgid "unless condition forms@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:203
msgid "This is a variant of @code{if} where there is no @var{then-form}:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:206
#, no-wrap
msgid "(unless @var{condition} @var{a} @var{b} @var{c})\n"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:214
#, no-wrap
msgid ""
"(if @var{condition} nil\n"
"   @var{a} @var{b} @var{c})\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:217
#, no-wrap
msgid "cond clause@dots{}"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:222
msgid ""
"@code{cond} chooses among an arbitrary number of alternatives.  Each "
"@var{clause} in the @code{cond} must be a list.  The @sc{car} of this list "
"is the @var{condition}; the remaining elements, if any, the "
"@var{body-forms}.  Thus, a clause looks like this:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:225
#, no-wrap
msgid "(@var{condition} @var{body-forms}@dots{})\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:232
msgid ""
"@code{cond} tries the clauses in textual order, by evaluating the "
"@var{condition} of each clause.  If the value of @var{condition} is "
"non-@code{nil}, the clause succeeds; then @code{cond} evaluates its "
"@var{body-forms}, and returns the value of the last of @var{body-forms}.  "
"Any remaining clauses are ignored."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:235
msgid ""
"If the value of @var{condition} is @code{nil}, the clause fails, so the "
"@code{cond} moves on to the following clause, trying its @var{condition}."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:237
msgid "A clause may also look like this:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:240
#, no-wrap
msgid "(@var{condition})\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:245
msgid ""
"Then, if @var{condition} is non-@code{nil} when tested, the @code{cond} form "
"returns the value of @var{condition}."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:248
msgid ""
"If every @var{condition} evaluates to @code{nil}, so that every clause "
"fails, @code{cond} returns @code{nil}."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:252
msgid ""
"The following example has four clauses, which test for the cases where the "
"value of @code{x} is a number, string, buffer and symbol, respectively:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:261
#, no-wrap
msgid ""
"(cond ((numberp x) x)\n"
"      ((stringp x) x)\n"
"      ((bufferp x)\n"
"       (setq temporary-hack x) ; @r{multiple body-forms}\n"
"       (buffer-name x))        ; @r{in one clause}\n"
"      ((symbolp x) (symbol-value x)))\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:270
msgid ""
"Often we want to execute the last clause whenever none of the previous "
"clauses was successful.  To do this, we use @code{t} as the @var{condition} "
"of the last clause, like this: @code{(t @var{body-forms})}.  The form "
"@code{t} evaluates to @code{t}, which is never @code{nil}, so this clause "
"never fails, provided the @code{cond} gets to it at all.  For example:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:277
#, no-wrap
msgid ""
"(setq a 5)\n"
"(cond ((eq a 'hack) 'foo)\n"
"      (t \"default\"))\n"
"@result{} \"default\"\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:283
msgid ""
"This @code{cond} expression returns @code{foo} if the value of @code{a} is "
"@code{hack}, and returns the string @code{\"default\"} otherwise."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:288
msgid ""
"Any conditional construct can be expressed with @code{cond} or with "
"@code{if}.  Therefore, the choice between them is a matter of style.  For "
"example:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:294
#, no-wrap
msgid ""
"(if @var{a} @var{b} @var{c})\n"
"@equiv{}\n"
"(cond (@var{a} @var{b}) (t @var{c}))\n"
msgstr ""

#. type: section
#: ../../../../../doc/lispref/control.texi:298
#, no-wrap
msgid "Constructs for Combining Conditions"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:299
#, no-wrap
msgid "combining conditions"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:305
msgid ""
"This section describes constructs that are often used together with "
"@code{if} and @code{cond} to express complicated conditions.  The constructs "
"@code{and} and @code{or} can also be used individually as kinds of multiple "
"conditional constructs."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:306
#, no-wrap
msgid "not condition"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:311
msgid ""
"This function tests for the falsehood of @var{condition}.  It returns "
"@code{t} if @var{condition} is @code{nil}, and @code{nil} otherwise.  The "
"function @code{not} is identical to @code{null}, and we recommend using the "
"name @code{null} if you are testing for an empty list."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:313
#, no-wrap
msgid "and conditions@dots{}"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:317
msgid ""
"The @code{and} special form tests whether all the @var{conditions} are "
"true.  It works by evaluating the @var{conditions} one by one in the order "
"written."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:322
msgid ""
"If any of the @var{conditions} evaluates to @code{nil}, then the result of "
"the @code{and} must be @code{nil} regardless of the remaining "
"@var{conditions}; so @code{and} returns @code{nil} right away, ignoring the "
"remaining @var{conditions}."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:328
msgid ""
"If all the @var{conditions} turn out non-@code{nil}, then the value of the "
"last of them becomes the value of the @code{and} form.  Just @code{(and)}, "
"with no @var{conditions}, returns @code{t}, appropriate because all the "
"@var{conditions} turned out non-@code{nil}.  (Think about it; which one did "
"not?)"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:333
msgid ""
"Here is an example.  The first condition returns the integer 1, which is not "
"@code{nil}.  Similarly, the second condition returns the integer 2, which is "
"not @code{nil}.  The third condition is @code{nil}, so the remaining "
"condition is never evaluated."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:340
#, no-wrap
msgid ""
"(and (print 1) (print 2) nil (print 3))\n"
"     @print{} 1\n"
"     @print{} 2\n"
"@result{} nil\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:344
msgid "Here is a more realistic example of using @code{and}:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:349
#, no-wrap
msgid ""
"(if (and (consp foo) (eq (car foo) 'x))\n"
"    (message \"foo is a list starting with x\"))\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:355
msgid ""
"Note that @code{(car foo)} is not executed if @code{(consp foo)} returns "
"@code{nil}, thus avoiding an error."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:358
msgid ""
"@code{and} expressions can also be written using either @code{if} or "
"@code{cond}.  Here's how:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:366
#, no-wrap
msgid ""
"(and @var{arg1} @var{arg2} @var{arg3})\n"
"@equiv{}\n"
"(if @var{arg1} (if @var{arg2} @var{arg3}))\n"
"@equiv{}\n"
"(cond (@var{arg1} (cond (@var{arg2} @var{arg3}))))\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:370
#, no-wrap
msgid "or conditions@dots{}"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:374
msgid ""
"The @code{or} special form tests whether at least one of the "
"@var{conditions} is true.  It works by evaluating all the @var{conditions} "
"one by one in the order written."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:379
msgid ""
"If any of the @var{conditions} evaluates to a non-@code{nil} value, then the "
"result of the @code{or} must be non-@code{nil}; so @code{or} returns right "
"away, ignoring the remaining @var{conditions}.  The value it returns is the "
"non-@code{nil} value of the condition just evaluated."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:385
msgid ""
"If all the @var{conditions} turn out @code{nil}, then the @code{or} "
"expression returns @code{nil}.  Just @code{(or)}, with no @var{conditions}, "
"returns @code{nil}, appropriate because all the @var{conditions} turned out "
"@code{nil}.  (Think about it; which one did not?)"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:388
msgid ""
"For example, this expression tests whether @code{x} is either @code{nil} or "
"the integer zero:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:391
#, no-wrap
msgid "(or (eq x nil) (eq x 0))\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:395
msgid ""
"Like the @code{and} construct, @code{or} can be written in terms of "
"@code{cond}.  For example:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:403
#, no-wrap
msgid ""
"(or @var{arg1} @var{arg2} @var{arg3})\n"
"@equiv{}\n"
"(cond (@var{arg1})\n"
"      (@var{arg2})\n"
"      (@var{arg3}))\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:407
msgid "You could almost write @code{or} in terms of @code{if}, but not quite:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:413
#, no-wrap
msgid ""
"(if @var{arg1} @var{arg1}\n"
"  (if @var{arg2} @var{arg2}\n"
"    @var{arg3}))\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:420
msgid ""
"This is not completely equivalent because it can evaluate @var{arg1} or "
"@var{arg2} twice.  By contrast, @code{(or @var{arg1} @var{arg2} @var{arg3})} "
"never evaluates any argument more than once."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:422
#, no-wrap
msgid "xor condition1 condition2"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:427
msgid ""
"This function returns the boolean exclusive-or of @var{condition1} and "
"@var{condition2}.  That is, @code{xor} returns @code{nil} if either both "
"arguments are @code{nil}, or both are non-@code{nil}.  Otherwise, it returns "
"the value of that argument which is non-@code{nil}."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:429
msgid "Note that in contrast to @code{or}, both arguments are always evaluated."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:433
#, no-wrap
msgid "pcase"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:434
#, no-wrap
msgid "pattern matching, programming style"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:443
msgid ""
"Aside from the four basic conditional forms, Emacs Lisp also has a "
"pattern-matching conditional form, the @code{pcase} macro, a hybrid of "
"@code{cond} and @code{cl-case} (@pxref{Conditionals,,,cl,Common Lisp "
"Extensions})  that overcomes their limitations and introduces the "
"@dfn{pattern matching programming style}.  The limitations that @code{pcase} "
"overcomes are:"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/control.texi:451
msgid ""
"The @code{cond} form chooses among alternatives by evaluating the predicate "
"@var{condition} of each of its clauses (@pxref{Conditionals}).  The primary "
"limitation is that variables let-bound in @var{condition} are not available "
"to the clause's @var{body-forms}."
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/control.texi:456
msgid ""
"Another annoyance (more an inconvenience than a limitation)  is that when a "
"series of @var{condition} predicates implement equality tests, there is a "
"lot of repeated code.  (@code{cl-case} solves this inconvenience.)"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/control.texi:461
msgid ""
"The @code{cl-case} macro chooses among alternatives by evaluating the "
"equality of its first argument against a set of specific values."
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/control.texi:463
msgid "Its limitations are two-fold:"
msgstr ""

#. type: enumerate
#: ../../../../../doc/lispref/control.texi:467
msgid "The equality tests use @code{eql}."
msgstr ""

#. type: enumerate
#: ../../../../../doc/lispref/control.texi:469
msgid "The values must be known and written in advance."
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/control.texi:475
msgid ""
"These render @code{cl-case} unsuitable for strings or compound data "
"structures (e.g., lists or vectors).  (@code{cond} doesn't have these "
"limitations, but it has others, see above.)"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:485
msgid ""
"Conceptually, the @code{pcase} macro borrows the first-arg focus of "
"@code{cl-case} and the clause-processing flow of @code{cond}, replacing "
"@var{condition} with a generalization of the equality test which is a "
"variant of @dfn{pattern matching}, and adding facilities so that you can "
"concisely express a clause's predicate, and arrange to share let-bindings "
"between a clause's predicate and @var{body-forms}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:490
msgid ""
"The concise expression of a predicate is known as a @dfn{pattern}.  When the "
"predicate, called on the value of the first arg, returns non-@code{nil}, we "
"say that ``the pattern matches the value'' (or sometimes ``the value matches "
"the pattern'')."
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:496
msgid "The @code{pcase} macro: pcase Macro"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:496
msgid "Includes examples and caveats."
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:496
msgid "Extending @code{pcase}: Extending pcase"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:496
msgid "Define new kinds of patterns."
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:496
msgid "Backquote-Style Patterns: Backquote Patterns"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:496
msgid "Structural patterns matching."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/control.texi:496 ../../../../../doc/lispref/control.texi:1210
#, no-wrap
msgid "Destructuring with pcase Patterns"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:496
msgid "Using pcase patterns to extract subfields."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/control.texi:498
#, no-wrap
msgid "pcase Macro"
msgstr ""

#. type: subsection
#: ../../../../../doc/lispref/control.texi:499
#, no-wrap
msgid "The @code{pcase} macro"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:502
msgid "For background, @xref{Pattern-Matching Conditional}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:503
#, no-wrap
msgid "pcase expression &rest clauses"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:506
msgid ""
"Each clause in @var{clauses} has the form: @w{@code{(@var{pattern} "
"@var{body-forms}@dots{})}}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:510
msgid ""
"Evaluate @var{expression} to determine its value, @var{expval}.  Find the "
"first clause in @var{clauses} whose @var{pattern} matches @var{expval} and "
"pass control to that clause's @var{body-forms}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:514
msgid ""
"If there is a match, the value of @code{pcase} is the value of the last of "
"@var{body-forms} in the successful clause.  Otherwise, @code{pcase} "
"evaluates to @code{nil}."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:516
#, no-wrap
msgid "pcase pattern"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:520
msgid ""
"Each @var{pattern} has to be a @dfn{pcase pattern}, which can use either one "
"of the core patterns defined below, or one of the patterns defined via "
"@code{pcase-defmacro} (@pxref{Extending pcase})."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:525
msgid ""
"The rest of this subsection describes different forms of core patterns, "
"presents some examples, and concludes with important caveats on using the "
"let-binding facility provided by some pattern forms.  A core pattern can "
"have the following forms:"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:528
#, no-wrap
msgid "_"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:531
msgid ""
"Matches any @var{expval}.  This is also known as @dfn{don't care} or "
"@dfn{wildcard}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:532
#, no-wrap
msgid "'@var{val}"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:535
msgid ""
"Matches if @var{expval} equals @var{val}.  The comparison is done as if by "
"@code{equal} (@pxref{Equality Predicates})."
msgstr ""

#. type: var{#1}
#: ../../../../../doc/lispref/control.texi:536 ../../../../../doc/lispref/control.texi:1133
#, no-wrap
msgid "keyword"
msgstr ""

#. type: var{#1}
#: ../../../../../doc/lispref/control.texi:537
#, no-wrap
msgid "integer"
msgstr ""

#. type: var{#1}
#: ../../../../../doc/lispref/control.texi:538 ../../../../../doc/lispref/control.texi:1135
#, no-wrap
msgid "string"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:542
msgid ""
"Matches if @var{expval} equals the literal object.  This is a special case "
"of @code{'@var{val}}, above, possible because literal objects of these types "
"are self-quoting."
msgstr ""

#. type: var{#1}
#: ../../../../../doc/lispref/control.texi:543 ../../../../../doc/lispref/control.texi:1132
#, no-wrap
msgid "symbol"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:547
msgid ""
"Matches any @var{expval}, and additionally let-binds @var{symbol} to "
"@var{expval}, such that this binding is available to @var{body-forms} "
"(@pxref{Dynamic Binding})."
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:552
msgid ""
"If @var{symbol} is part of a sequencing pattern @var{seqpat} (e.g., by using "
"@code{and}, below), the binding is also available to the portion of "
"@var{seqpat} following the appearance of @var{symbol}.  This usage has some "
"caveats, see @ref{pcase-symbol-caveats,,caveats}."
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:557
msgid ""
"Two symbols to avoid are @code{t}, which behaves like @code{_} (above) and "
"is deprecated, and @code{nil}, which signals an error.  Likewise, it makes "
"no sense to bind keyword symbols (@pxref{Constant Variables})."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:558
#, no-wrap
msgid "(pred @var{function})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:562
msgid ""
"Matches if the predicate @var{function} returns non-@code{nil} when called "
"on @var{expval}.  the predicate @var{function} can have one of the following "
"forms:"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:564
#, no-wrap
msgid "function name (a symbol)"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:566
msgid "Call the named function with one argument, @var{expval}."
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:568
msgid "Example: @code{integerp}"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:569
#, no-wrap
msgid "lambda expression"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:572
msgid ""
"Call the anonymous function with one argument, @var{expval} (@pxref{Lambda "
"Expressions})."
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:574
msgid "Example: @code{(lambda (n) (= 42 n))}"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:575
#, no-wrap
msgid "function call with @var{n} args"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:579
msgid ""
"Call the function (the first element of the function call)  with @var{n} "
"arguments (the other elements) and an additional @var{n}+1-th argument that "
"is @var{expval}."
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:583
msgid ""
"Example: @code{(= 42)}@* In this example, the function is @code{=}, @var{n} "
"is one, and the actual function call becomes: @w{@code{(= 42 "
"@var{expval})}}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:585
#, no-wrap
msgid "(app @var{function} @var{pattern})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:591
msgid ""
"Matches if @var{function} called on @var{expval} returns a value that "
"matches @var{pattern}.  @var{function} can take one of the forms described "
"for @code{pred}, above.  Unlike @code{pred}, however, @code{app} tests the "
"result against @var{pattern}, rather than against a boolean truth value."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:592
#, no-wrap
msgid "(guard @var{boolean-expression})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:594
msgid "Matches if @var{boolean-expression} evaluates to non-@code{nil}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:595
#, no-wrap
msgid "(let @var{pattern} @var{expr})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:599
msgid ""
"Evaluates @var{expr} to get @var{exprval} and matches if @var{exprval} "
"matches @var{pattern}.  (It is called @code{let} because @var{pattern} can "
"bind symbols to values using @var{symbol}.)"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:601
#, no-wrap
msgid "sequencing pattern"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:608
msgid ""
"A @dfn{sequencing pattern} (also known as @var{seqpat}) is a pattern that "
"processes its sub-pattern arguments in sequence.  There are two for "
"@code{pcase}: @code{and} and @code{or}.  They behave in a similar manner to "
"the special forms that share their name (@pxref{Combining Conditions}), but "
"instead of processing values, they process sub-patterns."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:610
#, no-wrap
msgid "(and @var{pattern1}@dots{})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:615
msgid ""
"Attempts to match @var{pattern1}@dots{}, in order, until one of them fails "
"to match.  In that case, @code{and} likewise fails to match, and the rest of "
"the sub-patterns are not tested.  If all sub-patterns match, @code{and} "
"matches."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:616
#, no-wrap
msgid "(or @var{pattern1} @var{pattern2}@dots{})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:625
msgid ""
"Attempts to match @var{pattern1}, @var{pattern2}, @dots{}, in order, until "
"one of them succeeds.  In that case, @code{or} likewise matches, and the "
"rest of the sub-patterns are not tested.  (Note that there must be at least "
"two sub-patterns.  Simply @w{@code{(or @var{pattern1})}} signals error.)"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:630
msgid ""
"To present a consistent environment (@pxref{Intro Eval})  to "
"@var{body-forms} (thus avoiding an evaluation error on match), if any of the "
"sub-patterns let-binds a set of symbols, they @emph{must} all bind the same "
"set of symbols."
msgstr ""

#. type: anchor{#1}
#: ../../../../../doc/lispref/control.texi:633
msgid "rx in pcase"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:633
#, no-wrap
msgid "(rx @var{rx-expr}@dots{})"
msgstr ""

#. type: ifnottex
#: ../../../../../doc/lispref/control.texi:637
msgid ""
"Matches strings against the regexp @var{rx-expr}@dots{}, using the @code{rx} "
"regexp notation (@pxref{Rx Notation}), as if by @code{string-match}."
msgstr ""

#. type: ifnottex
#: ../../../../../doc/lispref/control.texi:640
msgid ""
"In addition to the usual @code{rx} syntax, @var{rx-expr}@dots{} can contain "
"the following constructs:"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:642
#, no-wrap
msgid "(let @var{ref} @var{rx-expr}@dots{})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:647
msgid ""
"Bind the symbol @var{ref} to a submatch that matches "
"@var{rx-expr}@enddots{}.  @var{ref} is bound in @var{body-forms} to the "
"string of the submatch or nil, but can also be used in @code{backref}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:648
#, no-wrap
msgid "(backref @var{ref})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:652
msgid ""
"Like the standard @code{backref} construct, but @var{ref} can here also be a "
"name introduced by a previous @code{(let @var{ref} @dots{})} construct."
msgstr ""

#. type: anchor{#1}
#: ../../../../../doc/lispref/control.texi:658
msgid "pcase-example-0"
msgstr ""

#. type: subheading
#: ../../../../../doc/lispref/control.texi:658
#, no-wrap
msgid "Example: Advantage Over @code{cl-case}"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:663
msgid ""
"Here's an example that highlights some advantages @code{pcase} has over "
"@code{cl-case} (@pxref{Conditionals,,,cl,Common Lisp Extensions})."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:670
#, no-wrap
msgid ""
"(pcase (get-return-code x)\n"
"  ;; string\n"
"  ((and (pred stringp) msg)\n"
"   (message \"%s\" msg))\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:677
#, no-wrap
msgid ""
"  ;; symbol\n"
"  ('success       (message \"Done!\"))\n"
"  ('would-block   (message \"Sorry, can't do it now\"))\n"
"  ('read-only     (message \"The shmliblick is read-only\"))\n"
"  ('access-denied (message \"You do not have the needed rights\"))\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:681
#, no-wrap
msgid ""
"  ;; default\n"
"  (code           (message \"Unknown return code %S\" code)))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:689
msgid ""
"With @code{cl-case}, you would need to explicitly declare a local variable "
"@code{code} to hold the return value of @code{get-return-code}.  Also "
"@code{cl-case} is difficult to use with strings because it uses @code{eql} "
"for comparison."
msgstr ""

#. type: anchor{#1}
#: ../../../../../doc/lispref/control.texi:691
msgid "pcase-example-1"
msgstr ""

#. type: subheading
#: ../../../../../doc/lispref/control.texi:691
#, no-wrap
msgid "Example: Using @code{and}"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:697
msgid ""
"A common idiom is to write a pattern starting with @code{and}, with one or "
"more @var{symbol} sub-patterns providing bindings to the sub-patterns that "
"follow (as well as to the body forms).  For example, the following pattern "
"matches single-digit integers."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:704
#, no-wrap
msgid ""
"(and\n"
"  (pred integerp)\n"
"  n                     ; @r{bind @code{n} to @var{expval}}\n"
"  (guard (<= -9 n 9)))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:716
msgid ""
"First, @code{pred} matches if @w{@code{(integerp @var{expval})}} evaluates "
"to non-@code{nil}.  Next, @code{n} is a @var{symbol} pattern that matches "
"anything and binds @code{n} to @var{expval}.  Lastly, @code{guard} matches "
"if the boolean expression @w{@code{(<= -9 n 9)}} (note the reference to "
"@code{n})  evaluates to non-@code{nil}.  If all these sub-patterns match, "
"@code{and} matches."
msgstr ""

#. type: anchor{#1}
#: ../../../../../doc/lispref/control.texi:718
msgid "pcase-example-2"
msgstr ""

#. type: subheading
#: ../../../../../doc/lispref/control.texi:718
#, no-wrap
msgid "Example: Reformulation with @code{pcase}"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:728
msgid ""
"Here is another example that shows how to reformulate a simple matching task "
"from its traditional implementation (function @code{grok/traditional}) to "
"one using @code{pcase} (function @code{grok/pcase}).  The docstring for both "
"these functions is: ``If OBJ is a string of the form \"key:NUMBER\", return "
"NUMBER (a string).  Otherwise, return the list (\"149\" default).'' First, "
"the traditional implementation (@pxref{Regular Expressions}):"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:736
#, no-wrap
msgid ""
"(defun grok/traditional (obj)\n"
"  (if (and (stringp obj)\n"
"           (string-match \"^key:\\\\([[:digit:]]+\\\\)$\" obj))\n"
"      (match-string 1 obj)\n"
"    (list \"149\" 'default)))\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:742
#, no-wrap
msgid ""
"(grok/traditional \"key:0\")   @result{} \"0\"\n"
"(grok/traditional \"key:149\") @result{} \"149\"\n"
"(grok/traditional 'monolith) @result{} (\"149\" default)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:748
msgid ""
"The reformulation demonstrates @var{symbol} binding as well as @code{or}, "
"@code{and}, @code{pred}, @code{app} and @code{let}."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:762
#, no-wrap
msgid ""
"(defun grok/pcase (obj)\n"
"  (pcase obj\n"
"    ((or                                     ; @r{line 1}\n"
"      (and                                   ; @r{line 2}\n"
"       (pred stringp)                        ; @r{line 3}\n"
"       (pred (string-match                   ; @r{line 4}\n"
"              \"^key:\\\\([[:digit:]]+\\\\)$\"))   ; @r{line 5}\n"
"       (app (match-string 1)                 ; @r{line 6}\n"
"            val))                            ; @r{line 7}\n"
"      (let val (list \"149\" 'default)))       ; @r{line 8}\n"
"     val)))                                  ; @r{line 9}\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:768
#, no-wrap
msgid ""
"(grok/pcase \"key:0\")   @result{} \"0\"\n"
"(grok/pcase \"key:149\") @result{} \"149\"\n"
"(grok/pcase 'monolith) @result{} (\"149\" default)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:777
msgid ""
"The bulk of @code{grok/pcase} is a single clause of a @code{pcase} form, the "
"pattern on lines 1-8, the (single) body form on line 9.  The pattern is "
"@code{or}, which tries to match in turn its argument sub-patterns, first "
"@code{and} (lines 2-7), then @code{let} (line 8), until one of them "
"succeeds."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:783
msgid ""
"As in the previous example (@pxref{pcase-example-1,,Example 1}), @code{and} "
"begins with a @code{pred} sub-pattern to ensure the following sub-patterns "
"work with an object of the correct type (string, in this case).  If "
"@w{@code{(stringp @var{expval})}} returns @code{nil}, @code{pred} fails, and "
"thus @code{and} fails, too."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:789
msgid ""
"The next @code{pred} (lines 4-5) evaluates @w{@code{(string-match RX "
"@var{expval})}} and matches if the result is non-@code{nil}, which means "
"that @var{expval} has the desired form: @code{key:NUMBER}.  Again, failing "
"this, @code{pred} fails and @code{and}, too."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:796
msgid ""
"Lastly (in this series of @code{and} sub-patterns), @code{app} evaluates "
"@w{@code{(match-string 1 @var{expval})}} (line 6)  to get a temporary value "
"@var{tmp} (i.e., the ``NUMBER'' substring)  and tries to match @var{tmp} "
"against pattern @code{val} (line 7).  Since that is a @var{symbol} pattern, "
"it matches unconditionally and additionally binds @code{val} to @var{tmp}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:801
msgid ""
"Now that @code{app} has matched, all @code{and} sub-patterns have matched, "
"and so @code{and} matches.  Likewise, once @code{and} has matched, @code{or} "
"matches and does not proceed to try sub-pattern @code{let} (line 8)."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:807
msgid ""
"Let's consider the situation where @code{obj} is not a string, or it is a "
"string but has the wrong form.  In this case, one of the @code{pred} (lines "
"3-5) fails to match, thus @code{and} (line 2) fails to match, thus @code{or} "
"(line 1) proceeds to try sub-pattern @code{let} (line 8)."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:814
msgid ""
"First, @code{let} evaluates @w{@code{(list \"149\" 'default)}} to get "
"@w{@code{(\"149\" default)}}, the @var{exprval}, and then tries to match "
"@var{exprval} against pattern @code{val}.  Since that is a @var{symbol} "
"pattern, it matches unconditionally and additionally binds @code{val} to "
"@var{exprval}.  Now that @code{let} has matched, @code{or} matches."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:823
msgid ""
"Note how both @code{and} and @code{let} sub-patterns finish in the same way: "
"by trying (always successfully) to match against the @var{symbol} pattern "
"@code{val}, in the process binding @code{val}.  Thus, @code{or} always "
"matches and control always passes to the body form (line 9).  Because that "
"is the last body form in a successfully matched @code{pcase} clause, it is "
"the value of @code{pcase} and likewise the return value of @code{grok/pcase} "
"(@pxref{What Is a Function})."
msgstr ""

#. type: anchor{#1}
#: ../../../../../doc/lispref/control.texi:825
msgid "pcase-symbol-caveats"
msgstr ""

#. type: subheading
#: ../../../../../doc/lispref/control.texi:825
#, no-wrap
msgid "Caveats for @var{symbol} in Sequencing Patterns"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:831
msgid ""
"The preceding examples all use sequencing patterns which include the "
"@var{symbol} sub-pattern in some way.  Here are some important details about "
"that usage."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:833
#, no-wrap
msgid "When @var{symbol} occurs more than once in @var{seqpat},"
msgstr ""

#. type: enumerate
#: ../../../../../doc/lispref/control.texi:836
msgid ""
"the second and subsequent occurrences do not expand to re-binding, but "
"instead expand to an equality test using @code{eq}."
msgstr ""

#. type: enumerate
#: ../../../../../doc/lispref/control.texi:843
msgid ""
"The following example features a @code{pcase} form with two clauses and two "
"@var{seqpat}, A and B@.  Both A and B first check that @var{expval} is a "
"pair (using @code{pred}), and then bind symbols to the @code{car} and "
"@code{cdr} of @var{expval} (using one @code{app} each)."
msgstr ""

#. type: enumerate
#: ../../../../../doc/lispref/control.texi:848
msgid ""
"For A, because symbol @code{st} is mentioned twice, the second mention "
"becomes an equality test using @code{eq}.  On the other hand, B uses two "
"separate symbols, @code{s1} and @code{s2}, both of which become independent "
"bindings."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:857
#, no-wrap
msgid ""
"(defun grok (object)\n"
"  (pcase object\n"
"    ((and (pred consp)        ; seqpat A\n"
"          (app car st)        ; first mention: st\n"
"          (app cdr st))       ; second mention: st\n"
"     (list 'eq st))\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:863
#, no-wrap
msgid ""
"    ((and (pred consp)        ; seqpat B\n"
"          (app car s1)        ; first mention: s1\n"
"          (app cdr s2))       ; first mention: s2\n"
"     (list 'not-eq s1 s2))))\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:870
#, no-wrap
msgid ""
"(let ((s \"yow!\"))\n"
"  (grok (cons s s)))      @result{} (eq \"yow!\")\n"
"(grok (cons \"yo!\" \"yo!\")) @result{} (not-eq \"yo!\" \"yo!\")\n"
"(grok '(4 2))             @result{} (not-eq 4 (2))\n"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:873
#, no-wrap
msgid "Side-effecting code referencing @var{symbol} is undefined."
msgstr ""

#. type: enumerate
#: ../../../../../doc/lispref/control.texi:877
msgid ""
"Avoid.  For example, here are two similar functions.  Both use @code{and}, "
"@var{symbol} and @code{guard}:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:884
#, no-wrap
msgid ""
"(defun square-double-digit-p/CLEAN (integer)\n"
"  (pcase (* integer integer)\n"
"    ((and n (guard (< 9 n 100))) (list 'yes n))\n"
"    (sorry (list 'no sorry))))\n"
"\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:887
#, no-wrap
msgid ""
"(square-double-digit-p/CLEAN 9) @result{} (yes 81)\n"
"(square-double-digit-p/CLEAN 3) @result{} (no 9)\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:894
#, no-wrap
msgid ""
"(defun square-double-digit-p/MAYBE (integer)\n"
"  (pcase (* integer integer)\n"
"    ((and n (guard (< 9 (incf n) 100))) (list 'yes n))\n"
"    (sorry (list 'no sorry))))\n"
"\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:897
#, no-wrap
msgid ""
"(square-double-digit-p/MAYBE 9) @result{} (yes 81)\n"
"(square-double-digit-p/MAYBE 3) @result{} (yes 9)  ; @r{WRONG!}\n"
msgstr ""

#. type: enumerate
#: ../../../../../doc/lispref/control.texi:906
msgid ""
"The difference is in @var{boolean-expression} in @code{guard}: @code{CLEAN} "
"references @code{n} simply and directly, while @code{MAYBE} references "
"@code{n} with a side-effect, in the expression @code{(incf n)}.  When "
"@code{integer} is 3, here's what happens:"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:908
#, no-wrap
msgid "The first @code{n} binds it to @var{expval},"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/control.texi:910
msgid "i.e., the result of evaluating @code{(* 3 3)}, or 9."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:911
#, no-wrap
msgid "@var{boolean-expression} is evaluated:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:918
#, no-wrap
msgid ""
"start:   (< 9 (incf n)        100)\n"
"becomes: (< 9 (setq n (1+ n)) 100)\n"
"becomes: (< 9 (setq n (1+ 9)) 100)\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:925
#, no-wrap
msgid ""
"becomes: (< 9 (setq n 10)     100)\n"
"                                   ; @r{side-effect here!}\n"
"becomes: (< 9       n         100) ; @r{@code{n} now bound to 10}\n"
"becomes: (< 9      10         100)\n"
"becomes: t\n"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:928
#, no-wrap
msgid "Because the result of the evaluation is non-@code{nil},"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/control.texi:931
msgid ""
"@code{guard} matches, @code{and} matches, and control passes to that "
"clause's body forms."
msgstr ""

#. type: enumerate
#: ../../../../../doc/lispref/control.texi:938
msgid ""
"Aside from the mathematical incorrectness of asserting that 9 is a "
"double-digit integer, there is another problem with @code{MAYBE}.  The body "
"form references @code{n} once more, yet we do not see the updated "
"value---10---at all.  What happened to it?"
msgstr ""

#. type: enumerate
#: ../../../../../doc/lispref/control.texi:944
msgid ""
"To sum up, it's best to avoid side-effecting references to @var{symbol} "
"patterns entirely, not only in @var{boolean-expression} (in @code{guard}), "
"but also in @var{expr} (in @code{let})  and @var{function} (in @code{pred} "
"and @code{app})."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:945
#, no-wrap
msgid "On match, the clause's body forms can reference the set"
msgstr ""

#. type: enumerate
#: ../../../../../doc/lispref/control.texi:951
msgid ""
"of symbols the pattern let-binds.  When @var{seqpat} is @code{and}, this set "
"is the union of all the symbols each of its sub-patterns let-binds.  This "
"makes sense because, for @code{and} to match, all the sub-patterns must "
"match."
msgstr ""

#. type: enumerate
#: ../../../../../doc/lispref/control.texi:959
msgid ""
"When @var{seqpat} is @code{or}, things are different: @code{or} matches at "
"the first sub-pattern that matches; the rest of the sub-patterns are "
"ignored.  It makes no sense for each sub-pattern to let-bind a different set "
"of symbols because the body forms have no way to distinguish which "
"sub-pattern matched and choose among the different sets.  For example, the "
"following is invalid:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:968
#, no-wrap
msgid ""
"(require 'cl-lib)\n"
"(pcase (read-number \"Enter an integer: \")\n"
"  ((or (and (pred cl-evenp)\n"
"            e-num)      ; @r{bind @code{e-num} to @var{expval}}\n"
"       o-num)           ; @r{bind @code{o-num} to @var{expval}}\n"
"   (list e-num o-num)))\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:973
#, no-wrap
msgid ""
"Enter an integer: 42\n"
"@error{} Symbols value as variable is void: o-num\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:977
#, no-wrap
msgid ""
"Enter an integer: 149\n"
"@error{} Symbols value as variable is void: e-num\n"
msgstr ""

#. type: enumerate
#: ../../../../../doc/lispref/control.texi:985
msgid ""
"Evaluating body form @w{@code{(list e-num o-num)}} signals error.  To "
"distinguish between sub-patterns, you can use another symbol, identical in "
"name in all sub-patterns but differing in value.  Reworking the above "
"example:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:995
#, no-wrap
msgid ""
"(require 'cl-lib)\n"
"(pcase (read-number \"Enter an integer: \")\n"
"  ((and num                                ; @r{line 1}\n"
"        (or (and (pred cl-evenp)           ; @r{line 2}\n"
"                 (let spin 'even))         ; @r{line 3}\n"
"            (let spin 'odd)))              ; @r{line 4}\n"
"   (list spin num)))                       ; @r{line 5}\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1000
#, no-wrap
msgid ""
"Enter an integer: 42\n"
"@result{} (even 42)\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1004
#, no-wrap
msgid ""
"Enter an integer: 149\n"
"@result{} (odd 149)\n"
msgstr ""

#. type: enumerate
#: ../../../../../doc/lispref/control.texi:1015
msgid ""
"Line 1 ``factors out'' the @var{expval} binding with @code{and} and "
"@var{symbol} (in this case, @code{num}).  On line 2, @code{or} begins in the "
"same way as before, but instead of binding different symbols, uses "
"@code{let} twice (lines 3-4) to bind the same symbol @code{spin} in both "
"sub-patterns.  The value of @code{spin} distinguishes the sub-patterns.  The "
"body form references both symbols (line 5)."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/control.texi:1017
#, no-wrap
msgid "Extending pcase"
msgstr ""

#. type: subsection
#: ../../../../../doc/lispref/control.texi:1018
#, no-wrap
msgid "Extending @code{pcase}"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1019
#, no-wrap
msgid "pcase, defining new kinds of patterns"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1025
msgid ""
"The @code{pcase} macro supports several kinds of patterns "
"(@pxref{Pattern-Matching Conditional}).  You can add support for other kinds "
"of patterns using the @code{pcase-defmacro} macro."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1026
#, no-wrap
msgid "pcase-defmacro name args [doc] &rest body"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1033
msgid ""
"Define a new kind of pattern for @code{pcase}, to be invoked as "
"@w{@code{(@var{name} @var{actual-args})}}.  The @code{pcase} macro expands "
"this into a function call that evaluates @var{body}, whose job it is to "
"rewrite the invoked pattern into some other pattern, in an environment where "
"@var{args} are bound to @var{actual-args}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1039
msgid ""
"Additionally, arrange to display @var{doc} along with the docstring of "
"@code{pcase}.  By convention, @var{doc} should use @code{EXPVAL} to stand "
"for the result of evaluating @var{expression} (first arg to @code{pcase})."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1048
msgid ""
"Typically, @var{body} rewrites the invoked pattern to use more basic "
"patterns.  Although all patterns eventually reduce to core patterns, "
"@code{body} need not use core patterns straight away.  The following example "
"defines two patterns, named @code{less-than} and @code{integer-less-than}."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1054
#, no-wrap
msgid ""
"(pcase-defmacro less-than (n)\n"
"  \"Matches if EXPVAL is a number less than N.\"\n"
"  `(pred (> ,n)))\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1061
#, no-wrap
msgid ""
"(pcase-defmacro integer-less-than (n)\n"
"  \"Matches if EXPVAL is an integer less than N.\"\n"
"  `(and (pred integerp)\n"
"        (less-than ,n)))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1073
msgid ""
"Note that the docstrings mention @var{args} (in this case, only one: "
"@code{n}) in the usual way, and also mention @code{EXPVAL} by convention.  "
"The first rewrite (i.e., @var{body} for @code{less-than})  uses one core "
"pattern: @code{pred}.  The second uses two core patterns: @code{and} and "
"@code{pred}, as well as the newly-defined pattern @code{less-than}.  Both "
"use a single backquote construct (@pxref{Backquote})."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/control.texi:1074
#, no-wrap
msgid "Backquote Patterns"
msgstr ""

#. type: subsection
#: ../../../../../doc/lispref/control.texi:1075
#, no-wrap
msgid "Backquote-Style Patterns"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1076
#, no-wrap
msgid "backquote-style patterns"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1077
#, no-wrap
msgid "matching, structural"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1078
#, no-wrap
msgid "structural matching"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1083
msgid ""
"This subsection describes @dfn{backquote-style patterns}, a set of builtin "
"patterns that eases structural matching.  For background, "
"@pxref{Pattern-Matching Conditional}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1087
msgid ""
"Backquote-style patterns are a powerful set of @code{pcase} pattern "
"extensions (created using @code{pcase-defmacro}) that make it easy to match "
"@var{expval} against specifications of its @emph{structure}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1091
msgid ""
"For example, to match @var{expval} that must be a list of two elements whose "
"first element is a specific string and the second element is any value, you "
"can write a core pattern:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1096
#, no-wrap
msgid ""
"(and (pred listp)\n"
"     ls\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1101
#, no-wrap
msgid ""
"     (guard (= 2 (length ls)))\n"
"     (guard (string= \"first\" (car ls)))\n"
"     (let second-elem (cadr ls)))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1106
msgid "or you can write the equivalent backquote-style pattern:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:1109
#, no-wrap
msgid "`(\"first\" ,second-elem)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1115
msgid ""
"The backquote-style pattern is more concise, resembles the structure of "
"@var{expval}, and avoids binding @code{ls}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1118
msgid ""
"A backquote-style pattern has the form @code{`@var{qpat}} where @var{qpat} "
"can have the following forms:"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:1121
#, no-wrap
msgid "(@var{qpat1} . @var{qpat2})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:1126
msgid ""
"Matches if @var{expval} is a cons cell whose @code{car} matches @var{qpat1} "
"and whose @code{cdr} matches @var{qpat2}.  This readily generalizes to lists "
"as in @w{@code{(@var{qpat1} @var{qpat2} @dots{})}}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:1127
#, no-wrap
msgid "[@var{qpat1} @var{qpat2} @dots{} @var{qpatm}]"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:1131
msgid ""
"Matches if @var{expval} is a vector of length @var{m} whose "
"@code{0}..@code{(@var{m}-1)}th elements match @var{qpat1}, @var{qpat2} "
"@dots{} @var{qpatm}, respectively."
msgstr ""

#. type: var{#1}
#: ../../../../../doc/lispref/control.texi:1134
#, no-wrap
msgid "number"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:1138
msgid ""
"Matches if the corresponding element of @var{expval} is @code{equal} to the "
"specified literal object."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/control.texi:1139
#, no-wrap
msgid ",@var{pattern}"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/control.texi:1146
msgid ""
"Matches if the corresponding element of @var{expval} matches @var{pattern}.  "
"Note that @var{pattern} is any kind that @code{pcase} supports.  (In the "
"example above, @code{second-elem} is a @var{symbol} core pattern; it "
"therefore matches anything, and let-binds @code{second-elem}.)"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1153
msgid ""
"The @dfn{corresponding element} is the portion of @var{expval} that is in "
"the same structural position as the structural position of @var{qpat} in the "
"backquote-style pattern.  (In the example above, the corresponding element "
"of @code{second-elem} is the second element of @var{expval}.)"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1159
msgid ""
"Here is an example of using @code{pcase} to implement a simple interpreter "
"for a little expression language (note that this requires lexical binding "
"for the lambda expression in the @code{fn} clause to properly capture "
"@code{body} and @code{arg} (@pxref{Lexical Binding}):"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1166
#, no-wrap
msgid ""
"(defun evaluate (form env)\n"
"  (pcase form\n"
"    (`(add ,x ,y)       (+ (evaluate x env)\n"
"                           (evaluate y env)))\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1173
#, no-wrap
msgid ""
"    (`(call ,fun ,arg)  (funcall (evaluate fun env)\n"
"                                 (evaluate arg env)))\n"
"    (`(fn ,arg ,body)   (lambda (val)\n"
"                          (evaluate body (cons (cons arg val)\n"
"                                               env))))\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1178
#, no-wrap
msgid ""
"    ((pred numberp)     form)\n"
"    ((pred symbolp)     (cdr (assq form env)))\n"
"    (_                  (error \"Syntax error: %S\" form))))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1190
msgid ""
"The first three clauses use backquote-style patterns.  @code{`(add ,x ,y)} "
"is a pattern that checks that @code{form} is a three-element list starting "
"with the literal symbol @code{add}, then extracts the second and third "
"elements and binds them to symbols @code{x} and @code{y}, respectively.  The "
"clause body evaluates @code{x} and @code{y} and adds the results.  "
"Similarly, the @code{call} clause implements a function call, and the "
"@code{fn} clause implements an anonymous function definition."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1199
msgid ""
"The remaining clauses use core patterns.  @code{(pred numberp)} matches if "
"@code{form} is a number.  On match, the body evaluates it.  @code{(pred "
"symbolp)} matches if @code{form} is a symbol.  On match, the body looks up "
"the symbol in @code{env} and returns its association.  Finally, @code{_} is "
"the catch-all pattern that matches anything, so it's suitable for reporting "
"syntax errors."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1202
msgid ""
"Here are some sample programs in this small language, including their "
"evaluation results:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:1208
#, no-wrap
msgid ""
"(evaluate '(add 1 2) nil)                 @result{} 3\n"
"(evaluate '(add x y) '((x . 1) (y . 2)))  @result{} 3\n"
"(evaluate '(call (fn x (add 1 x)) 2) nil) @result{} 3\n"
"(evaluate '(sub 1 2) nil)                 @result{} error\n"
msgstr ""

#. type: subsection
#: ../../../../../doc/lispref/control.texi:1211
#, no-wrap
msgid "Destructuring with @code{pcase} Patterns"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1212
#, no-wrap
msgid "destructuring with pcase patterns"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1218
msgid ""
"Pcase patterns not only express a condition on the form of the objects they "
"can match, but they can also extract sub-fields of those objects.  For "
"example we can extract 2 elements from a list that is the value of the "
"variable @code{my-list} with the following code:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:1222
#, no-wrap
msgid ""
"  (pcase my-list\n"
"    (`(add ,x ,y)  (message \"Contains %S and %S\" x y)))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1229
msgid ""
"This will not only extract @code{x} and @code{y} but will additionally test "
"that @code{my-list} is a list containing exactly 3 elements and whose first "
"element is the symbol @code{add}.  If any of those tests fail, @code{pcase} "
"will immediately return @code{nil} without calling @code{message}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1236
msgid ""
"Extraction of multiple values stored in an object is known as "
"@dfn{destructuring}.  Using @code{pcase} patterns allows to perform "
"@dfn{destructuring binding}, which is similar to a local binding "
"(@pxref{Local Variables}), but gives values to multiple elements of a "
"variable by extracting those values from an object of compatible structure."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1242
msgid ""
"The macros described in this section use @code{pcase} patterns to perform "
"destructuring binding.  The condition of the object to be of compatible "
"structure means that the object must match the pattern, because only then "
"the object's subfields can be extracted.  For example:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:1246
#, no-wrap
msgid ""
"  (pcase-let ((`(add ,x ,y) my-list))\n"
"    (message \"Contains %S and %S\" x y))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1257
msgid ""
"does the same as the previous example, except that it directly tries to "
"extract @code{x} and @code{y} from @code{my-list} without first verifying if "
"@code{my-list} is a list which has the right number of elements and has "
"@code{add} as its first element.  The precise behavior when the object does "
"not actually match the pattern is undefined, although the body will not be "
"silently skipped: either an error is signaled or the body is run with some "
"of the variables potentially bound to arbitrary values like @code{nil}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1261
msgid ""
"The pcase patterns that are useful for destructuring bindings are generally "
"those described in @ref{Backquote Patterns}, since they express a "
"specification of the structure of objects that will match."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1264
msgid "For an alternative facility for destructuring binding, see @ref{seq-let}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1265
#, no-wrap
msgid "pcase-let bindings body@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1268 ../../../../../doc/lispref/control.texi:1284
msgid ""
"Perform destructuring binding of variables according to @var{bindings}, and "
"then evaluate @var{body}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1272
msgid ""
"@var{bindings} is a list of bindings of the form @w{@code{(@var{pattern} "
"@var{exp})}}, where @var{exp} is an expression to evaluate and @var{pattern} "
"is a @code{pcase} pattern."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1279
msgid ""
"All @var{exp}s are evaluated first, after which they are matched against "
"their respective @var{pattern}, introducing new variable bindings that can "
"then be used inside @var{body}.  The variable bindings are produced by "
"destructuring binding of elements of @var{pattern} to the values of the "
"corresponding elements of the evaluated @var{exp}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1281
#, no-wrap
msgid "pcase-let* bindings body@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1290
msgid ""
"@var{bindings} is a list of bindings of the form @code{(@var{pattern} "
"@var{exp})}, where @var{exp} is an expression to evaluate and @var{pattern} "
"is a @code{pcase} pattern.  The variable bindings are produced by "
"destructuring binding of elements of @var{pattern} to the values of the "
"corresponding elements of the evaluated @var{exp}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1297
msgid ""
"Unlike @code{pcase-let}, but similarly to @code{let*}, each @var{exp} is "
"matched against its corresponding @var{pattern} before processing the next "
"element of @var{bindings}, so the variable bindings introduced in each one "
"of the @var{bindings} are available in the @var{exp}s of the @var{bindings} "
"that follow it, additionally to being available in @var{body}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1299
#, no-wrap
msgid "pcase-dolist (pattern list) body@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1306
msgid ""
"Execute @var{body} once for each element of @var{list}, on each iteration "
"performing a destructuring binding of variables in @var{pattern} to the "
"values of the corresponding subfields of the element of @var{list}.  The "
"bindings are performed as if by @code{pcase-let}.  When @var{pattern} is a "
"simple variable, this ends up being equivalent to @code{dolist} "
"(@pxref{Iteration})."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1311
#, no-wrap
msgid "iteration"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1312
#, no-wrap
msgid "recursion"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1313
#, no-wrap
msgid "forms, iteration"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1319
msgid ""
"Iteration means executing part of a program repetitively.  For example, you "
"might want to repeat some computation once for each element of a list, or "
"once for each integer from 0 to @var{n}.  You can do this in Emacs Lisp with "
"the special form @code{while}:"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:1320
#, no-wrap
msgid "while condition forms@dots{}"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:1326
msgid ""
"@code{while} first evaluates @var{condition}.  If the result is "
"non-@code{nil}, it evaluates @var{forms} in textual order.  Then it "
"reevaluates @var{condition}, and if the result is non-@code{nil}, it "
"evaluates @var{forms} again.  This process repeats until @var{condition} "
"evaluates to @code{nil}."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:1330
msgid ""
"There is no limit on the number of iterations that may occur.  The loop will "
"continue until either @var{condition} evaluates to @code{nil} or until an "
"error or @code{throw} jumps out of it (@pxref{Nonlocal Exits})."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:1332
msgid "The value of a @code{while} form is always @code{nil}."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1337
#, no-wrap
msgid ""
"(setq num 0)\n"
"     @result{} 0\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1347
#, no-wrap
msgid ""
"(while (< num 4)\n"
"  (princ (format \"Iteration %d.\" num))\n"
"  (setq num (1+ num)))\n"
"     @print{} Iteration 0.\n"
"     @print{} Iteration 1.\n"
"     @print{} Iteration 2.\n"
"     @print{} Iteration 3.\n"
"     @result{} nil\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:1354
msgid ""
"To write a repeat-until loop, which will execute something on each iteration "
"and then do the end-test, put the body followed by the end-test in a "
"@code{progn} as the first argument of @code{while}, as shown here:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1360
#, no-wrap
msgid ""
"(while (progn\n"
"         (forward-line 1)\n"
"         (not (looking-at \"^$\"))))\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:1367
msgid ""
"This moves forward one line and continues moving by lines until it reaches "
"an empty line.  It is peculiar in that the @code{while} has no body, just "
"the end test (which also does the real work of moving point)."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1371
msgid ""
"The @code{dolist} and @code{dotimes} macros provide convenient ways to write "
"two common kinds of loops."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1372
#, no-wrap
msgid "dolist (var list [result]) body@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1378
msgid ""
"This construct executes @var{body} once for each element of @var{list}, "
"binding the variable @var{var} locally to hold the current element.  Then it "
"returns the value of evaluating @var{result}, or @code{nil} if @var{result} "
"is omitted.  For example, here is how you could use @code{dolist} to define "
"the @code{reverse} function:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:1384
#, no-wrap
msgid ""
"(defun reverse (list)\n"
"  (let (value)\n"
"    (dolist (elt list value)\n"
"      (setq value (cons elt value)))))\n"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1387
#, no-wrap
msgid "dotimes (var count [result]) body@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1394
msgid ""
"This construct executes @var{body} once for each integer from 0 (inclusive) "
"to @var{count} (exclusive), binding the variable @var{var} to the integer "
"for the current iteration.  Then it returns the value of evaluating "
"@var{result}, or @code{nil} if @var{result} is omitted.  Use of @var{result} "
"is deprecated.  Here is an example of using @code{dotimes} to do something "
"100 times:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:1398
#, no-wrap
msgid ""
"(dotimes (i 100)\n"
"  (insert \"I will not obey absurd orders\\n\"))\n"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1403
#, no-wrap
msgid "generators"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1408
msgid ""
"A @dfn{generator} is a function that produces a potentially-infinite stream "
"of values.  Each time the function produces a value, it suspends itself and "
"waits for a caller to request the next value."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1409
#, no-wrap
msgid "iter-defun name args [doc] [declare] [interactive] body@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1418
msgid ""
"@code{iter-defun} defines a generator function.  A generator function has "
"the same signature as a normal function, but works differently.  Instead of "
"executing @var{body} when called, a generator function returns an iterator "
"object.  That iterator runs @var{body} to generate values, emitting a value "
"and pausing where @code{iter-yield} or @code{iter-yield-from} appears.  When "
"@var{body} returns normally, @code{iter-next} signals "
"@code{iter-end-of-sequence} with @var{body}'s result as its condition data."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1422
msgid ""
"Any kind of Lisp code is valid inside @var{body}, but @code{iter-yield} and "
"@code{iter-yield-from} cannot appear inside @code{unwind-protect} forms."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1425
#, no-wrap
msgid "iter-lambda args [doc] [interactive] body@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1428
msgid ""
"@code{iter-lambda} produces an unnamed generator function that works just "
"like a generator function produced with @code{iter-defun}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1430
#, no-wrap
msgid "iter-yield value"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1435
msgid ""
"When it appears inside a generator function, @code{iter-yield} indicates "
"that the current iterator should pause and return @var{value} from "
"@code{iter-next}.  @code{iter-yield} evaluates to the @code{value} parameter "
"of next call to @code{iter-next}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1437
#, no-wrap
msgid "iter-yield-from iterator"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1442
msgid ""
"@code{iter-yield-from} yields all the values that @var{iterator} produces "
"and evaluates to the value that @var{iterator}'s generator function returns "
"normally.  While it has control, @var{iterator} receives values sent to the "
"iterator using @code{iter-next}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1450
msgid ""
"To use a generator function, first call it normally, producing a "
"@dfn{iterator} object.  An iterator is a specific instance of a generator.  "
"Then use @code{iter-next} to retrieve values from this iterator.  When there "
"are no more values to pull from an iterator, @code{iter-next} raises an "
"@code{iter-end-of-sequence} condition with the iterator's final value."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1457
msgid ""
"It's important to note that generator function bodies only execute inside "
"calls to @code{iter-next}.  A call to a function defined with "
"@code{iter-defun} produces an iterator; you must drive this iterator with "
"@code{iter-next} for anything interesting to happen.  Each call to a "
"generator function produces a @emph{different} iterator, each with its own "
"state."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1458
#, no-wrap
msgid "iter-next iterator value"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1464
msgid ""
"Retrieve the next value from @var{iterator}.  If there are no more values to "
"be generated (because @var{iterator}'s generator function returned), "
"@code{iter-next} signals the @code{iter-end-of-sequence} condition; the data "
"value associated with this condition is the value with which "
"@var{iterator}'s generator function returned."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1470
msgid ""
"@var{value} is sent into the iterator and becomes the value to which "
"@code{iter-yield} evaluates.  @var{value} is ignored for the first "
"@code{iter-next} call to a given iterator, since at the start of "
"@var{iterator}'s generator function, the generator function is not "
"evaluating any @code{iter-yield} form."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1472
#, no-wrap
msgid "iter-close iterator"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1479
msgid ""
"If @var{iterator} is suspended inside an @code{unwind-protect}'s "
"@code{bodyform} and becomes unreachable, Emacs will eventually run unwind "
"handlers after a garbage collection pass.  (Note that @code{iter-yield} is "
"illegal inside an @code{unwind-protect}'s @code{unwindforms}.)  To ensure "
"that these handlers are run before then, use @code{iter-close}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1483
msgid ""
"Some convenience functions are provided to make working with iterators "
"easier:"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1484
#, no-wrap
msgid "iter-do (var iterator) body @dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1487
msgid ""
"Run @var{body} with @var{var} bound to each value that @var{iterator} "
"produces."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1491
msgid ""
"The Common Lisp loop facility also contains features for working with "
"iterators.  @xref{Loop Facility,,,cl,Common Lisp Extensions}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1494
msgid ""
"The following piece of code demonstrates some important principles of "
"working with iterators."
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:1501
#, no-wrap
msgid ""
"(require 'generator)\n"
"(iter-defun my-iter (x)\n"
"  (iter-yield (1+ (iter-yield (1+ x))))\n"
"   ;; Return normally\n"
"  -1)\n"
"\n"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:1510
#, no-wrap
msgid ""
"(let* ((iter (my-iter 5))\n"
"       (iter2 (my-iter 0)))\n"
"  ;; Prints 6\n"
"  (print (iter-next iter))\n"
"  ;; Prints 9\n"
"  (print (iter-next iter 8))\n"
"  ;; Prints 1; iter and iter2 have distinct states\n"
"  (print (iter-next iter2 nil))\n"
"\n"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:1517
#, no-wrap
msgid ""
"  ;; We expect the iter sequence to end now\n"
"  (condition-case x\n"
"      (iter-next iter)\n"
"    (iter-end-of-sequence\n"
"      ;; Prints -1, which my-iter returned normally\n"
"      (print (cdr x)))))\n"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1521
#, no-wrap
msgid "nonlocal exits"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1528
msgid ""
"A @dfn{nonlocal exit} is a transfer of control from one point in a program "
"to another remote point.  Nonlocal exits can occur in Emacs Lisp as a result "
"of errors; you can also use them under explicit control.  Nonlocal exits "
"unbind all variable bindings made by the constructs being exited."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/control.texi:1534 ../../../../../doc/lispref/control.texi:1536
#, no-wrap
msgid "Catch and Throw"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:1534
msgid "Nonlocal exits for the program's own purposes."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/control.texi:1534 ../../../../../doc/lispref/control.texi:1636
#, no-wrap
msgid "Examples of Catch"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:1534
msgid "Showing how such nonlocal exits can be written."
msgstr ""

#. type: subsection
#: ../../../../../doc/lispref/control.texi:1534 ../../../../../doc/lispref/control.texi:1711 ../../../../../doc/lispref/control.texi:1712
#, no-wrap
msgid "Errors"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:1534
msgid "How errors are signaled and handled."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/control.texi:1534 ../../../../../doc/lispref/control.texi:2290
#, no-wrap
msgid "Cleanups"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:1534
msgid "Arranging to run a cleanup form if an error happens."
msgstr ""

#. type: subsection
#: ../../../../../doc/lispref/control.texi:1537
#, no-wrap
msgid "Explicit Nonlocal Exits: @code{catch} and @code{throw}"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1538
#, no-wrap
msgid "forms for nonlocal exits"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1546
msgid ""
"Most control constructs affect only the flow of control within the construct "
"itself.  The function @code{throw} is the exception to this rule of normal "
"program execution: it performs a nonlocal exit on request.  (There are other "
"exceptions, but they are for error handling only.)  @code{throw} is used "
"inside a @code{catch}, and jumps back to that @code{catch}.  For example:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1552
#, no-wrap
msgid ""
"(defun foo-outer ()\n"
"  (catch 'foo\n"
"    (foo-inner)))\n"
"\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1558
#, no-wrap
msgid ""
"(defun foo-inner ()\n"
"  @dots{}\n"
"  (if x\n"
"      (throw 'foo t))\n"
"  @dots{})\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1566
msgid ""
"The @code{throw} form, if executed, transfers control straight back to the "
"corresponding @code{catch}, which returns immediately.  The code following "
"the @code{throw} is not executed.  The second argument of @code{throw} is "
"used as the return value of the @code{catch}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1575
msgid ""
"The function @code{throw} finds the matching @code{catch} based on the first "
"argument: it searches for a @code{catch} whose first argument is @code{eq} "
"to the one specified in the @code{throw}.  If there is more than one "
"applicable @code{catch}, the innermost one takes precedence.  Thus, in the "
"above example, the @code{throw} specifies @code{foo}, and the @code{catch} "
"in @code{foo-outer} specifies the same symbol, so that @code{catch} is the "
"applicable one (assuming there is no other matching @code{catch} in "
"between)."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1585
msgid ""
"Executing @code{throw} exits all Lisp constructs up to the matching "
"@code{catch}, including function calls.  When binding constructs such as "
"@code{let} or function calls are exited in this way, the bindings are "
"unbound, just as they are when these constructs exit normally (@pxref{Local "
"Variables}).  Likewise, @code{throw} restores the buffer and position saved "
"by @code{save-excursion} (@pxref{Excursions}), and the narrowing status "
"saved by @code{save-restriction}.  It also runs any cleanups established "
"with the @code{unwind-protect} special form when it exits that form "
"(@pxref{Cleanups})."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1593
msgid ""
"The @code{throw} need not appear lexically within the @code{catch} that it "
"jumps to.  It can equally well be called from another function called within "
"the @code{catch}.  As long as the @code{throw} takes place chronologically "
"after entry to the @code{catch}, and chronologically before exit from it, it "
"has access to that @code{catch}.  This is why @code{throw} can be used in "
"commands such as @code{exit-recursive-edit} that throw back to the editor "
"command loop (@pxref{Recursive Editing})."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1594
#, no-wrap
msgid "CL note---only @code{throw} in Emacs"
msgstr ""

#. type: quotation
#: ../../../../../doc/lispref/control.texi:1601
msgid ""
"@b{Common Lisp note:} Most other versions of Lisp, including Common Lisp, "
"have several ways of transferring control nonsequentially: @code{return}, "
"@code{return-from}, and @code{go}, for example.  Emacs Lisp has only "
"@code{throw}.  The @file{cl-lib} library provides versions of some of "
"these.  @xref{Blocks and Exits,,,cl,Common Lisp Extensions}."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:1603
#, no-wrap
msgid "catch tag body@dots{}"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1604
#, no-wrap
msgid "tag on run time stack"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:1609
msgid ""
"@code{catch} establishes a return point for the @code{throw} function.  The "
"return point is distinguished from other such return points by @var{tag}, "
"which may be any Lisp object except @code{nil}.  The argument @var{tag} is "
"evaluated normally before the return point is established."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:1614
msgid ""
"With the return point in effect, @code{catch} evaluates the forms of the "
"@var{body} in textual order.  If the forms execute normally (without error "
"or nonlocal exit) the value of the last body form is returned from the "
"@code{catch}."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:1619
msgid ""
"If a @code{throw} is executed during the execution of @var{body}, specifying "
"the same value @var{tag}, the @code{catch} form exits immediately; the value "
"it returns is whatever was specified as the second argument of @code{throw}."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1621
#, no-wrap
msgid "throw tag value"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1627
msgid ""
"The purpose of @code{throw} is to return from a return point previously "
"established with @code{catch}.  The argument @var{tag} is used to choose "
"among the various existing return points; it must be @code{eq} to the value "
"specified in the @code{catch}.  If multiple return points match @var{tag}, "
"the innermost one is used."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1630
msgid ""
"The argument @var{value} is used as the value to return from that "
"@code{catch}."
msgstr ""

#. type: kindex
#: ../../../../../doc/lispref/control.texi:1631
#, no-wrap
msgid "no-catch"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1634
msgid ""
"If no return point is in effect with tag @var{tag}, then a @code{no-catch} "
"error is signaled with data @code{(@var{tag} @var{value})}."
msgstr ""

#. type: subsection
#: ../../../../../doc/lispref/control.texi:1637
#, no-wrap
msgid "Examples of @code{catch} and @code{throw}"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1643
msgid ""
"One way to use @code{catch} and @code{throw} is to exit from a doubly nested "
"loop.  (In most languages, this would be done with a @code{goto}.)  Here we "
"compute @code{(foo @var{i} @var{j})} for @var{i} and @var{j} varying from 0 "
"to 9:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1656
#, no-wrap
msgid ""
"(defun search-foo ()\n"
"  (catch 'loop\n"
"    (let ((i 0))\n"
"      (while (< i 10)\n"
"        (let ((j 0))\n"
"          (while (< j 10)\n"
"            (if (foo i j)\n"
"                (throw 'loop (list i j)))\n"
"            (setq j (1+ j))))\n"
"        (setq i (1+ i))))))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1664
msgid ""
"If @code{foo} ever returns non-@code{nil}, we stop immediately and return a "
"list of @var{i} and @var{j}.  If @code{foo} always returns @code{nil}, the "
"@code{catch} returns normally, and the value is @code{nil}, since that is "
"the result of the @code{while}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1668
msgid ""
"Here are two tricky examples, slightly different, showing two return points "
"at once.  First, two return points with the same tag, @code{hack}:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1675
#, no-wrap
msgid ""
"(defun catch2 (tag)\n"
"  (catch tag\n"
"    (throw 'hack 'yes)))\n"
"@result{} catch2\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1683
#, no-wrap
msgid ""
"(catch 'hack\n"
"  (print (catch2 'hack))\n"
"  'no)\n"
"@print{} yes\n"
"@result{} no\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1692
msgid ""
"Since both return points have tags that match the @code{throw}, it goes to "
"the inner one, the one established in @code{catch2}.  Therefore, "
"@code{catch2} returns normally with value @code{yes}, and this value is "
"printed.  Finally the second body form in the outer @code{catch}, which is "
"@code{'no}, is evaluated and returned from the outer @code{catch}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1694
msgid "Now let's change the argument given to @code{catch2}:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1701
#, no-wrap
msgid ""
"(catch 'hack\n"
"  (print (catch2 'quux))\n"
"  'no)\n"
"@result{} yes\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1710
msgid ""
"We still have two return points, but this time only the outer one has the "
"tag @code{hack}; the inner one has the tag @code{quux} instead.  Therefore, "
"@code{throw} makes the outer @code{catch} return the value @code{yes}.  The "
"function @code{print} is never called, and the body-form @code{'no} is never "
"evaluated."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1713
#, no-wrap
msgid "errors"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1717
msgid ""
"When Emacs Lisp attempts to evaluate a form that, for some reason, cannot be "
"evaluated, it @dfn{signals} an @dfn{error}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1722
msgid ""
"When an error is signaled, Emacs's default reaction is to print an error "
"message and terminate execution of the current command.  This is the right "
"thing to do in most cases, such as if you type @kbd{C-f} at the end of the "
"buffer."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1732
msgid ""
"In complicated programs, simple termination may not be what you want.  For "
"example, the program may have made temporary changes in data structures, or "
"created temporary buffers that should be deleted before the program is "
"finished.  In such cases, you would use @code{unwind-protect} to establish "
"@dfn{cleanup expressions} to be evaluated in case of error.  "
"(@xref{Cleanups}.)  Occasionally, you may wish the program to continue "
"execution despite an error in a subroutine.  In these cases, you would use "
"@code{condition-case} to establish @dfn{error handlers} to recover control "
"in case of error."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1736
msgid ""
"Resist the temptation to use error handling to transfer control from one "
"part of the program to another; use @code{catch} and @code{throw} instead.  "
"@xref{Catch and Throw}."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/control.texi:1742 ../../../../../doc/lispref/control.texi:1744
#, no-wrap
msgid "Signaling Errors"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:1742
msgid "How to report an error."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/control.texi:1742 ../../../../../doc/lispref/control.texi:1869
#, no-wrap
msgid "Processing of Errors"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:1742
msgid "What Emacs does when you report an error."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/control.texi:1742 ../../../../../doc/lispref/control.texi:1906
#, no-wrap
msgid "Handling Errors"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:1742
msgid "How you can trap errors and continue execution."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/control.texi:1742 ../../../../../doc/lispref/control.texi:2192
#, no-wrap
msgid "Error Symbols"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/control.texi:1742
msgid "How errors are classified for trapping them."
msgstr ""

#. type: subsubsection
#: ../../../../../doc/lispref/control.texi:1745
#, no-wrap
msgid "How to Signal an Error"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1746
#, no-wrap
msgid "signaling errors"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1753
msgid ""
"@dfn{Signaling} an error means beginning error processing.  Error processing "
"normally aborts all or part of the running program and returns to a point "
"that is set up to handle the error (@pxref{Processing of Errors}).  Here we "
"describe how to signal an error."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1759
msgid ""
"Most errors are signaled automatically within Lisp primitives which you call "
"for other purposes, such as if you try to take the @sc{car} of an integer or "
"move forward a character at the end of the buffer.  You can also signal "
"errors explicitly with the functions @code{error} and @code{signal}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1763
msgid ""
"Quitting, which happens when the user types @kbd{C-g}, is not considered an "
"error, but it is handled almost like an error.  @xref{Quitting}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1769
msgid ""
"Every error specifies an error message, one way or another.  The message "
"should state what is wrong (``File does not exist''), not how things ought "
"to be (``File must exist'').  The convention in Emacs Lisp is that error "
"messages should start with a capital letter, but should not end with any "
"sort of punctuation."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1770
#, no-wrap
msgid "error format-string &rest args"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1774
msgid ""
"This function signals an error with an error message constructed by applying "
"@code{format-message} (@pxref{Formatting Strings}) to @var{format-string} "
"and @var{args}."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1776
msgid "These examples show typical uses of @code{error}:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1781
#, no-wrap
msgid ""
"(error \"That is an error -- try something else\")\n"
"     @error{} That is an error -- try something else\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1786
#, no-wrap
msgid ""
"(error \"Invalid name `%s'\" \"A%%B\")\n"
"     @error{} Invalid name A%%B\n"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1792
msgid ""
"@code{error} works by calling @code{signal} with two arguments: the error "
"symbol @code{error}, and a list containing the string returned by "
"@code{format-message}."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1797
msgid ""
"Typically grave accent and apostrophe in the format translate to matching "
"curved quotes, e.g., @t{\"Missing `%s'\"} might result in @t{\"Missing "
"foo\"}.  @xref{Text Quoting Style}, for how to influence or inhibit this "
"translation."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1803
msgid ""
"@strong{Warning:} If you want to use your own string as an error message "
"verbatim, don't just write @code{(error @var{string})}.  If @var{string} "
"@var{string} contains @samp{%}, @samp{`}, or @samp{'} it may be reformatted, "
"with undesirable results.  Instead, use @code{(error \"%s\" @var{string})}."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1805
#, no-wrap
msgid "signal error-symbol data"
msgstr ""

#. type: anchor{#1}
#: ../../../../../doc/lispref/control.texi:1810
msgid "Definition of signal"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1810
msgid ""
"This function signals an error named by @var{error-symbol}.  The argument "
"@var{data} is a list of additional Lisp objects relevant to the "
"circumstances of the error."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1815
msgid ""
"The argument @var{error-symbol} must be an @dfn{error symbol}---a symbol "
"defined with @code{define-error}.  This is how Emacs Lisp classifies "
"different sorts of errors.  @xref{Error Symbols}, for a description of error "
"symbols, error conditions and condition names."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1823
msgid ""
"If the error is not handled, the two arguments are used in printing the "
"error message.  Normally, this error message is provided by the "
"@code{error-message} property of @var{error-symbol}.  If @var{data} is "
"non-@code{nil}, this is followed by a colon and a comma separated list of "
"the unevaluated elements of @var{data}.  For @code{error}, the error message "
"is the @sc{car} of @var{data} (that must be a string).  Subcategories of "
"@code{file-error} are handled specially."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1828
msgid ""
"The number and significance of the objects in @var{data} depends on "
"@var{error-symbol}.  For example, with a @code{wrong-type-argument} error, "
"there should be two objects in the list: a predicate that describes the type "
"that was expected, and the object that failed to fit that type."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1833
msgid ""
"Both @var{error-symbol} and @var{data} are available to any error handlers "
"that handle the error: @code{condition-case} binds a local variable to a "
"list of the form @code{(@var{error-symbol} .@: @var{data})} (@pxref{Handling "
"Errors})."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1836
msgid "The function @code{signal} never returns."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1841
#, no-wrap
msgid ""
"(signal 'wrong-number-of-arguments '(x y))\n"
"     @error{} Wrong number of arguments: x, y\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1846
#, no-wrap
msgid ""
"(signal 'no-such-error '(\"My unknown error condition\"))\n"
"     @error{} peculiar error: \"My unknown error condition\"\n"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1850
#, no-wrap
msgid "user errors, signaling"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1851
#, no-wrap
msgid "user-error format-string &rest args"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:1861
msgid ""
"This function behaves exactly like @code{error}, except that it uses the "
"error symbol @code{user-error} rather than @code{error}.  As the name "
"suggests, this is intended to report errors on the part of the user, rather "
"than errors in the code itself.  For example, if you try to use the command "
"@code{Info-history-back} (@kbd{l}) to move back beyond the start of your "
"Info browsing history, Emacs signals a @code{user-error}.  Such errors do "
"not cause entry to the debugger, even when @code{debug-on-error} is "
"non-@code{nil}.  @xref{Error Debugging}."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1863
#, no-wrap
msgid "CL note---no continuable errors"
msgstr ""

#. type: quotation
#: ../../../../../doc/lispref/control.texi:1867
msgid ""
"@b{Common Lisp note:} Emacs Lisp has nothing like the Common Lisp concept of "
"continuable errors."
msgstr ""

#. type: subsubsection
#: ../../../../../doc/lispref/control.texi:1870
#, no-wrap
msgid "How Emacs Processes Errors"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1871
#, no-wrap
msgid "processing of errors"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1881
msgid ""
"When an error is signaled, @code{signal} searches for an active "
"@dfn{handler} for the error.  A handler is a sequence of Lisp expressions "
"designated to be executed if an error happens in part of the Lisp program.  "
"If the error has an applicable handler, the handler is executed, and control "
"resumes following the handler.  The handler executes in the environment of "
"the @code{condition-case} that established it; all functions called within "
"that @code{condition-case} have already been exited, and the handler cannot "
"return to them."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1888
msgid ""
"If there is no applicable handler for the error, it terminates the current "
"command and returns control to the editor command loop.  (The command loop "
"has an implicit handler for all kinds of errors.)  The command loop's "
"handler uses the error symbol and associated data to print an error "
"message.  You can use the variable @code{command-error-function} to control "
"how this is done:"
msgstr ""

#. type: defvar
#: ../../../../../doc/lispref/control.texi:1889
#, no-wrap
msgid "command-error-function"
msgstr ""

#. type: defvar
#: ../../../../../doc/lispref/control.texi:1897
msgid ""
"This variable, if non-@code{nil}, specifies a function to use to handle "
"errors that return control to the Emacs command loop.  The function should "
"take three arguments: @var{data}, a list of the same form that "
"@code{condition-case} would bind to its variable; @var{context}, a string "
"describing the situation in which the error occurred, or (more often) "
"@code{nil}; and @var{caller}, the Lisp function which called the primitive "
"that signaled the error."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1899
#, no-wrap
msgid "@code{debug-on-error} use"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1905
msgid ""
"An error that has no explicit handler may call the Lisp debugger.  The "
"debugger is enabled if the variable @code{debug-on-error} (@pxref{Error "
"Debugging}) is non-@code{nil}.  Unlike error handlers, the debugger runs in "
"the environment of the error, so that you can examine values of variables "
"precisely as they were at the time of the error."
msgstr ""

#. type: subsubsection
#: ../../../../../doc/lispref/control.texi:1907
#, no-wrap
msgid "Writing Code to Handle Errors"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1908
#, no-wrap
msgid "error handler"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1909
#, no-wrap
msgid "handling errors"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1910
#, no-wrap
msgid "handle Lisp errors"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:1911
#, no-wrap
msgid "forms for handling errors"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1918
msgid ""
"The usual effect of signaling an error is to terminate the command that is "
"running and return immediately to the Emacs editor command loop.  You can "
"arrange to trap errors occurring in a part of your program by establishing "
"an error handler, with the special form @code{condition-case}.  A simple "
"example looks like this:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1924
#, no-wrap
msgid ""
"(condition-case nil\n"
"    (delete-file filename)\n"
"  (error nil))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1931
msgid ""
"This deletes the file named @var{filename}, catching any error and returning "
"@code{nil} if an error occurs.  (You can use the macro @code{ignore-errors} "
"for a simple case like this; see below.)"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1937
msgid ""
"The @code{condition-case} construct is often used to trap errors that are "
"predictable, such as failure to open a file in a call to "
"@code{insert-file-contents}.  It is also used to trap errors that are "
"totally unpredictable, such as when the program evaluates an expression read "
"from the user."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1948
msgid ""
"The second argument of @code{condition-case} is called the @dfn{protected "
"form}.  (In the example above, the protected form is a call to "
"@code{delete-file}.)  The error handlers go into effect when this form "
"begins execution and are deactivated when this form returns.  They remain in "
"effect for all the intervening time.  In particular, they are in effect "
"during the execution of functions called by this form, in their subroutines, "
"and so on.  This is a good thing, since, strictly speaking, errors can be "
"signaled only by Lisp primitives (including @code{signal} and @code{error}) "
"called by the protected form, not by the protected form itself."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1956
msgid ""
"The arguments after the protected form are handlers.  Each handler lists one "
"or more @dfn{condition names} (which are symbols) to specify which errors it "
"will handle.  The error symbol specified when an error is signaled also "
"defines a list of condition names.  A handler applies to an error if they "
"have any condition names in common.  In the example above, there is one "
"handler, and it specifies one condition name, @code{error}, which covers all "
"errors."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1961
msgid ""
"The search for an applicable handler checks all the established handlers "
"starting with the most recently established one.  Thus, if two nested "
"@code{condition-case} forms offer to handle the same error, the inner of the "
"two gets to handle it."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1965
msgid ""
"If an error is handled by some @code{condition-case} form, this ordinarily "
"prevents the debugger from being run, even if @code{debug-on-error} says "
"this error should invoke the debugger."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1971
msgid ""
"If you want to be able to debug errors that are caught by a "
"@code{condition-case}, set the variable @code{debug-on-signal} to a "
"non-@code{nil} value.  You can also specify that a particular handler should "
"let the debugger run first, by writing @code{debug} among the conditions, "
"like this:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:1977
#, no-wrap
msgid ""
"(condition-case nil\n"
"    (delete-file filename)\n"
"  ((debug error) nil))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1985
msgid ""
"The effect of @code{debug} here is only to prevent @code{condition-case} "
"from suppressing the call to the debugger.  Any given error will invoke the "
"debugger only if @code{debug-on-error} and the other usual filtering "
"mechanisms say it should.  @xref{Error Debugging}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1986
#, no-wrap
msgid "condition-case-unless-debug var protected-form handlers@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:1991
msgid ""
"The macro @code{condition-case-unless-debug} provides another way to handle "
"debugging of such forms.  It behaves exactly like @code{condition-case}, "
"unless the variable @code{debug-on-error} is non-@code{nil}, in which case "
"it does not handle any errors at all."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:1999
msgid ""
"Once Emacs decides that a certain handler handles the error, it returns "
"control to that handler.  To do so, Emacs unbinds all variable bindings made "
"by binding constructs that are being exited, and executes the cleanups of "
"all @code{unwind-protect} forms that are being exited.  Once control arrives "
"at the handler, the body of the handler executes normally."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2006
msgid ""
"After execution of the handler body, execution returns from the "
"@code{condition-case} form.  Because the protected form is exited completely "
"before execution of the handler, the handler cannot resume execution at the "
"point of the error, nor can it examine variable bindings that were made "
"within the protected form.  All it can do is clean up and proceed."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2013
msgid ""
"Error signaling and handling have some resemblance to @code{throw} and "
"@code{catch} (@pxref{Catch and Throw}), but they are entirely separate "
"facilities.  An error cannot be caught by a @code{catch}, and a @code{throw} "
"cannot be handled by an error handler (though using @code{throw} when there "
"is no suitable @code{catch} signals an error that can be handled)."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:2014
#, no-wrap
msgid "condition-case var protected-form handlers@dots{}"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:2021
msgid ""
"This special form establishes the error handlers @var{handlers} around the "
"execution of @var{protected-form}.  If @var{protected-form} executes without "
"error, the value it returns becomes the value of the @code{condition-case} "
"form; in this case, the @code{condition-case} has no effect.  The "
"@code{condition-case} form makes a difference when an error occurs during "
"@var{protected-form}."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:2029
msgid ""
"Each of the @var{handlers} is a list of the form @code{(@var{conditions} "
"@var{body}@dots{})}.  Here @var{conditions} is an error condition name to be "
"handled, or a list of condition names (which can include @code{debug} to "
"allow the debugger to run before the handler).  A condition name of @code{t} "
"matches any condition.  @var{body} is one or more Lisp expressions to be "
"executed when this handler handles an error.  Here are examples of handlers:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:2033
#, no-wrap
msgid ""
"(error nil)\n"
"\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:2035
#, no-wrap
msgid ""
"(arith-error (message \"Division by zero\"))\n"
"\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:2039
#, no-wrap
msgid ""
"((arith-error file-error)\n"
" (message\n"
"  \"Either division by zero or failure to open a file\"))\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:2049
msgid ""
"Each error that occurs has an @dfn{error symbol} that describes what kind of "
"error it is, and which describes also a list of condition names "
"(@pxref{Error Symbols}).  Emacs searches all the active "
"@code{condition-case} forms for a handler that specifies one or more of "
"these condition names; the innermost matching @code{condition-case} handles "
"the error.  Within this @code{condition-case}, the first applicable handler "
"handles the error."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:2053
msgid ""
"After executing the body of the handler, the @code{condition-case} returns "
"normally, using the value of the last form in the handler body as the "
"overall value."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:2054
#, no-wrap
msgid "error description"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:2064
msgid ""
"The argument @var{var} is a variable.  @code{condition-case} does not bind "
"this variable when executing the @var{protected-form}, only when it handles "
"an error.  At that time, it binds @var{var} locally to an @dfn{error "
"description}, which is a list giving the particulars of the error.  The "
"error description has the form @code{(@var{error-symbol} . @var{data})}.  "
"The handler can refer to this list to decide what to do.  For example, if "
"the error is for failure opening a file, the file name is the second element "
"of @var{data}---the third element of the error description."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:2067
msgid ""
"If @var{var} is @code{nil}, that means no variable is bound.  Then the error "
"symbol and associated data are not available to the handler."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:2068
#, no-wrap
msgid "rethrow a signal"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:2072
msgid ""
"Sometimes it is necessary to re-throw a signal caught by "
"@code{condition-case}, for some outer-level handler to catch.  Here's how to "
"do that:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:2075
#, no-wrap
msgid "  (signal (car err) (cdr err))\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:2081
msgid ""
"where @code{err} is the error description variable, the first argument to "
"@code{condition-case} whose error condition you want to re-throw.  "
"@xref{Definition of signal}."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:2083
#, no-wrap
msgid "error-message-string error-descriptor"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:2087
msgid ""
"This function returns the error message string for a given error "
"descriptor.  It is useful if you want to handle an error by printing the "
"usual error message for that error.  @xref{Definition of signal}."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:2089
#, no-wrap
msgid "@code{arith-error} example"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2093
msgid ""
"Here is an example of using @code{condition-case} to handle the error that "
"results from dividing by zero.  The handler displays the error message (but "
"without a beep), then returns a very large number."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:2100
#, no-wrap
msgid ""
"(defun safe-divide (dividend divisor)\n"
"  (condition-case err\n"
"      ;; @r{Protected form.}\n"
"      (/ dividend divisor)\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:2108
#, no-wrap
msgid ""
"    ;; @r{The handler.}\n"
"    (arith-error                        ; @r{Condition.}\n"
"     ;; @r{Display the usual message for this error.}\n"
"     (message \"%s\" (error-message-string err))\n"
"     1000000)))\n"
"@result{} safe-divide\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:2114
#, no-wrap
msgid ""
"(safe-divide 5 0)\n"
"     @print{} Arithmetic error: (arith-error)\n"
"@result{} 1000000\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2121
msgid ""
"The handler specifies condition name @code{arith-error} so that it will "
"handle only division-by-zero errors.  Other kinds of errors will not be "
"handled (by this @code{condition-case}).  Thus:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:2126
#, no-wrap
msgid ""
"(safe-divide nil 3)\n"
"     @error{} Wrong type argument: number-or-marker-p, nil\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2131
msgid ""
"Here is a @code{condition-case} that catches all kinds of errors, including "
"those from @code{error}:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:2136
#, no-wrap
msgid ""
"(setq baz 34)\n"
"     @result{} 34\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:2149
#, no-wrap
msgid ""
"(condition-case err\n"
"    (if (eq baz 35)\n"
"        t\n"
"      ;; @r{This is a call to the function @code{error}.}\n"
"      (error \"Rats!  The variable %s was %s, not 35\" 'baz baz))\n"
"  ;; @r{This is the handler; it is not a form.}\n"
"  (error (princ (format \"The error was: %s\" err))\n"
"         2))\n"
"@print{} The error was: (error \"Rats!  The variable baz was 34, not 35\")\n"
"@result{} 2\n"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:2152
#, no-wrap
msgid "ignore-errors body@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:2157
msgid ""
"This construct executes @var{body}, ignoring any errors that occur during "
"its execution.  If the execution is without error, @code{ignore-errors} "
"returns the value of the last form in @var{body}; otherwise, it returns "
"@code{nil}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:2160
msgid ""
"Here's the example at the beginning of this subsection rewritten using "
"@code{ignore-errors}:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:2165
#, no-wrap
msgid ""
"  (ignore-errors\n"
"   (delete-file filename))\n"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:2169
#, no-wrap
msgid "ignore-error condition body@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:2172
msgid ""
"This macro is like @code{ignore-errors}, but will only ignore the specific "
"error condition specified."
msgstr ""

#. type: example
#: ../../../../../doc/lispref/control.texi:2176
#, no-wrap
msgid ""
"  (ignore-error end-of-file\n"
"    (read \"\"))\n"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:2179
msgid "@var{condition} can also be a list of error conditions."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:2181
#, no-wrap
msgid "with-demoted-errors format body@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/control.texi:2190
msgid ""
"This macro is like a milder version of @code{ignore-errors}.  Rather than "
"suppressing errors altogether, it converts them into messages.  It uses the "
"string @var{format} to format the message.  @var{format} should contain a "
"single @samp{%}-sequence; e.g., @code{\"Error: %S\"}.  Use "
"@code{with-demoted-errors} around code that is not expected to signal "
"errors, but should be robust if one does occur.  Note that this macro uses "
"@code{condition-case-unless-debug} rather than @code{condition-case}."
msgstr ""

#. type: subsubsection
#: ../../../../../doc/lispref/control.texi:2193
#, no-wrap
msgid "Error Symbols and Condition Names"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:2194
#, no-wrap
msgid "error symbol"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:2195
#, no-wrap
msgid "error name"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:2196
#, no-wrap
msgid "condition name"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:2197
#, no-wrap
msgid "user-defined error"
msgstr ""

#. type: kindex
#: ../../../../../doc/lispref/control.texi:2198
#, no-wrap
msgid "error-conditions"
msgstr ""

#. type: kindex
#: ../../../../../doc/lispref/control.texi:2199
#, no-wrap
msgid "define-error"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2205
msgid ""
"When you signal an error, you specify an @dfn{error symbol} to specify the "
"kind of error you have in mind.  Each error has one and only one error "
"symbol to categorize it.  This is the finest classification of errors "
"defined by the Emacs Lisp language."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2215
msgid ""
"These narrow classifications are grouped into a hierarchy of wider classes "
"called @dfn{error conditions}, identified by @dfn{condition names}.  The "
"narrowest such classes belong to the error symbols themselves: each error "
"symbol is also a condition name.  There are also condition names for more "
"extensive classes, up to the condition name @code{error} which takes in all "
"kinds of errors (but not @code{quit}).  Thus, each error has one or more "
"condition names: @code{error}, the error symbol if that is distinct from "
"@code{error}, and perhaps some intermediate classifications."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:2216
#, no-wrap
msgid "define-error name message &optional parent"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/control.texi:2223
msgid ""
"In order for a symbol to be an error symbol, it must be defined with "
"@code{define-error} which takes a parent condition (defaults to "
"@code{error}).  This parent defines the conditions that this kind of error "
"belongs to.  The transitive set of parents always includes the error symbol "
"itself, and the symbol @code{error}.  Because quitting is not considered an "
"error, the set of parents of @code{quit} is just @code{(quit)}."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:2225
#, no-wrap
msgid "peculiar error"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2230
msgid ""
"In addition to its parents, the error symbol has a @var{message} which is a "
"string to be printed when that error is signaled but not handled.  If that "
"message is not valid, the error message @samp{peculiar error} is used.  "
"@xref{Definition of signal}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2234
msgid ""
"Internally, the set of parents is stored in the @code{error-conditions} "
"property of the error symbol and the message is stored in the "
"@code{error-message} property of the error symbol."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2236
msgid "Here is how we define a new error symbol, @code{new-error}:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:2240
#, no-wrap
msgid "(define-error 'new-error \"A new error\" 'my-own-errors)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2248
msgid ""
"This error has several condition names: @code{new-error}, the narrowest "
"classification; @code{my-own-errors}, which we imagine is a wider "
"classification; and all the conditions of @code{my-own-errors} which should "
"include @code{error}, which is the widest of all."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2251
msgid ""
"The error string should start with a capital letter but it should not end "
"with a period.  This is for consistency with the rest of Emacs."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2255
msgid ""
"Naturally, Emacs will never signal @code{new-error} on its own; only an "
"explicit call to @code{signal} (@pxref{Definition of signal}) in your code "
"can do this:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:2260
#, no-wrap
msgid ""
"(signal 'new-error '(x y))\n"
"     @error{} A new error: x, y\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2266
msgid ""
"This error can be handled through any of its condition names.  This example "
"handles @code{new-error} and any other errors in the class "
"@code{my-own-errors}:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:2272
#, no-wrap
msgid ""
"(condition-case foo\n"
"    (bar nil t)\n"
"  (my-own-errors nil))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2280
msgid ""
"The significant way that errors are classified is by their condition "
"names---the names used to match errors with handlers.  An error symbol "
"serves only as a convenient way to specify the intended error message and "
"list of condition names.  It would be cumbersome to give @code{signal} a "
"list of condition names rather than one error symbol."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2286
msgid ""
"By contrast, using only error symbols without condition names would "
"seriously decrease the power of @code{condition-case}.  Condition names make "
"it possible to categorize errors at various levels of generality when you "
"write an error handler.  Using error symbols alone would eliminate all but "
"the narrowest level of classification."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2289
msgid ""
"@xref{Standard Errors}, for a list of the main error symbols and their "
"conditions."
msgstr ""

#. type: subsection
#: ../../../../../doc/lispref/control.texi:2291
#, no-wrap
msgid "Cleaning Up from Nonlocal Exits"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:2292
#, no-wrap
msgid "nonlocal exits, cleaning up"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:2293
#, no-wrap
msgid "forms for cleanup"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2301
msgid ""
"The @code{unwind-protect} construct is essential whenever you temporarily "
"put a data structure in an inconsistent state; it permits you to make the "
"data consistent again in the event of an error or throw.  (Another more "
"specific cleanup construct that is used only for changes in buffer contents "
"is the atomic change group; @ref{Atomic Changes}.)"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:2302
#, no-wrap
msgid "unwind-protect body-form cleanup-forms@dots{}"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:2303
#, no-wrap
msgid "cleanup forms"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:2304
#, no-wrap
msgid "protected forms"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:2305
#, no-wrap
msgid "error cleanup"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/control.texi:2306
#, no-wrap
msgid "unwinding"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:2313
msgid ""
"@code{unwind-protect} executes @var{body-form} with a guarantee that the "
"@var{cleanup-forms} will be evaluated if control leaves @var{body-form}, no "
"matter how that happens.  @var{body-form} may complete normally, or execute "
"a @code{throw} out of the @code{unwind-protect}, or cause an error; in all "
"cases, the @var{cleanup-forms} will be evaluated."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:2318
msgid ""
"If @var{body-form} finishes normally, @code{unwind-protect} returns the "
"value of @var{body-form}, after it evaluates the @var{cleanup-forms}.  If "
"@var{body-form} does not finish, @code{unwind-protect} does not return any "
"value in the normal sense."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:2325
msgid ""
"Only @var{body-form} is protected by the @code{unwind-protect}.  If any of "
"the @var{cleanup-forms} themselves exits nonlocally (via a @code{throw} or "
"an error), @code{unwind-protect} is @emph{not} guaranteed to evaluate the "
"rest of them.  If the failure of one of the @var{cleanup-forms} has the "
"potential to cause trouble, then protect it with another "
"@code{unwind-protect} around that form."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/control.texi:2330
msgid ""
"The number of currently active @code{unwind-protect} forms counts, together "
"with the number of local variable bindings, against the limit "
"@code{max-specpdl-size} (@pxref{Definition of max-specpdl-size,, Local "
"Variables})."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2334
msgid ""
"For example, here we make an invisible buffer for temporary use, and make "
"sure to kill it before finishing:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:2342
#, no-wrap
msgid ""
"(let ((buffer (get-buffer-create \" *temp*\")))\n"
"  (with-current-buffer buffer\n"
"    (unwind-protect\n"
"        @var{body-form}\n"
"      (kill-buffer buffer))))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2353
msgid ""
"You might think that we could just as well write @code{(kill-buffer "
"(current-buffer))} and dispense with the variable @code{buffer}.  However, "
"the way shown above is safer, if @var{body-form} happens to get an error "
"after switching to a different buffer! (Alternatively, you could write a "
"@code{save-current-buffer} around @var{body-form}, to ensure that the "
"temporary buffer becomes current again in time to kill it.)"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2358
msgid ""
"Emacs includes a standard macro called @code{with-temp-buffer} which expands "
"into more or less the code shown above (@pxref{Definition of "
"with-temp-buffer,, Current Buffer}).  Several of the macros defined in this "
"manual use @code{unwind-protect} in this way."
msgstr ""

#. type: findex
#: ../../../../../doc/lispref/control.texi:2359
#, no-wrap
msgid "ftp-login"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2367
msgid ""
"Here is an actual example derived from an FTP package.  It creates a process "
"(@pxref{Processes}) to try to establish a connection to a remote machine.  "
"As the function @code{ftp-login} is highly susceptible to numerous problems "
"that the writer of the function cannot anticipate, it is protected with a "
"form that guarantees deletion of the process in the event of failure.  "
"Otherwise, Emacs might fill up with useless subprocesses."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/control.texi:2378
#, no-wrap
msgid ""
"(let ((win nil))\n"
"  (unwind-protect\n"
"      (progn\n"
"        (setq process (ftp-setup-buffer host file))\n"
"        (if (setq win (ftp-login process host user password))\n"
"            (message \"Logged in\")\n"
"          (error \"Ftp login failed\")))\n"
"    (or win (and process (delete-process process)))))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/control.texi:2385
msgid ""
"This example has a small bug: if the user types @kbd{C-g} to quit, and the "
"quit happens immediately after the function @code{ftp-setup-buffer} returns "
"but before the variable @code{process} is set, the process will not be "
"killed.  There is no easy way to fix this bug, but at least it is very "
"unlikely."
msgstr ""
