# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-10-16 23:19+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: ../../../../../doc/lispref/compile.texi:5 ../../../../../doc/lispref/compile.texi:6
#, no-wrap
msgid "Byte Compilation"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:7
#, no-wrap
msgid "byte compilation"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/compile.texi:8 ../../../../../doc/lispref/compile.texi:588
#, no-wrap
msgid "byte-code"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:9
#, no-wrap
msgid "compilation (Emacs Lisp)"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:16
msgid ""
"Emacs Lisp has a @dfn{compiler} that translates functions written in Lisp "
"into a special representation called @dfn{byte-code} that can be executed "
"more efficiently.  The compiler replaces Lisp function definitions with "
"byte-code.  When a byte-code function is called, its definition is evaluated "
"by the @dfn{byte-code interpreter}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:22
msgid ""
"Because the byte-compiled code is evaluated by the byte-code interpreter, "
"instead of being executed directly by the machine's hardware (as true "
"compiled code is), byte-code is completely transportable from machine to "
"machine without recompilation.  It is not, however, as fast as true compiled "
"code."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:25
msgid ""
"In general, any version of Emacs can run byte-compiled code produced by "
"recent earlier versions of Emacs, but the reverse is not true."
msgstr ""

#. type: vindex
#: ../../../../../doc/lispref/compile.texi:26
#, no-wrap
msgid "no-byte-compile"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:29
msgid ""
"If you do not want a Lisp file to be compiled, ever, put a file-local "
"variable binding for @code{no-byte-compile} into it, like this:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/compile.texi:32
#, no-wrap
msgid ";; -*-no-byte-compile: t; -*-\n"
msgstr ""

#. type: node
#: ../../../../../doc/lispref/compile.texi:43 ../../../../../doc/lispref/compile.texi:45
#, no-wrap
msgid "Speed of Byte-Code"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/compile.texi:43
msgid "An example of speedup from byte compilation."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/compile.texi:43 ../../../../../doc/lispref/compile.texi:82
#, no-wrap
msgid "Compilation Functions"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/compile.texi:43
msgid "Byte compilation functions."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/compile.texi:43 ../../../../../doc/lispref/compile.texi:243
#, no-wrap
msgid "Docs and Compilation"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/compile.texi:43
msgid "Dynamic loading of documentation strings."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/compile.texi:43 ../../../../../doc/lispref/compile.texi:291
#, no-wrap
msgid "Dynamic Loading"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/compile.texi:43
msgid "Dynamic loading of individual functions."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/compile.texi:43 ../../../../../doc/lispref/compile.texi:356
#, no-wrap
msgid "Eval During Compile"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/compile.texi:43
msgid "Code to be evaluated when you compile."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/compile.texi:43 ../../../../../doc/lispref/compile.texi:438 ../../../../../doc/lispref/compile.texi:439
#, no-wrap
msgid "Compiler Errors"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/compile.texi:43
msgid "Handling compiler error messages."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/compile.texi:43 ../../../../../doc/lispref/compile.texi:555
#, no-wrap
msgid "Byte-Code Objects"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/compile.texi:43
msgid "The data type used for byte-compiled functions."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/compile.texi:43 ../../../../../doc/lispref/compile.texi:635
#, no-wrap
msgid "Disassembly"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/compile.texi:43
msgid "Disassembling byte-code; how to read byte-code."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/compile.texi:46
#, no-wrap
msgid "Performance of Byte-Compiled Code"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:51
msgid ""
"A byte-compiled function is not as efficient as a primitive function written "
"in C, but runs much faster than the version written in Lisp.  Here is an "
"example:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:60
#, no-wrap
msgid ""
"(defun silly-loop (n)\n"
"  \"Return the time, in seconds, to run N iterations of a loop.\"\n"
"  (let ((t1 (float-time)))\n"
"    (while (> (setq n (1- n)) 0))\n"
"    (- (float-time) t1)))\n"
"@result{} silly-loop\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:65
#, no-wrap
msgid ""
"(silly-loop 50000000)\n"
"@result{} 10.235304117202759\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:70
#, no-wrap
msgid ""
"(byte-compile 'silly-loop)\n"
"@result{} @r{[Compiled code not shown]}\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:75
#, no-wrap
msgid ""
"(silly-loop 50000000)\n"
"@result{} 3.705854892730713\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:81
msgid ""
"In this example, the interpreted code required 10 seconds to run, whereas "
"the byte-compiled code required less than 4 seconds.  These results are "
"representative, but actual results may vary."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/compile.texi:83
#, no-wrap
msgid "Byte-Compilation Functions"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:84
#, no-wrap
msgid "compilation functions"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:90
msgid ""
"You can byte-compile an individual function or macro definition with the "
"@code{byte-compile} function.  You can compile a whole file with "
"@code{byte-compile-file}, or several files with "
"@code{byte-recompile-directory} or @code{batch-byte-compile}."
msgstr ""

#. type: vindex
#: ../../../../../doc/lispref/compile.texi:91
#, no-wrap
msgid "byte-compile-debug"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:99
msgid ""
"Sometimes, the byte compiler produces warning and/or error messages "
"(@pxref{Compiler Errors}, for details).  These messages are normally "
"recorded in a buffer called @file{*Compile-Log*}, which uses Compilation "
"mode.  @xref{Compilation Mode,,,emacs, The GNU Emacs Manual}.  However, if "
"the variable @code{byte-compile-debug} is non-@code{nil}, error messages "
"will be signaled as Lisp errors instead (@pxref{Errors})."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:100
#, no-wrap
msgid "macro compilation"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:113
msgid ""
"Be careful when writing macro calls in files that you intend to "
"byte-compile.  Since macro calls are expanded when they are compiled, the "
"macros need to be loaded into Emacs or the byte compiler will not do the "
"right thing.  The usual way to handle this is with @code{require} forms "
"which specify the files containing the needed macro definitions "
"(@pxref{Named Features}).  Normally, the byte compiler does not evaluate the "
"code that it is compiling, but it handles @code{require} forms specially, by "
"loading the specified libraries.  To avoid loading the macro definition "
"files when someone @emph{runs} the compiled program, write "
"@code{eval-when-compile} around the @code{require} calls (@pxref{Eval During "
"Compile}).  For more details, @xref{Compiling Macros}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:117
msgid ""
"Inline (@code{defsubst}) functions are less troublesome; if you compile a "
"call to such a function before its definition is known, the call will still "
"work right, it will just run slower."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/compile.texi:118
#, no-wrap
msgid "byte-compile symbol"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/compile.texi:125
msgid ""
"This function byte-compiles the function definition of @var{symbol}, "
"replacing the previous definition with the compiled one.  The function "
"definition of @var{symbol} must be the actual code for the function; "
"@code{byte-compile} does not handle function indirection.  The return value "
"is the byte-code function object which is the compiled definition of "
"@var{symbol} (@pxref{Byte-Code Objects})."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:133
#, no-wrap
msgid ""
"(defun factorial (integer)\n"
"  \"Compute factorial of INTEGER.\"\n"
"  (if (= 1 integer) 1\n"
"    (* integer (factorial (1- integer)))))\n"
"@result{} factorial\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:142
#, no-wrap
msgid ""
"(byte-compile 'factorial)\n"
"@result{}\n"
"#[(integer)\n"
"  \"^H\\301U\\203^H^@@\\301\\207\\302^H\\303^HS!\\\"\\207\"\n"
"  [integer 1 * factorial]\n"
"  4 \"Compute factorial of INTEGER.\"]\n"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/compile.texi:150
msgid ""
"If @var{symbol}'s definition is a byte-code function object, "
"@code{byte-compile} does nothing and returns @code{nil}.  It does not "
"compile the symbol's definition again, since the original (non-compiled) "
"code has already been replaced in the symbol's function cell by the "
"byte-compiled code."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/compile.texi:154
msgid ""
"The argument to @code{byte-compile} can also be a @code{lambda} expression.  "
"In that case, the function returns the corresponding compiled code but does "
"not store it anywhere."
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:156
#, no-wrap
msgid "Command compile-defun &optional arg"
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:161
msgid ""
"This command reads the defun containing point, compiles it, and evaluates "
"the result.  If you use this on a defun that is actually a function "
"definition, the effect is to install a compiled version of that function."
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:165
msgid ""
"@code{compile-defun} normally displays the result of evaluation in the echo "
"area, but if @var{arg} is non-@code{nil}, it inserts the result in the "
"current buffer after the form it has compiled."
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:167
#, no-wrap
msgid "Command byte-compile-file filename &optional load"
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:172
msgid ""
"This function compiles a file of Lisp code named @var{filename} into a file "
"of byte-code.  The output file's name is made by changing the @samp{.el} "
"suffix into @samp{.elc}; if @var{filename} does not end in @samp{.el}, it "
"adds @samp{.elc} to the end of @var{filename}."
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:179
msgid ""
"Compilation works by reading the input file one form at a time.  If it is a "
"definition of a function or macro, the compiled function or macro definition "
"is written out.  Other forms are batched together, then each batch is "
"compiled, and written so that its compiled code will be executed when the "
"file is read.  All comments are discarded when the input file is read."
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:182
msgid ""
"This command returns @code{t} if there were no errors and @code{nil} "
"otherwise.  When called interactively, it prompts for the file name."
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:185
msgid ""
"If @var{load} is non-@code{nil}, this command loads the compiled file after "
"compiling it.  Interactively, @var{load} is the prefix argument."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:190
#, no-wrap
msgid ""
"$ ls -l push*\n"
"-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:195
#, no-wrap
msgid ""
"(byte-compile-file \"~/emacs/push.el\")\n"
"     @result{} t\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:201
#, no-wrap
msgid ""
"$ ls -l push*\n"
"-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el\n"
"-rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc\n"
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:205
#, no-wrap
msgid "Command byte-recompile-directory directory &optional flag force"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:206
#, no-wrap
msgid "library compilation"
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:211
msgid ""
"This command recompiles every @samp{.el} file in @var{directory} (or its "
"subdirectories) that needs recompilation.  A file needs recompilation if a "
"@samp{.elc} file exists but is older than the @samp{.el} file."
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:217
msgid ""
"When a @samp{.el} file has no corresponding @samp{.elc} file, @var{flag} "
"says what to do.  If it is @code{nil}, this command ignores these files.  If "
"@var{flag} is 0, it compiles them.  If it is neither @code{nil} nor 0, it "
"asks the user whether to compile each such file, and asks about each "
"subdirectory as well."
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:220
msgid ""
"Interactively, @code{byte-recompile-directory} prompts for @var{directory} "
"and @var{flag} is the prefix argument."
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:223
msgid ""
"If @var{force} is non-@code{nil}, this command recompiles every @samp{.el} "
"file that has a @samp{.elc} file."
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:225
msgid "The returned value is unpredictable."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/compile.texi:227
#, no-wrap
msgid "batch-byte-compile &optional noforce"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/compile.texi:234
msgid ""
"This function runs @code{byte-compile-file} on files specified on the "
"command line.  This function must be used only in a batch execution of "
"Emacs, as it kills Emacs on completion.  An error in one file does not "
"prevent processing of subsequent files, but no output file will be generated "
"for it, and the Emacs process will terminate with a nonzero status code."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/compile.texi:237
msgid ""
"If @var{noforce} is non-@code{nil}, this function does not recompile files "
"that have an up-to-date @samp{.elc} file."
msgstr ""

#. type: example
#: ../../../../../doc/lispref/compile.texi:240
#, no-wrap
msgid "$ emacs -batch -f batch-byte-compile *.el\n"
msgstr ""

#. type: section
#: ../../../../../doc/lispref/compile.texi:244
#, no-wrap
msgid "Documentation Strings and Compilation"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:245
#, no-wrap
msgid "dynamic loading of documentation"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:252
msgid ""
"When Emacs loads functions and variables from a byte-compiled file, it "
"normally does not load their documentation strings into memory.  Each "
"documentation string is dynamically loaded from the byte-compiled file only "
"when needed.  This saves memory, and speeds up loading by skipping the "
"processing of the documentation strings."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:259
msgid ""
"This feature has a drawback: if you delete, move, or alter the compiled file "
"(such as by compiling a new version), Emacs may no longer be able to access "
"the documentation string of previously-loaded functions or variables.  Such "
"a problem normally only occurs if you build Emacs yourself, and happen to "
"edit and/or recompile the Lisp source files.  To solve it, just reload each "
"file after recompilation."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:263
msgid ""
"Dynamic loading of documentation strings from byte-compiled files is "
"determined, at compile time, for each byte-compiled file.  It can be "
"disabled via the option @code{byte-compile-dynamic-docstrings}."
msgstr ""

#. type: defopt
#: ../../../../../doc/lispref/compile.texi:264
#, no-wrap
msgid "byte-compile-dynamic-docstrings"
msgstr ""

#. type: defopt
#: ../../../../../doc/lispref/compile.texi:267
msgid ""
"If this is non-@code{nil}, the byte compiler generates compiled files that "
"are set up for dynamic loading of documentation strings."
msgstr ""

#. type: defopt
#: ../../../../../doc/lispref/compile.texi:271
msgid ""
"To disable the dynamic loading feature for a specific file, set this option "
"to @code{nil} in its header line (@pxref{File Variables, , Local Variables "
"in Files, emacs, The GNU Emacs Manual}), like this:"
msgstr ""

#. type: smallexample
#: ../../../../../doc/lispref/compile.texi:274
#, no-wrap
msgid "-*-byte-compile-dynamic-docstrings: nil;-*-\n"
msgstr ""

#. type: defopt
#: ../../../../../doc/lispref/compile.texi:279
msgid ""
"This is useful mainly if you expect to change the file, and you want Emacs "
"sessions that have already loaded it to keep working when the file changes."
msgstr ""

#. type: samp{#1}
#: ../../../../../doc/lispref/compile.texi:281
#, no-wrap
msgid "#@@@var{count}"
msgstr ""

#. type: samp{#1}
#: ../../../../../doc/lispref/compile.texi:282
#, no-wrap
msgid "#$"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:290
msgid ""
"Internally, the dynamic loading of documentation strings is accomplished by "
"writing compiled files with a special Lisp reader construct, "
"@samp{#@@@var{count}}.  This construct skips the next @var{count} "
"characters.  It also uses the @samp{#$} construct, which stands for the name "
"of this file, as a string.  Do not use these constructs in Lisp source "
"files; they are not designed to be clear to humans reading the file."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/compile.texi:292
#, no-wrap
msgid "Dynamic Loading of Individual Functions"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:294
#, no-wrap
msgid "dynamic loading of functions"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:295
#, no-wrap
msgid "lazy loading"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:303
msgid ""
"When you compile a file, you can optionally enable the @dfn{dynamic function "
"loading} feature (also known as @dfn{lazy loading}).  With dynamic function "
"loading, loading the file doesn't fully read the function definitions in the "
"file.  Instead, each function definition contains a place-holder which "
"refers to the file.  The first time each function is called, it reads the "
"full definition from the file, to replace the place-holder."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:310
msgid ""
"The advantage of dynamic function loading is that loading the file should "
"become faster.  This is a good thing for a file which contains many separate "
"user-callable functions, if using one of them does not imply you will "
"probably also use the rest.  A specialized mode which provides many keyboard "
"commands often has that usage pattern: a user may invoke the mode, but use "
"only a few of the commands it provides."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:312
msgid "The dynamic loading feature has certain disadvantages:"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/compile.texi:317
msgid ""
"If you delete or move the compiled file after loading it, Emacs can no "
"longer load the remaining function definitions not already loaded."
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/compile.texi:322
msgid ""
"If you alter the compiled file (such as by compiling a new version), then "
"trying to load any function not already loaded will usually yield nonsense "
"results."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:328
msgid ""
"These problems will never happen in normal circumstances with installed "
"Emacs files.  But they are quite likely to happen with Lisp files that you "
"are changing.  The easiest way to prevent these problems is to reload the "
"new compiled file immediately after each recompilation."
msgstr ""

#. type: emph{#1}
#: ../../../../../doc/lispref/compile.texi:332
msgid ""
"Experience shows that using dynamic function loading provides benefits that "
"are hardly measurable, so this feature is deprecated since Emacs 27.1."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:339
msgid ""
"The byte compiler uses the dynamic function loading feature if the variable "
"@code{byte-compile-dynamic} is non-@code{nil} at compilation time.  Do not "
"set this variable globally, since dynamic loading is desirable only for "
"certain files.  Instead, enable the feature for specific source files with "
"file-local variable bindings.  For example, you could do it by writing this "
"text in the source file's first line:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/compile.texi:342
#, no-wrap
msgid "-*-byte-compile-dynamic: t;-*-\n"
msgstr ""

#. type: defvar
#: ../../../../../doc/lispref/compile.texi:344
#, no-wrap
msgid "byte-compile-dynamic"
msgstr ""

#. type: defvar
#: ../../../../../doc/lispref/compile.texi:347
msgid ""
"If this is non-@code{nil}, the byte compiler generates compiled files that "
"are set up for dynamic function loading."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/compile.texi:349
#, no-wrap
msgid "fetch-bytecode function"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/compile.texi:354
msgid ""
"If @var{function} is a byte-code function object, this immediately finishes "
"loading the byte code of @var{function} from its byte-compiled file, if it "
"is not fully loaded already.  Otherwise, it does nothing.  It always returns "
"@var{function}."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/compile.texi:357
#, no-wrap
msgid "Evaluation During Compilation"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:358
#, no-wrap
msgid "eval during compilation"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:362
msgid ""
"These features permit you to write code to be evaluated during compilation "
"of a program."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:363
#, no-wrap
msgid "eval-and-compile body@dots{}"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:366
msgid ""
"This form marks @var{body} to be evaluated both when you compile the "
"containing code and when you run it (whether compiled or not)."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:372
msgid ""
"You can get a similar result by putting @var{body} in a separate file and "
"referring to that file with @code{require}.  That method is preferable when "
"@var{body} is large.  Effectively @code{require} is automatically "
"@code{eval-and-compile}, the package is loaded both when compiling and "
"executing."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:376
msgid ""
"@code{autoload} is also effectively @code{eval-and-compile} too.  It's "
"recognized when compiling, so uses of such a function don't produce ``not "
"known to be defined'' warnings."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:378
msgid "Most uses of @code{eval-and-compile} are fairly sophisticated."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:383
msgid ""
"If a macro has a helper function to build its result, and that macro is used "
"both locally and outside the package, then @code{eval-and-compile} should be "
"used to get the helper both when compiling and then later when running."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:388
msgid ""
"If functions are defined programmatically (with @code{fset} say), then "
"@code{eval-and-compile} can be used to have that done at compile-time as "
"well as run-time, so calls to those functions are checked (and warnings "
"about ``not known to be defined'' suppressed)."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:390
#, no-wrap
msgid "eval-when-compile body@dots{}"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:396
msgid ""
"This form marks @var{body} to be evaluated at compile time but not when the "
"compiled program is loaded.  The result of evaluation by the compiler "
"becomes a constant which appears in the compiled program.  If you load the "
"source file, rather than compiling it, @var{body} is evaluated normally."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:397
#, no-wrap
msgid "compile-time constant"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:400
msgid ""
"If you have a constant that needs some calculation to produce, "
"@code{eval-when-compile} can do that at compile-time.  For example,"
msgstr ""

#. type: lisp
#: ../../../../../doc/lispref/compile.texi:404
#, no-wrap
msgid ""
"(defvar my-regexp\n"
"  (eval-when-compile (regexp-opt '(\"aaa\" \"aba\" \"abb\"))))\n"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:406
#, no-wrap
msgid "macros, at compile time"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:410
msgid ""
"If you're using another package, but only need macros from it (the byte "
"compiler will expand those), then @code{eval-when-compile} can be used to "
"load it for compiling, but not executing.  For example,"
msgstr ""

#. type: lisp
#: ../../../../../doc/lispref/compile.texi:414
#, no-wrap
msgid ""
"(eval-when-compile\n"
"  (require 'my-macro-package))\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:420
msgid ""
"The same sort of thing goes for macros and @code{defsubst} functions defined "
"locally and only for use within the file.  They are needed for compiling the "
"file, but in most cases they are not needed for execution of the compiled "
"file.  For example,"
msgstr ""

#. type: lisp
#: ../../../../../doc/lispref/compile.texi:426
#, no-wrap
msgid ""
"(eval-when-compile\n"
"  (unless (fboundp 'some-new-thing)\n"
"    (defmacro 'some-new-thing ()\n"
"      (compatibility code))))\n"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:431
msgid ""
"This is often good for code that's only a fallback for compatibility with "
"other versions of Emacs."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:436
msgid ""
"@strong{Common Lisp Note:} At top level, @code{eval-when-compile} is "
"analogous to the Common Lisp idiom @code{(eval-when (compile eval) "
"@dots{})}.  Elsewhere, the Common Lisp @samp{#.} reader macro (but not when "
"interpreting) is closer to what @code{eval-when-compile} does."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:440
#, no-wrap
msgid "compiler errors"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:441
#, no-wrap
msgid "byte-compiler errors"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:448
msgid ""
"Error and warning messages from byte compilation are printed in a buffer "
"named @file{*Compile-Log*}.  These messages include file names and line "
"numbers identifying the location of the problem.  The usual Emacs commands "
"for operating on compiler output can be used on these messages."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:457
msgid ""
"When an error is due to invalid syntax in the program, the byte compiler "
"might get confused about the error's exact location.  One way to investigate "
"is to switch to the buffer @w{@file{ *Compiler Input*}}.  (This buffer name "
"starts with a space, so it does not show up in the Buffer Menu.)  This "
"buffer contains the program being compiled, and point shows how far the byte "
"compiler was able to read; the cause of the error might be nearby.  "
"@xref{Syntax Errors}, for some tips for locating syntax errors."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:458
#, no-wrap
msgid "byte-compiler warnings"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:459
#, no-wrap
msgid "free variable, byte-compiler warning"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:460
#, no-wrap
msgid "reference to free variable, compilation warning"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:461
#, no-wrap
msgid "function not known to be defined, compilation warning"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:467
msgid ""
"A common type of warning issued by the byte compiler is for functions and "
"variables that were used but not defined.  Such warnings report the line "
"number for the end of the file, not the locations where the missing "
"functions or variables were used; to find these, you must search the file "
"manually."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:470
msgid ""
"If you are sure that a warning message about a missing function or variable "
"is unjustified, there are several ways to suppress it:"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/compile.texi:476
msgid ""
"You can suppress the warning for a specific call to a function @var{func} by "
"conditionalizing it on an @code{fboundp} test, like this:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/compile.texi:479
#, no-wrap
msgid "(if (fboundp '@var{func}) ...(@var{func} ...)...)\n"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/compile.texi:485
msgid ""
"The call to @var{func} must be in the @var{then-form} of the @code{if}, and "
"@var{func} must appear quoted in the call to @code{fboundp}.  (This feature "
"operates for @code{cond} as well.)"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/compile.texi:490
msgid ""
"Likewise, you can suppress the warning for a specific use of a variable "
"@var{variable} by conditionalizing it on a @code{boundp} test:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/compile.texi:493
#, no-wrap
msgid "(if (boundp '@var{variable}) ...@var{variable}...)\n"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/compile.texi:499
msgid ""
"The reference to @var{variable} must be in the @var{then-form} of the "
"@code{if}, and @var{variable} must appear quoted in the call to "
"@code{boundp}."
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/compile.texi:503
msgid ""
"You can tell the compiler that a function is defined using "
"@code{declare-function}.  @xref{Declaring Functions}."
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/compile.texi:510
msgid ""
"Likewise, you can tell the compiler that a variable is defined using "
"@code{defvar} with no initial value.  (Note that this marks the variable as "
"special, i.e.@: dynamically bound, but only within the current lexical "
"scope, or file if at top-level.)  @xref{Defining Variables}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:514
msgid ""
"You can also suppress compiler warnings within a certain expression using "
"the @code{with-suppressed-warnings} macro:"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:515
#, no-wrap
msgid "with-suppressed-warnings warnings body@dots{}"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:522
msgid ""
"In execution, this is equivalent to @code{(progn @var{body}...)}, but the "
"compiler does not issue warnings for the specified conditions in "
"@var{body}.  @var{warnings} is an associative list of warning symbols and "
"function/variable symbols they apply to.  For instance, if you wish to call "
"an obsolete function called @code{foo}, but want to suppress the compilation "
"warning, say:"
msgstr ""

#. type: lisp
#: ../../../../../doc/lispref/compile.texi:526
#, no-wrap
msgid ""
"(with-suppressed-warnings ((obsolete foo))\n"
"  (foo ...))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:531
msgid ""
"For more coarse-grained suppression of compiler warnings, you can use the "
"@code{with-no-warnings} construct:"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:535
#, no-wrap
msgid "with-no-warnings body@dots{}"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:539
msgid ""
"In execution, this is equivalent to @code{(progn @var{body}...)}, but the "
"compiler does not issue warnings for anything that occurs inside @var{body}."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/compile.texi:544
msgid ""
"We recommend that you use @code{with-suppressed-warnings} instead, but if "
"you do use this construct, that you use it around the smallest possible "
"piece of code to avoid missing possible warnings other than one you intend "
"to suppress."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:549
msgid ""
"Byte compiler warnings can be controlled more precisely by setting the "
"variable @code{byte-compile-warnings}.  See its documentation string for "
"details."
msgstr ""

#. type: vindex
#: ../../../../../doc/lispref/compile.texi:550
#, no-wrap
msgid "byte-compile-error-on-warn"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:554
msgid ""
"Sometimes you may wish the byte-compiler warnings to be reported using "
"@code{error}.  If so, set @code{byte-compile-error-on-warn} to a "
"non-@code{nil} value."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/compile.texi:556
#, no-wrap
msgid "Byte-Code Function Objects"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:557
#, no-wrap
msgid "compiled function"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:558
#, no-wrap
msgid "byte-code function"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:559
#, no-wrap
msgid "byte-code object"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:565
msgid ""
"Byte-compiled functions have a special data type: they are @dfn{byte-code "
"function objects}.  Whenever such an object appears as a function to be "
"called, Emacs uses the byte-code interpreter to execute the byte-code."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:572
msgid ""
"Internally, a byte-code function object is much like a vector; its elements "
"can be accessed using @code{aref}.  Its printed representation is like that "
"for a vector, with an additional @samp{#} before the opening @samp{[}.  It "
"must have at least four elements; there is no maximum number, but only the "
"first six elements have any normal use.  They are:"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/compile.texi:574
#, no-wrap
msgid "argdesc"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/compile.texi:582
msgid ""
"The descriptor of the arguments.  This can either be a list of arguments, as "
"described in @ref{Argument List}, or an integer encoding the required number "
"of arguments.  In the latter case, the value of the descriptor specifies the "
"minimum number of arguments in the bits zero to 6, and the maximum number of "
"arguments in bits 8 to 14.  If the argument list uses @code{&rest}, then bit "
"7 is set; otherwise it's cleared."
msgstr ""

#. type: table
#: ../../../../../doc/lispref/compile.texi:587
msgid ""
"If @var{argdesc} is a list, the arguments will be dynamically bound before "
"executing the byte code.  If @var{argdesc} is an integer, the arguments will "
"be instead pushed onto the stack of the byte-code interpreter, before "
"executing the code."
msgstr ""

#. type: table
#: ../../../../../doc/lispref/compile.texi:590
msgid "The string containing the byte-code instructions."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/compile.texi:591
#, no-wrap
msgid "constants"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/compile.texi:594
msgid ""
"The vector of Lisp objects referenced by the byte code.  These include "
"symbols used as function names and variable names."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/compile.texi:595
#, no-wrap
msgid "stacksize"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/compile.texi:597
msgid "The maximum stack size this function needs."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/compile.texi:598
#, no-wrap
msgid "docstring"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/compile.texi:603
msgid ""
"The documentation string (if any); otherwise, @code{nil}.  The value may be "
"a number or a list, in case the documentation string is stored in a file.  "
"Use the function @code{documentation} to get the real documentation string "
"(@pxref{Accessing Documentation})."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/compile.texi:604
#, no-wrap
msgid "interactive"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/compile.texi:607
msgid ""
"The interactive spec (if any).  This can be a string or a Lisp expression.  "
"It is @code{nil} for a function that isn't interactive."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:612
msgid ""
"Here's an example of a byte-code function object, in printed "
"representation.  It is the definition of the command @code{backward-sexp}."
msgstr ""

#. type: example
#: ../../../../../doc/lispref/compile.texi:620
#, no-wrap
msgid ""
"#[256\n"
"  \"\\211\\204^G^@@\\300\\262^A\\301^A[!\\207\"\n"
"  [1 forward-sexp]\n"
"  3\n"
"  1793299\n"
"  \"^p\"]\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:624
msgid ""
"The primitive way to create a byte-code object is with "
"@code{make-byte-code}:"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/compile.texi:625
#, no-wrap
msgid "make-byte-code &rest elements"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/compile.texi:628
msgid ""
"This function constructs and returns a byte-code function object with "
"@var{elements} as its elements."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:634
msgid ""
"You should not try to come up with the elements for a byte-code function "
"yourself, because if they are inconsistent, Emacs may crash when you call "
"the function.  Always leave it to the byte compiler to create these objects; "
"it makes the elements consistent (we hope)."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/compile.texi:636
#, no-wrap
msgid "Disassembled Byte-Code"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/compile.texi:637
#, no-wrap
msgid "disassembled byte-code"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:643
msgid ""
"People do not write byte-code; that job is left to the byte compiler.  But "
"we provide a disassembler to satisfy a cat-like curiosity.  The disassembler "
"converts the byte-compiled code into human-readable form."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:649
msgid ""
"The byte-code interpreter is implemented as a simple stack machine.  It "
"pushes values onto a stack of its own, then pops them off to use them in "
"calculations whose results are themselves pushed back on the stack.  When a "
"byte-code function returns, it pops a value off the stack and returns it as "
"the value of the function."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:653
msgid ""
"In addition to the stack, byte-code functions can use, bind, and set "
"ordinary Lisp variables, by transferring values between variables and the "
"stack."
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:654
#, no-wrap
msgid "Command disassemble object &optional buffer-or-name"
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:661
msgid ""
"This command displays the disassembled code for @var{object}.  In "
"interactive use, or if @var{buffer-or-name} is @code{nil} or omitted, the "
"output goes in a buffer named @file{*Disassemble*}.  If @var{buffer-or-name} "
"is non-@code{nil}, it must be a buffer or the name of an existing buffer.  "
"Then the output goes there, at point, and point is left before the output."
msgstr ""

#. type: deffn
#: ../../../../../doc/lispref/compile.texi:666
msgid ""
"The argument @var{object} can be a function name, a lambda expression "
"(@pxref{Lambda Expressions}), or a byte-code object (@pxref{Byte-Code "
"Objects}).  If it is a lambda expression, @code{disassemble} compiles it and "
"disassembles the resulting compiled code."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:671
msgid ""
"Here are two examples of using the @code{disassemble} function.  We have "
"added explanatory comments to help you relate the byte-code to the Lisp "
"source; these do not appear in the output of @code{disassemble}."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:679
#, no-wrap
msgid ""
"(defun factorial (integer)\n"
"  \"Compute factorial of an integer.\"\n"
"  (if (= 1 integer) 1\n"
"    (* integer (factorial (1- integer)))))\n"
"     @result{} factorial\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:684
#, no-wrap
msgid ""
"(factorial 4)\n"
"     @result{} 24\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:691
#, no-wrap
msgid ""
"(disassemble 'factorial)\n"
"     @print{} byte-code for factorial:\n"
" doc: Compute factorial of an integer.\n"
" args: (integer)\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:697
#, no-wrap
msgid ""
"0   varref   integer      ; @r{Get the value of @code{integer} and}\n"
"                          ;   @r{push it onto the stack.}\n"
"1   constant 1            ; @r{Push 1 onto stack.}\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:701
#, no-wrap
msgid ""
"2   eqlsign               ; @r{Pop top two values off stack, compare}\n"
"                          ;   @r{them, and push result onto stack.}\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:707
#, no-wrap
msgid ""
"3   goto-if-nil 1         ; @r{Pop and test top of stack;}\n"
"                          ;   @r{if @code{nil}, go to 1, else continue.}\n"
"6   constant 1            ; @r{Push 1 onto top of stack.}\n"
"7   return                ; @r{Return the top element of the stack.}\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:717
#, no-wrap
msgid ""
"8:1 varref   integer      ; @r{Push value of @code{integer} onto stack.}\n"
"9   constant factorial    ; @r{Push @code{factorial} onto stack.}\n"
"10  varref   integer      ; @r{Push value of @code{integer} onto stack.}\n"
"11  sub1                  ; @r{Pop @code{integer}, decrement value,}\n"
"                          ;   @r{push new value onto stack.}\n"
"12  call     1            ; @r{Call function @code{factorial} using first}\n"
"                          ;   @r{(i.e., top) stack element as argument;}\n"
"                          ;   @r{push returned value onto stack.}\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:722
#, no-wrap
msgid ""
"13 mult                   ; @r{Pop top two values off stack, multiply}\n"
"                          ;   @r{them, and push result onto stack.}\n"
"14 return                 ; @r{Return the top element of the stack.}\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/compile.texi:726
msgid "The @code{silly-loop} function is somewhat more complex:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:736
#, no-wrap
msgid ""
"(defun silly-loop (n)\n"
"  \"Return time before and after N iterations of a loop.\"\n"
"  (let ((t1 (current-time-string)))\n"
"    (while (> (setq n (1- n))\n"
"              0))\n"
"    (list t1 (current-time-string))))\n"
"     @result{} silly-loop\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:743
#, no-wrap
msgid ""
"(disassemble 'silly-loop)\n"
"     @print{} byte-code for silly-loop:\n"
" doc: Return time before and after N iterations of a loop.\n"
" args: (n)\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:748
#, no-wrap
msgid ""
"0   constant current-time-string  ; @r{Push @code{current-time-string}}\n"
"                                  ;   @r{onto top of stack.}\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:752
#, no-wrap
msgid ""
"1   call     0            ; @r{Call @code{current-time-string} with no}\n"
"                          ;   @r{argument, push result onto stack.}\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:755
#, no-wrap
msgid ""
"2   varbind  t1           ; @r{Pop stack and bind @code{t1} to popped "
"value.}\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:760
#, no-wrap
msgid ""
"3:1 varref   n            ; @r{Get value of @code{n} from the environment}\n"
"                          ;   @r{and push the value on the stack.}\n"
"4   sub1                  ; @r{Subtract 1 from top of stack.}\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:766
#, no-wrap
msgid ""
"5   dup                   ; @r{Duplicate top of stack; i.e., copy the top}\n"
"                          ;   @r{of the stack and push copy onto stack.}\n"
"6   varset   n            ; @r{Pop the top of the stack,}\n"
"                          ;   @r{and bind @code{n} to the value.}\n"
"\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:769
#, no-wrap
msgid ""
";; @r{(In effect, the sequence @code{dup varset} copies the top of the "
"stack}\n"
";; @r{into the value of @code{n} without popping it.)}\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:776
#, no-wrap
msgid ""
"7   constant 0            ; @r{Push 0 onto stack.}\n"
"8   gtr                   ; @r{Pop top two values off stack,}\n"
"                          ;   @r{test if @var{n} is greater than 0}\n"
"                          ;   @r{and push result onto stack.}\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:781
#, no-wrap
msgid ""
"9   goto-if-not-nil 1     ; @r{Goto 1 if @code{n} > 0}\n"
"                          ;   @r{(this continues the while loop)}\n"
"                          ;   @r{else continue.}\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:787
#, no-wrap
msgid ""
"12  varref   t1           ; @r{Push value of @code{t1} onto stack.}\n"
"13  constant current-time-string  ; @r{Push @code{current-time-string}}\n"
"                                  ;   @r{onto the top of the stack.}\n"
"14  call     0            ; @r{Call @code{current-time-string} again.}\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/compile.texi:793
#, no-wrap
msgid ""
"15  unbind   1            ; @r{Unbind @code{t1} in local environment.}\n"
"16  list2                 ; @r{Pop top two elements off stack, create a}\n"
"                          ;   @r{list of them, and push it onto stack.}\n"
"17  return                ; @r{Return value of the top of stack.}\n"
msgstr ""
