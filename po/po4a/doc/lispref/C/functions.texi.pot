# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-10-16 23:20+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: ../../../../../doc/lispref/functions.texi:6 ../../../../../doc/lispref/functions.texi:7
#, no-wrap
msgid "Functions"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:12
msgid ""
"A Lisp program is composed mainly of Lisp functions.  This chapter explains "
"what functions are, how they accept arguments, and how to define them."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:35
#, no-wrap
msgid "What Is a Function"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid "Lisp functions vs. primitives; terminology."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:220 ../../../../../doc/lispref/functions.texi:221
#, no-wrap
msgid "Lambda Expressions"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid "How functions are expressed as Lisp objects."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:520
#, no-wrap
msgid "Function Names"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid "A symbol can serve as the name of a function."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:575 ../../../../../doc/lispref/functions.texi:576
#, no-wrap
msgid "Defining Functions"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid "Lisp expressions for defining functions."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:690 ../../../../../doc/lispref/functions.texi:691
#, no-wrap
msgid "Calling Functions"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid "How to use an existing function."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:861 ../../../../../doc/lispref/functions.texi:862
#, no-wrap
msgid "Mapping Functions"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid "Applying a function to each element of a list, etc."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:982 ../../../../../doc/lispref/functions.texi:983
#, no-wrap
msgid "Anonymous Functions"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid "Lambda expressions are functions with no names."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:1096 ../../../../../doc/lispref/functions.texi:1097
#, no-wrap
msgid "Generic Functions"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid "Polymorphism, Emacs-style."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:1332
#, no-wrap
msgid "Function Cells"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid "Accessing or setting the function definition of a symbol."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:1436 ../../../../../doc/lispref/functions.texi:1437
#, no-wrap
msgid "Closures"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid "Functions that enclose a lexical environment."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:1474
#, no-wrap
msgid "Advising Functions"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid "Adding to the definition of a function."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:1986
#, no-wrap
msgid "Obsolete Functions"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid "Declaring functions obsolete."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:2066 ../../../../../doc/lispref/functions.texi:2067
#, no-wrap
msgid "Inline Functions"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid "Functions that the compiler will expand inline."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:2206
#, no-wrap
msgid "Declare Form"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid "Adding additional information about a function."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:2297
#, no-wrap
msgid "Declaring Functions"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid "Telling the compiler that a function is defined."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:2384
#, no-wrap
msgid "Function Safety"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid "Determining whether a function is safe to call."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/functions.texi:33 ../../../../../doc/lispref/functions.texi:2471
#, no-wrap
msgid "Related Topics"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:33
msgid ""
"Cross-references to specific Lisp primitives that have a special bearing on "
"how functions work."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:36
#, no-wrap
msgid "What Is a Function?"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:38
#, no-wrap
msgid "return value"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:39
#, no-wrap
msgid "value of function"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:40
#, no-wrap
msgid "argument"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:41
#, no-wrap
msgid "pure function"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:51
msgid ""
"In a general sense, a function is a rule for carrying out a computation "
"given input values called @dfn{arguments}.  The result of the computation is "
"called the @dfn{value} or @dfn{return value} of the function.  The "
"computation can also have side effects, such as lasting changes in the "
"values of variables or the contents of data structures (@pxref{Definition of "
"side effect}).  A @dfn{pure function} is a function which, in addition to "
"having no side effects, always returns the same value for the same "
"combination of arguments, regardless of external factors such as machine "
"type or system state."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:61
msgid ""
"In most computer languages, every function has a name.  But in Lisp, a "
"function in the strictest sense has no name: it is an object which can "
"@emph{optionally} be associated with a symbol (e.g., @code{car})  that "
"serves as the function name.  @xref{Function Names}.  When a function has "
"been given a name, we usually also refer to that symbol as a ``function'' "
"(e.g., we refer to ``the function @code{car}'').  In this manual, the "
"distinction between a function name and the function object itself is "
"usually unimportant, but we will take note wherever it is relevant."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:66
msgid ""
"Certain function-like objects, called @dfn{special forms} and @dfn{macros}, "
"also accept arguments to carry out computations.  However, as explained "
"below, these are not considered functions in Emacs Lisp."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:68
msgid "Here are important terms for functions and function-like objects:"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:70 ../../../../../doc/lispref/functions.texi:222
#, no-wrap
msgid "lambda expression"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:73
msgid ""
"A function (in the strict sense, i.e., a function object) which is written "
"in Lisp.  These are described in the following section."
msgstr ""

#. type: ifnottex
#: ../../../../../doc/lispref/functions.texi:75
msgid "@xref{Lambda Expressions}."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:77 ../../../../../doc/lispref/functions.texi:78
#, no-wrap
msgid "primitive"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:79 ../../../../../doc/lispref/functions.texi:1240
#, no-wrap
msgid "subr"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:80
#, no-wrap
msgid "built-in function"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:86
msgid ""
"A function which is callable from Lisp but is actually written in C@.  "
"Primitives are also called @dfn{built-in functions}, or @dfn{subrs}.  "
"Examples include functions like @code{car} and @code{append}.  In addition, "
"all special forms (see below) are also considered primitives."
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:93
msgid ""
"Usually, a function is implemented as a primitive because it is a "
"fundamental part of Lisp (e.g., @code{car}), or because it provides a "
"low-level interface to operating system services, or because it needs to run "
"fast.  Unlike functions defined in Lisp, primitives can be modified or added "
"only by changing the C sources and recompiling Emacs.  See @ref{Writing "
"Emacs Primitives}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:94
#, no-wrap
msgid "special form"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:100
msgid ""
"A primitive that is like a function but does not evaluate all of its "
"arguments in the usual way.  It may evaluate only some of the arguments, or "
"may evaluate them in an unusual order, or several times.  Examples include "
"@code{if}, @code{and}, and @code{while}.  @xref{Special Forms}."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:101 ../../../../../doc/lispref/functions.texi:102
#, no-wrap
msgid "macro"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:108
msgid ""
"A construct defined in Lisp, which differs from a function in that it "
"translates a Lisp expression into another expression which is to be "
"evaluated instead of the original expression.  Macros enable Lisp "
"programmers to do the sorts of things that special forms can do.  "
"@xref{Macros}."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:109 ../../../../../doc/lispref/functions.texi:110
#, no-wrap
msgid "command"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:118
msgid ""
"An object which can be invoked via the @code{command-execute} primitive, "
"usually due to the user typing in a key sequence @dfn{bound} to that "
"command.  @xref{Interactive Call}.  A command is usually a function; if the "
"function is written in Lisp, it is made into a command by an "
"@code{interactive} form in the function definition (@pxref{Defining "
"Commands}).  Commands that are functions can also be called from Lisp "
"expressions, just like other functions."
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:124
msgid ""
"Keyboard macros (strings and vectors) are commands also, even though they "
"are not functions.  @xref{Keyboard Macros}.  We say that a symbol is a "
"command if its function cell contains a command (@pxref{Symbol Components}); "
"such a @dfn{named command} can be invoked with @kbd{M-x}."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:125 ../../../../../doc/lispref/functions.texi:1447
#, no-wrap
msgid "closure"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:129
msgid ""
"A function object that is much like a lambda expression, except that it also "
"encloses an environment of lexical variable bindings.  @xref{Closures}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:130
#, no-wrap
msgid "byte-code function"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:133
msgid ""
"A function that has been compiled by the byte compiler.  @xref{Byte-Code "
"Type}."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:134 ../../../../../doc/lispref/functions.texi:135
#, no-wrap
msgid "autoload object"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:139
msgid ""
"A place-holder for a real function.  If the autoload object is called, Emacs "
"loads the file containing the definition of the real function, and then "
"calls the real function.  @xref{Autoload}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:143
msgid ""
"You can use the function @code{functionp} to test if an object is a "
"function:"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:144
#, no-wrap
msgid "functionp object"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:149
msgid ""
"This function returns @code{t} if @var{object} is any kind of function, "
"i.e., can be passed to @code{funcall}.  Note that @code{functionp} returns "
"@code{t} for symbols that are function names, and returns @code{nil} for "
"special forms."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:153
msgid ""
"It is also possible to find out how many arguments an arbitrary function "
"expects:"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:154
#, no-wrap
msgid "func-arity function"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:162
msgid ""
"This function provides information about the argument list of the specified "
"@var{function}.  The returned value is a cons cell of the form "
"@w{@code{(@var{min} . @var{max})}}, where @var{min} is the minimum number of "
"arguments, and @var{max} is either the maximum number of arguments, or the "
"symbol @code{many} for functions with @code{&rest} arguments, or the symbol "
"@code{unevalled} if @var{function} is a special form."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:165
msgid ""
"Note that this function might return inaccurate results in some situations, "
"such as the following:"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:170
msgid ""
"Functions defined using @code{apply-partially} (@pxref{Calling Functions, "
"apply-partially})."
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:174
msgid ""
"Functions that are advised using @code{advice-add} (@pxref{Advising Named "
"Functions})."
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:178
msgid ""
"Functions that determine the argument list dynamically, as part of their "
"code."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:185
msgid ""
"Unlike @code{functionp}, the next three functions do @emph{not} treat a "
"symbol as its function definition."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:186
#, no-wrap
msgid "subrp object"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:189
msgid ""
"This function returns @code{t} if @var{object} is a built-in function (i.e., "
"a Lisp primitive)."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:194
#, no-wrap
msgid ""
"(subrp 'message)            ; @r{@code{message} is a symbol,}\n"
"     @result{} nil                 ;   @r{not a subr object.}\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:198
#, no-wrap
msgid ""
"(subrp (symbol-function 'message))\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:202
#, no-wrap
msgid "byte-code-function-p object"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:205
msgid ""
"This function returns @code{t} if @var{object} is a byte-code function.  For "
"example:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:210
#, no-wrap
msgid ""
"(byte-code-function-p (symbol-function 'next-line))\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:214
#, no-wrap
msgid "subr-arity subr"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:218
msgid ""
"This works like @code{func-arity}, but only for built-in functions and "
"without symbol indirection.  It signals an error for non-built-in "
"functions.  We recommend to use @code{func-arity} instead."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:226
msgid ""
"A lambda expression is a function object written in Lisp.  Here is an "
"example:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:231
#, no-wrap
msgid ""
"(lambda (x)\n"
"  \"Return the hyperbolic cosine of X.\"\n"
"  (* 0.5 (+ (exp x) (exp (- x)))))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:236
msgid ""
"In Emacs Lisp, such a list is a valid expression which evaluates to a "
"function object."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:243
msgid ""
"A lambda expression, by itself, has no name; it is an @dfn{anonymous "
"function}.  Although lambda expressions can be used this way "
"(@pxref{Anonymous Functions}), they are more commonly associated with "
"symbols to make @dfn{named functions} (@pxref{Function Names}).  Before "
"going into these details, the following subsections describe the components "
"of a lambda expression and what they do."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/functions.texi:249 ../../../../../doc/lispref/functions.texi:251
#, no-wrap
msgid "Lambda Components"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:249
msgid "The parts of a lambda expression."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/functions.texi:249 ../../../../../doc/lispref/functions.texi:295
#, no-wrap
msgid "Simple Lambda"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:249
msgid "A simple example."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/functions.texi:249 ../../../../../doc/lispref/functions.texi:345
#, no-wrap
msgid "Argument List"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:249
msgid "Details and special features of argument lists."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/functions.texi:249 ../../../../../doc/lispref/functions.texi:455
#, no-wrap
msgid "Function Documentation"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:249
msgid "How to put documentation in a function."
msgstr ""

#. type: subsection
#: ../../../../../doc/lispref/functions.texi:252
#, no-wrap
msgid "Components of a Lambda Expression"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:255
msgid "A lambda expression is a list that looks like this:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:261
#, no-wrap
msgid ""
"(lambda (@var{arg-variables}@dots{})\n"
"  [@var{documentation-string}]\n"
"  [@var{interactive-declaration}]\n"
"  @var{body-forms}@dots{})\n"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:263
#, no-wrap
msgid "lambda list"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:269
msgid ""
"The first element of a lambda expression is always the symbol "
"@code{lambda}.  This indicates that the list represents a function.  The "
"reason functions are defined to start with @code{lambda} is so that other "
"lists, intended for other uses, will not accidentally be valid as functions."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:276
msgid ""
"The second element is a list of symbols---the argument variable names "
"(@pxref{Argument List}).  This is called the @dfn{lambda list}.  When a Lisp "
"function is called, the argument values are matched up against the variables "
"in the lambda list, which are given local bindings with the values "
"provided.  @xref{Local Variables}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:280
msgid ""
"The documentation string is a Lisp string object placed within the function "
"definition to describe the function for the Emacs help facilities.  "
"@xref{Function Documentation}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:288
msgid ""
"The interactive declaration is a list of the form @code{(interactive "
"@var{code-string})}.  This declares how to provide arguments if the function "
"is used interactively.  Functions with this declaration are called "
"@dfn{commands}; they can be called using @kbd{M-x} or bound to a key.  "
"Functions not intended to be called in this way should not have interactive "
"declarations.  @xref{Defining Commands}, for how to write an interactive "
"declaration."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:289
#, no-wrap
msgid "body of function"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:294
msgid ""
"The rest of the elements are the @dfn{body} of the function: the Lisp code "
"to do the work of the function (or, as a Lisp programmer would say, ``a list "
"of Lisp forms to evaluate'').  The value returned by the function is the "
"value returned by the last element of the body."
msgstr ""

#. type: subsection
#: ../../../../../doc/lispref/functions.texi:296
#, no-wrap
msgid "A Simple Lambda Expression Example"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:299
msgid "Consider the following example:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:302
#, no-wrap
msgid "(lambda (a b c) (+ a b c))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:306
msgid "We can call this function by passing it to @code{funcall}, like this:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:311
#, no-wrap
msgid ""
"(funcall (lambda (a b c) (+ a b c))\n"
"         1 2 3)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:319
msgid ""
"This call evaluates the body of the lambda expression with the variable "
"@code{a} bound to 1, @code{b} bound to 2, and @code{c} bound to 3.  "
"Evaluation of the body adds these three numbers, producing the result 6; "
"therefore, this call to the function returns the value 6."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:322
msgid ""
"Note that the arguments can be the results of other function calls, as in "
"this example:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:327
#, no-wrap
msgid ""
"(funcall (lambda (a b c) (+ a b c))\n"
"         1 (* 2 3) (- 5 4))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:334
msgid ""
"This evaluates the arguments @code{1}, @code{(* 2 3)}, and @code{(- 5 4)} "
"from left to right.  Then it applies the lambda expression to the argument "
"values 1, 6 and 1 to produce the value 8."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:344
msgid ""
"As these examples show, you can use a form with a lambda expression as its "
"@sc{car} to make local variables and give them values.  In the old days of "
"Lisp, this technique was the only way to bind and initialize local "
"variables.  But nowadays, it is clearer to use the special form @code{let} "
"for this purpose (@pxref{Local Variables}).  Lambda expressions are mainly "
"used as anonymous functions for passing as arguments to other functions "
"(@pxref{Anonymous Functions}), or stored as symbol function definitions to "
"produce named functions (@pxref{Function Names})."
msgstr ""

#. type: subsection
#: ../../../../../doc/lispref/functions.texi:346
#, no-wrap
msgid "Features of Argument Lists"
msgstr ""

#. type: kindex
#: ../../../../../doc/lispref/functions.texi:347
#, no-wrap
msgid "wrong-number-of-arguments"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:348
#, no-wrap
msgid "argument binding"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:349
#, no-wrap
msgid "binding arguments"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:350
#, no-wrap
msgid "argument lists, features"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:357
msgid ""
"Our simple sample function, @code{(lambda (a b c) (+ a b c))}, specifies "
"three argument variables, so it must be called with three arguments: if you "
"try to call it with only two arguments or four arguments, you get a "
"@code{wrong-number-of-arguments} error (@pxref{Errors})."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:365
msgid ""
"It is often convenient to write a function that allows certain arguments to "
"be omitted.  For example, the function @code{substring} accepts three "
"arguments---a string, the start index and the end index---but the third "
"argument defaults to the @var{length} of the string if you omit it.  It is "
"also convenient for certain functions to accept an indefinite number of "
"arguments, as the functions @code{list} and @code{+} do."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:366
#, no-wrap
msgid "optional arguments"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:367
#, no-wrap
msgid "rest arguments"
msgstr ""

#. type: kindex
#: ../../../../../doc/lispref/functions.texi:368
#, no-wrap
msgid "&optional"
msgstr ""

#. type: kindex
#: ../../../../../doc/lispref/functions.texi:369
#, no-wrap
msgid "&rest"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:374
msgid ""
"To specify optional arguments that may be omitted when a function is called, "
"simply include the keyword @code{&optional} before the optional arguments.  "
"To specify a list of zero or more extra arguments, include the keyword "
"@code{&rest} before one final argument."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:376
msgid "Thus, the complete syntax for an argument list is as follows:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:382
#, no-wrap
msgid ""
"(@var{required-vars}@dots{}\n"
" @r{[}&optional @r{[}@var{optional-vars}@dots{}@r{]}@r{]}\n"
" @r{[}&rest @r{[}@var{rest-var}@r{]}@r{]})\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:388
msgid ""
"The square brackets indicate that the @code{&optional} and @code{&rest} "
"clauses, and the variables that follow them, are optional."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:394
msgid ""
"A call to the function requires one actual argument for each of the "
"@var{required-vars}.  There may be actual arguments for zero or more of the "
"@var{optional-vars}, and there cannot be any actual arguments beyond that "
"unless the lambda list uses @code{&rest}.  In that case, there may be any "
"number of extra actual arguments."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:402
msgid ""
"If actual arguments for the optional and rest variables are omitted, then "
"they always default to @code{nil}.  There is no way for the function to "
"distinguish between an explicit argument of @code{nil} and an omitted "
"argument.  However, the body of the function is free to consider @code{nil} "
"an abbreviation for some other meaningful value.  This is what "
"@code{substring} does; @code{nil} as the third argument to @code{substring} "
"means to use the length of the string supplied."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:403
#, no-wrap
msgid "CL note---default optional arg"
msgstr ""

#. type: quotation
#: ../../../../../doc/lispref/functions.texi:409
msgid ""
"@b{Common Lisp note:} Common Lisp allows the function to specify what "
"default value to use when an optional argument is omitted; Emacs Lisp always "
"uses @code{nil}.  Emacs Lisp does not support @code{supplied-p} variables "
"that tell you whether an argument was explicitly passed."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:412
msgid "For example, an argument list that looks like this:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:415
#, no-wrap
msgid "(a b &optional c d &rest e)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:429
msgid ""
"binds @code{a} and @code{b} to the first two actual arguments, which are "
"required.  If one or two more arguments are provided, @code{c} and @code{d} "
"are bound to them respectively; any arguments after the first four are "
"collected into a list and @code{e} is bound to that list.  Thus, if there "
"are only two arguments, @code{c}, @code{d} and @code{e} are @code{nil}; if "
"two or three arguments, @code{d} and @code{e} are @code{nil}; if four "
"arguments or fewer, @code{e} is @code{nil}.  Note that exactly five "
"arguments with an explicit @code{nil} argument provided for @code{e} will "
"cause that @code{nil} argument to be passed as a list with one element, "
"@code{(nil)}, as with any other single value for @code{e}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:438
msgid ""
"There is no way to have required arguments following optional ones---it "
"would not make sense.  To see why this must be so, suppose that @code{c} in "
"the example were optional and @code{d} were required.  Suppose three actual "
"arguments are given; which variable would the third argument be for? Would "
"it be used for the @var{c}, or for @var{d}? One can argue for both "
"possibilities.  Similarly, it makes no sense to have any more arguments "
"(either required or optional)  after a @code{&rest} argument."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:440
msgid "Here are some examples of argument lists and proper calls:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:453
#, no-wrap
msgid ""
"(funcall (lambda (n) (1+ n))        ; @r{One required:}\n"
"         1)                         ; @r{requires exactly one argument.}\n"
"     @result{} 2\n"
"(funcall (lambda (n &optional n1)   ; @r{One required and one optional:}\n"
"           (if n1 (+ n n1) (1+ n))) ; @r{1 or 2 arguments.}\n"
"         1 2)\n"
"     @result{} 3\n"
"(funcall (lambda (n &rest ns)       ; @r{One required and one rest:}\n"
"           (+ n (apply '+ ns)))     ; @r{1 or more arguments.}\n"
"         1 2 3 4 5)\n"
"     @result{} 15\n"
msgstr ""

#. type: subsection
#: ../../../../../doc/lispref/functions.texi:456
#, no-wrap
msgid "Documentation Strings of Functions"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:457
#, no-wrap
msgid "documentation string of function"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:458
#, no-wrap
msgid "function's documentation string"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:466
msgid ""
"A lambda expression may optionally have a @dfn{documentation string} just "
"after the lambda list.  This string does not affect execution of the "
"function; it is a kind of comment, but a systematized comment which actually "
"appears inside the Lisp world and can be used by the Emacs help facilities.  "
"@xref{Documentation}, for how the documentation string is accessed."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:471
msgid ""
"It is a good idea to provide documentation strings for all the functions in "
"your program, even those that are called only from within your program.  "
"Documentation strings are like comments, except that they are easier to "
"access."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:475
msgid ""
"The first line of the documentation string should stand on its own, because "
"@code{apropos} displays just this first line.  It should consist of one or "
"two complete sentences that summarize the function's purpose."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:484
msgid ""
"The start of the documentation string is usually indented in the source "
"file, but since these spaces come before the starting double-quote, they are "
"not part of the string.  Some people make a practice of indenting any "
"additional lines of the string so that the text lines up in the program "
"source.  @emph{That is a mistake.} The indentation of the following lines is "
"inside the string; what looks nice in the source code will look ugly when "
"displayed by the help commands."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:492
msgid ""
"You may wonder how the documentation string could be optional, since there "
"are required components of the function that follow it (the body).  Since "
"evaluation of a string returns that string, without any side effects, it has "
"no effect if it is not the last form in the body.  Thus, in practice, there "
"is no confusion between the first form of the body and the documentation "
"string; if the only body form is a string then it serves both as the return "
"value and as the documentation."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:496
msgid ""
"The last line of the documentation string can specify calling conventions "
"different from the actual function arguments.  Write text like this:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:499
#, no-wrap
msgid "\\(fn @var{arglist})\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:507
msgid ""
"following a blank line, at the beginning of the line, with no newline "
"following it inside the documentation string.  (The @samp{\\} is used to "
"avoid confusing the Emacs motion commands.)  The calling convention "
"specified in this way appears in help messages in place of the one derived "
"from the actual arguments of the function."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:511
msgid ""
"This feature is particularly useful for macro definitions, since the "
"arguments written in a macro definition often do not correspond to the way "
"users think of the parts of the macro call."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:519
msgid ""
"Do not use this feature if you want to deprecate the calling convention and "
"favor the one you advertise by the above specification.  Instead, use the "
"@code{advertised-calling-convention} declaration (@pxref{Declare Form}) or "
"@code{set-advertised-calling-convention} (@pxref{Obsolete Functions}), "
"because these two will cause the byte compiler emit a warning message when "
"it compiles Lisp programs which use the deprecated calling convention."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:521
#, no-wrap
msgid "Naming a Function"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:522
#, no-wrap
msgid "function definition"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:523
#, no-wrap
msgid "named function"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:524
#, no-wrap
msgid "function name"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:531
msgid ""
"A symbol can serve as the name of a function.  This happens when the "
"symbol's @dfn{function cell} (@pxref{Symbol Components}) contains a function "
"object (e.g., a lambda expression).  Then the symbol itself becomes a valid, "
"callable function, equivalent to the function object in its function cell."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:538
msgid ""
"The contents of the function cell are also called the symbol's @dfn{function "
"definition}.  The procedure of using a symbol's function definition in place "
"of the symbol is called @dfn{symbol function indirection}; see @ref{Function "
"Indirection}.  If you have not given a symbol a function definition, its "
"function cell is said to be @dfn{void}, and it cannot be used as a function."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:544
msgid ""
"In practice, nearly all functions have names, and are referred to by their "
"names.  You can create a named Lisp function by defining a lambda expression "
"and putting it in a function cell (@pxref{Function Cells}).  However, it is "
"more common to use the @code{defun} special form, described in the next "
"section."
msgstr ""

#. type: ifnottex
#: ../../../../../doc/lispref/functions.texi:546
msgid "@xref{Defining Functions}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:554
msgid ""
"We give functions names because it is convenient to refer to them by their "
"names in Lisp expressions.  Also, a named Lisp function can easily refer to "
"itself---it can be recursive.  Furthermore, primitives can only be referred "
"to textually by their names, since primitive function objects "
"(@pxref{Primitive Function Type}) have no read syntax."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:560
msgid ""
"A function need not have a unique name.  A given function object "
"@emph{usually} appears in the function cell of only one symbol, but this is "
"just a convention.  It is easy to store it in several symbols using "
"@code{fset}; then each of the symbols is a valid name for the same function."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:565
msgid ""
"Note that a symbol used as a function name may also be used as a variable; "
"these two uses of a symbol are independent and do not conflict.  (This is "
"not the case in some dialects of Lisp, like Scheme.)"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:574
msgid ""
"By convention, if a function's symbol consists of two names separated by "
"@samp{--}, the function is intended for internal use and the first part "
"names the file defining the function.  For example, a function named "
"@code{vc-git--rev-parse} is an internal function defined in "
"@file{vc-git.el}.  Internal-use functions written in C have names ending in "
"@samp{-internal}, e.g., @code{bury-buffer-internal}.  Emacs code contributed "
"before 2018 may follow other internal-use naming conventions, which are "
"being phased out."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:577
#, no-wrap
msgid "defining a function"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:583
msgid ""
"We usually give a name to a function when it is first created.  This is "
"called @dfn{defining a function}, and we usually do it with the @code{defun} "
"macro.  This section also describes other ways to define a function."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:584
#, no-wrap
msgid "defun name args [doc] [declare] [interactive] body@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:589
msgid ""
"@code{defun} is the usual way to define new Lisp functions.  It defines the "
"symbol @var{name} as a function with argument list @var{args} "
"(@pxref{Argument List}) and body forms given by @var{body}.  Neither "
"@var{name} nor @var{args} should be quoted."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:596
msgid ""
"@var{doc}, if present, should be a string specifying the function's "
"documentation string (@pxref{Function Documentation}).  @var{declare}, if "
"present, should be a @code{declare} form specifying function metadata "
"(@pxref{Declare Form}).  @var{interactive}, if present, should be an "
"@code{interactive} form specifying how the function is to be called "
"interactively (@pxref{Interactive Call})."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:598
msgid "The return value of @code{defun} is undefined."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:600
msgid "Here are some examples:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:606
#, no-wrap
msgid ""
"(defun foo () 5)\n"
"(foo)\n"
"     @result{} 5\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:613
#, no-wrap
msgid ""
"(defun bar (a &optional b &rest c)\n"
"    (list a b c))\n"
"(bar 1 2 3 4 5)\n"
"     @result{} (1 2 (3 4 5))\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:617
#, no-wrap
msgid ""
"(bar 1)\n"
"     @result{} (1 nil nil)\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:621
#, no-wrap
msgid ""
"(bar)\n"
"@error{} Wrong number of arguments.\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:631
#, no-wrap
msgid ""
"(defun capitalize-backwards ()\n"
"  \"Upcase the last letter of the word at point.\"\n"
"  (interactive)\n"
"  (backward-word 1)\n"
"  (forward-word 1)\n"
"  (backward-char 1)\n"
"  (capitalize-word 1))\n"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:634
#, no-wrap
msgid "override existing functions"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:635
#, no-wrap
msgid "redefine existing functions"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:642
msgid ""
"Be careful not to redefine existing functions unintentionally.  @code{defun} "
"redefines even primitive functions such as @code{car} without any hesitation "
"or notification.  Emacs does not prevent you from doing this, because "
"redefining a function is sometimes done deliberately, and there is no way to "
"distinguish deliberate redefinition from unintentional redefinition."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:644
#, no-wrap
msgid "function aliases"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:645
#, no-wrap
msgid "alias, for functions"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:646
#, no-wrap
msgid "defalias name definition &optional doc"
msgstr ""

#. type: anchor{#1}
#: ../../../../../doc/lispref/functions.texi:651
msgid "Definition of defalias"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:651
msgid ""
"This function defines the symbol @var{name} as a function, with definition "
"@var{definition} (which can be any valid Lisp function).  Its return value "
"is @emph{undefined}."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:655
msgid ""
"If @var{doc} is non-@code{nil}, it becomes the function documentation of "
"@var{name}.  Otherwise, any documentation provided by @var{definition} is "
"used."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:656
#, no-wrap
msgid "defalias-fset-function property"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:660
msgid ""
"Internally, @code{defalias} normally uses @code{fset} to set the "
"definition.  If @var{name} has a @code{defalias-fset-function} property, "
"however, the associated value is used as a function to call in place of "
"@code{fset}."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:666
msgid ""
"The proper place to use @code{defalias} is where a specific function name is "
"being defined---especially where that name appears explicitly in the source "
"file being loaded.  This is because @code{defalias} records which file "
"defined the function, just like @code{defun} (@pxref{Unloading})."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:670
msgid ""
"By contrast, in programs that manipulate function definitions for other "
"purposes, it is better to use @code{fset}, which does not keep such "
"records.  @xref{Function Cells}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:682
msgid ""
"You cannot create a new primitive function with @code{defun} or "
"@code{defalias}, but you can use them to change the function definition of "
"any symbol, even one such as @code{car} or @code{x-popup-menu} whose normal "
"definition is a primitive.  However, this is risky: for instance, it is next "
"to impossible to redefine @code{car} without breaking Lisp completely.  "
"Redefining an obscure function such as @code{x-popup-menu} is less "
"dangerous, but it still may not work as you expect.  If there are calls to "
"the primitive from C code, they call the primitive's C definition directly, "
"so changing the symbol's definition will have no effect on them."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:686
msgid ""
"See also @code{defsubst}, which defines a function like @code{defun} and "
"tells the Lisp compiler to perform inline expansion on it.  @xref{Inline "
"Functions}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:689
msgid "To undefine a function name, use @code{fmakunbound}.  @xref{Function Cells}."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:692
#, no-wrap
msgid "function invocation"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:693
#, no-wrap
msgid "calling a function"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:698
msgid ""
"Defining functions is only half the battle.  Functions don't do anything "
"until you @dfn{call} them, i.e., tell them to run.  Calling a function is "
"also known as @dfn{invocation}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:703
msgid ""
"The most common way of invoking a function is by evaluating a list.  For "
"example, evaluating the list @code{(concat \"a\" \"b\")} calls the function "
"@code{concat} with arguments @code{\"a\"} and @code{\"b\"}.  "
"@xref{Evaluation}, for a description of evaluation."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:710
msgid ""
"When you write a list as an expression in your program, you specify which "
"function to call, and how many arguments to give it, in the text of the "
"program.  Usually that's just what you want.  Occasionally you need to "
"compute at run time which function to call.  To do that, use the function "
"@code{funcall}.  When you also need to determine at run time how many "
"arguments to pass, use @code{apply}."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:711
#, no-wrap
msgid "funcall function &rest arguments"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:714
msgid ""
"@code{funcall} calls @var{function} with @var{arguments}, and returns "
"whatever @var{function} returns."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:724
msgid ""
"Since @code{funcall} is a function, all of its arguments, including "
"@var{function}, are evaluated before @code{funcall} is called.  This means "
"that you can use any expression to obtain the function to be called.  It "
"also means that @code{funcall} does not see the expressions you write for "
"the @var{arguments}, only their values.  These values are @emph{not} "
"evaluated a second time in the act of calling @var{function}; the operation "
"of @code{funcall} is like the normal procedure for calling a function, once "
"its arguments have already been evaluated."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:730
msgid ""
"The argument @var{function} must be either a Lisp function or a primitive "
"function.  Special forms and macros are not allowed, because they make sense "
"only when given the unevaluated argument expressions.  @code{funcall} cannot "
"provide these because, as we saw above, it never knows them in the first "
"place."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:734
msgid ""
"If you need to use @code{funcall} to call a command and make it behave as if "
"invoked interactively, use @code{funcall-interactively} (@pxref{Interactive "
"Call})."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:739 ../../../../../doc/lispref/functions.texi:774
#, no-wrap
msgid ""
"(setq f 'list)\n"
"     @result{} list\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:743
#, no-wrap
msgid ""
"(funcall f 'x 'y 'z)\n"
"     @result{} (x y z)\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:747
#, no-wrap
msgid ""
"(funcall f 'x 'y '(z))\n"
"     @result{} (x y (z))\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:751
#, no-wrap
msgid ""
"(funcall 'and t nil)\n"
"@error{} Invalid function: #<subr and>\n"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:755
msgid "Compare these examples with the examples of @code{apply}."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:757
#, no-wrap
msgid "apply function &rest arguments"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:764
msgid ""
"@code{apply} calls @var{function} with @var{arguments}, just like "
"@code{funcall} but with one difference: the last of @var{arguments} is a "
"list of objects, which are passed to @var{function} as separate arguments, "
"rather than a single list.  We say that @code{apply} @dfn{spreads} this list "
"so that each individual element becomes an argument."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:769
msgid ""
"@code{apply} returns the result of calling @var{function}.  As with "
"@code{funcall}, @var{function} must either be a Lisp function or a primitive "
"function; special forms and macros do not make sense in @code{apply}."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:778
#, no-wrap
msgid ""
"(apply f 'x 'y 'z)\n"
"@error{} Wrong type argument: listp, z\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:782
#, no-wrap
msgid ""
"(apply '+ 1 2 '(3 4))\n"
"     @result{} 10\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:786
#, no-wrap
msgid ""
"(apply '+ '(1 2 3 4))\n"
"     @result{} 10\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:791
#, no-wrap
msgid ""
"(apply 'append '((a b c) nil (x y z) nil))\n"
"     @result{} (a b c x y z)\n"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:796
msgid ""
"For an interesting example of using @code{apply}, see @ref{Definition of "
"mapcar}."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:798
#, no-wrap
msgid "partial application of functions"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:799
#, no-wrap
msgid "currying"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:811
msgid ""
"Sometimes it is useful to fix some of the function's arguments at certain "
"values, and leave the rest of arguments for when the function is actually "
"called.  The act of fixing some of the function's arguments is called "
"@dfn{partial application} of the function@footnote{ This is related to, but "
"different from @dfn{currying}, which transforms a function that takes "
"multiple arguments in such a way that it can be called as a chain of "
"functions, each one with a single argument.}.  The result is a new function "
"that accepts the rest of arguments and calls the original function with all "
"the arguments combined."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:813
msgid "Here's how to do partial application in Emacs Lisp:"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:814
#, no-wrap
msgid "apply-partially func &rest args"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:821
msgid ""
"This function returns a new function which, when called, will call "
"@var{func} with the list of arguments composed from @var{args} and "
"additional arguments specified at the time of the call.  If @var{func} "
"accepts @var{n} arguments, then a call to @code{apply-partially} with "
"@w{@code{@var{m} < @var{n}}} arguments will produce a new function of "
"@w{@code{@var{n} - @var{m}}} arguments."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:825
msgid ""
"Here's how we could define the built-in function @code{1+}, if it didn't "
"exist, using @code{apply-partially} and @code{+}, another built-in function:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:830
#, no-wrap
msgid ""
"(defalias '1+ (apply-partially '+ 1)\n"
"  \"Increment argument by one.\")\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:834
#, no-wrap
msgid ""
"(1+ 10)\n"
"     @result{} 11\n"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:838
#, no-wrap
msgid "functionals"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:843
msgid ""
"It is common for Lisp functions to accept functions as arguments or find "
"them in data structures (especially in hook variables and property lists) "
"and call them using @code{funcall} or @code{apply}.  Functions that accept "
"function arguments are often called @dfn{functionals}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:847
msgid ""
"Sometimes, when you call a functional, it is useful to supply a no-op "
"function as the argument.  Here are two different kinds of no-op function:"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:848
#, no-wrap
msgid "identity argument"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:850
msgid "This function returns @var{argument} and has no side effects."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:852
#, no-wrap
msgid "ignore &rest arguments"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:854
msgid "This function ignores any @var{arguments} and returns @code{nil}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:860
msgid ""
"Some functions are user-visible @dfn{commands}, which can be called "
"interactively (usually by a key sequence).  It is possible to invoke such a "
"command exactly as though it was called interactively, by using the "
"@code{call-interactively} function.  @xref{Interactive Call}."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:863
#, no-wrap
msgid "mapping functions"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:873
msgid ""
"A @dfn{mapping function} applies a given function (@emph{not} a special form "
"or macro) to each element of a list or other collection.  Emacs Lisp has "
"several such functions; this section describes @code{mapcar}, @code{mapc}, "
"@code{mapconcat}, and @code{mapcan}, which map over a list.  "
"@xref{Definition of mapatoms}, for the function @code{mapatoms} which maps "
"over the symbols in an obarray.  @xref{Definition of maphash}, for the "
"function @code{maphash} which maps over key/value associations in a hash "
"table."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:878
msgid ""
"These mapping functions do not allow char-tables because a char-table is a "
"sparse array whose nominal range of indices is very large.  To map over a "
"char-table in a way that deals properly with its sparse nature, use the "
"function @code{map-char-table} (@pxref{Char-Tables})."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:879
#, no-wrap
msgid "mapcar function sequence"
msgstr ""

#. type: anchor{#1}
#: ../../../../../doc/lispref/functions.texi:883
msgid "Definition of mapcar"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:883
msgid ""
"@code{mapcar} applies @var{function} to each element of @var{sequence} in "
"turn, and returns a list of the results."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:888
msgid ""
"The argument @var{sequence} can be any kind of sequence except a char-table; "
"that is, a list, a vector, a bool-vector, or a string.  The result is always "
"a list.  The length of the result is the same as the length of "
"@var{sequence}.  For example:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:897
#, no-wrap
msgid ""
"(mapcar 'car '((a b) (c d) (e f)))\n"
"     @result{} (a c e)\n"
"(mapcar '1+ [1 2 3])\n"
"     @result{} (2 3 4)\n"
"(mapcar 'string \"abc\")\n"
"     @result{} (\"a\" \"b\" \"c\")\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:902
#, no-wrap
msgid ""
";; @r{Call each function in @code{my-hooks}.}\n"
"(mapcar 'funcall my-hooks)\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:915
#, no-wrap
msgid ""
"(defun mapcar* (function &rest args)\n"
"  \"Apply FUNCTION to successive cars of all ARGS.\n"
"Return the list of results.\"\n"
"  ;; @r{If no list is exhausted,}\n"
"  (if (not (memq nil args))\n"
"      ;; @r{apply function to @sc{car}s.}\n"
"      (cons (apply function (mapcar 'car args))\n"
"            (apply 'mapcar* function\n"
"                   ;; @r{Recurse for rest of elements.}\n"
"                   (mapcar 'cdr args)))))\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:920
#, no-wrap
msgid ""
"(mapcar* 'cons '(a b c) '(1 2 3 4))\n"
"     @result{} ((a . 1) (b . 2) (c . 3))\n"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:924
#, no-wrap
msgid "mapcan function sequence"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:931
msgid ""
"This function applies @var{function} to each element of @var{sequence}, like "
"@code{mapcar}, but instead of collecting the results into a list, it returns "
"a single list with all the elements of the results (which must be lists), by "
"altering the results (using @code{nconc}; @pxref{Rearrangement}).  Like with "
"@code{mapcar}, @var{sequence} can be of any type except a char-table."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:940
#, no-wrap
msgid ""
";; @r{Contrast this:}\n"
"(mapcar 'list '(a b c d))\n"
"     @result{} ((a) (b) (c) (d))\n"
";; @r{with this:}\n"
"(mapcan 'list '(a b c d))\n"
"     @result{} (a b c d)\n"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:944
#, no-wrap
msgid "mapc function sequence"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:948
msgid ""
"@code{mapc} is like @code{mapcar} except that @var{function} is used for "
"side-effects only---the values it returns are ignored, not collected into a "
"list.  @code{mapc} always returns @var{sequence}."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:950
#, no-wrap
msgid "mapconcat function sequence separator"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:958
msgid ""
"@code{mapconcat} applies @var{function} to each element of @var{sequence}; "
"the results, which must be sequences of characters (strings, vectors, or "
"lists), are concatenated into a single string return value.  Between each "
"pair of result sequences, @code{mapconcat} inserts the characters from "
"@var{separator}, which also must be a string, or a vector or list of "
"characters.  @xref{Sequences Arrays Vectors}."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:964
msgid ""
"The argument @var{function} must be a function that can take one argument "
"and returns a sequence of characters: a string, a vector, or a list.  The "
"argument @var{sequence} can be any kind of sequence except a char-table; "
"that is, a list, a vector, a bool-vector, or a string."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:971
#, no-wrap
msgid ""
"(mapconcat 'symbol-name\n"
"           '(The cat in the hat)\n"
"           \" \")\n"
"     @result{} \"The cat in the hat\"\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:978
#, no-wrap
msgid ""
"(mapconcat (lambda (x) (format \"%c\" (1+ x)))\n"
"           \"HAL-8000\"\n"
"           \"\")\n"
"     @result{} \"IBM.9111\"\n"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:984
#, no-wrap
msgid "anonymous function"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:995
msgid ""
"Although functions are usually defined with @code{defun} and given names at "
"the same time, it is sometimes convenient to use an explicit lambda "
"expression---an @dfn{anonymous function}.  Anonymous functions are valid "
"wherever function names are.  They are often assigned as variable values, or "
"as arguments to functions; for instance, you might pass one as the "
"@var{function} argument to @code{mapcar}, which applies that function to "
"each element of a list (@pxref{Mapping Functions}).  @xref{describe-symbols "
"example}, for a realistic example of this."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1000
msgid ""
"When defining a lambda expression that is to be used as an anonymous "
"function, you can in principle use any method to construct the list.  But "
"typically you should use the @code{lambda} macro, or the @code{function} "
"special form, or the @code{#'} read syntax:"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1001
#, no-wrap
msgid "lambda args [doc] [interactive] body@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1005
msgid ""
"This macro returns an anonymous function with argument list @var{args}, "
"documentation string @var{doc} (if any), interactive spec @var{interactive} "
"(if any), and body forms given by @var{body}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1009
msgid ""
"Under dynamic binding, this macro effectively makes @code{lambda} forms "
"self-quoting: evaluating a form whose @sc{car} is @code{lambda} yields the "
"form itself:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1013
#, no-wrap
msgid ""
"(lambda (x) (* x x))\n"
"     @result{} (lambda (x) (* x x))\n"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1017
msgid ""
"Note that when evaluating under lexical binding the result is a closure "
"object (@pxref{Closures})."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1021
msgid ""
"The @code{lambda} form has one other effect: it tells the Emacs evaluator "
"and byte-compiler that its argument is a function, by using @code{function} "
"as a subroutine (see below)."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/functions.texi:1023
#, no-wrap
msgid "function function-object"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:1024
#, no-wrap
msgid "function quoting"
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/functions.texi:1031
msgid ""
"This special form returns @var{function-object} without evaluating it.  In "
"this, it is similar to @code{quote} (@pxref{Quoting}).  But unlike "
"@code{quote}, it also serves as a note to the Emacs evaluator and "
"byte-compiler that @var{function-object} is intended to be used as a "
"function.  Assuming @var{function-object} is a valid lambda expression, this "
"has two effects:"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:1036
msgid ""
"When the code is byte-compiled, @var{function-object} is compiled into a "
"byte-code function object (@pxref{Byte Compilation})."
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:1040
msgid ""
"When lexical binding is enabled, @var{function-object} is converted into a "
"closure.  @xref{Closures}."
msgstr ""

#. type: defspec
#: ../../../../../doc/lispref/functions.texi:1045
msgid ""
"When @var{function-object} is a symbol and the code is byte compiled, the "
"byte-compiler will warn if that function is not defined or might not be "
"known at run time."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:1047
#, no-wrap
msgid "@samp{#'} syntax"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1050
msgid ""
"The read syntax @code{#'} is a short-hand for using @code{function}.  The "
"following forms are all equivalent:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1055
#, no-wrap
msgid ""
"(lambda (x) (* x x))\n"
"(function (lambda (x) (* x x)))\n"
"#'(lambda (x) (* x x))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1061
msgid ""
"In the following example, we define a @code{change-property} function that "
"takes a function as its third argument, followed by a @code{double-property} "
"function that makes use of @code{change-property} by passing it an anonymous "
"function:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:1067
#, no-wrap
msgid ""
"(defun change-property (symbol prop function)\n"
"  (let ((value (get symbol prop)))\n"
"    (put symbol prop (funcall function value))))\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:1072
#, no-wrap
msgid ""
"(defun double-property (symbol prop)\n"
"  (change-property symbol prop (lambda (x) (* 2 x))))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1077
msgid "Note that we do not quote the @code{lambda} form."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1081
msgid ""
"If you compile the above code, the anonymous function is also compiled.  "
"This would not happen if, say, you had constructed the anonymous function by "
"quoting it as a list:"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:1087
#, no-wrap
msgid ""
"(defun double-property (symbol prop)\n"
"  (change-property symbol prop '(lambda (x) (* 2 x))))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1095
msgid ""
"In that case, the anonymous function is kept as a lambda expression in the "
"compiled code.  The byte-compiler cannot assume this list is a function, "
"even though it looks like one, since it does not know that "
"@code{change-property} intends to use it as a function."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:1098
#, no-wrap
msgid "generic functions"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:1099
#, no-wrap
msgid "polymorphism"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1109
msgid ""
"Functions defined using @code{defun} have a hard-coded set of assumptions "
"about the types and expected values of their arguments.  For example, a "
"function that was designed to handle values of its argument that are either "
"numbers or lists of numbers will fail or signal an error if called with a "
"value of any other type, such as a vector or a string.  This happens because "
"the implementation of the function is not prepared to deal with types other "
"than those assumed during the design."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1115
msgid ""
"By contrast, object-oriented programs use @dfn{polymorphic functions}: a set "
"of specialized functions having the same name, each one of which was written "
"for a certain specific set of argument types.  Which of the functions is "
"actually called is decided at run time based on the types of the actual "
"arguments."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:1116
#, no-wrap
msgid "CLOS"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1123
msgid ""
"Emacs provides support for polymorphism.  Like other Lisp environments, "
"notably Common Lisp and its Common Lisp Object System (@acronym{CLOS}), this "
"support is based on @dfn{generic functions}.  The Emacs generic functions "
"closely follow @acronym{CLOS}, including use of similar names, so if you "
"have experience with @acronym{CLOS}, the rest of this section will sound "
"very familiar."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1134
msgid ""
"A generic function specifies an abstract operation, by defining its name and "
"list of arguments, but (usually) no implementation.  The actual "
"implementation for several specific classes of arguments is provided by "
"@dfn{methods}, which should be defined separately.  Each method that "
"implements a generic function has the same name as the generic function, but "
"the method's definition indicates what kinds of arguments it can handle by "
"@dfn{specializing} the arguments defined by the generic function.  These "
"@dfn{argument specializers} can be more or less specific; for example, a "
"@code{string} type is more specific than a more general type, such as "
"@code{sequence}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1138
msgid ""
"Note that, unlike in message-based OO languages, such as C@t{++} and Simula, "
"methods that implement generic functions don't belong to a class, they "
"belong to the generic function they implement."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1146
msgid ""
"When a generic function is invoked, it selects the applicable methods by "
"comparing the actual arguments passed by the caller with the argument "
"specializers of each method.  A method is applicable if the actual arguments "
"of the call are compatible with the method's specializers.  If more than one "
"method is applicable, they are combined using certain rules, described "
"below, and the combination then handles the call."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1147
#, no-wrap
msgid ""
"cl-defgeneric name arguments [documentation] [options-and-methods@dots{}] "
"&rest body"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1154
msgid ""
"This macro defines a generic function with the specified @var{name} and "
"@var{arguments}.  If @var{body} is present, it provides the default "
"implementation.  If @var{documentation} is present (it should always be), it "
"specifies the documentation string for the generic function, in the form "
"@code{(:documentation @var{docstring})}.  The optional "
"@var{options-and-methods} can be one of the following forms:"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1156
#, no-wrap
msgid "(declare @var{declarations})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1158
msgid "A declare form, as described in @ref{Declare Form}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1158
#, no-wrap
msgid "(:argument-precedence-order &rest @var{args})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1165
msgid ""
"This form affects the sorting order for combining applicable methods.  "
"Normally, when two methods are compared during combination, method arguments "
"are examined left to right, and the first method whose argument specializer "
"is more specific will come before the other one.  The order defined by this "
"form overrides that, and the arguments are examined according to their order "
"in this form, and not left to right."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1165
#, no-wrap
msgid "(:method [@var{qualifiers}@dots{}] args &rest body)"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1167
msgid "This form defines a method like @code{cl-defmethod} does."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1170
#, no-wrap
msgid ""
"cl-defmethod name [qualifier] arguments [&context (expr spec)@dots{}] &rest "
"[docstring] body"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1180
msgid ""
"This macro defines a particular implementation for the generic function "
"called @var{name}.  The implementation code is given by @var{body}.  If "
"present, @var{docstring} is the documentation string for the method.  The "
"@var{arguments} list, which must be identical in all the methods that "
"implement a generic function, and must match the argument list of that "
"function, provides argument specializers of the form @code{(@var{arg} "
"@var{spec})}, where @var{arg} is the argument name as specified in the "
"@code{cl-defgeneric} call, and @var{spec} is one of the following "
"specializer forms:"
msgstr ""

#. type: var{#1}
#: ../../../../../doc/lispref/functions.texi:1182
#, no-wrap
msgid "type"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1185
msgid ""
"This specializer requires the argument to be of the given @var{type}, one of "
"the types from the type hierarchy described below."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1185
#, no-wrap
msgid "(eql @var{object})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1188
msgid ""
"This specializer requires the argument be @code{eql} to the given "
"@var{object}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1188
#, no-wrap
msgid "(head @var{object})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1191
msgid ""
"The argument must be a cons cell whose @code{car} is @code{eql} to "
"@var{object}."
msgstr ""

#. type: var{#1}
#: ../../../../../doc/lispref/functions.texi:1191
#, no-wrap
msgid "struct-type"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1195
msgid ""
"The argument must be an instance of a class named @var{struct-type} defined "
"with @code{cl-defstruct} (@pxref{Structures,,, cl, Common Lisp Extensions "
"for GNU Emacs Lisp}), or of one of its child classes."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1211
msgid ""
"Method definitions can make use of a new argument-list keyword, "
"@code{&context}, which introduces extra specializers that test the "
"environment at the time the method is run.  This keyword should appear after "
"the list of required arguments, but before any @code{&rest} or "
"@code{&optional} keywords.  The @code{&context} specializers look much like "
"regular argument specializers---(@var{expr} @var{spec})---except that "
"@var{expr} is an expression to be evaluated in the current context, and the "
"@var{spec} is a value to compare against.  For example, @code{&context "
"(overwrite-mode (eql t))} will make the method applicable only when "
"@code{overwrite-mode} is turned on.  The @code{&context} keyword can be "
"followed by any number of context specializers.  Because the context "
"specializers are not part of the generic function's argument signature, they "
"may be omitted in methods that don't require them."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1217
msgid ""
"The type specializer, @code{(@var{arg} @var{type})}, can specify one of the "
"@dfn{system types} in the following list.  When a parent type is specified, "
"an argument whose type is any of its more specific child types, as well as "
"grand-children, grand-grand-children, etc. will also be compatible."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1219
#, no-wrap
msgid "integer"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1221 ../../../../../doc/lispref/functions.texi:1237
msgid "Parent type: @code{number}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1221
#, no-wrap
msgid "number"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1222
#, no-wrap
msgid "null"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1224
msgid "Parent type: @code{symbol}"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1224
#, no-wrap
msgid "symbol"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1225
#, no-wrap
msgid "string"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1227 ../../../../../doc/lispref/functions.texi:1245 ../../../../../doc/lispref/functions.texi:1247 ../../../../../doc/lispref/functions.texi:1249
msgid "Parent type: @code{array}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1227
#, no-wrap
msgid "array"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1229 ../../../../../doc/lispref/functions.texi:1233
msgid "Parent type: @code{sequence}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1229
#, no-wrap
msgid "cons"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1231
msgid "Parent type: @code{list}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1231
#, no-wrap
msgid "list"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1233
#, no-wrap
msgid "marker"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1234
#, no-wrap
msgid "overlay"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1235
#, no-wrap
msgid "float"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1237
#, no-wrap
msgid "window-configuration"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1238
#, no-wrap
msgid "process"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1239
#, no-wrap
msgid "window"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1241
#, no-wrap
msgid "compiled-function"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1242
#, no-wrap
msgid "buffer"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1243
#, no-wrap
msgid "char-table"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1245
#, no-wrap
msgid "bool-vector"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1247
#, no-wrap
msgid "vector"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1249
#, no-wrap
msgid "frame"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1250
#, no-wrap
msgid "hash-table"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1251
#, no-wrap
msgid "font-spec"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1252
#, no-wrap
msgid "font-entity"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1253
#, no-wrap
msgid "font-object"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1262
msgid ""
"The optional @var{qualifier} allows combining several applicable methods.  "
"If it is not present, the defined method is a @dfn{primary} method, "
"responsible for providing the primary implementation of the generic function "
"for the specialized arguments.  You can also define @dfn{auxiliary methods}, "
"by using one of the following values as @var{qualifier}:"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1264 ../../../../../doc/lispref/functions.texi:1791
#, no-wrap
msgid ":before"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1268
msgid ""
"This auxiliary method will run before the primary method.  More accurately, "
"all the @code{:before} methods will run before the primary, in the "
"most-specific-first order."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1268 ../../../../../doc/lispref/functions.texi:1803
#, no-wrap
msgid ":after"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1272
msgid ""
"This auxiliary method will run after the primary method.  More accurately, "
"all such methods will run after the primary, in the most-specific-last "
"order."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1272 ../../../../../doc/lispref/functions.texi:1819
#, no-wrap
msgid ":around"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1277
msgid ""
"This auxiliary method will run @emph{instead} of the primary method.  The "
"most specific of such methods will be run before any other method.  Such "
"methods normally use @code{cl-call-next-method}, described below, to invoke "
"the other auxiliary or primary methods."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1277
#, no-wrap
msgid ":extra @var{string}"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1280
msgid ""
"This allows you to add more methods, distinguished by @var{string}, for the "
"same specializers and qualifiers."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1288
msgid ""
"Functions defined using @code{cl-defmethod} cannot be made interactive, "
"i.e.@: commands (@pxref{Defining Commands}), by adding the "
"@code{interactive} form to them.  If you need a polymorphic command, we "
"recommend defining a normal command that calls a polymorphic function "
"defined via @code{cl-defgeneric} and @code{cl-defmethod}."
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:1290
#, no-wrap
msgid "dispatch of methods for generic function"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:1291
#, no-wrap
msgid "multiple-dispatch methods"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1302
msgid ""
"Each time a generic function is called, it builds the @dfn{effective method} "
"which will handle this invocation by combining the applicable methods "
"defined for the function.  The process of finding the applicable methods and "
"producing the effective method is called @dfn{dispatch}.  The applicable "
"methods are those all of whose specializers are compatible with the actual "
"arguments of the call.  Since all of the arguments must be compatible with "
"the specializers, they all determine whether a method is applicable.  "
"Methods that explicitly specialize more than one argument are called "
"@dfn{multiple-dispatch methods}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1315
msgid ""
"The applicable methods are sorted into the order in which they will be "
"combined.  The method whose left-most argument specializer is the most "
"specific one will come first in the order.  (Specifying "
"@code{:argument-precedence-order} as part of @code{cl-defmethod} overrides "
"that, as described above.)  If the method body calls "
"@code{cl-call-next-method}, the next most-specific method will run.  If "
"there are applicable @code{:around} methods, the most-specific of them will "
"run first; it should call @code{cl-call-next-method} to run any of the less "
"specific @code{:around} methods.  Next, the @code{:before} methods run in "
"the order of their specificity, followed by the primary method, and lastly "
"the @code{:after} methods in the reverse order of their specificity."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1316
#, no-wrap
msgid "cl-call-next-method &rest args"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1323
msgid ""
"When invoked from within the lexical body of a primary or an @code{:around} "
"auxiliary method, call the next applicable method for the same generic "
"function.  Normally, it is called with no arguments, which means to call the "
"next applicable method with the same arguments that the calling method was "
"invoked.  Otherwise, the specified arguments are used instead."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1325
#, no-wrap
msgid "cl-next-method-p"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1329
msgid ""
"This function, when called from within the lexical body of a primary or an "
"@code{:around} auxiliary method, returns non-@code{nil} if there is a next "
"method to call."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:1333
#, no-wrap
msgid "Accessing Function Cell Contents"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1338
msgid ""
"The @dfn{function definition} of a symbol is the object stored in the "
"function cell of the symbol.  The functions described here access, test, and "
"set the function cell of symbols."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1341
msgid ""
"See also the function @code{indirect-function}.  @xref{Definition of "
"indirect-function}."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1342
#, no-wrap
msgid "symbol-function symbol"
msgstr ""

#. type: kindex
#: ../../../../../doc/lispref/functions.texi:1343
#, no-wrap
msgid "void-function"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1346
msgid ""
"This returns the object in the function cell of @var{symbol}.  It does not "
"check that the returned object is a legitimate function."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1350
msgid ""
"If the function cell is void, the return value is @code{nil}.  To "
"distinguish between a function cell that is void and one set to @code{nil}, "
"use @code{fboundp} (see below)."
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:1356
#, no-wrap
msgid ""
"(defun bar (n) (+ n 2))\n"
"(symbol-function 'bar)\n"
"     @result{} (lambda (n) (+ n 2))\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:1360
#, no-wrap
msgid ""
"(fset 'baz 'bar)\n"
"     @result{} bar\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:1364
#, no-wrap
msgid ""
"(symbol-function 'baz)\n"
"     @result{} bar\n"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:1368
#, no-wrap
msgid "void function cell"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1373
msgid ""
"If you have never given a symbol any function definition, we say that that "
"symbol's function cell is @dfn{void}.  In other words, the function cell "
"does not have any Lisp object in it.  If you try to call the symbol as a "
"function, Emacs signals a @code{void-function} error."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1379
msgid ""
"Note that void is not the same as @code{nil} or the symbol @code{void}.  The "
"symbols @code{nil} and @code{void} are Lisp objects, and can be stored into "
"a function cell just as any other object can be (and they can be valid "
"functions if you define them in turn with @code{defun}).  A void function "
"cell contains no object whatsoever."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1383
msgid ""
"You can test the voidness of a symbol's function definition with "
"@code{fboundp}.  After you have given a symbol a function definition, you "
"can make it void once more using @code{fmakunbound}."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1384
#, no-wrap
msgid "fboundp symbol"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1388
msgid ""
"This function returns @code{t} if the symbol has an object in its function "
"cell, @code{nil} otherwise.  It does not check that the object is a "
"legitimate function."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1390
#, no-wrap
msgid "fmakunbound symbol"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1395
msgid ""
"This function makes @var{symbol}'s function cell void, so that a subsequent "
"attempt to access this cell will cause a @code{void-function} error.  It "
"returns @var{symbol}.  (See also @code{makunbound}, in @ref{Void "
"Variables}.)"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:1401
#, no-wrap
msgid ""
"(defun foo (x) x)\n"
"(foo 1)\n"
"     @result{}1\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:1405
#, no-wrap
msgid ""
"(fmakunbound 'foo)\n"
"     @result{} foo\n"
msgstr ""

#. type: group
#: ../../../../../doc/lispref/functions.texi:1409
#, no-wrap
msgid ""
"(foo 1)\n"
"@error{} Symbol's function definition is void: foo\n"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1413
#, no-wrap
msgid "fset symbol definition"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1419
msgid ""
"This function stores @var{definition} in the function cell of @var{symbol}.  "
"The result is @var{definition}.  Normally @var{definition} should be a "
"function or the name of a function, but this is not checked.  The argument "
"@var{symbol} is an ordinary evaluated argument."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1424
msgid ""
"The primary use of this function is as a subroutine by constructs that "
"define or alter functions, like @code{defun} or @code{advice-add} "
"(@pxref{Advising Functions}).  You can also use it to give a symbol a "
"function definition that is not a function, e.g., a keyboard macro "
"(@pxref{Keyboard Macros}):"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1429
#, no-wrap
msgid ""
";; @r{Define a named keyboard macro.}\n"
"(fset 'kill-two-lines \"\\^u2\\^k\")\n"
"     @result{} \"\\^u2\\^k\"\n"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1434
msgid ""
"It you wish to use @code{fset} to make an alternate name for a function, "
"consider using @code{defalias} instead.  @xref{Definition of defalias}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1446
msgid ""
"As explained in @ref{Variable Scoping}, Emacs can optionally enable lexical "
"binding of variables.  When lexical binding is enabled, any named function "
"that you create (e.g., with @code{defun}), as well as any anonymous function "
"that you create using the @code{lambda} macro or the @code{function} special "
"form or the @code{#'} syntax (@pxref{Anonymous Functions}), is automatically "
"converted into a @dfn{closure}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1454
msgid ""
"A closure is a function that also carries a record of the lexical "
"environment that existed when the function was defined.  When it is invoked, "
"any lexical variable references within its definition use the retained "
"lexical environment.  In all other respects, closures behave much like "
"ordinary functions; in particular, they can be called in the same way as "
"ordinary functions."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1456
msgid "@xref{Lexical Binding}, for an example of using a closure."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1461
msgid ""
"Currently, an Emacs Lisp closure object is represented by a list with the "
"symbol @code{closure} as the first element, a list representing the lexical "
"environment as the second element, and the argument list and body forms as "
"the remaining elements:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1466
#, no-wrap
msgid ""
";; @r{lexical binding is enabled.}\n"
"(lambda (x) (* x x))\n"
"     @result{} (closure (t) (x) (* x x))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1473
msgid ""
"However, the fact that the internal structure of a closure is exposed to the "
"rest of the Lisp world is considered an internal implementation detail.  For "
"this reason, we recommend against directly examining or altering the "
"structure of closure objects."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:1475
#, no-wrap
msgid "Advising Emacs Lisp Functions"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:1476
#, no-wrap
msgid "advising functions"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:1477
#, no-wrap
msgid "piece of advice"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1486
msgid ""
"When you need to modify a function defined in another library, or when you "
"need to modify a hook like @code{@var{foo}-function}, a process filter, or "
"basically any variable or object field which holds a function value, you can "
"use the appropriate setter function, such as @code{fset} or @code{defun} for "
"named functions, @code{setq} for hook variables, or "
"@code{set-process-filter} for process filters, but those are often too "
"blunt, completely throwing away the previous value."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1490
msgid ""
"The @dfn{advice} feature lets you add to the existing definition of a "
"function, by @dfn{advising the function}.  This is a cleaner method than "
"redefining the whole function."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1496
msgid ""
"Emacs's advice system provides two sets of primitives for that: the core "
"set, for function values held in variables and object fields (with the "
"corresponding primitives being @code{add-function} and "
"@code{remove-function}) and another set layered on top of it for named "
"functions (with the main primitives being @code{advice-add} and "
"@code{advice-remove})."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1499
msgid ""
"As a trivial example, here's how to add advice that'll modify the return "
"value of a function every time it's called:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1506
#, no-wrap
msgid ""
"(defun my-double (x)\n"
"  (* x 2))\n"
"(defun my-increase (x)\n"
"  (+ x 1))\n"
"(advice-add 'my-double :filter-return #'my-increase)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1510
msgid ""
"After adding this advice, if you call @code{my-double} with @samp{3}, the "
"return value will be @samp{7}.  To remove this advice, say"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1513
#, no-wrap
msgid "(advice-remove 'my-double #'my-increase)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1517
msgid ""
"A more advanced example would be to trace the calls to the process filter of "
"a process @var{proc}:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1521
#, no-wrap
msgid ""
"(defun my-tracing-function (proc string)\n"
"  (message \"Proc %S received %S\" proc string))\n"
"\n"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1523
#, no-wrap
msgid "(add-function :before (process-filter @var{proc}) #'my-tracing-function)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1529
msgid ""
"This will cause the process's output to be passed to "
"@code{my-tracing-function} before being passed to the original process "
"filter.  @code{my-tracing-function} receives the same arguments as the "
"original function.  When you're done with it, you can revert to the untraced "
"behavior with:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1532
#, no-wrap
msgid "(remove-function (process-filter @var{proc}) #'my-tracing-function)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1536
msgid ""
"Similarly, if you want to trace the execution of the function named "
"@code{display-buffer}, you could use:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1543
#, no-wrap
msgid ""
"(defun his-tracing-function (orig-fun &rest args)\n"
"  (message \"display-buffer called with args %S\" args)\n"
"  (let ((res (apply orig-fun args)))\n"
"    (message \"display-buffer returned %S\" res)\n"
"    res))\n"
"\n"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1545
#, no-wrap
msgid "(advice-add 'display-buffer :around #'his-tracing-function)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1552
msgid ""
"Here, @code{his-tracing-function} is called instead of the original function "
"and receives the original function (additionally to that function's "
"arguments)  as argument, so it can call it if and when it needs to.  When "
"you're tired of seeing this output, you can revert to the untraced behavior "
"with:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1555
#, no-wrap
msgid "(advice-remove 'display-buffer #'his-tracing-function)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1560
msgid ""
"The arguments @code{:before} and @code{:around} used in the above examples "
"specify how the two functions are composed, since there are many different "
"ways to do it.  The added function is also called a piece of @emph{advice}."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/functions.texi:1566 ../../../../../doc/lispref/functions.texi:1568
#, no-wrap
msgid "Core Advising Primitives"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:1566
msgid "Primitives to manipulate advice."
msgstr ""

#. type: subsection
#: ../../../../../doc/lispref/functions.texi:1566 ../../../../../doc/lispref/functions.texi:1697 ../../../../../doc/lispref/functions.texi:1698
#, no-wrap
msgid "Advising Named Functions"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:1566
msgid "Advising named functions."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/functions.texi:1566 ../../../../../doc/lispref/functions.texi:1783
#, no-wrap
msgid "Advice Combinators"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:1566
msgid "Ways to compose advice."
msgstr ""

#. type: node
#: ../../../../../doc/lispref/functions.texi:1566 ../../../../../doc/lispref/functions.texi:1896
#, no-wrap
msgid "Porting Old Advice"
msgstr ""

#. type: menuentry
#: ../../../../../doc/lispref/functions.texi:1566
msgid "Adapting code using the old defadvice."
msgstr ""

#. type: subsection
#: ../../../../../doc/lispref/functions.texi:1569
#, no-wrap
msgid "Primitives to manipulate advices"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:1570
#, no-wrap
msgid "advice, add and remove"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1572
#, no-wrap
msgid "add-function where place function &optional props"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1575
msgid ""
"This macro is the handy way to add the advice @var{function} to the function "
"stored in @var{place} (@pxref{Generalized Variables})."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1580
msgid ""
"@var{where} determines how @var{function} is composed with the existing "
"function, e.g., whether @var{function} should be called before, or after the "
"original function.  @xref{Advice Combinators}, for the list of available "
"ways to compose the two functions."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1589
msgid ""
"When modifying a variable (whose name will usually end with "
"@code{-function}), you can choose whether @var{function} is used globally or "
"only in the current buffer: if @var{place} is just a symbol, then "
"@var{function} is added to the global value of @var{place}.  Whereas if "
"@var{place} is of the form @code{(local @var{symbol})}, where @var{symbol} "
"is an expression which returns the variable name, then @var{function} will "
"only be added in the current buffer.  Finally, if you want to modify a "
"lexical variable, you will have to use @code{(var @var{variable})}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1593
msgid ""
"Every function added with @code{add-function} can be accompanied by an "
"association list of properties @var{props}.  Currently only two of those "
"properties have a special meaning:"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1595
#, no-wrap
msgid "name"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1599
msgid ""
"This gives a name to the advice, which @code{remove-function} can use to "
"identify which function to remove.  Typically used when @var{function} is an "
"anonymous function."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1600
#, no-wrap
msgid "depth"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1607
msgid ""
"This specifies how to order the advice, should several pieces of advice be "
"present.  By default, the depth is 0.  A depth of 100 indicates that this "
"piece of advice should be kept as deep as possible, whereas a depth of "
"@minus{}100 indicates that it should stay as the outermost piece.  When two "
"pieces of advice specify the same depth, the most recently added one will be "
"outermost."
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1620
msgid ""
"For @code{:before} advice, being outermost means that this advice will be "
"run first, before any other advice, whereas being innermost means that it "
"will run right before the original function, with no other advice run "
"between itself and the original function.  Similarly, for @code{:after} "
"advice innermost means that it will run right after the original function, "
"with no other advice run in between, whereas outermost means that it will be "
"run right at the end after all other advice.  An innermost @code{:override} "
"piece of advice will only override the original function and other pieces of "
"advice will apply to it, whereas an outermost @code{:override} piece of "
"advice will override not only the original function but all other advice "
"applied to it as well."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1631
msgid ""
"If @var{function} is not interactive, then the combined function will "
"inherit the interactive spec, if any, of the original function.  Else, the "
"combined function will be interactive and will use the interactive spec of "
"@var{function}.  One exception: if the interactive spec of @var{function} is "
"a function (i.e., a @code{lambda} expression or an @code{fbound} symbol "
"rather than an expression or a string), then the interactive spec of the "
"combined function will be a call to that function with as sole argument the "
"interactive spec of the original function.  To interpret the spec received "
"as argument, use @code{advice-eval-interactive-spec}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1639
msgid ""
"Note: The interactive spec of @var{function} will apply to the combined "
"function and should hence obey the calling convention of the combined "
"function rather than that of @var{function}.  In many cases, it makes no "
"difference since they are identical, but it does matter for @code{:around}, "
"@code{:filter-args}, and @code{:filter-return}, where @var{function} "
"receives different arguments than the original function stored in "
"@var{place}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1641
#, no-wrap
msgid "remove-function place function"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1645
msgid ""
"This macro removes @var{function} from the function stored in @var{place}.  "
"This only works if @var{function} was added to @var{place} using "
"@code{add-function}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1651
msgid ""
"@var{function} is compared with functions added to @var{place} using "
"@code{equal}, to try and make it work also with lambda expressions.  It is "
"additionally compared also with the @code{name} property of the functions "
"added to @var{place}, which can be more reliable than comparing lambda "
"expressions using @code{equal}."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1653
#, no-wrap
msgid "advice-function-member-p advice function-def"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1657
msgid ""
"Return non-@code{nil} if @var{advice} is already in @var{function-def}.  "
"Like for @code{remove-function} above, instead of @var{advice} being the "
"actual function, it can also be the @code{name} of the piece of advice."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1659
#, no-wrap
msgid "advice-function-mapc f function-def"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1663
msgid ""
"Call the function @var{f} for every piece of advice that was added to "
"@var{function-def}.  @var{f} is called with two arguments: the advice "
"function and its properties."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1665
#, no-wrap
msgid "advice-eval-interactive-spec spec"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1671
msgid ""
"Evaluate the interactive @var{spec} just like an interactive call to a "
"function with such a spec would, and then return the corresponding list of "
"arguments that was built.  E.g., @code{(advice-eval-interactive-spec "
"\"r\\nP\")} will return a list of three elements, containing the boundaries "
"of the region and the current prefix argument."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1675
msgid ""
"For instance, if you want to make the @kbd{C-x m} (@code{compose-mail}) "
"command prompt for a @samp{From:} header, you could say something like this:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1692
#, no-wrap
msgid ""
"(defun my-compose-mail-advice (orig &rest args)\n"
"  \"Read From: address interactively.\"\n"
"  (interactive\n"
"   (lambda (spec)\n"
"     (let* ((user-mail-address\n"
"             (completing-read \"From: \"\n"
"                              '(\"one.address@@example.net\"\n"
"                                \"alternative.address@@example.net\")))\n"
"            (from (message-make-from user-full-name\n"
"                                     user-mail-address))\n"
"            (spec (advice-eval-interactive-spec spec)))\n"
"       ;; Put the From header into the OTHER-HEADERS argument.\n"
"       (push (cons 'From from) (nth 2 spec))\n"
"       spec)))\n"
"  (apply orig args))\n"
"\n"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1694
#, no-wrap
msgid "(advice-add 'compose-mail :around #'my-compose-mail-advice)\n"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:1699
#, no-wrap
msgid "advising named functions"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1703
msgid ""
"A common use of advice is for named functions and macros.  You could just "
"use @code{add-function} as in:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1706
#, no-wrap
msgid "(add-function :around (symbol-function '@var{fun}) #'his-tracing-function)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1715
msgid ""
"But you should use @code{advice-add} and @code{advice-remove} for that "
"instead.  This separate set of functions to manipulate pieces of advice "
"applied to named functions, offers the following extra features compared to "
"@code{add-function}: they know how to deal with macros and autoloaded "
"functions, they let @code{describe-function} preserve the original docstring "
"as well as document the added advice, and they let you add and remove advice "
"before a function is even defined."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1723
msgid ""
"@code{advice-add} can be useful for altering the behavior of existing calls "
"to an existing function without having to redefine the whole function.  "
"However, it can be a source of bugs, since existing callers to the function "
"may assume the old behavior, and work incorrectly when the behavior is "
"changed by advice.  Advice can also cause confusion in debugging, if the "
"person doing the debugging does not notice or remember that the function has "
"been modified by advice."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1730
msgid ""
"For these reasons, advice should be reserved for the cases where you cannot "
"modify a function's behavior in any other way.  If it is possible to do the "
"same thing via a hook, that is preferable (@pxref{Hooks}).  If you simply "
"want to change what a particular key does, it may be better to write a new "
"command, and remap the old command's key bindings to the new one "
"(@pxref{Remapping Commands})."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1739
msgid ""
"If you are writing code for release, for others to use, try to avoid "
"including advice in it.  If the function you want to advise has no hook to "
"do the job, please talk with the Emacs developers about adding a suitable "
"hook.  Especially, Emacs's own source files should not put advice on "
"functions in Emacs.  (There are currently a few exceptions to this "
"convention, but we aim to correct them.)  It is generally cleaner to create "
"a new hook in @code{foo}, and make @code{bar} use the hook, than to have "
"@code{bar} put advice in @code{foo}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1744
msgid ""
"Special forms (@pxref{Special Forms}) cannot be advised, however macros can "
"be advised, in much the same way as functions.  Of course, this will not "
"affect code that has already been macro-expanded, so you need to make sure "
"the advice is installed before the macro is expanded."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1752
msgid ""
"It is possible to advise a primitive (@pxref{What Is a Function}), but one "
"should typically @emph{not} do so, for two reasons.  Firstly, some "
"primitives are used by the advice mechanism, and advising them could cause "
"an infinite recursion.  Secondly, many primitives are called directly from "
"C, and such calls ignore advice; hence, one ends up in a confusing situation "
"where some calls (occurring from Lisp code) obey the advice and other calls "
"(from C code) do not."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1753
#, no-wrap
msgid "define-advice symbol (where lambda-list &optional name depth) &rest body"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:1758
msgid ""
"This macro defines a piece of advice and adds it to the function named "
"@var{symbol}.  The advice is an anonymous function if @var{name} is "
"@code{nil} or a function named @code{symbol@@name}.  See @code{advice-add} "
"for explanation of other arguments."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1760
#, no-wrap
msgid "advice-add symbol where function &optional props"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1764
msgid ""
"Add the advice @var{function} to the named function @var{symbol}.  "
"@var{where} and @var{props} have the same meaning as for @code{add-function} "
"(@pxref{Core Advising Primitives})."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1766
#, no-wrap
msgid "advice-remove symbol function"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1769
msgid ""
"Remove the advice @var{function} from the named function @var{symbol}.  "
"@var{function} can also be the @code{name} of a piece of advice."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1771
#, no-wrap
msgid "advice-member-p function symbol"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1775
msgid ""
"Return non-@code{nil} if the advice @var{function} is already in the named "
"function @var{symbol}.  @var{function} can also be the @code{name} of a "
"piece of advice."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1777
#, no-wrap
msgid "advice-mapc function symbol"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:1781
msgid ""
"Call @var{function} for every piece of advice that was added to the named "
"function @var{symbol}.  @var{function} is called with two arguments: the "
"advice function and its properties."
msgstr ""

#. type: subsection
#: ../../../../../doc/lispref/functions.texi:1784
#, no-wrap
msgid "Ways to compose advice"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1789
msgid ""
"Here are the different possible values for the @var{where} argument of "
"@code{add-function} and @code{advice-add}, specifying how the advice "
"@var{function} and the original function should be composed."
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1796
msgid ""
"Call @var{function} before the old function.  Both functions receive the "
"same arguments, and the return value of the composition is the return value "
"of the old function.  More specifically, the composition of the two "
"functions behaves like:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1798
#, no-wrap
msgid "(lambda (&rest r) (apply @var{function} r) (apply @var{oldfun} r))\n"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1802
msgid ""
"@code{(add-function :before @var{funvar} @var{function})} is comparable for "
"single-function hooks to @code{(add-hook '@var{hookvar} @var{function})} for "
"normal hooks."
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1808
msgid ""
"Call @var{function} after the old function.  Both functions receive the same "
"arguments, and the return value of the composition is the return value of "
"the old function.  More specifically, the composition of the two functions "
"behaves like:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1810
#, no-wrap
msgid "(lambda (&rest r) (prog1 (apply @var{oldfun} r) (apply @var{function} r)))\n"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1814
msgid ""
"@code{(add-function :after @var{funvar} @var{function})} is comparable for "
"single-function hooks to @code{(add-hook '@var{hookvar} @var{function} "
"'append)} for normal hooks."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1815
#, no-wrap
msgid ":override"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1818
msgid ""
"This completely replaces the old function with the new one.  The old "
"function can of course be recovered if you later call "
"@code{remove-function}."
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1826
msgid ""
"Call @var{function} instead of the old function, but provide the old "
"function as an extra argument to @var{function}.  This is the most flexible "
"composition.  For example, it lets you call the old function with different "
"arguments, or many times, or within a let-binding, or you can sometimes "
"delegate the work to the old function and sometimes override it completely.  "
"More specifically, the composition of the two functions behaves like:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1828
#, no-wrap
msgid "(lambda (&rest r) (apply @var{function} @var{oldfun} r))\n"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1830
#, no-wrap
msgid ":before-while"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1836
msgid ""
"Call @var{function} before the old function and don't call the old function "
"if @var{function} returns @code{nil}.  Both functions receive the same "
"arguments, and the return value of the composition is the return value of "
"the old function.  More specifically, the composition of the two functions "
"behaves like:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1838
#, no-wrap
msgid "(lambda (&rest r) (and (apply @var{function} r) (apply @var{oldfun} r)))\n"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1842
msgid ""
"@code{(add-function :before-while @var{funvar} @var{function})} is "
"comparable for single-function hooks to @code{(add-hook '@var{hookvar} "
"@var{function})} when @var{hookvar} is run via "
"@code{run-hook-with-args-until-failure}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1843
#, no-wrap
msgid ":before-until"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1847
msgid ""
"Call @var{function} before the old function and only call the old function "
"if @var{function} returns @code{nil}.  More specifically, the composition of "
"the two functions behaves like:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1849
#, no-wrap
msgid "(lambda (&rest r) (or (apply @var{function} r) (apply @var{oldfun} r)))\n"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1853
msgid ""
"@code{(add-function :before-until @var{funvar} @var{function})} is "
"comparable for single-function hooks to @code{(add-hook '@var{hookvar} "
"@var{function})} when @var{hookvar} is run via "
"@code{run-hook-with-args-until-success}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1854
#, no-wrap
msgid ":after-while"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1859
msgid ""
"Call @var{function} after the old function and only if the old function "
"returned non-@code{nil}.  Both functions receive the same arguments, and the "
"return value of the composition is the return value of @var{function}.  More "
"specifically, the composition of the two functions behaves like:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1861
#, no-wrap
msgid "(lambda (&rest r) (and (apply @var{oldfun} r) (apply @var{function} r)))\n"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1866
msgid ""
"@code{(add-function :after-while @var{funvar} @var{function})} is comparable "
"for single-function hooks to @code{(add-hook '@var{hookvar} @var{function} "
"'append)} when @var{hookvar} is run via "
"@code{run-hook-with-args-until-failure}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1867
#, no-wrap
msgid ":after-until"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1871
msgid ""
"Call @var{function} after the old function and only if the old function "
"returned @code{nil}.  More specifically, the composition of the two "
"functions behaves like:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1873
#, no-wrap
msgid "(lambda (&rest r) (or  (apply @var{oldfun} r) (apply @var{function} r)))\n"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1878
msgid ""
"@code{(add-function :after-until @var{funvar} @var{function})} is comparable "
"for single-function hooks to @code{(add-hook '@var{hookvar} @var{function} "
"'append)} when @var{hookvar} is run via "
"@code{run-hook-with-args-until-success}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1879
#, no-wrap
msgid ":filter-args"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1883
msgid ""
"Call @var{function} first and use the result (which should be a list) as the "
"new arguments to pass to the old function.  More specifically, the "
"composition of the two functions behaves like:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1885
#, no-wrap
msgid "(lambda (&rest r) (apply @var{oldfun} (funcall @var{function} r)))\n"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:1887
#, no-wrap
msgid ":filter-return"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:1890
msgid ""
"Call the old function first and pass the result to @var{function}.  More "
"specifically, the composition of the two functions behaves like:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1892
#, no-wrap
msgid "(lambda (&rest r) (funcall @var{function} (apply @var{oldfun} r)))\n"
msgstr ""

#. type: subsection
#: ../../../../../doc/lispref/functions.texi:1897
#, no-wrap
msgid "Adapting code using the old defadvice"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:1898
#, no-wrap
msgid "old advices, porting"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:1903
#, no-wrap
msgid "advices, porting from @code{defadvice}"
msgstr ""

#. type: findex
#: ../../../../../doc/lispref/functions.texi:1904
#, no-wrap
msgid "defadvice"
msgstr ""

#. type: findex
#: ../../../../../doc/lispref/functions.texi:1905
#, no-wrap
msgid "ad-activate"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1910
msgid ""
"A lot of code uses the old @code{defadvice} mechanism, which is largely made "
"obsolete by the new @code{advice-add}, whose implementation and semantics is "
"significantly simpler."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1912
msgid "An old piece of advice such as:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1922
#, no-wrap
msgid ""
"(defadvice previous-line (before next-line-at-end\n"
"                                 (&optional arg try-vscroll))\n"
"  \"Insert an empty line when moving up from the top line.\"\n"
"  (if (and next-line-add-newlines (= arg 1)\n"
"           (save-excursion (beginning-of-line) (bobp)))\n"
"      (progn\n"
"        (beginning-of-line)\n"
"        (newline))))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1925
msgid "could be translated in the new advice mechanism into a plain function:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1934
#, no-wrap
msgid ""
"(defun previous-line--next-line-at-end (&optional arg try-vscroll)\n"
"  \"Insert an empty line when moving up from the top line.\"\n"
"  (if (and next-line-add-newlines (= arg 1)\n"
"           (save-excursion (beginning-of-line) (bobp)))\n"
"      (progn\n"
"        (beginning-of-line)\n"
"        (newline))))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1938
msgid ""
"Obviously, this does not actually modify @code{previous-line}.  For that the "
"old advice needed:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1940
#, no-wrap
msgid "(ad-activate 'previous-line)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1942
msgid "whereas the new advice mechanism needs:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1944
#, no-wrap
msgid "(advice-add 'previous-line :before #'previous-line--next-line-at-end)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1951
msgid ""
"Note that @code{ad-activate} had a global effect: it activated all pieces of "
"advice enabled for that specified function.  If you wanted to only activate "
"or deactivate a particular piece, you needed to @emph{enable} or "
"@emph{disable} it with @code{ad-enable-advice} and "
"@code{ad-disable-advice}.  The new mechanism does away with this "
"distinction."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1953
msgid "Around advice such as:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1960
#, no-wrap
msgid ""
"(defadvice foo (around foo-around)\n"
"  \"Ignore case in `foo'.\"\n"
"  (let ((case-fold-search t))\n"
"    ad-do-it))\n"
"(ad-activate 'foo)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1963
msgid "could translate into:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:1970
#, no-wrap
msgid ""
"(defun foo--foo-around (orig-fun &rest args)\n"
"  \"Ignore case in `foo'.\"\n"
"  (let ((case-fold-search t))\n"
"    (apply orig-fun args)))\n"
"(advice-add 'foo :around #'foo--foo-around)\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1980
msgid ""
"Regarding the advice's @emph{class}, note that the new @code{:before} is not "
"quite equivalent to the old @code{before}, because in the old advice you "
"could modify the function's arguments (e.g., with @code{ad-set-arg}), and "
"that would affect the argument values seen by the original function, whereas "
"in the new @code{:before}, modifying an argument via @code{setq} in the "
"advice has no effect on the arguments seen by the original function.  When "
"porting @code{before} advice which relied on this behavior, you'll need to "
"turn it into new @code{:around} or @code{:filter-args} advice instead."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1985
msgid ""
"Similarly old @code{after} advice could modify the returned value by "
"changing @code{ad-return-value}, whereas new @code{:after} advice cannot, so "
"when porting such old @code{after} advice, you'll need to turn it into new "
"@code{:around} or @code{:filter-return} advice instead."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:1987
#, no-wrap
msgid "Declaring Functions Obsolete"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:1988
#, no-wrap
msgid "obsolete functions"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:1996
msgid ""
"You can mark a named function as @dfn{obsolete}, meaning that it may be "
"removed at some point in the future.  This causes Emacs to warn that the "
"function is obsolete whenever it byte-compiles code containing that "
"function, and whenever it displays the documentation for that function.  In "
"all other respects, an obsolete function behaves like any other function."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2001
msgid ""
"The easiest way to mark a function as obsolete is to put a @code{(declare "
"(obsolete @dots{}))} form in the function's @code{defun} definition.  "
"@xref{Declare Form}.  Alternatively, you can use the @code{make-obsolete} "
"function, described below."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2007
msgid ""
"A macro (@pxref{Macros}) can also be marked obsolete with "
"@code{make-obsolete}; this has the same effects as for a function.  An alias "
"for a function or macro can also be marked as obsolete; this makes the alias "
"itself obsolete, not the function or macro which it resolves to."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:2008
#, no-wrap
msgid "make-obsolete obsolete-name current-name when"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:2012
msgid ""
"This function marks @var{obsolete-name} as obsolete.  @var{obsolete-name} "
"should be a symbol naming a function or macro, or an alias for a function or "
"macro."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:2021
msgid ""
"If @var{current-name} is a symbol, the warning message says to use "
"@var{current-name} instead of @var{obsolete-name}.  @var{current-name} does "
"not need to be an alias for @var{obsolete-name}; it can be a different "
"function with similar functionality.  @var{current-name} can also be a "
"string, which serves as the warning message.  The message should begin in "
"lower case, and end with a period.  It can also be @code{nil}, in which case "
"the warning message provides no additional details."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:2024
msgid ""
"The argument @var{when} should be a string indicating when the function was "
"first made obsolete---for example, a date or a release number."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2026
#, no-wrap
msgid "define-obsolete-function-alias obsolete-name current-name when &optional doc"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2030
msgid ""
"This convenience macro marks the function @var{obsolete-name} obsolete and "
"also defines it as an alias for the function @var{current-name}.  It is "
"equivalent to the following:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:2034
#, no-wrap
msgid ""
"(defalias @var{obsolete-name} @var{current-name} @var{doc})\n"
"(make-obsolete @var{obsolete-name} @var{current-name} @var{when})\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2039
msgid ""
"In addition, you can mark a particular calling convention for a function as "
"obsolete:"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:2040
#, no-wrap
msgid "set-advertised-calling-convention function signature when"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:2048
msgid ""
"This function specifies the argument list @var{signature} as the correct way "
"to call @var{function}.  This causes the Emacs byte compiler to issue a "
"warning whenever it comes across an Emacs Lisp program that calls "
"@var{function} any other way (however, it will still allow the code to be "
"byte compiled).  @var{when} should be a string indicating when the variable "
"was first made obsolete (usually a version number string)."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:2051
msgid ""
"For instance, in old versions of Emacs the @code{sit-for} function accepted "
"three arguments, like this"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:2054
#, no-wrap
msgid "  (sit-for seconds milliseconds nodisp)\n"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:2059
msgid ""
"However, calling @code{sit-for} this way is considered obsolete "
"(@pxref{Waiting}).  The old calling convention is deprecated like this:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:2063
#, no-wrap
msgid ""
"(set-advertised-calling-convention\n"
"  'sit-for '(seconds &optional nodisp) \"22.1\")\n"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:2068
#, no-wrap
msgid "inline functions"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2074
msgid ""
"An @dfn{inline function} is a function that works just like an ordinary "
"function, except for one thing: when you byte-compile a call to the function "
"(@pxref{Byte Compilation}), the function's definition is expanded into the "
"caller."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2079
msgid ""
"The simple way to define an inline function, is to write @code{defsubst} "
"instead of @code{defun}.  The rest of the definition looks just the same, "
"but using @code{defsubst} says to make it inline for byte compilation."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2080
#, no-wrap
msgid "defsubst name args [doc] [declare] [interactive] body@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2083
msgid ""
"This macro defines an inline function.  Its syntax is exactly the same as "
"@code{defun} (@pxref{Defining Functions})."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2089
msgid ""
"Making a function inline often makes its function calls run faster.  But it "
"also has disadvantages.  For one thing, it reduces flexibility; if you "
"change the definition of the function, calls already inlined still use the "
"old definition until you recompile them."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2094
msgid ""
"Another disadvantage is that making a large function inline can increase the "
"size of compiled code both in files and in memory.  Since the speed "
"advantage of inline functions is greatest for small functions, you generally "
"should not make large functions inline."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2101
msgid ""
"Also, inline functions do not behave well with respect to debugging, "
"tracing, and advising (@pxref{Advising Functions}).  Since ease of debugging "
"and the flexibility of redefining functions are important features of Emacs, "
"you should not make a function inline, even if it's small, unless its speed "
"is really crucial, and you've timed the code to verify that using "
"@code{defun} actually has performance problems."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2104
msgid ""
"After an inline function is defined, its inline expansion can be performed "
"later on in the same file, just like macros."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2115
msgid ""
"It's possible to use @code{defmacro} to define a macro to expand into the "
"same code that an inline function would execute (@pxref{Macros}).  But the "
"macro would be limited to direct use in expressions---a macro cannot be "
"called with @code{apply}, @code{mapcar} and so on.  Also, it takes some work "
"to convert an ordinary function into a macro.  To convert it into an inline "
"function is easy; just replace @code{defun} with @code{defsubst}.  Since "
"each argument of an inline function is evaluated exactly once, you needn't "
"worry about how many times the body uses the arguments, as you do for "
"macros."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2119
msgid ""
"Alternatively, you can define a function by providing the code which will "
"inline it as a compiler macro.  The following macros make this possible."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2121
#, no-wrap
msgid "define-inline name args [doc] [declare] body@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2125
msgid ""
"Define a function @var{name} by providing code that does its inlining, as a "
"compiler macro.  The function will accept the argument list @var{args} and "
"will have the specified @var{body}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2130
msgid ""
"If present, @var{doc} should be the function's documentation string "
"(@pxref{Function Documentation}); @var{declare}, if present, should be a "
"@code{declare} form (@pxref{Declare Form}) specifying the function's "
"metadata."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2134
msgid ""
"Functions defined via @code{define-inline} have several advantages with "
"respect to macros defined by @code{defsubst} or @code{defmacro}:"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:2138
msgid "They can be passed to @code{mapcar} (@pxref{Mapping Functions})."
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:2141
msgid "They are more efficient."
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:2145
msgid ""
"They can be used as @dfn{place forms} to store values (@pxref{Generalized "
"Variables})."
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:2150
msgid ""
"They behave in a more predictable way than @code{cl-defsubst} "
"(@pxref{Argument Lists,,, cl, Common Lisp Extensions for GNU Emacs Lisp})."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2155
msgid ""
"Like @code{defmacro}, a function inlined with @code{define-inline} inherits "
"the scoping rules, either dynamic or lexical, from the call site.  "
"@xref{Variable Scoping}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2158
msgid ""
"The following macros should be used in the body of a function defined by "
"@code{define-inline}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2159
#, no-wrap
msgid "inline-quote expression"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2163
msgid ""
"Quote @var{expression} for @code{define-inline}.  This is similar to the "
"backquote (@pxref{Backquote}), but quotes code and accepts only @code{,}, "
"not @code{,@@}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2165
#, no-wrap
msgid "inline-letevals (bindings@dots{}) body@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2175
msgid ""
"This is similar to @code{let} (@pxref{Local Variables}): it sets up local "
"variables as specified by @var{bindings}, and then evaluates @var{body} with "
"those bindings in effect.  Each element of @var{bindings} should be either a "
"symbol or a list of the form @w{@code{(@var{var} @var{expr})}}; the result "
"is to evaluate @var{expr} and bind @var{var} to the result.  The tail of "
"@var{bindings} can be either @code{nil} or a symbol which should hold a list "
"of arguments, in which case each argument is evaluated, and the symbol is "
"bound to the resulting list."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2177
#, no-wrap
msgid "inline-const-p expression"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2180
msgid "Return non-@code{nil} if the value of @var{expression} is already known."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2182
#, no-wrap
msgid "inline-const-val expression"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2184
msgid "Return the value of @var{expression}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2186
#, no-wrap
msgid "inline-error format &rest args"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2188
msgid "Signal an error, formatting @var{args} according to @var{format}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2191
msgid "Here's an example of using @code{define-inline}:"
msgstr ""

#. type: lisp
#: ../../../../../doc/lispref/functions.texi:2196
#, no-wrap
msgid ""
"(define-inline myaccessor (obj)\n"
"  (inline-letevals (obj)\n"
"    (inline-quote (if (foo-p ,obj) (aref (cdr ,obj) 3) (aref ,obj 2)))))\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2200
msgid "This is equivalent to"
msgstr ""

#. type: lisp
#: ../../../../../doc/lispref/functions.texi:2204
#, no-wrap
msgid ""
"(defsubst myaccessor (obj)\n"
"  (if (foo-p obj) (aref (cdr obj) 3) (aref obj 2)))\n"
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:2207
#, no-wrap
msgid "The @code{declare} Form"
msgstr ""

#. type: findex
#: ../../../../../doc/lispref/functions.texi:2208
#, no-wrap
msgid "declare"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2214
msgid ""
"@code{declare} is a special macro which can be used to add meta properties "
"to a function or macro: for example, marking it as obsolete, or giving its "
"forms a special @key{TAB} indentation convention in Emacs Lisp mode."
msgstr ""

#. type: anchor{#1}
#: ../../../../../doc/lispref/functions.texi:2216
msgid "Definition of declare"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2216
#, no-wrap
msgid "declare specs@dots{}"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2225
msgid ""
"This macro ignores its arguments and evaluates to @code{nil}; it has no "
"run-time effect.  However, when a @code{declare} form occurs in the "
"@var{declare} argument of a @code{defun} or @code{defsubst} function "
"definition (@pxref{Defining Functions}) or a @code{defmacro} macro "
"definition (@pxref{Defining Macros}), it appends the properties specified by "
"@var{specs} to the function or macro.  This work is specially performed by "
"@code{defun}, @code{defsubst}, and @code{defmacro}."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2229
msgid ""
"Each element in @var{specs} should have the form @code{(@var{property} "
"@var{args}@dots{})}, which should not be quoted.  These have the following "
"effects:"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2231
#, no-wrap
msgid "(advertised-calling-convention @var{signature} @var{when})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2236
msgid ""
"This acts like a call to @code{set-advertised-calling-convention} "
"(@pxref{Obsolete Functions}); @var{signature} specifies the correct argument "
"list for calling the function or macro, and @var{when} should be a string "
"indicating when the old argument list was first made obsolete."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2237
#, no-wrap
msgid "(debug @var{edebug-form-spec})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2240
msgid ""
"This is valid for macros only.  When stepping through the macro with Edebug, "
"use @var{edebug-form-spec}.  @xref{Instrumenting Macro Calls}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2241
#, no-wrap
msgid "(doc-string @var{n})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2246
msgid ""
"This is used when defining a function or macro which itself will be used to "
"define entities like functions, macros, or variables.  It indicates that the "
"@var{n}th argument, if any, should be considered as a documentation string."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2247
#, no-wrap
msgid "(indent @var{indent-spec})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2251
msgid ""
"Indent calls to this function or macro according to @var{indent-spec}.  This "
"is typically used for macros, though it works for functions too.  "
"@xref{Indenting Macros}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2252
#, no-wrap
msgid "(interactive-only @var{value})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2255
msgid ""
"Set the function's @code{interactive-only} property to @var{value}.  "
"@xref{The interactive-only property}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2256
#, no-wrap
msgid "(obsolete @var{current-name} @var{when})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2264
msgid ""
"Mark the function or macro as obsolete, similar to a call to "
"@code{make-obsolete} (@pxref{Obsolete Functions}).  @var{current-name} "
"should be a symbol (in which case the warning message says to use that "
"instead), a string (specifying the warning message), or @code{nil} (in which "
"case the warning message gives no extra details).  @var{when} should be a "
"string indicating when the function or macro was first made obsolete."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2265
#, no-wrap
msgid "(compiler-macro @var{expander})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2277
msgid ""
"This can only be used for functions, and tells the compiler to use "
"@var{expander} as an optimization function.  When encountering a call to the "
"function, of the form @code{(@var{function} @var{args}@dots{})}, the macro "
"expander will call @var{expander} with that form as well as with "
"@var{args}@dots{}, and @var{expander} can either return a new expression to "
"use instead of the function call, or it can return just the form unchanged, "
"to indicate that the function call should be left alone.  @var{expander} can "
"be a symbol, or it can be a form @code{(lambda (@var{arg}) @var{body})} in "
"which case @var{arg} will hold the original function call expression, and "
"the (unevaluated) arguments to the function can be accessed using the "
"function's formal arguments."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2278
#, no-wrap
msgid "(gv-expander @var{expander})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2284
msgid ""
"Declare @var{expander} to be the function to handle calls to the macro (or "
"function) as a generalized variable, similarly to "
"@code{gv-define-expander}.  @var{expander} can be a symbol or it can be of "
"the form @code{(lambda (@var{arg}) @var{body})} in which case that function "
"will additionally have access to the macro (or function)'s arguments."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2285
#, no-wrap
msgid "(gv-setter @var{setter})"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2292
msgid ""
"Declare @var{setter} to be the function to handle calls to the macro (or "
"function) as a generalized variable.  @var{setter} can be a symbol in which "
"case it will be passed to @code{gv-define-simple-setter}, or it can be of "
"the form @code{(lambda (@var{arg}) @var{body})} in which case that function "
"will additionally have access to the macro (or function)'s arguments and it "
"will be passed to @code{gv-define-setter}."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:2298
#, no-wrap
msgid "Telling the Compiler that a Function is Defined"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:2299
#, no-wrap
msgid "function declaration"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:2300
#, no-wrap
msgid "declaring functions"
msgstr ""

#. type: findex
#: ../../../../../doc/lispref/functions.texi:2301
#, no-wrap
msgid "declare-function"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2308
msgid ""
"Byte-compiling a file often produces warnings about functions that the "
"compiler doesn't know about (@pxref{Compiler Errors}).  Sometimes this "
"indicates a real problem, but usually the functions in question are defined "
"in other files which would be loaded if that code is run.  For example, "
"byte-compiling @file{simple.el} used to warn:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:2312
#, no-wrap
msgid ""
"simple.el:8727:1:Warning: the function ‘shell-mode’ is not known to be\n"
"    defined.\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2320
msgid ""
"In fact, @code{shell-mode} is used only in a function that executes "
"@code{(require 'shell)} before calling @code{shell-mode}, so "
"@code{shell-mode} will be defined properly at run-time.  When you know that "
"such a warning does not indicate a real problem, it is good to suppress the "
"warning.  That makes new warnings which might mean real problems more "
"visible.  You do that with @code{declare-function}."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2323
msgid ""
"All you need to do is add a @code{declare-function} statement before the "
"first use of the function in question:"
msgstr ""

#. type: example
#: ../../../../../doc/lispref/functions.texi:2326
#, no-wrap
msgid "(declare-function shell-mode \"shell\" ())\n"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2331
msgid ""
"This says that @code{shell-mode} is defined in @file{shell.el} (the "
"@samp{.el} can be omitted).  The compiler takes for granted that that file "
"really defines the function, and does not check."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2338
msgid ""
"The optional third argument specifies the argument list of "
"@code{shell-mode}.  In this case, it takes no arguments (@code{nil} is "
"different from not specifying a value).  In other cases, this might be "
"something like @code{(file &optional overwrite)}.  You don't have to specify "
"the argument list, but if you do the byte compiler can check that the calls "
"match the declaration."
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2339
#, no-wrap
msgid "declare-function function file &optional arglist fileonly"
msgstr ""

#. type: defmac
#: ../../../../../doc/lispref/functions.texi:2350
msgid ""
"Tell the byte compiler to assume that @var{function} is defined in the file "
"@var{file}.  The optional third argument @var{arglist} is either @code{t}, "
"meaning the argument list is unspecified, or a list of formal parameters in "
"the same style as @code{defun}.  An omitted @var{arglist} defaults to "
"@code{t}, not @code{nil}; this is atypical behavior for omitted arguments, "
"and it means that to supply a fourth but not third argument one must specify "
"@code{t} for the third-argument placeholder instead of the usual "
"@code{nil}.  The optional fourth argument @var{fileonly} non-@code{nil} "
"means check only that @var{file} exists, not that it actually defines "
"@var{function}."
msgstr ""

#. type: findex
#: ../../../../../doc/lispref/functions.texi:2352
#, no-wrap
msgid "check-declare-file"
msgstr ""

#. type: findex
#: ../../../../../doc/lispref/functions.texi:2353
#, no-wrap
msgid "check-declare-directory"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2359
msgid ""
"To verify that these functions really are declared where "
"@code{declare-function} says they are, use @code{check-declare-file} to "
"check all @code{declare-function} calls in one source file, or use "
"@code{check-declare-directory} check all the files in and under a certain "
"directory."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2364
msgid ""
"These commands find the file that ought to contain a function's definition "
"using @code{locate-library}; if that finds no file, they expand the "
"definition file name relative to the directory of the file that contains the "
"@code{declare-function} call."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2369
msgid ""
"You can also say that a function is a primitive by specifying a file name "
"ending in @samp{.c} or @samp{.m}.  This is useful only when you call a "
"primitive that is defined only on certain systems.  Most primitives are "
"always defined, so they will never give you a warning."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2374
msgid ""
"Sometimes a file will optionally use functions from an external package.  If "
"you prefix the filename in the @code{declare-function} statement with "
"@samp{ext:}, then it will be checked if it is found, otherwise skipped "
"without error."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2383
msgid ""
"There are some function definitions that @samp{check-declare} does not "
"understand (e.g., @code{defstruct} and some other macros).  In such cases, "
"you can pass a non-@code{nil} @var{fileonly} argument to "
"@code{declare-function}, meaning to only check that the file exists, not "
"that it actually defines the function.  Note that to do this without having "
"to specify an argument list, you should set the @var{arglist} argument to "
"@code{t} (because @code{nil} means an empty argument list, as opposed to an "
"unspecified one)."
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:2385
#, no-wrap
msgid "Determining whether a Function is Safe to Call"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:2386
#, no-wrap
msgid "function safety"
msgstr ""

#. type: cindex
#: ../../../../../doc/lispref/functions.texi:2387
#, no-wrap
msgid "safety of functions"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2395
msgid ""
"Some major modes, such as SES, call functions that are stored in user "
"files.  (@inforef{Top, ,ses}, for more information on SES@.)  User files "
"sometimes have poor pedigrees---you can get a spreadsheet from someone "
"you've just met, or you can get one through email from someone you've never "
"met.  So it is risky to call a function whose source code is stored in a "
"user file until you have determined that it is safe."
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:2396
#, no-wrap
msgid "unsafep form &optional unsafep-vars"
msgstr ""

#. type: defun
#: ../../../../../doc/lispref/functions.texi:2403
msgid ""
"Returns @code{nil} if @var{form} is a @dfn{safe} Lisp expression, or returns "
"a list that describes why it might be unsafe.  The argument "
"@var{unsafep-vars} is a list of symbols known to have temporary bindings at "
"this point; it is mainly used for internal recursive calls.  The current "
"buffer is an implicit argument, which provides a list of buffer-local "
"bindings."
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2414
msgid ""
"Being quick and simple, @code{unsafep} does a very light analysis and "
"rejects many Lisp expressions that are actually safe.  There are no known "
"cases where @code{unsafep} returns @code{nil} for an unsafe expression.  "
"However, a safe Lisp expression can return a string with a @code{display} "
"property, containing an associated Lisp expression to be executed after the "
"string is inserted into a buffer.  This associated expression can be a "
"virus.  In order to be safe, you must delete properties from all strings "
"calculated by user code before inserting them into buffers."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2422
#, no-wrap
msgid "Safe expression"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:2426
#, no-wrap
msgid "An atom or quoted thing.\n"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:2429
#, no-wrap
msgid ""
"A call to a safe function (see below), if all its arguments are\n"
"safe expressions.\n"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:2434
#, no-wrap
msgid ""
"One of the special forms @code{and}, @code{catch}, @code{cond},\n"
"@code{if}, @code{or}, @code{prog1}, @code{prog2}, @code{progn},\n"
"@code{while}, and @code{unwind-protect}], if all its arguments are\n"
"safe.\n"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:2439
#, no-wrap
msgid ""
"A form that creates temporary bindings (@code{condition-case},\n"
"@code{dolist}, @code{dotimes}, @code{lambda}, @code{let}, or\n"
"@code{let*}), if all args are safe and the symbols to be bound are not\n"
"explicitly risky (@pxref{File Local Variables}).\n"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:2444
#, no-wrap
msgid ""
"An assignment using @code{add-to-list}, @code{setq}, @code{push}, or\n"
"@code{pop}, if all args are safe and the symbols to be assigned are\n"
"not explicitly risky and they already have temporary or buffer-local\n"
"bindings.\n"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:2447
#, no-wrap
msgid ""
"One of [apply, mapc, mapcar, mapconcat] if the first argument is a\n"
"safe explicit lambda and the other args are safe expressions.\n"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2449
#, no-wrap
msgid "Safe function"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:2453
#, no-wrap
msgid "A lambda containing safe expressions.\n"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:2455
#, no-wrap
msgid "A symbol on the list @code{safe-functions}, so the user says it's safe.\n"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:2457
#, no-wrap
msgid "A symbol with a non-@code{nil} @code{side-effect-free} property.\n"
msgstr ""

#. type: itemize
#: ../../../../../doc/lispref/functions.texi:2462
#, no-wrap
msgid ""
"A symbol with a non-@code{nil} @code{safe-function} property.  The\n"
"value @code{t} indicates a function that is safe but has innocuous\n"
"side effects.  Other values will someday indicate functions with\n"
"classes of side effects that are not always safe.\n"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2468
#, no-wrap
msgid ""
"The @code{side-effect-free} and @code{safe-function} properties are\n"
"provided for built-in functions and for low-level functions and macros\n"
"defined in @file{subr.el}.  You can assign these properties for the\n"
"functions you write.\n"
msgstr ""

#. type: section
#: ../../../../../doc/lispref/functions.texi:2472
#, no-wrap
msgid "Other Topics Related to Functions"
msgstr ""

#. type: Plain text
#: ../../../../../doc/lispref/functions.texi:2477
msgid ""
"Here is a table of several functions that do things related to function "
"calling and function definitions.  They are documented elsewhere, but we "
"provide cross references here."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2479
#, no-wrap
msgid "apply"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2481 ../../../../../doc/lispref/functions.texi:2502 ../../../../../doc/lispref/functions.texi:2508
msgid "See @ref{Calling Functions}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2482
#, no-wrap
msgid "autoload"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2484
msgid "See @ref{Autoload}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2485
#, no-wrap
msgid "call-interactively"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2487 ../../../../../doc/lispref/functions.texi:2493
msgid "See @ref{Interactive Call}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2488
#, no-wrap
msgid "called-interactively-p"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2490 ../../../../../doc/lispref/functions.texi:2517
msgid "See @ref{Distinguish Interactive}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2491
#, no-wrap
msgid "commandp"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2494
#, no-wrap
msgid "documentation"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2496
msgid "See @ref{Accessing Documentation}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2497
#, no-wrap
msgid "eval"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2499
msgid "See @ref{Eval}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2500
#, no-wrap
msgid "funcall"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2503
#, no-wrap
msgid "function"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2505
msgid "See @ref{Anonymous Functions}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2506
#, no-wrap
msgid "ignore"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2509
#, no-wrap
msgid "indirect-function"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2511
msgid "See @ref{Function Indirection}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2512
#, no-wrap
msgid "interactive"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2514
msgid "See @ref{Using Interactive}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2515
#, no-wrap
msgid "interactive-p"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2518
#, no-wrap
msgid "mapatoms"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2520
msgid "See @ref{Creating Symbols}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2521
#, no-wrap
msgid "mapcar"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2523 ../../../../../doc/lispref/functions.texi:2529
msgid "See @ref{Mapping Functions}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2524
#, no-wrap
msgid "map-char-table"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2526
msgid "See @ref{Char-Tables}."
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2527
#, no-wrap
msgid "mapconcat"
msgstr ""

#. type: item
#: ../../../../../doc/lispref/functions.texi:2530
#, no-wrap
msgid "undefined"
msgstr ""

#. type: table
#: ../../../../../doc/lispref/functions.texi:2532
msgid "See @ref{Functions for Key Lookup}."
msgstr ""
